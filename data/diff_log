------
HomePage|1178781158
------
HomePage|1178781345
------
HomePage|1178782485
------
HomePage|1178782519
------
CreatingWikiEntries|1178782941
------
CreatingWikiEntries/WikiTextFormatting|1178782977
------
CreatingWikiEntries/WikiTables|1178783690
------
CreatingWikiEntries/WikiLists|1178783746
------
CreatingWikiEntries/WikiHeadings|1178783770
------
CreatingWikiEntries/TableOfContents|1178783805
------
CreatingWikiEntries/WikiImages|1178783835
------
CreatingWikiEntries/WikiLines|1178783867
------
CreatingWikiEntries|1178784162
------
CreatingWikiEntries/WikiLists|1178784230
------
CreatingWikiEntries|1178784853
------
CreatingWikiEntries|1178784958
------
DeletingPages|1178784981
------
DeletingPages|1178785005
------
HowDoIDeleteAPage|1178785012
------
DeletingPages|1178785054
------
DeletingPages|1178785063
------
HyperTextMarkupLanguage|1178785303
------
WikiWord|1178785450
------
HtmlTags|1178785687
------
RawHtml|1178785720
------
HtmlPairs|1178785739
------
HtmlTags|1178785868
------
HtmlSingle|1178785883
------
CreatingWikiEntries|1178785980
------
CreatingWikiEntries/WikiURLs|1178785989
------
CreatingWikiEntries/DeletingPages|1178786060
------
DeletedPage|1178786113
------
CreatingWikiEntries|1178786182
------
TextFormattingExamples|1178786439
------
TextFormattingExamples|1178786474
------
CreatingWikiEntries|1178786583
------
WikiName|1178786687
------
WikiName|1178786725
------
WikiName|1178786891
------
DeletedPage|1178787513
------
DeletingPages|1178787594
------
CreatingWikiEntries|1178787928
------
SandBox|1178787942
------
SandBox|1178787964
------
SandBox|1178787998
------
CreatingWikiEntries|1178788033
------
CreatingWikiEntries|1178788080
------
CreatingWikiEntries|1178788148
------
HomePage|1178788486
------
HomePage|1178788500
------
AdminFeatures|1178788709
------
HomePage|1178788723
------
Actions|1178788954
------
CreatingWikiEntries/TableOfContents|1178789234
------
CreatingWikiEntries/TableOfContents|1178789242
------
CreatingWikiEntries/WikiLines|1178789262
------
CreatingWikiEntries|1178789293
------
CreatingWikiEntries/WikiImages|1178789473
------
CreatingWikiEntries/WikiImages|1178789523
------
CreatingWikiEntries/WikiImages|1178789548
------
RecentChanges|1178998422
------
WikiName|1178998527
------
WikiName|1178998539
------
HomePage|1178999837
------
AdminFeatures|1179013553
------
AdminFeatures|1179013648
------
AdminFeatures|1179013960
------
AdminFeatures|1179014151
------
CreatingWikiEntries|1179014613
------
CreatingWikiEntries|1179014652
------
CreatingWikiEntries|1179014694
------
CreatingWikiEntries|1179014757
------
HomePage|1179015367
------
CreatingWikiEntries|1179016554
------
CreatingWikiEntries|1179016578
------
CreatingWikiEntries|1179016624
------
CreatingWikiEntries|1179016638
------
CreatingWikiEntries|1179016711
------
HtmlTags|1179019551
------
HtmlTags|1179019618
------
HomePage|1179027097
------
HomePage|1179027171
------
HomePage|1179027192
------
CreatingWikiEntries/WikiTextFormatting|1179027238
------
HomePage|1179027263
------
HomePage|1179027346
------
HomePage|1179027396
------
PageNotFound|1179027487
------
PageNotFound|1179028156
------
HomePage|1179028182
------
HomePage|1179028206
------
HomePage|1179028257
------
HomePage|1179028273
------
AdminFeatures|1179028344
------
HomePage|1179033705
------
HomePage|1179041704
------
HomePage|1179044989
------
HomePage|1179045044
------
HomePage|1179045085
------
HomePage|1179045094
------
HomePage|1179045149
------
HomePage|1179045159
------
HomePage|1179045542
------
HomePage|1179046843
------
HomePage|1179046853
------
AdminFeatures|1179046877
------
HomePage|1179047075
------
HomePage|1179047091
------
AdminFeatures|1179047186
------
AdminFeatures|1179047470
------
HomePage|1179053437
------
HomePage|1179087035
------
CreatingWikiEntries|1179087096
------
CreatingWikiEntries|1179087767
------
SandBox|1179088252
------
SandBox/SecondSandBox|1179088291
------
SandBox|1179088385
------
AdminFeatures|1179092659
------
CreatingWikiEntries/WikiImages|1179095233
------
CreatingWikiEntries/WikiImages|1179095252
------
CreatingWikiEntries/WikiImages|1179095274
------
CreatingWikiEntries/WikiImages|1179095322
------
CreatingWikiEntries/WikiImages|1179095669
------
CreatingWikiEntries/WikiImages|1179096083
------
CreatingWikiEntries/WikiTables|1179096652
------
CreatingWikiEntries/WikiTables|1179096736
------
CreatingWikiEntries/WikiTables|1179097212
------
CreatingWikiEntries/WikiTables|1179097777
------
CreatingWikiEntries/WikiTables|1179097884
------
CreatingWikiEntries/WikiTables|1179097902
------
CreatingWikiEntries/WikiTables|1179098179
------
HomePage|1179098412
------
HomePage|1179098455
------
HomePage|1179098552
------
CreatingWikiEntries/WikiHeadings|1179099144
------
CreatingWikiEntries/WikiLists|1179099902
------
CreatingWikiEntries/WikiLists|1179099945
------
CreatingWikiEntries/WikiLists|1179099960
------
CreatingWikiEntries/WikiLists|1179099978
------
CreatingWikiEntries/WikiHeadings|1179100121
------
CreatingWikiEntries/WikiHeadings|1179100235
------
HomePage|1179100356
------
CreatingWikiEntries|1179100737
------
CreatingWikiEntries|1179100893
------
TextFormattingExamples|1179101144
------
TextFormattingExamples|1179101150
------
CreatingWikiEntries|1179101897
------
WikiWord|1179101959
------
WikiWord|1179101967
------
WikiWord|1179101997
------
WikiWord|1179102096
------
CreatingWikiEntries|1179102555
------
CreatingWikiEntries/WikiImages|1179102941
------
WikiName|1179103081
------
CreatingWikiEntries/WikiURLs|1179103272
------
CreatingWikiEntries/WikiURLs|1179103359
------
CreatingWikiEntries/WikiURLs|1179104870
------
CreatingWikiEntries/WikiURLs|1179112072
------
ReallyLongPage|1179112265
------
ReallyLongPage|1179112390
------
ReallyLongPage|1179112468
------
ReallyLongPage|1179112504
------
ReallyLongPage|1179112522
------
CreatingWikiEntries/WikiURLs|1179112638
------
CreatingWikiEntries/WikiURLs|1179112713
------
CreatingWikiEntries/WikiURLs|1179113036
------
CreatingWikiEntries/WikiTextFormatting|1179113642
------
CreatingWikiEntries/WikiTextFormatting|1179113825
------
StyleGuide|1179125464
------
CreatingWikiEntries/WikiTables|1179126558
------
HomePage|1179126719
------
HomePage|1179127174
------
HomePage|1179127407
------
CreatingWikiEntries|1179127559
------
CreatingWikiEntries|1179127758
------
CreatingWikiEntries/WikiTextFormatting|1179128064
------
StyleGuide|1179128349
------
StyleGuide|1179128407
------
CreatingWikiEntries|1179128467
------
CreatingWikiEntries|1179128500
------
StyleGuide|1179128568
------
ReallyLongPage|1179128602
------
ReallyLongPage|1179128613
------
CreatingWikiEntries/WikiTextFormatting|1179128670
------
HomePage|1179128856
------
HomePage|1179129272
------
HomePage|1179129481
------
CreatingWikiEntries/WikiTables|1179129586
------
CreatingWikiEntries/WikiTables|1179129874
------
CreatingWikiEntries/WikiTables|1179129895
------
CreatingWikiEntries|1179131071
------
CreatingWikiEntries/WikiHeadings|1179131106
------
ContributorsList|1179131379
------
ContributorsList|1179131390
------
StyleGuide|1179131492
------
DesignsInProgress|1179131614
------
ContributorsList|1179131642
------
DesignsInProgress|1179131988
------
DesignsInProgress|1179132208
------
DesignsInProgress|1179132240
------
DesignsInProgress|1179132313
------
StyleGuide|1179133109
------
AdminFeatures|1179159365
------
HomePage|1179194289
------
HomePage|1179194313
------
HomePage|1179195364
------
HomePage|1179196247
------
DesignsInProgress|1179204708
------
CreatingWikiEntries/WikiURLs|1179205121
------
CreatingWikiEntries/WikiImages|1179205204
------
CreatingWikiEntries/WikiImages|1179205214
------
PageNotFound|1179215635
------
Help|1179217964
------
Help|1179217979
------
NobleWiki|1179218118
------
CategoryCategory|1179218376
------
CategoryCategory|1179219338
------
CategoryCategory|1179221313
------
Actions|1179246000
------
Actions|1179246032
------
AdminFeatures|1179246094
------
CategoryCategory|1179246235
------
CategoryCategory|1179246268
------
CreatingWikiEntries/WikiHeadings|1179286193
------
HomePage|1179287822
------
Actions|1179288733
------
Actions|1179291037
------
Actions|1179291330
------
CreatingWikiEntries|1179309020
------
WikiTables|1179309226
------
WikiTables|1179310445
------
WikiTables|1179310488
------
SandBox|1179311431
------
SandBox|1179311441
------
HomePage|1179311691
------
HomePage|1179314057
------
SandBox|1179331469
------
TableOfContents|1179375099
------
TableOfContents|1179375170
------
CreatingWikiEntries|1179375199
------
WikiStyleGuide|1179375599
------
WikiHeadings|1179375676
------
WikiEditing|1179375773
------
WikiStyleGuide|1179375827
------
WikiHeadings|1179375841
------
WikiTOCs|1179375856
------
WikiURLs|1179375872
------
WikiTables|1179375884
------
WikiLists|1179375900
------
WikiMarkup|1179375914
------
TextFormattingExamples|1179377313
------
NobleWiki|1179378652
------
NobleWiki|1179381657
------
NobleWiki|1179382738
------
NobleWiki|1179382761
------
HowDoIDeleteAPage|1179382932
------
NobleWiki|1179383419
------
NobleWiki|1179385473
------
NobleWiki|1179385598
------
WikiSearch|1179385729
------
DeletedPage|1179386134
------
DeletedPage|1179386189
------
DeletedPage|1179386213
------
CategoryWiki|1179386478
------
CategoryWiki|1179386499
------
CategoryWiki|1179386529
------
CategoryWiki|1179386748
------
CategoryAdmin|1179386993
------
CategoryWiki|1179387041
------
CategoryWiki|1179387067
------
CategoryOverview|1179387301
------
CategoryOverview|1179387420
------
CategoryOverview|1179387524
------
CategoryWiki|1179387569
------
TourBus|1179387794
------
WikiEditing|1179387845
------
TourBus|1179387901
------
SessionReports|1179388017
------
SessionReports|1179388024
------
WikiSearch|1179388284
------
WikiImages|1179388411
------
WikiSearch|1179388824
------
DeletingPages|1179388909
------
HtmlTags|1179388951
------
WikiName|1179389046
------
AdminFeatures|1179389163
------
AdminActions|1179389203
------
AdminActions|1179389270
------
Help|1179389315
------
NobleWiki|1179389848
------
HomePage|1179389934
------
TourBus|1179390507
------
TourBus|1179391736
------
TourBus|1179391840
------
NoblePursuit|1179393355
------
NoblePursuit|1179393679
------
NoblePursuit|1179394549
------
TourBus|1179394684
------
TourBus|1179394786
------
TourBus|1179394820
------
TourBus|1179394859
------
CategoryOverview|1179395408
------
CategoryWiki|1179395470
------
WikiMarkup|1179396916
------
WikiMarkup|1179397012
------
NoblePursuit|1179398508
------
NoblePursuit|1179398657
------
CategoryWiki|1179398749
------
WikiStyleGuide|1179417524
------
WikiStyleGuide|1179418015
------
WikiStyleGuide|1179418243
------
WikiStyleGuide|1179418298
------
WikiImages|1179418331
------
WikiURLs|1179456979
------
WikiImages|1179457171
------
NobleWiki|1179461448
------
WikiImages|1179461817
------
WikiImages|1179469671
------
WikiSearch|1179470109
------
CategoryWiki|1179470148
------
NobleWiki|1179502906
------
WikiStyleGuide|1179548115
------
HomePage|1179550611
------
HomePage/HomePageCentral|1179550622
------
HomePage/HomePageCentral|1179550633
------
HomePage|1179550808
------
SandBox|1179550863
------
SandBox|1179550871
------
SandBox|1179550913
------
SandBox/SandLot|1179550924
------
SandLot|1179552009
------
NobleWiki|1179552749
------
NobleWiki|1179552846
------
HomePage|1179552899
------
HomePage|1179552933
------
TourBusStop|1179553458
------
WikiHelp|1179553467
------
HomePage|1179553647
------
CategoryCategory|1179554176
------
CategoryGames|1179554264
------
CategoryGames|1179554366
------
CategoryCategory|1179554530
------
CategoryGames|1179554699
------
CategoryCategory|1179554728
------
CategoryCategory|1179554795
------
CategoryCategory|1179554817
------
CategoryOverview|1179557600
------
VisitorRole|1179557702
------
VisitorRole|1179558035
------
DesignerRole|1179558367
------
PlayTesterRole|1179558628
------
ReallyLongPage|1179559190
------
WikiURLs|1179559236
------
WikiURLs|1179568377
------
WikiURLs|1179568393
------
WikiStyleGuide|1179568698
------
WikiURLs|1179569789
------
CategoryPeople|1179570133
------
NoblePursuit|1179570562
------
CategoryPeople|1179570639
------
WikiURLs|1179634925
------
InterMap|1179636042
------
InterMap|1179636103
------
CategoryWiki|1179636141
------
CategoryWiki|1179636178
------
HomePage|1179636552
------
NobleMission|1179637679
------
WikiHelp|1179638505
------
CategoryWiki|1179638534
------
AdminFeatures|1179639016
------
AdminFeatures|1179639593
------
AdminFeatures|1179639684
------
AdminFeatures|1179639771
------
WikiWord|1179643667
------
WikiWord|1179643683
------
HomePage|1179644653
------
HomePage/RobertKurcina|1179644766
------
HomePage/RalphMorgan|1179644775
------
HomePage|1179645167
------
AdminActions|1179650001
------
NobleWiki|1179650498
------
NobleWiki|1179650924
------
NobleWiki|1179650974
------
NoblePursuit|1179651396
------
CategoryPeople|1179651468
------
CategoryPeople|1179651486
------
CategoryPeople|1179651553
------
AdminActions|1179651856
------
AdminFeatures|1179651892
------
CategoryCategory|1179651910
------
WikiEditing|1179651967
------
WikiImages|1179651987
------
WikiMarkup|1179652056
------
WikiMarkup|1179652083
------
WikiURLs|1179652292
------
NobleWiki|1179653203
------
NobleWiki|1179654401
------
WikiTables|1179655731
------
WikiStyleGuide|1179655837
------
NobleWiki|1179655945
------
NobleWiki|1179728124
------
HomePage/RobertKurcina|1179728352
------
NobleWiki|1179728396
------
HomePage/RobertKurcina|1179728509
------
HomePage/RobertKurcina|1179728574
------
NobleMission|1179729031
------
WikiHeadings|1179734027
------
HtmlTags|1179734152
------
WikiStyleGuide|1179801535
------
CategoryOverview|1179801562
------
CasualContent|1179801651
------
DraftContent|1179801720
------
StubContent|1179801803
------
CategoryOverview|1179804155
------
DeveloperRole|1179804352
------
DeveloperRole|1179804422
------
WikiEditing|1179818745
------
NobleWiki|1179822283
------
NobleMission|1179822928
------
NobleGames|1179824844
------
WikiStyleGuide|1179824888
------
WikiTOCs|1179852084
------
NobleWiki|1179890120
------
NobleWiki|1179890544
------
NobleWiki|1179895130
24a25
> ||UseMod:WikiPatches/PerlDiff||Perl-based diff; should work on WIN32 and LINUX||
34d34
< ||UseMod:WikiPatches/PerlDiff||want, Perl-based diff; should work on WIN32 and LINUX||
------
AdminDelete|1179979081
1,3c1,3
< '''Q: How do I completely delete an existing page, so that further links to it will show up with the little "?" symbol?  Or is that a silly thing to do?'''
< 
< '''A:''' Place DeletedPage on a line by itself at the top of the page.  This will flag the page for deletion after 60 days.  If you really need a page deleted immediately, make a note of it in the change summary, and a WikiAdmin can delete the page immediately if they concur that it should be deleted without delay.
---
> ===== TASK: Deleting a Page =
> 
> Place DeletedPage on a line by itself at the top of the page.  This will flag the page for deletion after 60 days.  If you really need a page deleted immediately, make a note of it in the change summary, and a WikiAdmin can delete the page immediately if they concur that it should be deleted without delay.
------
WikiTemplates|1179982138
1c1,3
< Describe the new page here.
---
> == Template Hub =
> 
>  /DeviceTemplate
------
WikiTemplates/DeviceTemplate|1179982148
1c1,6
< Describe the new page here.
---
> |||| '''Device description''' ||
> || Device ID: || $DEVICEID$ ||
> || Key mapping: || $KEYMAPPING$ ||
> || Backlight: || $BACKLIGHT$ ||
> || Storage card path: || $STORAGECARDPATH$ ||
> || Internal storage: || $INTERNALSTORAGE$ ||
------
TemplateExample|1179982298
1c1,6
< Describe the new page here.
---
> |||| '''Device description''' ||
> || Device ID: || $DEVICEID$ ||
> || Key mapping: || $KEYMAPPING$ ||
> || Backlight: || $BACKLIGHT$ ||
> || Storage card path: || $STORAGECARDPATH$ ||
> || Internal storage: || $INTERNALSTORAGE$ ||
------
WikiTemplates|1179982457
3c2,14
<  /DeviceTemplate
---
> Example use of a template created under <tt><nowiki>TemplateExample</nowiki></tt>
> 
>  TemplateExample
> 
> Example parameters sent into device.
> 
> {{template TemplateExample
> DEVICEID=Acme device 101
> BACKLIGHT =
> KEYMAPPING=75 (info) 76 (menu) 77 (vol-) 78 (vol+)
> STORAGECARDPATH=''currently unknown!'' <br> CategoryUnknownStorageCard
> }}
> 
------
WikiTemplates|1179982528
8c8
< {{template TemplateExample
---
> {{TemplateExample
------
TemplateExample|1179982794
1,2c1,4
< |||| '''Device description''' ||
< || Device ID: || $DEVICEID$ ||
---
>  
> 
> !!!! Device description !!
> || Device ID|| $DEVICEID$ ||
4,6c6,8
< || Backlight: || $BACKLIGHT$ ||
< || Storage card path: || $STORAGECARDPATH$ ||
< || Internal storage: || $INTERNALSTORAGE$ ||
---
> || Backlight || $BACKLIGHT$ ||
> || Storage card path || $STORAGECARDPATH$ ||
> || Internal storage || $INTERNALSTORAGE$ ||
------
WikiTemplates/TemplateExample|1179982863
1c1,9
< Describe the new page here.
---
>  
> 
> !!!! Device description !!
> || Device ID|| $DEVICEID$ ||
> || Key mapping: || $KEYMAPPING$ ||
> || Backlight || $BACKLIGHT$ ||
> || Storage card path || $STORAGECARDPATH$ ||
> || Internal storage || $INTERNALSTORAGE$ ||
> 
------
WikiTemplates|1179982923
4c4
<  TemplateExample
---
>  /TemplateExample
8c8
< {{TemplateExample
---
> {{WikiTemplates/TemplateExample
------
NobleWiki|1179990337
26,27c26,27
< ||UseMod:WikiPatches/GetSubPages||Return all subpages of a page via the Manage Pages interface for administrators||
< ||UseMod:WikiPatches/RenameSubPages||Rename subpages if it's parent page is renamed||
---
> ||UseMod:WikiPatches/GetSubpages||Return all subpages of a page via the Manage Pages interface for administrators||
> ||UseMod:WikiPatches/RenameSubpages||Rename subpages if it's parent page is renamed||
------
WikiTemplates|1179990493
8c8
< {{WikiTemplates/TemplateExample
---
> {{TemplateExample
14a16,21
> {{WikiTemplates/TemplateExample
> DEVICEID=Acme device 101
> BACKLIGHT =
> KEYMAPPING=75 (info) 76 (menu) 77 (vol-) 78 (vol+)
> STORAGECARDPATH=''currently unknown!'' <br> CategoryUnknownStorageCard
> }}
------
WikiTemplates/TemplateExample|1179992198
4c4
< || Device ID|| $DEVICEID$ ||
---
> || Device ID|| upload:$DEVICEID$ ||
------
WikiTemplates|1179992769
12c12
< STORAGECARDPATH=''currently unknown!'' <br> CategoryUnknownStorageCard
---
> STORAGECARDPATH=''currently unknown!'' <br> [[CategoryUnknownStorageCard]]
16c15
< {{WikiTemplates/TemplateExample
---
> {{TemplateExample
20c19
< STORAGECARDPATH=''currently unknown!'' <br> CategoryUnknownStorageCard
---
> STORAGECARDPATH=''currently unknown!'' <br> /CategoryUnknownStorageCard
21a23,29
> {{WikiTemplates/TemplateExample
> DEVICEID=SAMPLE.churcill.jpg
> BACKLIGHT =
> KEYMAPPING=75 (info) 76 (menu) 77 (vol-) 78 (vol+)
> STORAGECARDPATH=''currently unknown!'' <br> [[CategoryUnknownStorageCard]]
> }}
> 
------
WikiTemplates/TemplateExample|1179994172
4c4
< || Device ID|| upload:$DEVICEID$ ||
---
> || Device ID|| $DEVICEID$ ||
------
ExampleTemplate|1179994890
3,8c3,6
< !!!! Device description !!
< || Device ID|| $DEVICEID$ ||
< || Key mapping: || $KEYMAPPING$ ||
< || Backlight || $BACKLIGHT$ ||
< || Storage card path || $STORAGECARDPATH$ ||
< || Internal storage || $INTERNALSTORAGE$ ||
---
> !!!! EXAMPLE Template !!
> || Item|| $VARIABLE1$ ||
> || Item|| $VARIABLE2$ ||
> || Item ||$VARIABLE3$ ||
------
WikiTemplates/TemplateExample|1179994948
3,9c2,5
< !!!! Device description !!
< || Device ID|| $DEVICEID$ ||
< || Key mapping: || $KEYMAPPING$ ||
< || Backlight || $BACKLIGHT$ ||
< || Storage card path || $STORAGECARDPATH$ ||
< || Internal storage || $INTERNALSTORAGE$ ||
< 
---
> !!!! EXAMPLE Template !!
> || Item|| $VARIABLE1$ ||
> || Item|| $VARIABLE2$ ||
> || Item ||$VARIABLE3$ ||
------
WikiTemplates/TemplateExample|1179994959
------
ExampleTemplate|1179995523
4,6c4,8
< || Item|| $VARIABLE1$ ||
< || Item|| $VARIABLE2$ ||
< || Item ||$VARIABLE3$ ||
---
> || Image|| $VARIABLE1$ ||
> || link|| $VARIABLE2$ ||
> || my sub-page|| $VARIABLE3$ ||
> || your sub-page ||$VARIABLE4$ ||
> || bracketed url ||$VARIABLE5$ ||
------
WikiTemplates/TemplateExample|1179995542
3,6c3,8
< !!!! EXAMPLE Template !!
< || Item|| $VARIABLE1$ ||
< || Item|| $VARIABLE2$ ||
< || Item ||$VARIABLE3$ ||
---
> !!!! EXAMPLE Sub-page Template !!
> || Image|| $VARIABLE1$ ||
> || link|| $VARIABLE2$ ||
> || my sub-page|| $VARIABLE3$ ||
> || your sub-page ||$VARIABLE4$ ||
> || bracketed url ||$VARIABLE5$ ||
------
WikiTemplates|1179996060
1,3c1,5
< == Template Hub =
< Example use of a template created under <tt><nowiki>TemplateExample</nowiki></tt>
< 
---
> == Templates =
> A template is an entry with a specific layout and place-holder variables.  Any other entry may then make reference to the template and send variables to it.  This allows a standardized presentation of commonly provided information, such as profile pages.
> 
> Two kinds of templates can be created; primary or sub-pages, as can be seen on these two links:
>  ExampleTemplate
6,12c8,38
< Example parameters sent into device.
< 
< {{ExampleTemplate
< DEVICEID=Acme device 101
< BACKLIGHT =
< KEYMAPPING=75 (info) 76 (menu) 77 (vol-) 78 (vol+)
< STORAGECARDPATH=''currently unknown!'' <br> [[CategoryUnknownStorageCard]]
---
> === Sample Template =
> For example, here's the code for the both of the templates used.  It's a simple table with three variables named <code>$VARIABLE1$, $VARIABLE2$, $VARIABLE3$</code>.  Note that each variable is cushioned by the <tt>$</tt> symbol on either side.
> 
> <pre>
> !!!! EXAMPLE Template !!
> || Image|| $VARIABLE1$ ||
> || link|| $VARIABLE2$ ||
> || my sub-page|| $VARIABLE3$ ||
> || your sub-page ||$VARIABLE4$ ||
> || bracketed url ||$VARIABLE5$ ||
> </pre>
> 
> === Sending parameters =
> To utilize a template, create a data block that begins with <code>'{{template:'</code> ends with paired curly braces <code>'}}'</code>.  Within that block, specify the template name immediately after the 'template;' command, and calling out each place-holder variable exactly as defined in the template except for the <tt>'$'</tt> symbols.  Set values to each variables as desired following an <tt>'='</tt> equals sign symbol.
> 
> ==== Sample Primary Page Template Data Block =
> This example shows a data block using a primary page template <code>'ExampleTemplate</code>, and passing several values including an image link via the <code>upload:</code> syntax.
> <pre>
> {{template:ExampleTemplate
> VARIABLE1 = upload:SAMPLE.churcill.jpg
> VARIABLE2 = DoesntExist
> VARIABLE3 = /ImpossibleFile
> VARIABLE4 = DoesntExist/ExampleDummy
> VARIABLE5 = [[DoesntExist/ExampleDummy|Nothing]]
> }}</pre>
> {{template:ExampleTemplate
> VARIABLE1 = upload:SAMPLE.churcill.jpg
> VARIABLE2 = DoesntExist
> VARIABLE3 = /ImpossibleFile
> VARIABLE4 = DoesntExist/ExampleDummy
> VARIABLE5 = [[DoesntExist/ExampleDummy|Nothing]]
15,19c41,56
< {{ExampleTemplate
< DEVICEID=Acme device 101
< BACKLIGHT =
< KEYMAPPING=75 (info) 76 (menu) 77 (vol-) 78 (vol+)
< STORAGECARDPATH=''currently unknown!'' <br> /CategoryUnknownStorageCard
---
> ==== Sample Sub-page Template Data Block =
> This example shows use of a template created as a sub-page.  Notice that the parameters are the same, and that the sub-page is shown fully qualified as <code>WikiTemplates/TemplateExample</code> instead of <code>/TemplateExample</code>.
> <pre>
> {{template:WikiTemplates/TemplateExample
> VARIABLE1 = upload:SAMPLE.churcill.jpg
> VARIABLE2 = DoesntExist
> VARIABLE3 = /ImpossibleFile
> VARIABLE4 = DoesntExist/ExampleDummy
> VARIABLE5 = [[DoesntExist/ExampleDummy|Nothing]]
> }}</pre>
> {{template:WikiTemplates/TemplateExample
> VARIABLE1 = upload:SAMPLE.churcill.jpg
> VARIABLE2 = DoesntExist
> VARIABLE3 = /ImpossibleFile
> VARIABLE4 = DoesntExist/ExampleDummy
> VARIABLE5 = [[DoesntExist/ExampleDummy|Nothing]]
23,29d57
< {{WikiTemplates/TemplateExample
< DEVICEID=SAMPLE.churcill.jpg
< BACKLIGHT =
< KEYMAPPING=75 (info) 76 (menu) 77 (vol-) 78 (vol+)
< STORAGECARDPATH=''currently unknown!'' <br> [[CategoryUnknownStorageCard]]
< }}
< 
------
WikiEditing|1179996094
43a44
>  WikiTemplates
------
CategoryWiki|1179996109
27a27,28
>  WikiTemplates
> 
------
WikiName|1179996720
------
WikiName|1179996770
15a14,15
>   
>  .
------
NobleWiki|1179998901
33a33,34
> ||UseMod:WikiPatches/WikiTemplate||Created instructions for use as well; see WikiTemplates||
> 
42,43d43
< ||UseMod:WikiPatches/WikiTemplate||want, unsure if useful||
< 
------
NobleWiki|1179999247
15a15,17
> ||Lock-out Indicators||Added small symbols to allow quick access to editing a page from the title, and symbols to indicate that a page is locked.  <code>'&not;'</code> is that symbol prefixed to a locked page.||
> ||Title attribute||Added a title attribute to all links where possible||
> 
33c35
< ||UseMod:WikiPatches/WikiTemplate||Created instructions for use as well; see WikiTemplates||
---
> ||UseMod:WikiPatches/WikiTemplate||Modified to require a command string of <code>{{template:</code> before it can be used. Created instructions for use as well; see WikiTemplates||
------
NobleWiki|1179999562
59,63c59,63
< ||<tt><nowiki>@@ImageLink|Caption</nowiki></tt>||Will insert the caption at the bottom of the picture, centered||
< ||<tt><nowiki>@@LightBox|ImageLink:Dimension</nowiki></tt>||Will utilize the <nowiki>LightBox 2.0 JavaScript</nowiki> widget||
< ||<tt><nowiki>@@Section|WikiPage:Section</nowiki></tt>||Non-recursively insert the section text for any page of the identified TOC header||
< ||<tt><nowiki>@@Subpages</nowiki></tt>||Inserts all of a page's subpages||
< ||<tt><nowiki>@@Comments</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure.||
---
> ||<tt><nowiki><subpages></nowiki></tt>||Inserts all of a page's subpages||
> ||<tt><nowiki>upload:url|caption</nowiki></tt>||Will insert the caption at the bottom of the picture, centered||
> ||<tt><nowiki>{{gallery|size|uploads}}</nowiki></tt>||Will utilize the <nowiki>LightBox 2.0 JavaScript</nowiki> widget||
> ||<tt><nowiki>{{section|WikiPage|section}}</nowiki></tt>||Non-recursively insert the section text for any page of the identified TOC header||
> ||<tt><nowiki>{{Comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab.||
------
CategoryCategory|1179999799
8,11c8,11
< ||CategoryPeople   ||Lists of persons contributing, developing, or related to any aspect of this wiki.||
< 
< !!Site-centric    !!Purpose                                                                            !!
< ||CategoryGames   ||Lists of all games grouped by their purpose, with links to their own subsections.  ||
---
> ||CategoryPeople    ||Lists of persons contributing, developing, or related to any aspect of this wiki.||
> 
> !!Site-centric      !!Purpose                                                                            !!
> ||CategoryGames     ||Lists of all games grouped by their purpose, with links to their own subsections.  ||
13c13
< ||CategoryWebDev  ||Items of interests for W/LAMP web development; HTML/CSS, javascript, perl, <nowiki>MySql<nowiki>||
---
> ||CategoryWebDev    ||Items of interests for W/LAMP web development; HTML/CSS, javascript, perl, <nowiki>MySql<nowiki>||
16c16,17
< ||CategoryMisc    ||A bucket category to catch small things until a separate category can be created.  ||
---
> ||CategoryMisc      ||A bucket category to catch small things until a separate category can be created.  ||
> ||CategoryTemplates ||A list of all templates and [MeatBall:TransClusion transclusion] files           ||
------
NobleWiki|1180088790
59c59
< ||<tt><nowiki><subpages></nowiki></tt>||Inserts all of a page's subpages||
---
> ||<tt><nowiki>subpages</nowiki></tt>||Inserts all of a page's subpages||
60a61,62
> ||<tt><nowiki>{{flash|size}}</nowiki></tt>||Will embed a flash object||
> ||<tt><nowiki>{{history|events}}</nowiki></tt>||Create a timeline using the Timeline javascript widget||
62,65c64,67
< ||<tt><nowiki>{{section|WikiPage|section}}</nowiki></tt>||Non-recursively insert the section text for any page of the identified TOC header||
< ||<tt><nowiki>{{Comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab.||
< ||<tt><nowiki>@@CSS|Media|StyleSheet</nowiki></tt>||Added at top of page to alter CSS used before rendering||
< ||<tt><nowiki>@@HTML|Template</nowiki></tt>||Added at top of page to use a different HTML template.  Would require a rewrite so that NobleWiki uses a simple templating engine||
---
> ||<tt><nowiki>{{section|WikiPage|header}}</nowiki></tt>||Non-recursively insert the section text for any page of the identified TOC header||
> ||<tt><nowiki>{{comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab.||
> ||<tt><nowiki>@@CSS|media|StyleSheet</nowiki></tt>||Added at top of an editor's home-page to alter CSS used before rendering any wiki page.||
> ||<tt><nowiki>@@HTML|Template</nowiki></tt>||Added at top of page of an editor's home-page to use force wiki to render pages using a different HTML template.  Would require a rewrite so that NobleWiki uses a simple templating engine||
------
SandBox|1180108592
1d0
< Edit this page.
2a2,3
>  http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox
> 
------
SandBox|1180108599
1c1
< 
---
>  
------
SandBox|1180108609
------
SandBox|1180108653
3c3,4
<  http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox
---
>  
>  [http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox Edit this page.]
------
SandBox|1180108723
4c4
<  [http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox Edit this page.]
---
>  [LocalWiki:action=edit&id=SandBox Edit this page.]
------
SandBox|1180109042
------
SandBox|1180109050
1,2c1
<  
<  
---
>   
------
SandBox|1180109061
1c1,2
<   
---
>  
>  
------
SandBox|1180109068
3c3
<  [LocalWiki:action=edit&id=SandBox Edit this page.]
---
> [LocalWiki:action=edit&id=SandBox Edit this page.]
------
SandBox|1180109218
1,2c1,2
<  
<  
---
> ==== EXPERIMENT WITH EDITING ON THIS PAGE =
> 
------
SandBox|1180109283
1c1
< ==== EXPERIMENT WITH EDITING ON THIS PAGE =
---
> 
------
SandBox|1180109337
3c2,3
< [LocalWiki:action=edit&id=SandBox Edit this page.]
---
>  
>  [http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox Edit this page.]
------
SandBox|1180245439
1d0
< 
3c3
<  [http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox Edit this page.]
---
> [http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox Edit this page.]
------
WikiURLs|1180334172
20,22c20,22
< === Free Links =
< A URL to a wiki entry can be created using a single word instead of a WikiWord by enclosing that single word with pairs of square brackets like <tt>[[Free]]</tt>.  Optionally specify the actual display text after a pipe as in <tt>[[HomePage|Go home]]</tt>
< * [[Free]]
---
> === [#freelink] Free Links =
> A URL to a wiki entry can be created using a single word instead of a WikiWord by enclosing that single word with pairs of square brackets like <tt><nowiki>[[WheeFree]]</nowiki></tt>.  Optionally specify the actual display text after a pipe as in <tt><nowiki>[[HomePage|Go home]]</nowiki></tt>
> * [[WheeFree]]
------
WikiURLs|1180334262
20c20
< === [#freelink] Free Links =
---
> === [#freelinks] Free Links =
------
NobleWiki|1180334304
26a27
> ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
38d39
< ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix||need||
------
NobleWiki|1180334854
------
WikiTOCs|1180336065
15,18c15
< == # SandBox SampleUndefinedPage ==
< Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.  
< 
< === # I am a [http://blogs.kurcina.org/cgi-bin/blosxom.cgi bracketed link]. ===
---
> === # A sub-heading ==
21,22c18,22
< === # I am another [http://blogs.kurcina.org/cgi-bin/blosxom.cgi bracketed link]. ===
< Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.  
---
> === # Another sub-heading ==
> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
> 
> == # Another Heading ==
> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
31,38c31,38
< == # SandBox SampleUndefinedPage ==
< Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.  
< 
< === # I am a [http://blogs.kurcina.org/cgi-bin/blosxom.cgi bracketed link]. ===
< Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.  
< 
< === # I am another [http://blogs.kurcina.org/cgi-bin/blosxom.cgi bracketed link]. ===
< Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
---
> === # A sub-heading ==
> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
> 
> === # Another sub-heading ==
> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
> 
> == # Another Heading ==
> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
------
NobleWiki|1180338021
23a23,24
> ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] feature now adds a 215px box around it with the a title of 'Content'||
> 
------
NobleWiki|1180339565
40a41
> ||UseMod:WikiPatches/MagicContent||want, tons of ideas for use||
------
NobleWiki|1180394780
35d34
< ||UseMod:WikiPatches/RobotsMetaTag||Supposed to place INDEX,FOLLOW on current page versions and the Recent Changes list, and NOINDEX,NOFOLLOW on all prior revisions||
39a39
> ||UseMod:WikiPatches/RobotsMetaTag||Supposed to place INDEX,FOLLOW on current page versions and the Recent Changes list, and NOINDEX,NOFOLLOW on all prior revisions||
70a71,72
> Additionally, I've been reading about what appears to be a major fork of <nowiki>UseMod</nowiki> created by [UseMod:AlexSchroeder Alex Schroeder] named [UseMod:OddMuse OddMuse] that I want to investigate.  The interesting thing is how that wiki's modules are set up.
> 
------
HomePage|1180599802
2c2
< <blockquote>The goal of this Noble Pursuit Games wiki is to provide a common repository and access point for all structured datum gathered either from the forums, the blog, or elsewhere.  <cite>-- RobertKurcina</cite></blockquote>
---
> <blockquote>The goal of this Noble Pursuit Games wiki is to provide a common repository and access point for all structured datum gathered either from the forums, the blog, or elsewhere.  <cite>-- [LocalWiki:RobertKurcina Robert Kurcina]</cite></blockquote>
------
CategoryPeople|1180599930
5,7c5,6
<  /RobertKurcina
<  /RalphMorgan
<  /RichardFrausto
---
>  [LocalWiki:HomePage/RobertKurcina Robert Kurcina]
>  [LocalWiki:HomePage/RalphMorgan Ralph Morgan]
------
NobleWiki|1180599962
1c1
< <blockquote>I really wished that I read more of the [Wiki:UseModWiki UseModWiki] before I started fussing with the 1.0 code.  I see a number of cool ideas from that site that has [Wiki:SunirShah Sunir Shah's] plans for a [Wiki:UseMod UseMod 2.0] that I'd like to include via the available patches.  I think that this behavior of mine to fix something not broken - and therefore break it - is also known as 'hubris'. -- <cite>RobertKurcina</cite></blockquote>
---
> <blockquote>I really wished that I read more of the [Wiki:UseModWiki UseModWiki] before I started fussing with the 1.0 code.  I see a number of cool ideas from that site that has [Wiki:SunirShah Sunir Shah's] plans for a [Wiki:UseMod UseMod 2.0] that I'd like to include via the available patches.  I think that this behavior of mine to fix something not broken - and therefore break it - is also known as 'hubris'. -- <cite>[LocalWiki:RobertKurcina Robert Kurcina]</cite></blockquote>
------
WikiMarkup|1180600006
83c83
< During each adjustment period, each meme may perform one task; infect, dominate, support, weaken, poison or ingrain. Once a host has been infected by a specific meme, it may not be infected by that meme again until the host rids the meme. <cite>-- RobertKurcina</cite></blockquote>
---
> During each adjustment period, each meme may perform one task; infect, dominate, support, weaken, poison or ingrain. Once a host has been infected by a specific meme, it may not be infected by that meme again until the host rids the meme. <cite>-- [LocalWiki:RobertKurcina Robert Kurcina]</cite></blockquote>
------
WikiMarkup|1180600037
83c83
< During each adjustment period, each meme may perform one task; infect, dominate, support, weaken, poison or ingrain. Once a host has been infected by a specific meme, it may not be infected by that meme again until the host rids the meme. <cite>-- [LocalWiki:RobertKurcina Robert Kurcina]</cite></blockquote>
---
> During each adjustment period, each meme may perform one task; infect, dominate, support, weaken, poison or ingrain. Once a host has been infected by a specific meme, it may not be infected by that meme again until the host rids the meme. <cite>-- [LocalWiki:HomePage/RobertKurcina Robert Kurcina]</cite></blockquote>
------
NobleWiki|1180600061
1c1
< <blockquote>I really wished that I read more of the [Wiki:UseModWiki UseModWiki] before I started fussing with the 1.0 code.  I see a number of cool ideas from that site that has [Wiki:SunirShah Sunir Shah's] plans for a [Wiki:UseMod UseMod 2.0] that I'd like to include via the available patches.  I think that this behavior of mine to fix something not broken - and therefore break it - is also known as 'hubris'. -- <cite>[LocalWiki:RobertKurcina Robert Kurcina]</cite></blockquote>
---
> <blockquote>I really wished that I read more of the [Wiki:UseModWiki UseModWiki] before I started fussing with the 1.0 code.  I see a number of cool ideas from that site that has [Wiki:SunirShah Sunir Shah's] plans for a [Wiki:UseMod UseMod 2.0] that I'd like to include via the available patches.  I think that this behavior of mine to fix something not broken - and therefore break it - is also known as 'hubris'. -- <cite>[LocalWiki:HomePage/RobertKurcina Robert Kurcina]</cite></blockquote>
------
SandBox/ExampleTimeline|1180935406
1c1,10
< Describe the new page here.
---
> {{timeline:Giant Robots of World War II|YYYY.MM.DD
> section:USA
> 1895.09.xx|Nikola Tesla demonstrates remote controlled torpedoes|HomePage
> 1895.10.xx|Nikola Tesla demonstrates remote controlled torpedoes|[SomePage|reference]
> 1895.11.xx|Nikola Tesla demonstrates remote controlled torpedoes|[http://www.google.com/|news read here]
> section:UK
> 1895.06.xx|Nikola Tesla demonstrates remote controlled torpedoes
> 1895.07.xx|Nikola Tesla demonstrates remote controlled torpedoes
> 1895.08.xx|Nikola Tesla demonstrates remote controlled torpedoes
> }}
------
CategoryGames|1189753872
6c6,7
< ||GameRules     ||Rules for the various games or hobbies described on this site                    ||
---
> ||GameRules     ||Rules for the various games or hobbies described on this site||
> ||GameDesign||Notes designing a game; terms and mechanics||
------
NobleWiki|1190265833
70a70,71
> ||<tt><nowiki>{{feedback|template}}</nowiki></tt>||Use a template [ see above ] to capture feedback or voting information||
> 
------
SandBox|1191717107
1,3c1
<  
< 
< [http://wiki.kurcina.org/cgi-bin/index.cgi?action=edit&id=SandBox Edit this page.]
---
> #MAGIC @top Params param1=fred param2=wilma
------
SandBox|1191717249
1c1
< #MAGIC @top Params param1=fred param2=wilma
---
> #MAGIC @top ListCommands param1=fred param2=wilma
------
SandBox|1191718571
1c1
< #MAGIC @top ListCommands param1=fred param2=wilma
---
> #MAGIC @top WantedPages param1=fred param2=wilma
------
SandBox|1191718764
1c1
< #MAGIC @top WantedPages param1=fred param2=wilma
---
> #MAGIC @top WantedPages threshold=2
------
SandBox|1191719465
1c1
< #MAGIC @top WantedPages threshold=2
---
> #MAGIC @top WantedPages threshold=0
------
NobleWiki|1191720323
37a37,39
> ||UseMod:WikiPatches/MagicContent||Added.  Need to create links to standard magic content pages||
> ||UseMod:WikiPatches/MagicWantedPages||Uses MagicContent; creates a list of pages that have not yet been created but are referenced by at least 1 existing page||
> 
41,42d42
< ||UseMod:WikiPatches/MagicContent||want, tons of ideas for use||
< ||UseMod:WikiPatches/MagicWantedPages||unsure if useful||
------
NobleWiki|1191721609
39a39,40
> ||UseMod:WikiPatches/ListOrphans||Available via Admin view; list all pages that have no links leading to them||
> 
43d43
< ||UseMod:WikiPatches/ListOrphans||need, but probably not useful based on the coded logic||
------
NobleWiki|1191721844
38c38
< ||UseMod:WikiPatches/MagicWantedPages||Uses MagicContent; creates a list of pages that have not yet been created but are referenced by at least 1 existing page||
---
> ||UseMod:WikiPatches/MagicWantedPages||Via [Wiki:WikiPatches/MagicContent MagicContent]; creates a list of pages that have not yet been created but are referenced by at least 1 existing page||
------
SandBox|1191726090
1a2
> #INCLUDE fred.html
------
NobleWiki|1191727024
0a1
> INCLUDE: something.html
------
NobleWiki|1191727260
1d0
< INCLUDE: something.html
------
NobleWiki|1191727336
40a40,41
> ||UseMod:WikiPatches/FileInclusion||Insert a file into <nowiki>$DataDir/includes</nowiki> and have it appear in a page using command INCLUDE: filename||
> 
------
NobleWiki|1191727440
40c40
< ||UseMod:WikiPatches/FileInclusion||Insert a file into <nowiki>$DataDir/includes</nowiki> and have it appear in a page using command INCLUDE: filename||
---
> ||UseMod:WikiPatches/FileInclusion||Insert a file into <nowiki>$DataDir/includes</nowiki> and have it appear in a page using command <code><nowiki>INCLUDE</nowiki>: filename</code>||
------
NobleWiki|1191729726
41a41,43
> ||UseMod:WikiPatches/UneditablePageBugFix||Prevent pages to be created that can't be edited||
> ||UseMod:WikiPatches/RobotsMetaTag||Prevent search engine robots from indexing edit history versions||
> 
43d44
< ||UseMod:WikiPatches/RobotsMetaTag||Supposed to place INDEX,FOLLOW on current page versions and the Recent Changes list, and NOINDEX,NOFOLLOW on all prior revisions||
------
NobleWiki|1191730561
43a43,44
> ||UseMod:WikiPatches/OriginalAuthor||Modified from original.  Inserts prior to 'Last Edited by' the phrase 'Created on DATE' and adds an author if it one exists||
> 
------
HomePage/Kitrok|1191736794
------
HomePage/Kitrok|1191736917
1c1
< Describe the new page here.
---
>   #REDIRECT HomePage/RobertKurcina
------
HomePage/Kitrok|1191736935
1c1
<   #REDIRECT HomePage/RobertKurcina
---
> #REDIRECT HomePage/RobertKurcina
------
NobleWiki|1191737554
17a17,18
> ||Auto Signature||Insert <code><nowiki>~~~~</nowiki></code> to automatically insert username with link to home page, and timestamp.  Uses 'Guest' if not logged in.|
> 
------
NobleWiki|1191737568
17c17
< ||Auto Signature||Insert <code><nowiki>~~~~</nowiki></code> to automatically insert username with link to home page, and timestamp.  Uses 'Guest' if not logged in.|
---
> ||Auto Signature||Insert <code><nowiki>~~~~</nowiki></code> to automatically insert username with link to home page, and timestamp.  Uses 'Guest' if not logged in.||
------
NobleWiki|1191737779
17c17
< ||Auto Signature||Insert <code><nowiki>~~~~</nowiki></code> to automatically insert username with link to home page, and timestamp.  Uses 'Guest' if not logged in.||
---
> ||Auto Signature||Insert <code><nowiki>~~~</nowiki></code> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <code><nowiki>~~~~</nowiki></code> to append timestamp.||
45a45,46
> ||UseMod:WikiPatches/AutoSignature||Modified from original; basically checks for login status and sets $id to 'Guest' if empty||
> 
------
NobleWiki|1191738305
23a24
> ||UserHome||User home pages are to be created and are assumed to exist as sub-pages under <nowiki>UserHome</nowiki>||
------
NobleWiki|1191738321
24c24
< ||UserHome||User home pages are to be created and are assumed to exist as sub-pages under <nowiki>UserHome</nowiki>||
---
> ||User Home||User home pages are to be created and are assumed to exist as sub-pages under <nowiki>UserHome</nowiki>||
------
NobleWiki|1191738525
24c24
< ||User Home||User home pages are to be created and are assumed to exist as sub-pages under <nowiki>UserHome</nowiki>||
---
> ||User Home||User home pages are to be created and are assumed to exist as sub-pages under <nowiki>UserHome</nowiki> which is defined within <code><nowiki>$HomePagePrefix</nowiki></code>||
------
NobleWiki|1191738756
24c24
< ||User Home||User home pages are to be created and are assumed to exist as sub-pages under <nowiki>UserHome</nowiki> which is defined within <code><nowiki>$HomePagePrefix</nowiki></code>||
---
> ||User Home||User home pages are to be created and are assumed to exist as sub-pages defined within <code><nowiki>$HomePagePrefix</nowiki></code> which is defaulted to be <code><nowiki>HomePage</nowiki></code>||
------
NobleWiki/AuthUser|1191739812
1c1
< Describe the new page here.
---
> kitrok
------
NobleWiki/AuthUsers|1191739913
1c1
< Describe the new page here.
---
> kitrok
------
NobleWiki/AuthUsers|1191739984
1d0
< kitrok
2a2,4
> kitrok
> 
> 
------
NobleWiki/AuthUsers|1191742433
0a1,2
> Kitrok
> 
2,4d3
< kitrok
< 
< 
------
WikiEditing|1191744011
28a30
> === Directives =
34a36,45
> * To include a file that was added into the <code><nowiki>$DataDir</nowiki></code>:
> <pre>
>   <nowiki>INCLUDE: filename</nowiki>
> </pre>
> * To utilize a Magic Content command [ won't show up until page is save ]:
> <pre>
>   <nowiki>#MAGIC @top key=value, key=value, ...
> </pre>
> 
> 
------
TemplateHomePage|1191998619
1c1,8
< Describe the new page here.
---
> ==== Profile =
> 
> || Image || $VARIABLE2$ ||
> || Name || $VARIABLE1$ ||
> || Skills ||$VARIABLE3$ ||
> || Interests ||$VARIABLE4$ ||
> || Quote|| $VARIABLE5$ ||
> || Web site ||$VARIABLE6$ ||
------
TemplateHomePage|1191999365
3c3
< || Image || $VARIABLE2$ ||
---
> || Image || [LocalWiki HomePage upload: $VARIABLE1$] ||
------
TemplateHomePage|1191999668
3,8c3,8
< || Image || [LocalWiki HomePage upload: $VARIABLE1$] ||
< || Name || $VARIABLE1$ ||
< || Skills ||$VARIABLE3$ ||
< || Interests ||$VARIABLE4$ ||
< || Quote|| $VARIABLE5$ ||
< || Web site ||$VARIABLE6$ ||
---
> || Image || [LocalWiki: HomePage upload: $UPLOADIMAGE$] ||
> || Name || $NAME$ ||
> || Skills ||$SKILLS$ ||
> || Interests ||$INTERESTS$ ||
> || Quote|| $QUOTE$ ||
> || Web site ||$WEBSITEURL$ ||
------
TemplateHomePage|1191999714
3c3
< || Image || [LocalWiki: HomePage upload: $UPLOADIMAGE$] ||
---
> || Image || [LocalWiki:HomePage upload:$UPLOADIMAGE$] ||
------
TemplateHomePage|1191999792
3c3
< || Image || [LocalWiki:HomePage upload:$UPLOADIMAGE$] ||
---
> || Image || $UPLOADIMAGE$ ||
------
HomePage/RobertKurcina|1191999829
1,4c1,8
< === Profile =
< 
< This is a temporary page.
< Stuff.  A minor edit.
---
> {{template:TemplateHomePage
> UPLOADIMAGE = [LocalWiki:HomePage upload:homepage.RobertKurcina.jpg]
> NAME = RobertKurcina
> SKILLS = Programming, Illustration, Game Design, Technical Writing,
> INTERESTS = Game Theory, History
> QUOTE = Work harder <i>and</i> work smarter
> WEBSITEURL= http://talkorigins.org/
> }}
------
HomePage/RalphMorgan|1191999992
1,2c1,8
< Describe the new page here.
< ssss
---
> {{template:TemplateHomePage
> UPLOADIMAGE = [LocalWiki:HomePage upload:homepage-RalphMorgan.jpg]
> NAME = Ralph Morgan
> SKILLS = Game Design, Project Coordination
> INTERESTS = Game Theory, History, Illustration
> QUOTE = Robert, this game sucks.
> WEBSITEURL= http://rosecitygames.org/
> }}
------
TemplateHomePage|1192000037
2a3
> !! Name !! <b>$NAME$</b> !!
4d4
< || Name || $NAME$ ||
------
HomePage/RalphMorgan|1192000061
7c7
< WEBSITEURL= http://rosecitygames.org/
---
> WEBSITEURL= http://rosecitygames.com/
------
HomePage/RobertKurcina|1192000098
3c3
< NAME = RobertKurcina
---
> NAME = Robert Kurcina
------
HomePage/RobertKurcina|1192000126
2c2
< UPLOADIMAGE = [LocalWiki:HomePage upload:homepage.RobertKurcina.jpg]
---
> UPLOADIMAGE = [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg]
------
HomePage/RobertKurcina|1192000241
2c2
< UPLOADIMAGE = [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg]
---
> UPLOADIMAGE =
------
HomePage/RobertKurcina|1192000286
2c2
< UPLOADIMAGE =
---
> UPLOADIMAGE =  [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg]
------
SandBox|1192001134
1,2c1
< #MAGIC @top WantedPages threshold=0
< #INCLUDE fred.html
---
> ====== Edit me! =
------
SandBox|1192001181
1c1,3
< ====== Edit me! =
---
> ===== Edit me! =
> 
> 
------
ListOfWantedPages|1192001189
1c1
< Describe the new page here.
---
> #MAGIC @top WantedPages threshold=0
------
HomePage|1192001233
11a11,12
> ||ListOfWantedPages||These are stubbed pages yet to be created||
> 
------
NoblePursuit|1192001490
1c1
< <blockquote>It is unlikely that traditional gaming will ever disappear, but it is quite possible that on-line games will begin to either acquire greater versimilitude or that the culture of gaming will migrate entirely into the Internet leaving no champions of yesterday's games. <cite>-- RobertKurcina </cite></blockquote>
---
> <blockquote>It is unlikely that traditional gaming will ever disappear, but it is quite possible that on-line games will begin to either acquire greater versimilitude or that the culture of gaming will migrate entirely into the Internet leaving no champions of yesterday's games. <cite>-- [LocalWiki:HomePage/RobertKurcina RobertKurcina]</cite></blockquote>
------
ListOfWantedPages|1192177125
1c1
< #MAGIC @top WantedPages threshold=0
---
> #MAGIC @top Params threshold=0
------
ListOfWantedPages|1192177153
1a2,3
> image1=2
> image2=3
------
ListOfWantedPages|1192177555
1,3c1
< #MAGIC @top Params threshold=0
< image1=2
< image2=3
---
> #MAGIC @top Params threshold=0 images=upload1.jpg,upload2.jpg,upload3.jpg
------
ListOfWantedPages|1192177583
1c1
< #MAGIC @top Params threshold=0 images=upload1.jpg,upload2.jpg,upload3.jpg
---
> #MAGIC @top Params threshold=0 images=[upload1.jpg,upload2.jpg,upload3.jpg]
------
ListOfWantedPages|1192177648
1c1
< #MAGIC @top Params threshold=0 images=[upload1.jpg,upload2.jpg,upload3.jpg]
---
> #MAGIC @top Params threshold=0 images={history:"blue", files:[upload1.jpg,upload2.jpg,upload3.jpg]}
------
ListOfWantedPages|1192177668
1c1
< #MAGIC @top Params threshold=0 images={history:"blue", files:[upload1.jpg,upload2.jpg,upload3.jpg]}
---
> #MAGIC @top Params threshold=0 images=history:"blue", files:[upload1.jpg,upload2.jpg,upload3.jpg]
------
ListOfWantedPages|1192177678
1c1
< #MAGIC @top Params threshold=0 images=history:"blue", files:[upload1.jpg,upload2.jpg,upload3.jpg]
---
> #MAGIC @top Params threshold=0 images=history:"blue", files:upload1.jpg,upload2.jpg,upload3.jpg
------
ListOfWantedPages|1192177693
1c1
< #MAGIC @top Params threshold=0 images=history:"blue", files:upload1.jpg,upload2.jpg,upload3.jpg
---
> #MAGIC @top Params threshold=0 images=history:"blue" files=upload1.jpg,upload2.jpg,upload3.jpg
------
ListOfWantedPages|1192177714
1c1
< #MAGIC @top Params threshold=0 images=history:"blue" files=upload1.jpg,upload2.jpg,upload3.jpg
---
> #MAGIC @top Params threshold=0 images=blue files=upload1.jpg,upload2.jpg,upload3.jpg
------
ListOfWantedPages|1192177728
1a3,4
> == h1 =
> 
------
ListOfWantedPages|1192177742
1c1
< #MAGIC @top Params threshold=0 images=blue files=upload1.jpg,upload2.jpg,upload3.jpg
---
> #MAGIC @top Params threshold=0 files=upload1.jpg,upload2.jpg,upload3.jpg images=blue 
------
ListOfWantedPages|1192177907
1,4c1
< #MAGIC @top Params threshold=0 files=upload1.jpg,upload2.jpg,upload3.jpg images=blue 
< 
< == h1 =
< 
---
> #MAGIC @top Params threshold=0 files=upload:upload1.jpg,upload2.jpg,upload3.jpg
------
ListOfWantedPages|1192177971
1c1
< #MAGIC @top Params threshold=0 files=upload:upload1.jpg,upload2.jpg,upload3.jpg
---
> #MAGIC @top Params threshold=0 files=upload1.jpg:This is a short file,upload2.jpg:This was taken during a party,upload3.jpg:Another close-up
------
ListOfWantedPages|1192178033
1c1
< #MAGIC @top Params threshold=0 files=upload1.jpg:This is a short file,upload2.jpg:This was taken during a party,upload3.jpg:Another close-up
---
> #MAGIC @top ListParameters threshold=0 files=upload1.jpg:This is a short file,upload2.jpg:This was taken during a party,upload3.jpg:Another close-up
------
ListOfWantedPages|1192178047
1c1
< #MAGIC @top ListParameters threshold=0 files=upload1.jpg:This is a short file,upload2.jpg:This was taken during a party,upload3.jpg:Another close-up
---
> #MAGIC @top ListParameters threshold=0 files=upload1.jpg
------
ListOfWantedPages|1192178364
1c1
< #MAGIC @top ListParameters threshold=0 files=upload1.jpg
---
> #MAGIC @top Params threshold=0 files=upload1.jpg
------
ListOfWantedPages|1192178376
1c1
< #MAGIC @top Params threshold=0 files=upload1.jpg
---
> #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
------
ListOfWantedPages|1192178499
1c1,3
< #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
---
> #MAGIC @top Params 
> threshold=0 
> files=upload1.jpg|upload2.jpg
------
ListOfWantedPages|1192178549
1,3c1
< #MAGIC @top Params 
< threshold=0 
< files=upload1.jpg|upload2.jpg
---
> #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
------
ListOfWantedPages|1192178634
1c1
< #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
---
> #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg#
------
ListOfWantedPages|1192178640
------
ListOfWantedPages|1192178646
1c1,2
< #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg#
---
> #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
> #
------
ListOfWantedPages|1192178678
1,2c1
< #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
< #
---
> #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg#
------
ListOfWantedPages|1192178755
1c1
< #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg#
---
> #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
------
ListOfWantedPages|1192178773
1c1
< #MAGIC @top Params threshold=0 files=upload1.jpg|upload2.jpg
---
> #MAGIC @top WantedPages threshold=0 files=upload1.jpg|upload2.jpg
------
ListOfWantedPages|1192178867
1c1
< #MAGIC @top WantedPages threshold=0 files=upload1.jpg|upload2.jpg
---
> #MAGIC @top WantedPages threshold=0
------
HomePage|1192297729
2c2
< <blockquote>The goal of this Noble Pursuit Games wiki is to provide a common repository and access point for all structured datum gathered either from the forums, the blog, or elsewhere.  <cite>-- [LocalWiki:RobertKurcina Robert Kurcina]</cite></blockquote>
---
> <blockquote>The goal of this Noble Pursuit Games wiki is to provide a common repository and access point for all structured datum gathered either from the forums, the blog, or elsewhere.  <cite>-- [LocalWiki:HomePage/RobertKurcina Robert Kurcina]</cite></blockquote>
------
AdminActions|1192298165
60c60
< ||[LocalWiki:action=trimusers  trimusers] || Trims down the user database, removing users with no useful preferences set. You must change the $StartUID variable in the config afterwards.||
---
> ||[LocalWiki:action=trimusers  trimusers] || Trims down the user database, removing users with no useful preferences set. You must change the <nowiki><tt>$StartUID</tt></nowiki> variable in the config afterwards.||
67c67
< :It can be useful for sites that haven't set up an admin password (and can't use the web interface).  --CliffordAdams
---
> :It can be useful for sites that haven't set up an admin password (and can't use the web interface).  --[UseMod:CliffordAdams CliffordAdams]
69,71c69,71
< '''Q:''' Is there a way to prune the difflog file? One of my wikis has a 4-meg file. &quot;maintain&quot; does not seem to prune any of the reference log files. -- [[JerryMuelver]]
< 
< '''A:''' Not within the wiki.  You can simply remove the difflog file--it is not used by the wiki (it is a write-only log).  I probably should have disabled it by default in 1.0  The purpose of the difflog file is to allow an admin to track changes (and possibly undo them) if wanted, but the new KeptPages functionality makes this feature almost useless.  --CliffordAdams
---
> '''Q:''' Is there a way to prune the difflog file? One of my wikis has a 4-meg file. &quot;maintain&quot; does not seem to prune any of the reference log files. -- [UseMod:JerryMuelver JerryMuelver]
> 
> '''A:''' Not within the wiki.  You can simply remove the difflog file--it is not used by the wiki (it is a write-only log).  I probably should have disabled it by default in 1.0  The purpose of the difflog file is to allow an admin to track changes (and possibly undo them) if wanted, but the new <nowiki><tt>KeptPages</tt></nowiki> functionality makes this feature almost useless.  --[UseMod:CliffordAdams CliffordAdams]
75,76c75,76
< '''A:''' Yes, there is.  :-)  More helpfully, you can use the browse action and add the &quot;raw=1&quot; parameter, like LocalWiki?action=browse&amp;id=Free_Links&amp;raw=1
< :Note that spaces in the page name should be replaced with _ (underscore) characters.  --CliffordAdams
---
> '''A:''' Yes, there is.  :-)  More helpfully, you can use the browse action and add the &quot;raw=1&quot; parameter, like <nowiki><tt>LocalWiki?action=browse&amp;id=Free_Links&amp;raw=1</tt></nowiki>
> :Note that spaces in the page name should be replaced with _ (underscore) characters.  --[UseMod:CliffordAdams CliffordAdams]
88c88
< '''A:''' Set your $FooterNote variable (in the config) to this:
---
> '''A:''' Set your <nowiki><tt>$FooterNote</tt></nowiki> variable (in the config) to this:
102c102
< '''A:''' You may call the maintain action. This will remove versions older than $KeepDays. A more radical way would be to delete the file with all the older versions. This is placed somewhere under keep/ in the $DataDir. Maybe make a backup before removing. Why is it a problem, if people link to some older version of a page? --MarkusLude
---
> '''A:''' You may call the maintain action. This will remove versions older than <nowiki><tt>$KeepDays</tt></nowiki>. A more radical way would be to delete the file with all the older versions. This is placed somewhere under keep/ in the <nowiki><tt>$DataDir</tt></nowiki>. Maybe make a backup before removing. Why is it a problem, if people link to some older version of a page? --[UseMod:MarkusLude MarkusLude]
108c108
< :See [http://www.usemod.com/robots.txt www.usemod.com 's robots.txt file] - CameronDewe
---
> :See [http://www.usemod.com/robots.txt www.usemod.com 's robots.txt file] - [UseMod:CameronDewe CameronDewe]
------
WikiURLs|1192298266
2c2
< You can link to a page by removing the spaces between two or more words, and starting each word with a capital letter. For instance, WikiName and TextFormattingExamples are samples of page links. 
---
> You can link to a page by removing the spaces between two or more words, and starting each word with a capital letter. For instance, WikiName and SampleUndefinedPage are samples of page links. 
------
WikiURLs|1192298280
2c2
< You can link to a page by removing the spaces between two or more words, and starting each word with a capital letter. For instance, WikiName and SampleUndefinedPage are samples of page links. 
---
> You can link to a page by removing the spaces between two or more words, and starting each word with a capital letter. For instance, WikiName and SandBox are samples of page links. 
------
WikiURLs|1192298330
30c30
< The <tt>InterWiki</tt> is a list or other wikis available on the Internet. The InterMap shows the names for each of those wikis as a namespace.  One common wiki is the <tt>Wiki:</tt> namespace which resolves to either Wiki:WardCunningham""s original wiki at c2.com.  For example, using Wiki:InterWiki will resolve the URL to <tt><nowiki>http://c2.com/cgi-bin/wiki?InterWiki</nowiki></tt>.
---
> The [UseMod:InterWiki InterWiki] is a list or other wikis available on the Internet. The InterMap shows the names for each of those wikis as a namespace.  One common wiki is the <tt>Wiki:</tt> namespace which resolves to either Wiki:WardCunningham""s original wiki at c2.com.  For example, using Wiki:InterWiki will resolve the URL to <tt><nowiki>http://c2.com/cgi-bin/wiki?InterWiki</nowiki></tt>.
------
WikiAdmin|1192298486
1c1,3
< Describe the new page here.
---
> ===== DEFINITION: Wiki Administrator =
> 
> The Wiki Administrator is the person with the huge ego, the big head, and a great responsibility to ensure that the Wiki thrives, is not spammed, is not broken, and is easy to use. This person has many special powers not given to the WikiEditor such as the ability to ban users and ip subnets.
------
WikiEditor|1192298561
1c1,3
< Describe the new page here.
---
> ===== DEFINITION: Wiki Editor =
> 
> And editor has been provided a password to allow them access to certain non-locked sections of the wiki to modify content or to add content.  Editors may upload assets as well.
------
WikiAdmin|1192298606
3c3
< The Wiki Administrator is the person with the huge ego, the big head, and a great responsibility to ensure that the Wiki thrives, is not spammed, is not broken, and is easy to use. This person has many special powers not given to the WikiEditor such as the ability to ban users and ip subnets.
---
> The Wiki Administrator is the person with the huge ego, the big head, and a great responsibility to ensure that the Wiki thrives, is not spammed, is not broken, and is easy to use. This person has many special powers not given to the WikiEditor such as the ability to ban users and ip subnets.  See AdminFeatures for more on this.
------
AdminRole|1192298634
1c1
< Describe the new page here.
---
> REDIRECT: WikiAdmin
------
AdminRole|1192298641
1c1
< REDIRECT: WikiAdmin
---
> #REDIRECT: WikiAdmin
------
AdminRole|1192298697
1c1
< #REDIRECT: WikiAdmin
---
> #REDIRECT WikiAdmin
------
AdminFeatures|1192298973
2,4c2,4
< UseMod:UseModWiki 0.90 and later include some "admin" features.  A new configuration variable <nowiki>$AdminPass</nowiki> has been added.  By default it is "", which disables all admin features.  It can be set to a space-separated list of passwords, allowing multiple separate passwords to be given out.
< 
< Users are considered "admins" if UserIsAdmin (their "administrator" password (set in Preferences) is the same as any admin password). Alternatively, one can add "adminpw=password" to the command line (see below), but it puts the password into the site's logs. (On usemod.com and many other sites the logs are semi-public information.) Saving the editbanned list or submitting an editlinks request requires the user to set their administrator password in Preferences.
---
> UseMod:UseModWiki 0.90 and later include some "admin" features.  A new configuration variable <nowiki><tt>$AdminPass<tt></nowiki> has been added.  By default it is "", which disables all admin features.  It can be set to a space-separated list of passwords, allowing multiple separate passwords to be given out.
> 
> Users are considered "admins" if <nowiki>UserIsAdmin</nowiki> (their "administrator" password (set in Preferences) is the same as any admin password). Alternatively, one can add "adminpw=password" to the command line (see below), but it puts the password into the site's logs. (On usemod.com and many other sites the logs are semi-public information.) Saving the editbanned list or submitting an editlinks request requires the user to set their administrator password in Preferences.
51c51
< The maintainance action (action=maintain) currently (in version 0.92) removes old versions of pages from the keep file if they are more than $KeepDays old (default 14 days).  In future versions the maintenance action may also permanently delete pages (using the MeatBall:DeletedPage convention) or update configuration files.  --UseMod:CliffordAdams
---
> The maintainance action (action=maintain) currently (in version 0.92) removes old versions of pages from the keep file if they are more than <nowiki><tt>$KeepDays</tt></nowiki> old (default 14 days).  In future versions the maintenance action may also permanently delete pages (using the MeatBall:DeletedPage convention) or update configuration files.  --UseMod:CliffordAdams
------
AdminFeatures|1192299029
2c2
< UseMod:UseModWiki 0.90 and later include some "admin" features.  A new configuration variable <nowiki><tt>$AdminPass<tt></nowiki> has been added.  By default it is "", which disables all admin features.  It can be set to a space-separated list of passwords, allowing multiple separate passwords to be given out.
---
> UseMod:UseModWiki 0.90 and later include some "admin" features.  A new configuration variable <nowiki>$AdminPass</nowiki> has been added.  By default it is "", which disables all admin features.  It can be set to a space-separated list of passwords, allowing multiple separate passwords to be given out.
------
BadPeople|1192299222
1c1,3
< Describe the new page here.
---
> ===== DEFINITION: Bad People =
> 
> Hackers, Spammers, malicious content editors, malicious admins, people with weapons of the QWERTY nature.  Maybe even people from across the street.
------
RealContent|1192299470
1c1,3
< Describe the new page here.
---
> ===== DEFINITION: Real Content =
> 
> This page is an example of real content.  It's not very deep or broad in it's presentation of a particular topic, but it is concise.  Other examples of real content would be deeper pages like NobleWiki, NoblePursuit, and WikiStyleGuide.  Those pages have a lot more text for sure, but they are a bit later in the stages of writing.  However, since this is a wiki, all content is living, changing, forever being open to quick revision.  In that sense, all pages in a wiki are still yet DraftContent.
------
ListOfWantedPages|1192299537
1c1
< #MAGIC @top WantedPages threshold=0
---
> #MAGIC @top WantedPages threshold=1
------
ListOfWantedPages|1192299547
1c1
< #MAGIC @top WantedPages threshold=1
---
> #MAGIC @top WantedPages threshold=0
------
WikiPage|1192299802
1c1,4
< Describe the new page here.
---
> ===== DEFINITION: Wiki Pages =
> 
> All pages in this wiki are <nowiki>WikiPages</nowiki>.  A <nowiki>WikiPages</nowiki> is created by first inserting a WikiWord into an existing page, such as the SandBox.  If you then click the save or preview buttons after editing an existing page, the wiki engine will create a link to the new page.  Use the WikiStyleGuide to format your content.
> 
------
WikiPage|1192299839
------
WikiPage|1192300033
------
SandBox|1192300161
3a6,7
> NobleWiki
> 
------
SandBox|1192300186
6,7d2
< NobleWiki
< 
------
WikiBugs|1192301346
1c1,4
< Describe the new page here.
---
> These are the defects or 'bugs' that have been identified to exist within the NobleWiki wiki engine. 
> 
> !!Date Discovered!!Contributor!!Description!!
> ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||
------
NobleWiki|1192301402
55c55
< Here are some standard [UseMod:UseMod UseMod] wiki.pl features that have been removed; not to worry - they'll return.
---
> Here are some standard [UseMod:UseMod UseMod] wiki.pl features that have been removed; not to worry - they'll return.  For a list of actual defects, see WikiBugs.
81a82
>  WikiBugs
------
WikiDefects|1192301432
1c1
< Describe the new page here.
---
> #REDIRECT WikiBugs
------
NobleWiki|1192301460
83a84
>  ListOfWantedPages
------
ListOfWantedPages|1192301547
0a1,2
> This is a list of WikiPages that have been cited but do not as of yet exist.  At present there's a [WikiBug defect] in how this code returns its results; it shows pages that have been  created but may exist as a WikiSubPage or as an external link.
> 
------
ListOfWantedPages|1192301560
3c3
< #MAGIC @top WantedPages threshold=0
---
> #MAGIC @bottom WantedPages threshold=0
------
ListOfWantedPages|1192301569
3c3
< #MAGIC @bottom WantedPages threshold=0
---
> #MAGIC WantedPages threshold=0
------
ListOfWantedPages|1192301578
------
ListOfWantedPages|1192301584
------
ListOfWantedPages|1192301594
1,3d0
< This is a list of WikiPages that have been cited but do not as of yet exist.  At present there's a [WikiBug defect] in how this code returns its results; it shows pages that have been  created but may exist as a WikiSubPage or as an external link.
< 
< 
4a2
> This is a list of WikiPages that have been cited but do not as of yet exist.  At present there's a [WikiBug defect] in how this code returns its results; it shows pages that have been  created but may exist as a WikiSubPage or as an external link.
------
ListOfWantedPages|1192301612
2d1
< This is a list of WikiPages that have been cited but do not as of yet exist.  At present there's a [WikiBug defect] in how this code returns its results; it shows pages that have been  created but may exist as a WikiSubPage or as an external link.
------
WikiBugs|1192301703
4a5,6
> ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the <nowiki><tt>MagicContent</tt></nowiki> will show pages that have been created but may exist as a WikiSubPage or as an external link.||
> 
------
WikiBugs|1192301750
5,6c5
< ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the <nowiki><tt>MagicContent</tt></nowiki> will show pages that have been created but may exist as a WikiSubPage or as an external link.||
< 
---
> ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the UseMod:MagicContent will show pages that have been created but may exist as a Wiki sub-page or as an external link.||
------
CategoryCategory|1192333030
13c13
< ||CategoryWebDev    ||Items of interests for W/LAMP web development; HTML/CSS, javascript, perl, <nowiki>MySql<nowiki>||
---
> ||CategoryWebDev    ||Items of interests for W/LAMP web development; HTML/CSS, javascript, perl, <nowiki>MySql</nowiki>||
------
WikiImages|1192337408
47c47
<  WikiUpload
---
>  WikiUploads
------
GameDesignsInProgress|1192337513
6,7c6,7
<  [[HonourBound]]
<  [[Vigilantes]]
---
>  HonourBound
>  VigilanteS
------
GameDesignsInProgress|1192338000
6,7c6,7
<  HonourBound
<  VigilanteS
---
>  [[HonourBound]]
>  [[Vigilantes]]
------
WikiBugs|1192338107
3,5c3,5
< !!Date Discovered!!Contributor!!Description!!
< ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||
< ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the UseMod:MagicContent will show pages that have been created but may exist as a Wiki sub-page or as an external link.||
---
> !!Date Discovered!!Contributor!!Description!!Status!!
> ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||OPEN||
> ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the UseMod:MagicContent will show pages that have been created but may exist as a Wiki sub-page or as an external link.||FIXED-2007.10.13||
------
WikiTemplates|1192350346
9c9
< For example, here's the code for the both of the templates used.  It's a simple table with three variables named <code>$VARIABLE1$, $VARIABLE2$, $VARIABLE3$</code>.  Note that each variable is cushioned by the <tt>$</tt> symbol on either side.
---
> For example, here's the code for the both of the templates used.  It's a simple table with three variables named <tt>$VARIABLE1$, $VARIABLE2$, $VARIABLE3$</tt>.  Note that each variable is cushioned by the <tt>$</tt> symbol on either side.
21c21
< To utilize a template, create a data block that begins with <code>'{{template:'</code> ends with paired curly braces <code>'}}'</code>.  Within that block, specify the template name immediately after the 'template;' command, and calling out each place-holder variable exactly as defined in the template except for the <tt>'$'</tt> symbols.  Set values to each variables as desired following an <tt>'='</tt> equals sign symbol.
---
> To utilize a template, create a data block that begins with <tt>'{{template:'</tt> ends with paired curly braces <tt>'}}'</tt>.  Within that block, specify the template name immediately after the 'template;' command, and calling out each place-holder variable exactly as defined in the template except for the <tt>'$'</tt> symbols.  Set values to each variables as desired following an <tt>'='</tt> equals sign symbol.
24c24
< This example shows a data block using a primary page template <code>'ExampleTemplate</code>, and passing several values including an image link via the <code>upload:</code> syntax.
---
> This example shows a data block using a primary page template <tt>'ExampleTemplate</tt>, and passing several values including an image link via the <tt>upload:</tt> syntax.
42c42
< This example shows use of a template created as a sub-page.  Notice that the parameters are the same, and that the sub-page is shown fully qualified as <code>WikiTemplates/TemplateExample</code> instead of <code>/TemplateExample</code>.
---
> This example shows use of a template created as a sub-page.  Notice that the parameters are the same, and that the sub-page is shown fully qualified as <tt>WikiTemplates/TemplateExample</tt> instead of <tt>/TemplateExample</tt>.
------
NobleWiki|1192350443
15c15
< ||Lock-out Indicators||Added small symbols to allow quick access to editing a page from the title, and symbols to indicate that a page is locked.  <code>'&not;'</code> is that symbol prefixed to a locked page.||
---
> ||Lock-out Indicators||Added small symbols to allow quick access to editing a page from the title, and symbols to indicate that a page is locked.  <tt>'&not;'</tt> is that symbol prefixed to a locked page.||
17c17
< ||Auto Signature||Insert <code><nowiki>~~~</nowiki></code> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <code><nowiki>~~~~</nowiki></code> to append timestamp.||
---
> ||Auto Signature||Insert <tt><nowiki>~~~</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>~~~~</nowiki></tt> to append timestamp.||
20,22c20,22
< ||Cancel button||Added to Edit page; basically <code>onclick='window.location="&ScriptName()?$id;";'</code>||
< ||IE6 textarea||Added <code><div style='width:100%;'>...</div></code> around the textarea in <code>sub GetTextArea {}</code> to enable 100% width in IE6||
< ||Recent Changes||Instead of <code>$FS3</code> to split the recent changes log, use <code>\W</code>.  For example <code>($ts) = split( /\W/, $fullrc[$i] );</code>.  Seems to work better for WIN32.||
---
> ||Cancel button||Added to Edit page; basically <tt>onclick='window.location="&ScriptName()?$id;";'</tt>||
> ||IE6 textarea||Added <tt><div style='width:100%;'>...</div></tt> around the textarea in <tt>sub GetTextArea {}</tt> to enable 100% width in IE6||
> ||Recent Changes||Instead of <tt>$FS3</tt> to split the recent changes log, use <tt>\W</tt>.  For example <tt>($ts) = split( /\W/, $fullrc[$i] );</tt>.  Seems to work better for WIN32.||
24c24
< ||User Home||User home pages are to be created and are assumed to exist as sub-pages defined within <code><nowiki>$HomePagePrefix</nowiki></code> which is defaulted to be <code><nowiki>HomePage</nowiki></code>||
---
> ||User Home||User home pages are to be created and are assumed to exist as sub-pages defined within <tt><nowiki>$HomePagePrefix</nowiki></tt> which is defaulted to be <tt><nowiki>HomePage</nowiki></tt>||
38c38
< ||UseMod:WikiPatches/WikiTemplate||Modified to require a command string of <code>{{template:</code> before it can be used. Created instructions for use as well; see WikiTemplates||
---
> ||UseMod:WikiPatches/WikiTemplate||Modified to require a command string of <tt>{{template:</tt> before it can be used. Created instructions for use as well; see WikiTemplates||
42c42
< ||UseMod:WikiPatches/FileInclusion||Insert a file into <nowiki>$DataDir/includes</nowiki> and have it appear in a page using command <code><nowiki>INCLUDE</nowiki>: filename</code>||
---
> ||UseMod:WikiPatches/FileInclusion||Insert a file into <nowiki>$DataDir/includes</nowiki> and have it appear in a page using command <tt><nowiki>INCLUDE</nowiki>: filename</tt>||
------
WikiEditing|1192350490
36c36
< * To include a file that was added into the <code><nowiki>$DataDir</nowiki></code>:
---
> * To include a file that was added into the <tt><nowiki>$DataDir</nowiki></tt>:
------
WikiMarkup|1192350590
38c38
< <tt>typewriter</tt> <code>code</code>
---
> <tt>typewriter</tt>
40c40
< <tt>typewriter</tt> <code>code</code>
---
> <tt>typewriter</tt>
80c80
< Wrap any text with <code><blockquote></blockquote></code> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
---
> Wrap any text with <tt><blockquote></blockquote></tt> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
------
WikiStyleGuide|1192350612
20c20
< Divider lines are formed by a string of 4 dashes like so; <code>----</code>.  Dividers are meant to separate common elements of the same topic.  Use divider lines sparingly! Never use a divider unless adequate non-header content appears before and after it.  Do not have blank lines precede or succeed a divider. 
---
> Divider lines are formed by a string of 4 dashes like so; <tt>----</tt>.  Dividers are meant to separate common elements of the same topic.  Use divider lines sparingly! Never use a divider unless adequate non-header content appears before and after it.  Do not have blank lines precede or succeed a divider. 
------
WikiEditing|1192353115
42c42
<   <nowiki>#MAGIC @top key=value, key=value, ...
---
>   #MAGIC @top key=value, key=value, ...
------
WikiEditing|1192353337
38c38
<   <nowiki>INCLUDE: filename</nowiki>
---
>   <nowiki>#INCLUDE filename</nowiki>
39a41,42
>  #INCLUDE something.html
> 
------
WikiBugs|1192353827
3a4
> ||2007.10.14||[HomePage/RobertKurcina RobertKurcina]||List Orphans appears to list valid pages||OPEN||
------
HomePage/RobertKurcina|1192417705
4c4
< SKILLS = Programming, Illustration, Game Design, Technical Writing,
---
> SKILLS = Software Development [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash/Web, AI/AL ], Technical Writing
------
HomePage/RobertKurcina|1192417909
4c4
< SKILLS = Software Development [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash/Web, AI/AL ], Technical Writing
---
> SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash/Web, AI/AL ], Technical Writing, Digital Media [ PhotoShop, Illustrator, Freehand, InDesign, MS-Office ]
------
HomePage/RobertKurcina|1192421427
4c4
< SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash/Web, AI/AL ], Technical Writing, Digital Media [ PhotoShop, Illustrator, Freehand, InDesign, MS-Office ]
---
> SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash/Web, AI/AL ], Technical Writing, Digital Media [ PhotoShop, Illustrator, Freehand, InDesign, MS-Office ]<
------
HomePage/RobertKurcina|1192421457
4c4
< SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash/Web, AI/AL ], Technical Writing, Digital Media [ PhotoShop, Illustrator, Freehand, InDesign, MS-Office ]<
---
> SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash, AI/AL ], Technical Writing, Digital Media [ PhotoShop, Illustrator, Freehand, InDesign, MS-Office ]<
------
HomePage/RobertKurcina|1192421522
4c4
< SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, JavaScript, ActionScript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash, AI/AL ], Technical Writing, Digital Media [ PhotoShop, Illustrator, Freehand, InDesign, MS-Office ]<
---
> SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, Javascript, Actionscript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash, AI/AL ], Technical Writing, Digital Media [ Photoshop, Illustrator, Freehand, MS-Office ]
------
HomePage/RobertKurcina|1192437679
4c4
< SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, Javascript, Actionscript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Paper, Flash, AI/AL ], Technical Writing, Digital Media [ Photoshop, Illustrator, Freehand, MS-Office ]
---
> SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, Javascript, Actionscript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Boardgames, Role-playing Games, Flash, AI/AL ], Writing [ Technical, Storycraft ], Digital Media [ Photoshop, Illustrator, Freehand, MS-Office ]
------
HomePage/RalphMorgan|1192858936
6c6
< QUOTE = Robert, this game sucks.
---
> QUOTE = Robert, this game sucks.  ... hey, I never said that! - ralph
------
GiantRobotsOfWorldWarII/History1865|1192947919
1c1
< Describe the new page here.
---
> TEST
------
GiantRobotsOfWorldWarII|1192948241
1c1,15
< Describe the new page here.
---
> = Introduction =
> 
> "Giant Robots of World War Two: European Theatre" focuses on a pulp-fiction alternate reality in which World War II became sustainable because of the arrival of nuclear power, super alloys, and robotics.  Combined with intense non-failing loyalty among all nations to their leaders or its dictators; these factors allowed what we know as the technology of the Atomic Age to be introduced into the global fighting of WWII which now engulfs the remainder of the world.
> 
> == Nations at War =
> There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America [ USA ], peered with Russia [ USSR ] and the United Kingdom Empire [ UK ].  On the opposing side are Germany, Japan, and Italy.
> 
> == Game Goal =
> Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
> 
> Objective Markers are also placed upon the battlefield as goals for acquisition during play which translate into victory points.  Victory points are also awarded for eliminating enemy units.  At the end of the game  usually 6 turns long  the player with the most points wins!
> 
> ====== Related =
>  /WorldHistory
>  /RulesFAQ
------
GiantRobotsOfWorldWarII/WorldHistory|1192948397
1c1,20
< Describe the new page here.
---
> == World History =
> This is a stub
> 
> == Current Events = 
>  /History1865
>  /History1870
>  /History1875
>  /History1880
>  /History1885
>  /History1890
>  /History1895
>  /History1900
>  /History1905
>  /History1910
>  /History1915
>  /History1920
>  /History1925
>  /History1930
>  /History1935
>  /History1940
------
GiantRobotsOfWorldWarII/History1865|1192949050
1c1,11
< TEST
---
> = HISTORY 1865-1869 =
> These are the events that made for the interesting future of Giant Robots of World War II
> 
> ==== 1864 =  
> * SPRING - End of the American Civil War at a stand-still after the "Cotton Gin Man" became self-produced in large quantities.
> * SUMMER - Dissolution of the manumission system.
> 
> 
> ==== 1865 =  
> * WINTER - 
> 
------
GiantRobotsOfWorldWarII/WorldHistory|1192949070
4c4,5
< == Current Events = 
---
> == Current Events =
>  /History1860
------
GiantRobotsOfWorldWarII/History1860|1192949258
1c1,36
< Describe the new page here.
---
> = HISTORY 1860-1864 =
> These are the events that made for the interesting future of Giant Robots of World War II
> 
> ==== 1860 =  
> * SPRING - Introduction of the "Cotton Gin Men" into Virginia, invention by Theodore Krunk.  A self-replicating machine that picks and bales cotton.
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
> 
> 
> ==== 1861 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
> 
> 
> ==== 1862 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
> 
> 
> ==== 1863 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
> 
> 
> ==== 1864 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
------
GiantRobotsOfWorldWarII/History1865|1192949294
4,8d3
< ==== 1864 =  
< * SPRING - End of the American Civil War at a stand-still after the "Cotton Gin Man" became self-produced in large quantities.
< * SUMMER - Dissolution of the manumission system.
< 
< 
9a5,7
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
11a11,36
> ==== 1866 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
> 
> 
> ==== 1867 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
> 
> 
> ==== 1868 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
> 
> 
> ==== 1869 =  
> * SPRING -
> * SUMMER - 
> * AUTMUN - 
> * WINTER - 
------
GiantRobotsOfWorldWarII/History1860|1192949397
5c5
< * SPRING - Introduction of the "Cotton Gin Men" into Virginia, invention by Theodore Krunk.  A self-replicating machine that picks and bales cotton.
---
> * SPRING - Introduction of the "Cotton Gin Men" into Virginia, invention by Theodore Krunk.  A wheeled machine that picks and bales cotton.
------
GiantRobotsOfWorldWarII/WorldHistory|1192949895
2c2
< This is a stub
---
> These are the events that made for the interesting future of Giant Robots of World War II
------
GiantRobotsOfWorldWarII/WorldHistory|1192949911
4c4
< == Current Events =
---
> == Events =
------
GRoWWII|1192949974
1c1
< Describe the new page here.
---
> #REDIRECT GiantRobotsOfWorldWarII
------
HomePage|1193242270
13a14
>  GiantRobotsOfWorldWarII
------
GiantRobotsOfWorldWarII|1193242532
9c9,10
< Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
---
> Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating 
> Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
12a14,36
> == The Operational Art of War =
> This game is a fanciful but detailed look at how to prosecute warfare at the operational level.  Unlike many such games that employ hundreds of unit counters to recreate such a simulation, this one focuses on the interaction of ten or twenty.  
> 
> === EPIC GAMES =
> Here are the key differences of operational level games when compared to tactical level games that deal with smaller units like men, squads, or platoons:
> 
> ==== Game Scale =
> This operational level game deals with units that are companies and battalions.  Theres about a thousand soldiers or one-hundred vehicles in a battalion.  Or, maybe it just contains 10 really humongous robots and their nervous human handlers.  
> 
> Operational level games are epic; with just a few units, these games simulate what would normally take hundreds of pieces in smaller scale games.  With this scale; battles can be waged over control of a city and its country-sides instead of just individual buildings or bridges.
> 
> ==== Zone-of-Control [ ZOC ] =
> Imagine reaching out your hands in front of you, and whirling about to cover your back.  You probably could cover about 3 feet in a radius around you; anybody coming within range would probably get smacked, or at least move cautiously by.  Now do this with a machine gun, with mortars, with cannons, with giant robot beam weapons.  And then, multiply that by several hundred or several thousand rounds of weapons fire by nearly as many soldiers or tanks covering several hundred meters all about.  Thats Zone-of-Control.
> 
> ==== Supply =
> In the scale of tactical level games, the firefights go pretty quickly; maybe five to twenty minutes pass in game-time depending on the scale of the simulation.  Ammo does run out, but probably not fuel.  You can always reload.  In operation level games, supply is critical.  Being in supply - within the distance of the supply truck convoys  can be the difference between having your units perforated, running for cover, or pressing the battle-line victoriously forward.
> 
> ==== Line-of-Command [ LOC ] =
> At the tactical level, the heroic commanders could probably shout orders to their equally heroic underlings, and maybe get some things done by all as a team.  It doesnt work that well with the units that are way across the hill, especially when each unit represents the average response of possibly hundreds of disorganized warriors awaiting instruction.  Without Line-of-Command, units will not be able to participate in the glory of taking down that mammoth tank or draw the line against the rogue sentinel robot together.
> 
> ==== Weather =
> Lastly, weather conditions become a grave concern for the force commanders in operational-level play.  At smaller scales, it may rain or snow for the duration of the battle.  Perhaps the mud conditions might prevail through-out.  However, at this larger scale; the mud may clear up as soon as day breaks.  The time to make an opportune strike can be seen just a few hours away; hold that battle-line until then!
> 
------
WikiMarkup|1193242614
80c80
< Wrap any text with <tt><blockquote></blockquote></tt> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
---
> Wrap any text with <nowiki><tt><blockquote></blockquote></tt></nowiki> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
------
WikiMarkup|1193242648
80c80
< Wrap any text with <nowiki><tt><blockquote></blockquote></tt></nowiki> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
---
> Wrap any text with <nowiki><code><blockquote></blockquote></code></nowiki> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
------
WikiMarkup|1193242667
80c80
< Wrap any text with <nowiki><code><blockquote></blockquote></code></nowiki> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
---
> Wrap any text with <code><nowiki><blockquote></blockquote></nowiki></code> tags in order to show it with a nice quotation mark image.  Insert your author name within <tt><cite></cite></tt> tags before closing the quote.  Here's a nice example of using blockquote:
------
GiantRobotsOfWorldWarII|1193242752
3c3
< "Giant Robots of World War Two: European Theatre" focuses on a pulp-fiction alternate reality in which World War II became sustainable because of the arrival of nuclear power, super alloys, and robotics.  Combined with intense non-failing loyalty among all nations to their leaders or its dictators; these factors allowed what we know as the technology of the Atomic Age to be introduced into the global fighting of WWII which now engulfs the remainder of the world.
---
> <blockquote>"Giant Robots of World War Two: European Theatre" focuses on a pulp-fiction alternate reality in which World War II became sustainable because of the arrival of nuclear power, super alloys, and robotics.  Combined with intense non-failing loyalty among all nations to their leaders or its dictators; these factors allowed what we know as the technology of the Atomic Age to be introduced into the global fighting of WWII which now engulfs the remainder of the world.</blockquote>
------
GiantRobotsOfWorldWarII|1193242896
39a40,41
>  /DesignNotes
>  /NewIdeas
------
HomePage|1193636362
16c16,18
<  [http://forums.kurcina.org/cgi-bin/groww2/index.cgi Giant Robots of World War II Forums]\
---
>  [http://forums.kurcina.org/cgi-bin/groww2/index.cgi Giant Robots of World War II Forums]
> 
>  TotallyNew/DoesntExist
------
HomePage|1193636383
19a19,20
>  /NeitherDoesThisExist
> 
------
GiantRobotsOfWorldWarII/History1860|1193642939
10a9,10
>  /AgainAgain
> 
------
GiantRobotsOfWorldWarII/History1935|1193643253
1a2
> done.
------
GiantRobotsOfWorldWarII/History1935|1193643267
------
GiantRobotsOfWorldWarII/History1940|1193643288
1a4
> ok. done.
------
HomePage|1193673048
18,20d17
<  TotallyNew/DoesntExist
<  /NeitherDoesThisExist
< 
------
HomePage|1193673277
18c18
<  <subpages>
---
>  #SUBPAGES
------
HomePage|1193673325
18c18
<  #SUBPAGES
---
>  #SUBPAGES GiantRobotsOfWorldWarII
------
HomePage|1193674088
18c18
<  #SUBPAGES GiantRobotsOfWorldWarII
---
>  #SUBPAGES
------
WikiEditing|1193674429
43c43
< * To utilize a Magic Content command [ won't show up until page is save ]:
---
> * To utilize a Magic Content command [ effects won't show up until page is saved ]:
48a48,53
> * To list all of the sub pages of a parent page do the following, leaving 'TargetPage' blank if this is for the current page being edited:
> <pre>
>   #SUBPAGES TargetPage
> </pre>
> 
> 
------
WikiEditing|1193674461
48c48
< * To list all of the sub pages of a parent page do the following, leaving 'TargetPage' blank if this is for the current page being edited:
---
> * To list all of the sub pages of a parent page do the following, leaving <tt><nowiki>TargetPage</nowiki></tt> blank if this is for the current page being edited:
------
GameDesignsInProgress|1193702210
16a16,17
>  WarAtSea
> 
------
WikiImages|1193969698
43c43
<  <b>As well as: </b> <tt><nowiki><[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]</nowiki></tt>
---
>  <b>As well as: </b> <tt><nowiki>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]</nowiki></tt>
------
HomePage|1193977650
17a18,21
> [http://www.yahoo.com/ upload:SAMPLE.churcill.jpg|width=600|title=Sample Picture|description=A wonderful thing to see such as this.  Sometimes the information is overwhelming, but the evidence favors the detail-oriented observer.]
> 
> [http://www.google.com/ upload:SAMPLE.churcill.jpg|float=left|title=Sample Picture|description=A wonderful thing to see such as this.  Sometimes the information is overwhelming, but the evidence favors the detail-oriented observer.]
> 
------
HomePage|1193977678
18,21d17
< [http://www.yahoo.com/ upload:SAMPLE.churcill.jpg|width=600|title=Sample Picture|description=A wonderful thing to see such as this.  Sometimes the information is overwhelming, but the evidence favors the detail-oriented observer.]
< 
< [http://www.google.com/ upload:SAMPLE.churcill.jpg|float=left|title=Sample Picture|description=A wonderful thing to see such as this.  Sometimes the information is overwhelming, but the evidence favors the detail-oriented observer.]
< 
------
SandBox|1193981630
2a2,8
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|title=Sample Picture|description=This is a short bit of text <a href='http://www.yahoo.com/things'>thung</a>.]
> 
> [http://www.yahoo.com/ upload:sample_bocage.jpg|float=right|clear=both|title=Sample Picture]
> 
> [http://www.yahoo.com/ upload:sample_bocage.jpg|float=right|clear=both|title=Sample Picture]
> 
> [http://www.yahoo.com/ upload:sample_bocage.jpg|float=right|clear=both|title=Sample Picture]
------
SandBox|1193985255
2,8c2,4
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|title=Sample Picture|description=This is a short bit of text <a href='http://www.yahoo.com/things'>thung</a>.]
< 
< [http://www.yahoo.com/ upload:sample_bocage.jpg|float=right|clear=both|title=Sample Picture]
< 
< [http://www.yahoo.com/ upload:sample_bocage.jpg|float=right|clear=both|title=Sample Picture]
< 
< [http://www.yahoo.com/ upload:sample_bocage.jpg|float=right|clear=both|title=Sample Picture]
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture|description=asdasdfasdf asdfasdf] This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.
> 
> 
------
SandBox|1193985306
2,4c2
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture|description=asdasdfasdf asdfasdf] This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.This change is a minor edit.
< 
< 
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture] 
------
SandBox|1193985312
------
SandBox|1193985382
1a2,3
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture]
>  
3a6
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture] 
------
SandBox|1193986442
2c2
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture]
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|boxclear=right|title=Sample Picture|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ]
------
SandBox|1193986651
2c2
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|boxclear=right|title=Sample Picture|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ]
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=Sample Picture|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
4,6c4,6
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture] 
< 
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|boxclear=right|title=Sample Picture] 
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=right|float=left|title=Sample Picture|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
> 
> [http://www.yahoo.com/ Some link goes here|title=Awesome news!|description=not relevant]
------
SandBox|1193988444
2c2
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=Sample Picture|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
6a8,9
> [http://www.yahoo.com/ upload:sample_bocage.jpg|description=whatever works is good for here.] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
> 
------
SandBox|1193988791
8,9c8,14
< [http://www.yahoo.com/ upload:sample_bocage.jpg|description=whatever works is good for here.] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
< 
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxfloat=left|description=very long description worthy of an Emmy. See more in the next line.  And also here and here and here.] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
> 
> revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsrevisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsrevisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsrevisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
> 
> revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
> 
> revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
------
SandBox|1193989028
8,14c8,50
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxfloat=left|description=very long description worthy of an Emmy. See more in the next line.  And also here and here and here.] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
< 
< revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsrevisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsrevisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsrevisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
< 
< revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
< 
< revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxfloat=left|description=very long description worthy of an Emmy. See more in the next line.  And also here and here and here.] 
> 
> = Introduction =
> 
> <blockquote>"Giant Robots of World War Two: European Theatre" focuses on a pulp-fiction alternate reality in which World War II became sustainable because of the arrival of nuclear power, super alloys, and robotics.  Combined with intense non-failing loyalty among all nations to their leaders or its dictators; these factors allowed what we know as the technology of the Atomic Age to be introduced into the global fighting of WWII which now engulfs the remainder of the world.</blockquote>
> 
> == Nations at War =
> There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America [ USA ], peered with Russia [ USSR ] and the United Kingdom Empire [ UK ].  On the opposing side are Germany, Japan, and Italy.
> 
> == Game Goal =
> Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating 
> Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
> 
> Objective Markers are also placed upon the battlefield as goals for acquisition during play which translate into victory points.  Victory points are also awarded for eliminating enemy units.  At the end of the game  usually 6 turns long  the player with the most points wins!
> 
> == The Operational Art of War =
> This game is a fanciful but detailed look at how to prosecute warfare at the operational level.  Unlike many such games that employ hundreds of unit counters to recreate such a simulation, this one focuses on the interaction of ten or twenty.  
> 
> === EPIC GAMES =
> Here are the key differences of operational level games when compared to tactical level games that deal with smaller units like men, squads, or platoons:
> 
> ==== Game Scale =
> This operational level game deals with units that are companies and battalions.  Theres about a thousand soldiers or one-hundred vehicles in a battalion.  Or, maybe it just contains 10 really humongous robots and their nervous human handlers.  
> 
> Operational level games are epic; with just a few units, these games simulate what would normally take hundreds of pieces in smaller scale games.  With this scale; battles can be waged over control of a city and its country-sides instead of just individual buildings or bridges.
> 
> ==== Zone-of-Control [ ZOC ] =
> Imagine reaching out your hands in front of you, and whirling about to cover your back.  You probably could cover about 3 feet in a radius around you; anybody coming within range would probably get smacked, or at least move cautiously by.  Now do this with a machine gun, with mortars, with cannons, with giant robot beam weapons.  And then, multiply that by several hundred or several thousand rounds of weapons fire by nearly as many soldiers or tanks covering several hundred meters all about.  Thats Zone-of-Control.
> 
> ==== Supply =
> In the scale of tactical level games, the firefights go pretty quickly; maybe five to twenty minutes pass in game-time depending on the scale of the simulation.  Ammo does run out, but probably not fuel.  You can always reload.  In operation level games, supply is critical.  Being in supply - within the distance of the supply truck convoys  can be the difference between having your units perforated, running for cover, or pressing the battle-line victoriously forward.
> 
> ==== Line-of-Command [ LOC ] =
> At the tactical level, the heroic commanders could probably shout orders to their equally heroic underlings, and maybe get some things done by all as a team.  It doesnt work that well with the units that are way across the hill, especially when each unit represents the average response of possibly hundreds of disorganized warriors awaiting instruction.  Without Line-of-Command, units will not be able to participate in the glory of taking down that mammoth tank or draw the line against the rogue sentinel robot together.
> 
> ==== Weather =
> Lastly, weather conditions become a grave concern for the force commanders in operational-level play.  At smaller scales, it may rain or snow for the duration of the battle.  Perhaps the mud conditions might prevail through-out.  However, at this larger scale; the mud may clear up as soon as day breaks.  The time to make an opportune strike can be seen just a few hours away; hold that battle-line until then!
> 
> ====== Related =
>  /WorldHistory
>  /RulesFAQ
>  /DesignNotes
>  /NewIdeas
------
SandBox|1193989453
------
SandBox|1193990024
11c11
< <blockquote>"Giant Robots of World War Two: European Theatre" focuses on a pulp-fiction alternate reality in which World War II became sustainable because of the arrival of nuclear power, super alloys, and robotics.  Combined with intense non-failing loyalty among all nations to their leaders or its dictators; these factors allowed what we know as the technology of the Atomic Age to be introduced into the global fighting of WWII which now engulfs the remainder of the world.</blockquote>
---
> ew other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revision
------
NobleWiki|1193991400
18a18,19
> ||Bracketed Image URLs with options||<tt><nowiki>[URL upload:image|<options>]</nowiki></tt>]; There's a number of options available now for images including title, description, boxclear, boxwidth, boxfloat, float, and clear.  The last are for images within a caption box if description is provided.  If description is provided but not title, then the title will show "FIGURE X" where X is computed as the current number of un-titled images||
> 
47a48,49
> ||UseMod:WikiPatches/SubPages||Modified synatx.  <tt><nowiki>#SUBPAGES</nowiki></tt>Inserts all of a page's sub-pages.  Optional page name as in <tt><nowiki>#SUBPAGES somepage</nowiki></tt> will show that page's subpages||
> 
67,68d68
< ||<tt><nowiki>subpages</nowiki></tt>||Inserts all of a page's subpages||
< ||<tt><nowiki>upload:url|caption</nowiki></tt>||Will insert the caption at the bottom of the picture, centered||
------
NobleWiki|1193991424
18c18
< ||Bracketed Image URLs with options||<tt><nowiki>[URL upload:image|<options>]</nowiki></tt>]; There's a number of options available now for images including title, description, boxclear, boxwidth, boxfloat, float, and clear.  The last are for images within a caption box if description is provided.  If description is provided but not title, then the title will show "FIGURE X" where X is computed as the current number of un-titled images||
---
> ||Bracketed Image URLs with options||<tt><nowiki>[URL upload:image|<options>]</nowiki></tt> There's a number of options available now for images including title, description, boxclear, boxwidth, boxfloat, float, and clear.  The last are for images within a caption box if description is provided.  If description is provided but not title, then the title will show "FIGURE X" where X is computed as the current number of un-titled images||
------
NobleWiki|1194001329
19a19,20
> ||Left Navigation||Created 2-column layout with left navigation.  This HTML content is set by the value of <tt><nowiki>$WikiLeftNavigation</nowiki></tt>||
> 
------
NobleWiki|1194001358
22c22
< ||Cancel button||Added to Edit page; basically <tt>onclick='window.location="&ScriptName()?$id;";'</tt>||
---
> ||Cancel button||Added to Edit page; basically <tt><nowili>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
------
NobleWiki|1194001401
23c23
< ||IE6 textarea||Added <tt><div style='width:100%;'>...</div></tt> around the textarea in <tt>sub GetTextArea {}</tt> to enable 100% width in IE6||
---
> ||IE6 textarea||Added <tt><div style='width:100%;'>...</div></tt> around the textarea in <tt><nowiki>sub GetTextArea {}</nowiki></tt> to enable 100% width in IE6||
------
NobleWiki|1194001422
22c22
< ||Cancel button||Added to Edit page; basically <tt><nowili>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
---
> ||Cancel button||Added to Edit page; basically <tt><nowik>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
------
FeaturedContent|1194002126
1c1,5
< Describe the new page here.
---
> = Featured Content =
> This section is to provide a list of currently hot topics, projects, or pages.  The 'hotness' is a manual effort.  If you feel that a particular subject should be represented on this page, be sure to add it or ContactUs so that we can add it.
> 
> == Giant Robots of World War II =
> GRoWWII is the most active game project.
------
ContactUs|1194002300
1c1,8
< Describe the new page here.
---
> = Contact Information =
> We're just a small team of developers.  Well, just one developer and a bunch of friends.  Well, okay; just one developer and people that I get to hang out with once in a while.
> 
> === E-Mail Address =
> kitrok@yahoo.com
> 
> 
> 
------
NobleWiki|1194002330
22c22
< ||Cancel button||Added to Edit page; basically <tt><nowik>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
---
> ||Cancel button||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
------
GiantRobotsOfWorldWarII|1194067706
------
GiantRobotsOfWorldWarII/TableOfOrganizationAndEquipment|1194069079
1c1,323
< Describe the new page here.
---
> <toc>
> 
> == Table of Organization and Equipment =
> <blockquote>Consider that 1 Operational Point [ OP ] is equivalent to about	100 soldiers.  A standard 5 OP unit like the Biluxi Regulars then represent about 500 soldiers.  Keep this in mind when seeing the very end of this document that the Allied Supreme Headquarters governs about 100,000 OP. That's about 10 million soldiers across approximately 2,000 divisions from all nations in the Allied powers [ USA, USSR, UK, plus minor nations ].</blockquote>
> 
> === # Construction =
> Historically, the US used square elements while the European forces used triangular elements.  That means; 2 battalions forms 1 regiment, and then 2 regiments for 1 brigade, and 2 brigades form 1 divisin.  Etc.  In the world of GROWWII, things are quadratic because of the increased numbers of available soldiers and equipment. In addition there's an assumption that well-balanced forces will be constructed with an average of 1 support unit [ HQ, Supply, Signals ] for every 4 or so combat units.
> 
> Therefore, define regiments as 4 declared battalions.  These regiments are OP independent in order to allow grouping into divisions or brigades.  Create divisions by defining 4 regiments.  
> 
> Corps are then defined as 4 divisions, and Armies as 4 corps.  Army Groups are then 4 Armies.  Following Army Groups are Theater of Operations with 3-6 Army Groups apiece, and then Supreme Forces as defined by either the Axis or Allies; each of which have 3-6 Theaters depending on the year within the GROWWII world history.
> 
> === # Orders of Battle =
> All levels of organization could be configured with 3-6 sub-elements instead of the normal 4. Depending on the needs of strategic command; each sub-element could instead be 3-6 of the next level lower in order to fulfill special operations demands.  At all organizational levels International elements are allowed but are most likely the be represented within the Army Groups from an administrative perspective. From a mission construction perspective; divisions, brigades, regiments, and battalions will appear from various international parent elements according to the conditions of environment and the period represented.  
> 
> ==== # Example: Simple OOB =
> The 3rd US Army that had 3 Corps and the 87th Airborne Division attached. 
> 	
> ==== # Example: Mixed OOB =
> The FUSAG [ First United States Army Group ] was a fictitious OOB which included the US 14th Army and the British 4th Army as follows:
> 
>  US Fourteenth Army:		
> 	XXXIII Corps
> 		17th Division
> 		59th Division
> 		
> 	XXXVII Corps
> 		25th Division
> 		11th Division
> 		48th Division 
> 
>  British 4th Army: 
> 	2nd Corps 
> 		55th Division
> 		61st Division
> 		80th Division
> 		35th Division
> 		
> 	7th Corps
> 		5th Division
> 		58th Division 
> 		
> 	2nd Airborne Division
> 
> 
> ==== # Example: Complete OOB =		
> The Battle for France entry on wikipedia.org has an outstanding OOB with further links into the site for details.  Here's the URL: http://en.wikipedia.org/wiki/Order_of_Battle_for_the_Battle_of_France
> 	
> and here's an excerpt:
> 		
>  Allies
>   French First Army Group
>     French Cavalry Corps
>       2nd Light Mechanized Division
>       3rd Light Mechanized Division
>     French III Corps
>       1st Moroccan Infantry Division
>       2nd North African Infantry Division
>     4th Army Corps (France)
>       32nd Infantry Division
>     French V Corps
>       5th North African Infantry Division
>       101st Infantry Division
>     Belgian VII Corps
>       2nd Chasseurs Ardennais
>       8th Infantry Division
> 
>   French Second Army Group
>   French Third Army Group
>   Dutch Army
>   Army of the Alps 
>   French reserves
>   British Expeditionary Force
>   
>  Axis
>   OKH Reserve
>   German Army Group A
>   German Army Group B
>   German Army Group C
> 
> === # Corps Organization Roles =
> Not all Corps have combat mission roles; as a result their sub-elements will have different emphasis missions, and the parent Army and Army Groups will also vary as a result of aggregation.
> 
> There are four broad categories of roles; Combat Mission, Service Missions, Support Missions, and Base Missions.  The first two are near the battlefront and are separated by perhaps 100 miles.  Support Missions are usually out of the combat zones, but Base Missions are always at established cities of national origin.
> 
> !!Mission!!Role!!
> ||Combat Missions||Amphibious||
> || ||Armor||
> || ||Engineers||
> || ||Infantry||
> || ||Naval Operations||
> || ||Strategic Air||
>  
> ||Service Missions||Logistics||
> || ||Ordnance|| 
> || ||Repair||
> || ||Robotics||
> || ||Signals||
> || ||Technology||
>   
> ||Support Missions||Advanced Research||
> || ||Chaplain||
> || ||Command||
> || ||Electronics||
> || ||Intelligence||
> || ||Medical||
>  
> ||Base Missions||Construction||
> || ||Finance||
> || ||Legal||
> || ||Peace||
> || ||Police||
> || ||Public Affairs||
> || ||Research||
> || ||Training||
> || ||Transportation||
> 			
> === # Pseudo-historical Details =
> From a history-building perspective; these kinds configurations can be used in
> various numbers to be doctrinal, uncommon, or rare assignments.  Regardless;
> when a configuration is defined it can be named and cited with full illustrative
> examples and force anaylsis for puff pieces.  That's a goal.  For example: 
> 
> ==== # Example: Allohistorical LADs =
> <i>The "Robotic Assault Regiment" first became established with the wide-spread production of the Halen Assault robot, which was not possible until the creation of the positronic neural-net at Harvard University in 1941. The regiment had multiple configurations including a couple with greater presence of infantry companies in order to hold ground. It was then determined that the best mission for which this type of regiment could be employed was those of Search and Destroy.  As such, great amounts of firepower - regardless of speed of approach - was desired. In 1944, the first of what became known as the "Loer Automated Destroyers [ LADs ]" became deployed at Gibraltar, Spain. They proved entirely successful	in weeding out remnant Axis pockets in short order. See FIGURE 30A and 30B for the	most common configurations. FIGURE 30C shows how the LADs were organized into the standard Brute Assault Corps.  The most famous of the LAD implementations was the 5th LAD Regiment, 2nd Mechanized Division of the 10th Armored Corps. Equally famous was the 23rd LAD Rgt of the	3/10 AC.</i>
> 
> === # Leader Assignment =
> Once the various divisions are configured can assign specific leaders to each of the divisions. The rules as of version 0.43.2 allow 1 leader per regiment and 1 more per 50 OP. The application of this should be conservative in order to keep leader ranks consistent between divisions.
> 
> Therefore apply this to the division:
>  4 x 1-star [ 1 per regiment ]
>  1 x 2-star [ 1 per the division ]
>  
>  1 x 2-star [ if 150 OP or more ]
>  1 x 3-star [ if 200 OP or more ]
>  1 x 2-star [ if 250 OP or more ]
> 
> To round things out, assign a 4-star leader to the corps but associate it with the division that has the most OP in support units, or preferably a division that is mechanized or wing.
> 
>  3-star Leaders may control a Division; it could be shared by 2 2-star Leaders
>  4-star Leaders will control a Corps
>  5-star Leaders will control an Army
>  6-star Leaders will control an Army Group
>  7-star Leaders will control a Theater of Operations
>  8-star Leaders will control a Supreme Forces
> 
> === # Decorated Units =
> Lastly, we can create Insignia bonuses to map out to very specific implementations of a division configuration.  These bonuses should be between at most 2 insignia per regiment within one division of a given corps.  Each bonus will increase the OP value of the overal division by 1-3 OP and should come from a restricted list.
> 
> ===== # Example: Regimental TOEs =
> These are various seed examples of TO & E for a possible direction that combat units for the USA can be modeled.
> 
>  Light Infantry Regiment   [ 23 OP ]
>  INF - Biluxi Regulars    [  5 OP ]
>  INF - Biluxi Regulars    [  5 OP ]
>  INF - Biluxi Regulars    [  5 OP ]
>  INF - Sectarian Troopers   [  8 OP ]
>  
>  Heavy Infantry Regiment   [ 27 OP ]
>  INF - Sectarian Troopers   [  8 OP ]
>  INF - Raven Battle Armor   [  9 OP ]
>  INF - Biluxi Regulars    [  5 OP ]
>  INF - Biluxi Regulars    [  5 OP ]
>  
>  Advanced Infantry Regiment   [ 40 OP ]
>  INF - Raven Battle Armor   [  9 OP ]
>  INF - Feldman AT-88 Walkers   [  8 OP ]
>  RBT - Orum Slaughterbots   [ 17 OP ]
>  WNG - Carver Recon     [  6 OP ]
>  
>  Robotic Assault Regiment   [ 82 OP ]
>  RBT - Orum Slaughter Bots   [ 17 OP ]
>  RBT - Orum Slaughter Bots   [ 17 OP ]
>  RBT - Halen Assault Ballistar  [ 34 OP ]
>  WPN - Garfield Rocket Platform  [ 14 OP ]
>  
>  Vanguard Infantry Regiment  [ 46 OP ]
>  INF - Nabilum Rocketeers   [ 11 OP ]
>  INF - Nabilum Rocketeers   [ 11 OP ]
>  INF - Heavy Marines     [ 10 OP ]
>  WPN - Kennision Heavy Weapons  [ 14 OP ]
>  
>  Artillery Support Regiment  [ 37 OP ]
>  BAT - Machron Field Artillery  [ 12 OP ]
>  BAT - Macrhon Field Artillery  [ 12 OP ]
>  BAT - Paulson Anti-air    [  9 OP ]
>  WNG - Carver Recon     [  5 OP ]
>  
>  Field Infantry Regiment   [ 27 OP ]
>  INF - Biluxi Regulars    [  5 OP ]
>  INF - Biluxi Regulars    [  5 OP ]
>  INF - Heavy Marines     [ 10 OP ]
>  SUP - Newcomb Field Support   [  7 OP ]
>  
>  Division Support Regiment  [ 33 OP ]
>  HQ  - FSN Command Center   [ 10 OP ]
>  HQ - FSN Command Center   [ 10 OP ]
>  SUP - FSN Support Battalion   [  8 OP ]
>  SGN - Ground Hog Signals Battalion [  5 OP ]
>  
>  Armored Assault Regiment  [ 78 OP ]
>  CAV - Nevadan Light Tanks   [ 17 OP ]
>  CAV - Nevadan Light Tanks   [ 17 OP ]
>  CAV - M6A4 Heavy Tanks    [ 30 OP ]
>  WNG - Ferguson Bombardier   [ 14 OP ]
>  
>  
>  
> ===== # Example: Corps Organization =
>  Divisions of the 10th Armored Corps [ 983 OP ] Leaders 20* | 8** | 3*** | 1****
> 
>  2nd Mechanized Division [ NOTE ][ 239 OP ]     4    2  1  1
>   Robotic Assault Regiment   [ 82 OP ] 
>   Robotic Assault Regiment   [ 82 OP ]
>   Artillery Support Regiment  [ 37 OP ] 
>   Division Support Regiment  [ 33 OP ]
>  
>  4th Mechanized Division   [ 230 OP ]     4    2  1  -
>   Robotic Assault Regiment   [ 82 OP ] 
>   Armored Assault Regiment  [ 78 OP ]
>   Artillery Support Regiment  [ 37 OP ] 
>   Division Support Regiment  [ 33 OP ]
>   
>  178th Infantry Division   [ 242 OP ]     4    2  1  -
>   Advanced Infantry Regiment   [ 40 OP ]
>   Vanguard Infantry Regiment  [ 46 OP ]
>   Armored Assault Regiment  [ 78 OP ]
>   Armored Assault Regiment  [ 78 OP ]
>   
>  3rd Infantry Division   [ 129 OP ]     4    1  -  -
>   Light Infantry Regiment   [ 23 OP ]
>   Light Infantry Regiment   [ 23 OP ]
>   Field Infantry Regiment   [ 27 OP ]
>   Vanguard Infantry Regiment  [ 46 OP ]
>  
>  52nd Infantry Division   [ 133 OP ]     4    1  -  -
>   Light Infantry Regiment   [ 23 OP ]
>   Heavy Infantry Regiment   [ 27 OP ]
>   Field Infantry Regiment   [ 27 OP ]
>   Vanguard Infantry Regiment  [ 46 OP ]
>   
>  
>   NOTE: 
>   Insignia [ +5 OP ]
>    One of the Robotic Assault Regiments of the 2nd Mechanized Division is
>    the highly-decorated 5th LAD Regiment. Two of the units within receive
>    Insignia with these effects according to the unit type boosted:
>       
>    RBT - Orum Slaughter Bots; receives Agile 1
>    RBT - Halen Assault Ballistar; receives +2 MOV
>    WPN - Garfield Rocket Platform; receives Heavy Metal 2
>  
>  
> ===== # Example: Army Group =
> 12th Army Group [ ~5000 OP and about 100 divisions ]
> 
>  3rd United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   9th Armored Corps
>   10th Armored Corps
>   Marine Corps
>   Robot Corps
>   
>  9th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   4th Assault Corps
>   Assault Wing Corps
>   11th Armored Corps
>   14th Armored Corps
>   
>  12th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   1st Assault Corps
>   2nd Assault Corps
>   17th Armored Corps
>   Auxiliary Corps
>   
>  18th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   8th Armored Corps
>   15th Armored Corps
>   Strategic Air Corps
>   3rd Assault Corps
>   
>  49th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   3rd Armored Corps
>   6th Armored Corps
>   Expeditionary Corps
>   Guardian Corps
>  
>  
> ===== # Example: Supreme Forces =
> Supreme Headquarters Allied Expeditionary Forces (SHAEF) [ ~100 K OP and 2000 divisions ]
> 
>  European Theater Operations Group [ ~20K OP and 500 divisions ]
>   1st Army Group 
>   3rd Army Group 
>   12th Army Group 
>   17th Army Group
>   22nd Army Group
>   
>  Mediterranean Theater Operations Group [ ~20K OP and 500 divisions ]
>   2nd Army Group 
>   5th Army Group 
>   6th Army Group 
>   21st Army Group 
>    
>  Pacific Theater Operations Group [ ~20K OP and 500 divisions ]
>   4th Army Group 
>   7th Army Group
>   9th Army Group 
>   17th Army Group 
>   19th Army Group 
>   23rd Army Group
>  
>  Atlantic Theater Operations Group [ ~20K OP and 500 divisions ]
>   8th Army Group 
>   11th Army Group 
>   14th Army Group 
>  
>  Asiatic Theater Operations Group [ ~20K OP and 500 divisions ]
>   10th Army Group 
>   13th Army Group 
>   15th Army Group 
>   16th Army Group 
>   20th Army Group 
> 	
------
GiantRobotsOfWorldWarII/TableOfOrganizationAndEquipment|1194069225
150c150
< ===== # Example: Regimental TOEs =
---
> == # Example: Regimental TOEs =
------
GiantRobotsOfWorldWarII/TableOfOrganizationAndEquipment|1194069844
3c3
< == Table of Organization and Equipment =
---
> == # Table of Organization and Equipment =
5a6,7
> Otherwise known as TOEs or TO&Es; these were blueprints used by each nations logistical and strategy experts to create new units and budget for training and technology.  Even within a nation the various branches could have their own variations based upon combat or support philosophy.  For example; the USA Marine Corps uses 13-man squads while the Army uses 9-man squads, or even 6 for BMP vehicles.  This bubbles up through the battalion levels and higher; resulting in an average of 15,000 persons per Marine Infantry division versus 10,000 persons on average for an Army Infantry division.
> 
153,157c155,216
<  Light Infantry Regiment   [ 23 OP ]
<  INF - Biluxi Regulars    [  5 OP ]
<  INF - Biluxi Regulars    [  5 OP ]
<  INF - Biluxi Regulars    [  5 OP ]
<  INF - Sectarian Troopers   [  8 OP ]
---
> !!Light Infantry Regiment!! Unit Type !! [ 23 OP ]!!
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]
> ||INF||Biluxi Regulars||[ 5 OP ]
> ||INF||Sectarian Troopers||[ 8 OP ]||
> 
> !!Heavy Infantry Regiment!! Unit Type !! [ 27 OP ]!!
> ||INF||Sectarian Troopers||[ 8 OP ]||
> ||INF||Raven Battle Armor||[ 9 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> 
> !!Advanced Infantry Regiment!! Unit Type !! [ 40 OP ]!!
> ||INF||Raven Battle Armor||[ 9 OP ]||
> ||INF||Feldman AT-88 Walkers||[ 8 OP ]||
> ||RBT||Orum Slaughterbots||[ 17 OP ]||
> ||WNG||Carver Recon||[ 6 OP ]||
> 
> !!Robotic Assault Regiment!! Unit Type !! [ 82 OP ]!!
> ||RBT||Orum Slaughter Bots||[ 17 OP ]||
> ||RBT||Orum Slaughter Bots||[ 17 OP ]||
> ||RBT||Halen Assault Ballistar||[ 34 OP ]||
> ||WPN||Garfield Rocket Platform||[ 14 OP ]||
> 
> !!Vanguard Infantry Regiment!! Unit Type !! [ 46 OP ]!!
> ||INF||Nabilum Rocketeers||[ 11 OP ]||
> ||INF||Nabilum Rocketeers||[ 11 OP ]||
> ||INF||Heavy Marines||[ 10 OP ]||
> ||WPN||Kennision Heavy Weapons||[ 14 OP ]||
> 
> !!Artillery Support Regiment!! Unit Type !! [ 37 OP ]!!
> ||BAT||Machron Field Artillery||[ 12 OP ]||
> ||BAT||Macrhon Field Artillery||[ 12 OP ]||
> ||BAT||Paulson Anti-air||[ 9 OP ]||
> ||WNG||Carver Recon||[ 5 OP ]||
> 
> !!Field Infantry Regiment!! Unit Type !! [ 27 OP ]!!
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Heavy Marines||[ 10 OP ]||
> ||SUP||Newcomb Field Support||[ 7 OP ]||
> 
> !!Division Support Regiment!! Unit Type !! [ 33 OP ]!!
> ||HQ ||FSN Command Center||[ 10 OP ]||
> ||HQ||FSN Command Center||[ 10 OP ]||
> ||SUP||FSN Support Battalion||[ 8 OP ]||
> ||SGN||Ground Hog Signals Battalion [ 5 OP ]||
> 
> !!Armored Assault Regiment!! Unit Type !! [ 78 OP ]!!
> ||CAV||Nevadan Light Tanks||[ 17 OP ]||
> ||CAV||Nevadan Light Tanks||[ 17 OP ]||
> ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
> ||WNG||Ferguson Bombardier||[ 14 OP ]||
> 
> ===== # Example: Corps Organization =
>  Divisions of the 10th Armored Corps [ 983 OP ] Leaders 20* | 8** | 3*** | 1****
> 
>  2nd Mechanized Division [ NOTE ][ 239 OP ]     4    2  1  1
>   Robotic Assault Regiment   [ 82 OP ] 
>   Robotic Assault Regiment   [ 82 OP ]
>   Artillery Support Regiment  [ 37 OP ] 
>   Division Support Regiment  [ 33 OP ]
159,163c218,234
<  Heavy Infantry Regiment   [ 27 OP ]
<  INF - Sectarian Troopers   [  8 OP ]
<  INF - Raven Battle Armor   [  9 OP ]
<  INF - Biluxi Regulars    [  5 OP ]
<  INF - Biluxi Regulars    [  5 OP ]
---
>  4th Mechanized Division   [ 230 OP ]     4    2  1  -
>   Robotic Assault Regiment   [ 82 OP ] 
>   Armored Assault Regiment  [ 78 OP ]
>   Artillery Support Regiment  [ 37 OP ] 
>   Division Support Regiment  [ 33 OP ]
>   
>  178th Infantry Division   [ 242 OP ]     4    2  1  -
>   Advanced Infantry Regiment   [ 40 OP ]
>   Vanguard Infantry Regiment  [ 46 OP ]
>   Armored Assault Regiment  [ 78 OP ]
>   Armored Assault Regiment  [ 78 OP ]
>   
>  3rd Infantry Division   [ 129 OP ]     4    1  -  -
>   Light Infantry Regiment   [ 23 OP ]
>   Light Infantry Regiment   [ 23 OP ]
>   Field Infantry Regiment   [ 27 OP ]
>   Vanguard Infantry Regiment  [ 46 OP ]
165,169c236,241
<  Advanced Infantry Regiment   [ 40 OP ]
<  INF - Raven Battle Armor   [  9 OP ]
<  INF - Feldman AT-88 Walkers   [  8 OP ]
<  RBT - Orum Slaughterbots   [ 17 OP ]
<  WNG - Carver Recon     [  6 OP ]
---
>  52nd Infantry Division   [ 133 OP ]     4    1  -  -
>   Light Infantry Regiment   [ 23 OP ]
>   Heavy Infantry Regiment   [ 27 OP ]
>   Field Infantry Regiment   [ 27 OP ]
>   Vanguard Infantry Regiment  [ 46 OP ]
>   
171,175c243,251
<  Robotic Assault Regiment   [ 82 OP ]
<  RBT - Orum Slaughter Bots   [ 17 OP ]
<  RBT - Orum Slaughter Bots   [ 17 OP ]
<  RBT - Halen Assault Ballistar  [ 34 OP ]
<  WPN - Garfield Rocket Platform  [ 14 OP ]
---
>   NOTE: 
>   Insignia [ +5 OP ]
>    One of the Robotic Assault Regiments of the 2nd Mechanized Division is
>    the highly-decorated 5th LAD Regiment. Two of the units within receive
>    Insignia with these effects according to the unit type boosted:
>       
>    RBT - Orum Slaughter Bots; receives Agile 1
>    RBT - Halen Assault Ballistar; receives +2 MOV
>    WPN - Garfield Rocket Platform; receives Heavy Metal 2
177,181d252
<  Vanguard Infantry Regiment  [ 46 OP ]
<  INF - Nabilum Rocketeers   [ 11 OP ]
<  INF - Nabilum Rocketeers   [ 11 OP ]
<  INF - Heavy Marines     [ 10 OP ]
<  WPN - Kennision Heavy Weapons  [ 14 OP ]
183,187c254,285
<  Artillery Support Regiment  [ 37 OP ]
<  BAT - Machron Field Artillery  [ 12 OP ]
<  BAT - Macrhon Field Artillery  [ 12 OP ]
<  BAT - Paulson Anti-air    [  9 OP ]
<  WNG - Carver Recon     [  5 OP ]
---
> ===== # Example: Army Group =
> 12th Army Group [ ~5000 OP and about 100 divisions ]
> 
>  3rd United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   9th Armored Corps
>   10th Armored Corps
>   Marine Corps
>   Robot Corps
>   
>  9th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   4th Assault Corps
>   Assault Wing Corps
>   11th Armored Corps
>   14th Armored Corps
>   
>  12th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   1st Assault Corps
>   2nd Assault Corps
>   17th Armored Corps
>   Auxiliary Corps
>   
>  18th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   8th Armored Corps
>   15th Armored Corps
>   Strategic Air Corps
>   3rd Assault Corps
>   
>  49th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
>   3rd Armored Corps
>   6th Armored Corps
>   Expeditionary Corps
>   Guardian Corps
189,193d286
<  Field Infantry Regiment   [ 27 OP ]
<  INF - Biluxi Regulars    [  5 OP ]
<  INF - Biluxi Regulars    [  5 OP ]
<  INF - Heavy Marines     [ 10 OP ]
<  SUP - Newcomb Field Support   [  7 OP ]
195,199c288,310
<  Division Support Regiment  [ 33 OP ]
<  HQ  - FSN Command Center   [ 10 OP ]
<  HQ - FSN Command Center   [ 10 OP ]
<  SUP - FSN Support Battalion   [  8 OP ]
<  SGN - Ground Hog Signals Battalion [  5 OP ]
---
> ===== # Example: Supreme Forces =
> Supreme Headquarters Allied Expeditionary Forces (SHAEF) [ ~100 K OP and 2000 divisions ]
> 
>  European Theater Operations Group [ ~20K OP and 500 divisions ]
>   1st Army Group 
>   3rd Army Group 
>   12th Army Group 
>   17th Army Group
>   22nd Army Group
>   
>  Mediterranean Theater Operations Group [ ~20K OP and 500 divisions ]
>   2nd Army Group 
>   5th Army Group 
>   6th Army Group 
>   21st Army Group 
>    
>  Pacific Theater Operations Group [ ~20K OP and 500 divisions ]
>   4th Army Group 
>   7th Army Group
>   9th Army Group 
>   17th Army Group 
>   19th Army Group 
>   23rd Army Group
201,205c312,315
<  Armored Assault Regiment  [ 78 OP ]
<  CAV - Nevadan Light Tanks   [ 17 OP ]
<  CAV - Nevadan Light Tanks   [ 17 OP ]
<  CAV - M6A4 Heavy Tanks    [ 30 OP ]
<  WNG - Ferguson Bombardier   [ 14 OP ]
---
>  Atlantic Theater Operations Group [ ~20K OP and 500 divisions ]
>   8th Army Group 
>   11th Army Group 
>   14th Army Group 
207,316d316
<  
<  
< ===== # Example: Corps Organization =
<  Divisions of the 10th Armored Corps [ 983 OP ] Leaders 20* | 8** | 3*** | 1****
< 
<  2nd Mechanized Division [ NOTE ][ 239 OP ]     4    2  1  1
<   Robotic Assault Regiment   [ 82 OP ] 
<   Robotic Assault Regiment   [ 82 OP ]
<   Artillery Support Regiment  [ 37 OP ] 
<   Division Support Regiment  [ 33 OP ]
<  
<  4th Mechanized Division   [ 230 OP ]     4    2  1  -
<   Robotic Assault Regiment   [ 82 OP ] 
<   Armored Assault Regiment  [ 78 OP ]
<   Artillery Support Regiment  [ 37 OP ] 
<   Division Support Regiment  [ 33 OP ]
<   
<  178th Infantry Division   [ 242 OP ]     4    2  1  -
<   Advanced Infantry Regiment   [ 40 OP ]
<   Vanguard Infantry Regiment  [ 46 OP ]
<   Armored Assault Regiment  [ 78 OP ]
<   Armored Assault Regiment  [ 78 OP ]
<   
<  3rd Infantry Division   [ 129 OP ]     4    1  -  -
<   Light Infantry Regiment   [ 23 OP ]
<   Light Infantry Regiment   [ 23 OP ]
<   Field Infantry Regiment   [ 27 OP ]
<   Vanguard Infantry Regiment  [ 46 OP ]
<  
<  52nd Infantry Division   [ 133 OP ]     4    1  -  -
<   Light Infantry Regiment   [ 23 OP ]
<   Heavy Infantry Regiment   [ 27 OP ]
<   Field Infantry Regiment   [ 27 OP ]
<   Vanguard Infantry Regiment  [ 46 OP ]
<   
<  
<   NOTE: 
<   Insignia [ +5 OP ]
<    One of the Robotic Assault Regiments of the 2nd Mechanized Division is
<    the highly-decorated 5th LAD Regiment. Two of the units within receive
<    Insignia with these effects according to the unit type boosted:
<       
<    RBT - Orum Slaughter Bots; receives Agile 1
<    RBT - Halen Assault Ballistar; receives +2 MOV
<    WPN - Garfield Rocket Platform; receives Heavy Metal 2
<  
<  
< ===== # Example: Army Group =
< 12th Army Group [ ~5000 OP and about 100 divisions ]
< 
<  3rd United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   9th Armored Corps
<   10th Armored Corps
<   Marine Corps
<   Robot Corps
<   
<  9th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   4th Assault Corps
<   Assault Wing Corps
<   11th Armored Corps
<   14th Armored Corps
<   
<  12th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   1st Assault Corps
<   2nd Assault Corps
<   17th Armored Corps
<   Auxiliary Corps
<   
<  18th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   8th Armored Corps
<   15th Armored Corps
<   Strategic Air Corps
<   3rd Assault Corps
<   
<  49th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   3rd Armored Corps
<   6th Armored Corps
<   Expeditionary Corps
<   Guardian Corps
<  
<  
< ===== # Example: Supreme Forces =
< Supreme Headquarters Allied Expeditionary Forces (SHAEF) [ ~100 K OP and 2000 divisions ]
< 
<  European Theater Operations Group [ ~20K OP and 500 divisions ]
<   1st Army Group 
<   3rd Army Group 
<   12th Army Group 
<   17th Army Group
<   22nd Army Group
<   
<  Mediterranean Theater Operations Group [ ~20K OP and 500 divisions ]
<   2nd Army Group 
<   5th Army Group 
<   6th Army Group 
<   21st Army Group 
<    
<  Pacific Theater Operations Group [ ~20K OP and 500 divisions ]
<   4th Army Group 
<   7th Army Group
<   9th Army Group 
<   17th Army Group 
<   19th Army Group 
<   23rd Army Group
<  
<  Atlantic Theater Operations Group [ ~20K OP and 500 divisions ]
<   8th Army Group 
<   11th Army Group 
<   14th Army Group 
<  
------
GiantRobotsOfWorldWarII/TableOfOrganizationAndEquipment|1194069881
157,158c157,158
< ||INF||Biluxi Regulars||[ 5 OP ]
< ||INF||Biluxi Regulars||[ 5 OP ]
---
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
------
GiantRobotsOfWorldWarII/TableOfOrganizationAndEquipment|1194069952
152c152
< == # Example: Regimental TOEs =
---
> === # Example: Regimental TOEs =
209c209
< ===== # Example: Corps Organization =
---
> ==== # Example: Corps Organization =
254c254
< ===== # Example: Army Group =
---
> ==== # Example: Army Group =
288c288
< ===== # Example: Supreme Forces =
---
> ==== # Example: Supreme Forces =
------
GiantRobotsOfWorldWarII/TableOfOrganizationAndEquipment|1194070167
155,207c155,207
< !!Light Infantry Regiment!! Unit Type !! [ 23 OP ]!!
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Sectarian Troopers||[ 8 OP ]||
< 
< !!Heavy Infantry Regiment!! Unit Type !! [ 27 OP ]!!
< ||INF||Sectarian Troopers||[ 8 OP ]||
< ||INF||Raven Battle Armor||[ 9 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< 
< !!Advanced Infantry Regiment!! Unit Type !! [ 40 OP ]!!
< ||INF||Raven Battle Armor||[ 9 OP ]||
< ||INF||Feldman AT-88 Walkers||[ 8 OP ]||
< ||RBT||Orum Slaughterbots||[ 17 OP ]||
< ||WNG||Carver Recon||[ 6 OP ]||
< 
< !!Robotic Assault Regiment!! Unit Type !! [ 82 OP ]!!
< ||RBT||Orum Slaughter Bots||[ 17 OP ]||
< ||RBT||Orum Slaughter Bots||[ 17 OP ]||
< ||RBT||Halen Assault Ballistar||[ 34 OP ]||
< ||WPN||Garfield Rocket Platform||[ 14 OP ]||
< 
< !!Vanguard Infantry Regiment!! Unit Type !! [ 46 OP ]!!
< ||INF||Nabilum Rocketeers||[ 11 OP ]||
< ||INF||Nabilum Rocketeers||[ 11 OP ]||
< ||INF||Heavy Marines||[ 10 OP ]||
< ||WPN||Kennision Heavy Weapons||[ 14 OP ]||
< 
< !!Artillery Support Regiment!! Unit Type !! [ 37 OP ]!!
< ||BAT||Machron Field Artillery||[ 12 OP ]||
< ||BAT||Macrhon Field Artillery||[ 12 OP ]||
< ||BAT||Paulson Anti-air||[ 9 OP ]||
< ||WNG||Carver Recon||[ 5 OP ]||
< 
< !!Field Infantry Regiment!! Unit Type !! [ 27 OP ]!!
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Heavy Marines||[ 10 OP ]||
< ||SUP||Newcomb Field Support||[ 7 OP ]||
< 
< !!Division Support Regiment!! Unit Type !! [ 33 OP ]!!
< ||HQ ||FSN Command Center||[ 10 OP ]||
< ||HQ||FSN Command Center||[ 10 OP ]||
< ||SUP||FSN Support Battalion||[ 8 OP ]||
< ||SGN||Ground Hog Signals Battalion [ 5 OP ]||
< 
< !!Armored Assault Regiment!! Unit Type !! [ 78 OP ]!!
< ||CAV||Nevadan Light Tanks||[ 17 OP ]||
< ||CAV||Nevadan Light Tanks||[ 17 OP ]||
< ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
< ||WNG||Ferguson Bombardier||[ 14 OP ]||
---
> !!Light Infantry Regiment!! [ 23 OP ]!!
> ||INF / Biluxi Regulars||[ 5 OP ]||
> ||INF / Biluxi Regulars||[ 5 OP ]||
> ||INF / Biluxi Regulars||[ 5 OP ]||
> ||INF / Sectarian Troopers||[ 8 OP ]||
> 
> !!Heavy Infantry Regiment!! [ 27 OP ]!!
> ||INF / Sectarian Troopers||[ 8 OP ]||
> ||INF / Raven Battle Armor||[ 9 OP ]||
> ||INF / Biluxi Regulars||[ 5 OP ]||
> ||INF / Biluxi Regulars||[ 5 OP ]||
> 
> !!Advanced Infantry Regiment!! [ 40 OP ]!!
> ||INF / Raven Battle Armor||[ 9 OP ]||
> ||INF / Feldman AT-88 Walkers||[ 8 OP ]||
> ||RBT / Orum Slaughterbots||[ 17 OP ]||
> ||WNG / Carver Recon||[ 6 OP ]||
> 
> !!Robotic Assault Regiment!! [ 82 OP ]!!
> ||RBT / Orum Slaughter Bots||[ 17 OP ]||
> ||RBT / Orum Slaughter Bots||[ 17 OP ]||
> ||RBT / Halen Assault Ballistar||[ 34 OP ]||
> ||WPN / Garfield Rocket Platform||[ 14 OP ]||
> 
> !!Vanguard Infantry Regiment!! [ 46 OP ]!!
> ||INF / Nabilum Rocketeers||[ 11 OP ]||
> ||INF / Nabilum Rocketeers||[ 11 OP ]||
> ||INF / Heavy Marines||[ 10 OP ]||
> ||WPN / Kennision Heavy Weapons||[ 14 OP ]||
> 
> !!Artillery Support Regiment!! [ 37 OP ]!!
> ||BAT / Machron Field Artillery||[ 12 OP ]||
> ||BAT / Macrhon Field Artillery||[ 12 OP ]||
> ||BAT / Paulson Anti-air||[ 9 OP ]||
> ||WNG / Carver Recon||[ 5 OP ]||
> 
> !!Field Infantry Regiment!! [ 27 OP ]!!
> ||INF / Biluxi Regulars||[ 5 OP ]||
> ||INF / Biluxi Regulars||[ 5 OP ]||
> ||INF / Heavy Marines||[ 10 OP ]||
> ||SUP / Newcomb Field Support||[ 7 OP ]||
> 
> !!Division Support Regiment!! [ 33 OP ]!!
> ||HQ / FSN Command Center||[ 10 OP ]||
> ||HQ / FSN Command Center||[ 10 OP ]||
> ||SUP / FSN Support Battalion||[ 8 OP ]||
> ||SGN / Ground Hog Signals Battalion||[ 5 OP ]||
> 
> !!Armored Assault Regiment!! [ 78 OP ]!!
> ||CAV / Nevadan Light Tanks||[ 17 OP ]||
> ||CAV / Nevadan Light Tanks||[ 17 OP ]||
> ||CAV / M6A4 Heavy Tanks||[ 30 OP ]||
> ||WNG / Ferguson Bombardier||[ 14 OP ]||
------
GiantRobotsOfWorldWarII/TableOfOrganizationAndEquipment|1194070230
152c152
< === # Example: Regimental TOEs =
---
> === # Sample TOEs =
154a155
> ==== # Example: Regimental TOEs =
------
GRoWWII|1194123616
1c1
< = Introduction =
---
> = Giant Robots of World War II =
------
GRoWWII|1194123629
2c2
< <blockquote>"Giant Robots of World War Two: European Theatre" focuses on a pulp-fiction alternate reality in which World War II became sustainable because of the arrival of nuclear power, super alloys, and robotics.  Combined with intense non-failing loyalty among all nations to their leaders or its dictators; these factors allowed what we know as the technology of the Atomic Age to be introduced into the global fighting of WWII which now engulfs the remainder of the world.</blockquote>
---
> <blockquote>"Giant Robots of World War Two: European Theater Operations" focuses on a pulp-fiction alternate reality in which World War II became sustainable because of the arrival of nuclear power, super alloys, and robotics.  Combined with intense non-failing loyalty among all nations to their leaders or its dictators; these factors allowed what we know as the technology of the Atomic Age to be introduced into the global fighting of WWII which now engulfs the remainder of the world.</blockquote>
------
GRoWWII/TableOfOrganizationAndEquipment|1194124147
18c18
< ==== # Example: Simple OOB =
---
> ==== # Simple OOB =
21c21
< ==== # Example: Mixed OOB =
---
> ==== # Mixed OOB =
48c48
< ==== # Example: Complete OOB =		
---
> ==== # Complete OOB =		
126c126
< ==== # Example: Allohistorical LADs =
---
> ==== # Allohistorical LADs =
155c155
< ==== # Example: Regimental TOEs =
---
> ==== # Regimental TOEs =
210c210
< ==== # Example: Corps Organization =
---
> ==== # Corps Organization =
255c255
< ==== # Example: Army Group =
---
> ==== # Army Group =
289c289
< ==== # Example: Supreme Forces =
---
> ==== # Supreme Forces =
------
GRoWWII/TableOfOrganizationAndEquipment|1194124244
------
GRoWWII/TableOfOrganizationAndEquipment|1194124275
1c1
< <toc>
---
> #TOC
------
GRoWWII/TableOfOrganizationAndEquipment|1194124283
1c1
< #TOC
---
> #TOC 
------
GRoWWII/TableOfOrganizationAndEquipment|1194124291
1c1,2
< #TOC 
---
> #TOC
> 
------
GRoWWII/TableOfOrganizationAndEquipment|1194124385
1,2c1
< #TOC
< 
---
> #TOC 
------
GRoWWII/TableOfOrganizationAndEquipment|1194124412
1c1
< #TOC 
---
> <toc>
------
WikiTOCs|1194124447
------
CategoryAdmin|1194151336
------
GRoWWII|1194151970
39a40
>  /TableOfOrganizationAndEquipment
------
WikiContacts|1194153173
1c1,2
< Describe the new page here.
---
> = Contact Information =
> kitrok@yahoo.com
------
WikiContacts|1194153191
2c3
< kitrok@yahoo.com
---
>  kitrok@yahoo.com
------
WikiContacts|1194153235
3c3
<  kitrok@yahoo.com
---
>  kitrok
------
CategoryAdmin|1194153729
------
CategoryAdmin|1194153737
------
CategoryAdmin|1194153749
------
CategoryAdmin|1194153758
------
GRoWWII|1194156177
40c40
<  /TableOfOrganizationAndEquipment
---
>  /TOE
------
GRoWWII|1194156199
40c40
<  /TOE
---
>  /TOandE
------
NobleWiki|1194167685
32c32
< ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
---
> ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
52c52
< ||UseMod:WikiPatches/PrivateUserGroups||want, not sure about how authors work||
---
> ||UseMod:WikiPatches/PrivateUserGroups width=300||want, not sure about how authors work||
------
GRoWWII/TOandE|1194168005
88c88
< ||Combat Missions||Amphibious||
---
> ||Combat Missions width=150||Amphibious||
95c95
< ||Service Missions||Logistics||
---
> ||Service Missions width=150||Logistics||
102c102
< ||Support Missions||Advanced Research||
---
> ||Support Missions width=150||Advanced Research||
109c109
< ||Base Missions||Construction||
---
> ||Base Missions width=150||Construction||
155c155
< !!Light Infantry Regiment!! [ 23 OP ]!!
---
> !!Light Infantry Regiment width=250!! [ 23 OP ] !!
161c161
< !!Heavy Infantry Regiment!! [ 27 OP ]!!
---
> !!Heavy Infantry Regiment width=250!! [ 27 OP ] !!
167c167
< !!Advanced Infantry Regiment!! [ 40 OP ]!!
---
> !!Advanced Infantry Regiment width=250!! [ 40 OP ]!!
173c173
< !!Robotic Assault Regiment!! [ 82 OP ]!!
---
> !!Robotic Assault Regiment width=250!! [ 82 OP ]!!
179c179
< !!Vanguard Infantry Regiment!! [ 46 OP ]!!
---
> !!Vanguard Infantry Regiment width=250!! [ 46 OP ]!!
185c185
< !!Artillery Support Regiment!! [ 37 OP ]!!
---
> !!Artillery Support Regiment width=250!! [ 37 OP ]!!
191c191
< !!Field Infantry Regiment!! [ 27 OP ]!!
---
> !!Field Infantry Regiment width=250!! [ 27 OP ]!!
197c197
< !!Division Support Regiment!! [ 33 OP ]!!
---
> !!Division Support Regiment width=250!! [ 33 OP ]!!
203c203
< !!Armored Assault Regiment!! [ 78 OP ]!!
---
> !!Armored Assault Regiment width=250!! [ 78 OP ]!!
------
GRoWWII/TOandE|1194193833
1c1,2
< <toc>
---
> <toc 350>
> 
------
GRoWWII/TOandE|1194193846
1c1
< <toc 350>
---
> <toc 300>
------
GRoWWII/TOandE|1194193870
1,2c1
< <toc 300>
< 
---
> <toc 280>
------
WikiEditing|1194194028
1c1,2
< = Wiki Text Formatting Rules =
---
> <toc>
> = # Wiki Text Formatting Rules =
5c6
< == Basic Syntax =
---
> == # Basic Syntax =
15c16
< === Decoration =
---
> === # Decoration =
20c21
< === Miscellaneous =
---
> === # Miscellaneous =
26c27
< == Advanced Syntax =
---
> == # Advanced Syntax =
30c31
< === Directives =
---
> === # Directives =
54c55
< ====== Related Entries =
---
> ====== # Related Entries =
------
WikiTOCs|1194194243
2c2
< <toc>
---
> <toc 250>
4c4
< The Table of Contents shown above was created automatically by the wiki engine.  The generated table of contents lists headings at level 2 and below; level 1 headings are not included. To flag a header for inclusion into the TOC, it's title entry must be preceded by header markup and a '#' hash symbol.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section. 
---
> The Table of Contents shown above was created automatically by the wiki engine.  The generated table of contents lists headings at level 2 and below; level 1 headings are not included. To flag a header for inclusion into the TOC, it's title entry must be preceded by header markup and a '#' hash symbol.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section.  If the TOC needs to be of a specific width, insert that value in pixels right before the closing angle bracket as in <tt><nowiki><toc NNN></nowiki></tt>
------
NobleWiki|1194194342
27c27
< ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] feature now adds a 215px box around it with the a title of 'Content'||
---
> ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] may be assigned a pixel width parameter as in <tt><nowiki><toc NNN></nowiki></tt>||
------
NobleWiki|1194192042
20a20
> ||Full Tables||Implemented UseMod:WikiPatches/WikiTemplate with a twist; specify alignment and cell width.  See WikiTables for more information||
------
NobleWiki|1194192062
------
WikiTables|1194195475
25,36c24,30
< === HTML Tables ===
< This particular wiki allows the use HTML to create tables as well.  However, such usage should be applied judiciously since no HTML validation is provided.  When creating the table, do not use any attributes except insert class='wikilargelist' for the opening table tag.
< 
< <b>Example HTML table</b>
< <table class='wikilargelist'>
< <tr><th>Hello</th><th>2nd Column</th><th>3rd Column</th></tr>
< <tr><td>Row 1</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 2</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 3</td><td>Value 1</td><td>Value 2</td></tr>
< </table>
< 
< The above table was created using this syntax:
---
> ==== Cell Alignment ===
> The wiki tables allow syntax for setting up cell width and alignment.  Set alignment to 'right' by padding the cell's content with 2 blank spaces preceding the entry.  For 'center' alignment, pad the content on both sides.  This feature works only with the table rows, and not with the table headers; those stay 'left' aligned.
> 
> ||default is left aligned||  right-aligned||  center-aligned  ||
> 
> The above was created using:
> 
38,43c32
< <table class='wikilargelist'>
< <tr><th>Hello</th><th>2nd Column</th><th>3rd Column</th></tr>
< <tr><td>Row 1</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 2</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 3</td><td>Value 1</td><td>Value 2</td></tr>
< </table>
---
> ||default is left aligned||  right-aligned||  center-aligned  ||
45a35,68
> ==== Cell Width ===
> Set a cell's width in pixels by adding a width=NNN attribute next to it's content.  The wiki engine will then strip out that key=value pair and generate the table accordingly. This works for both table headers and rows.  Once the width for a column is set, that rule will continue for all cells in the same column.
> 
> !!A width=400!!B width=100!!C width=200!!
> ||A||B||C||
> 
> The above was created using:
> 
> <pre>
> !!A width=400!!B width=100!!C width=200!!
> ||A||B||C||
> </pre>
> 
> === HTML Tables ===
> This particular wiki allows the use HTML to create tables as well.  However, such usage should be applied judiciously since no HTML validation is provided.  When creating the table, do not use any attributes except insert class='wikilargelist' for the opening table tag.
> 
> <b>Example HTML table</b>
> <table class='wikilargelist'>
> <tr><th>Hello</th><th>2nd Column</th><th>3rd Column</th></tr>
> <tr><td>Row 1</td><td>Value 1</td><td>Value 2</td></tr>
> <tr><td>Row 2</td><td>Value 1</td><td>Value 2</td></tr>
> <tr><td>Row 3</td><td>Value 1</td><td>Value 2</td></tr>
> </table>
> 
> The above table was created using this syntax:
> <pre>
> <table class='wikilargelist'>
> <tr><th>Hello</th><th>2nd Column</th><th>3rd Column</th></tr>
> <tr><td>Row 1</td><td>Value 1</td><td>Value 2</td></tr>
> <tr><td>Row 2</td><td>Value 1</td><td>Value 2</td></tr>
> <tr><td>Row 3</td><td>Value 1</td><td>Value 2</td></tr>
> </table>
> </pre>
> 
------
LoremIpsum|1194196974
1c1,3
< Describe the new page here.
---
> ===== Lorem Ipsum Data =
> 
> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
------
SandBox|1194197179
2c2
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=oops|description=Sample Image|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
4c4
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=right|float=left|title=Sample Picture|description=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=right|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
------
WikiImages|1194197316
45a46,70
> === Customized Formatting ===
> If the alternate linking style is used - the one with the square brackets, above - then customization is allowed via key=value pairs.  Insert these before the closing bracket and separate them with the pipe characer '|' in order to control appearance.
> 
> !!Option width=250!!Description!!
> ||float=left||Makes the image float to the left; all text appearing after the image information will wrap around it||
> ||float=right||Makes the image float to the left; all text appearing after the image information will wrap around it||
> ||clear=left||If the image has float=left, this command will force it to appear on the next line.||
> ||clear=right||If the image has float=right, this command will force it to appear on the next line.||
> ||title=NNN||Adds a tooltip to the image that will appear upon mouseover.  This will default to the URL specified||
> ||caption=NNN||Creates a caption box that will appear beneath the image.  The caption box will create by default a description box as well. Wraps the image, the caption box, and its description in a container.||
> ||description=NNN||Used with the caption option.  This will default to FIGURE QQQ which number is determined by the order of the images' appearance in the page body.  The description is a single-line that appears above the caption.||
> ||boxfloat=left||Used with the caption option.  Makes the container float to the left; all text appearing after the container will wrap around it.||
> ||boxfloat=right||Used with the caption option.  Makes the container float to the left; all text appearing after the container will wrap around it.||
> ||boxclear=left||Used with the caption option.  If the container has boxfloat=left, this command will force it to appear on the next line.||
> ||boxclear=right||Used with the caption option.  If the container has boxfloat=right, this command will force it to appear on the next line.||
> 
> For example:
> 
> 
> 
> That was created using:
> <tt><nowiki>
> [LocalWiki:HomePage upload:SAMPLE.churcill.jpg|float=left]
> </nowiki></tt>
> 
------
WikiImages|1194197470
1c1,2
< == Images and Assets ==
---
> <toc>
> == # Images and Assets ==
24c25
< === Remote File Linking ===
---
> === # Remote File Linking ===
30c31
< === Local Assets ===
---
> === # Local Assets ===
36c37
< === Alternate Linking ===
---
> === # Alternate Linking ===
46c47
< === Customized Formatting ===
---
> === # Customized Formatting ===
61a62,63
> ||boxwidth=NNN||Used with the caption option.  Specify the maximum width of the container.||
> 
65a66,67
> [http://www.yahoo.com/ upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd] Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
> 
68c70
< [LocalWiki:HomePage upload:SAMPLE.churcill.jpg|float=left]
---
> [http://www.yahoo.com/ upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd]
71c73
< ====== Related Entries =
---
> ====== # Related Entries =
------
WikiImages|1194198542
50c50
< !!Option width=250!!Description!!
---
> !!Option width=100!!Description!!
------
WikiImages|1194198739
51,62c51,62
< ||float=left||Makes the image float to the left; all text appearing after the image information will wrap around it||
< ||float=right||Makes the image float to the left; all text appearing after the image information will wrap around it||
< ||clear=left||If the image has float=left, this command will force it to appear on the next line.||
< ||clear=right||If the image has float=right, this command will force it to appear on the next line.||
< ||title=NNN||Adds a tooltip to the image that will appear upon mouseover.  This will default to the URL specified||
< ||caption=NNN||Creates a caption box that will appear beneath the image.  The caption box will create by default a description box as well. Wraps the image, the caption box, and its description in a container.||
< ||description=NNN||Used with the caption option.  This will default to FIGURE QQQ which number is determined by the order of the images' appearance in the page body.  The description is a single-line that appears above the caption.||
< ||boxfloat=left||Used with the caption option.  Makes the container float to the left; all text appearing after the container will wrap around it.||
< ||boxfloat=right||Used with the caption option.  Makes the container float to the left; all text appearing after the container will wrap around it.||
< ||boxclear=left||Used with the caption option.  If the container has boxfloat=left, this command will force it to appear on the next line.||
< ||boxclear=right||Used with the caption option.  If the container has boxfloat=right, this command will force it to appear on the next line.||
< ||boxwidth=NNN||Used with the caption option.  Specify the maximum width of the container.||
---
> ||<tt>float=left</tt>||Makes the image float to the left; all text appearing after the image information will wrap around it||
> ||<tt>float=right</tt>||Makes the image float to the left; all text appearing after the image information will wrap around it||
> ||<tt>clear=left</tt>||If the image has float=left, this command will force it to appear on the next line.||
> ||<tt>clear=right</tt>||If the image has float=right, this command will force it to appear on the next line.||
> ||<tt>title=NNN</tt>||Adds a tooltip to the image that will appear upon mouseover.  This will default to the URL specified||
> ||<tt>caption=NNN</tt>||Creates a caption box that will appear beneath the image.  The caption box will create by default a description box as well. Wraps the image, the caption box, and its description in a container.||
> ||<tt>description=NNN</tt>||Used with the caption option.  This will default to FIGURE QQQ which number is determined by the order of the images' appearance in the page body.  The description is a single-line that appears above the caption.||
> ||<tt>boxfloat=left</tt>||Used with the caption option.  Makes the container float to the left; all text appearing after the container will wrap around it.||
> ||<tt>boxfloat=right</tt>||Used with the caption option.  Makes the container float to the left; all text appearing after the container will wrap around it.||
> ||<tt>boxclear=left</tt>||Used with the caption option.  If the container has boxfloat=left, this command will force it to appear on the next line.||
> ||<tt>boxclear=right</tt>||Used with the caption option.  If the container has boxfloat=right, this command will force it to appear on the next line.||
> ||<tt>boxwidth=NNN</tt>||Used with the caption option.  Specify the maximum width of the container.||
------
WikiContacts|1194206100
3d1
<  kitrok
------
WikiContacts|1194206112
------
WikiImages|1194207980
72a76,85
> [LocalWiki:HomePage upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=center|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd] Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
> 
> 
> The above was created using:
> 
> <tt><nowiki>
> [LocalWiki:HomePage upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=center|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd]
> </nowiki></tt>
> 
> 
------
SandBox|1194211244
1,2c1,417
< ===== Edit me! =
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=oops|description=Sample Image|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
---
> /* The following is a sample CSS file for UseModWiki 1.0.
>    It is not pretty, but it demonstrates all of the new DIVs and
>    tag classes. */
> 
> .wikibutton {
> 	padding: 1px;
> }
> * { 
>  	font-family: Verdana, Arial, Sans-serif;
>  	line-height: 1.6em;
>  	font-size: 9pt;
> }
> 
> a {
> 	font-size: 9pt;
> }
> tt, code, pre {
> 	font-family: Courier, Serif;
> 	overflow: auto;
> }
> 
> code {
> 	color: #996666;
> 	padding: 5px;
> 	overflow:auto;
> }
> 
> pre {
> 	font-family: Courier, Serif;
> 	color: #666666;
> }
> 
> blockquote {
> 	font-family: Courier, Serif;
> 	color: #666666;
> 	margin-top: 5px;
> 	padding-top: 10px;
> 	padding-left: 35px;
> 	padding-right: 35px;
> 	background: url("/img/blockquote.jpg") left top no-repeat;
> }
> blockquote a:link {
> 	font-family: Courier, Serif;
> 	color: #333333;
> }
> 
> wikipreview blockquote {
> 	background: url("/img/blockquote.preview.jpg") left top no-repeat;	
> }
> body {
> 	background-image: url("/img/purple.stripe.gif");
> 	text-align: center; /* for IE */
> }
> 
> h1 { font-size: 18pt; }
> h2 { font-size: 16pt; }
> h3 { font-size: 14pt; }
> h4 { font-size: 12pt; }
> h5 { font-size: 11pt; }
> h6 { font-size: 10pt; }
> 
> h1 a{ font-size: 18pt; }
> h2 a{ font-size: 16pt; }
> h3 a{ font-size: 14pt; }
> h4 a{ font-size: 12pt; }
> h5 a{ font-size: 11pt; }
> h6 a{ font-size: 10pt; }
> 
> h1, h2, h3, h4, h5, h6 {
> 	font-weight: bold;
> 	margin-bottom: 6px;
> }
> 
> input[type="checkbox"]{
> 	margin-right: 10px;
> 	margin-bottom: 3px;
> }
> 
> .wikitext h1,
> .wikipreview h1 {
> 	font-weight: bold;
> 	color: #000000;
> 	border-bottom: 2px solid Orange;
> 	background-repeat: no-repeat;
> 	background-position: -10px -200px
> }
> 
> .wikitext h2,
> .wikipreview h2 {
> 	border-bottom: 3px solid #cccccc;
> 	font-weight: bold;
> 	color: #000000;
> }
> .wikitext h3,
> .wikipreview h3 {
> 	border-bottom: 1px solid #cccccc;
> 	font-weight: bold;
> 	color: #000000;
> }
> .wikitext h4,
> .wikipreview h4 {
> 	font-weight: bold;
> 	padding-left: 10px;
> 	border-bottom: 1px solid #999999;
> 	color: #ffffff;
> 	background-color: #000000;
> }
> .wikitext h5,
> .wikipreview h5 {
> 	font-weight: bold;
> 	padding-left: 10px;
> 	border-bottom: 1px solid #999999;
> 	background-color: Red;
> 	color: #ffffff;
> }
> .wikitext h6,
> .wikipreview h6 {
> 	font-weight: bold;
> 	font-style: italics;
> 	margin-bottom: 0px;
> 	padding-left: 10px;
> 	color: #000000;
> 	background-color: #ff9900;
> }
> 
> p {
> 	padding-right: 5px;
> 	padding-bottom: 5px;
> 	margin-bottom: 5px;
> }
> 
> .wikitoc {
> 	margin-top: 10px;
> 	border-top: 1px solid #cccccc;
> 	border-right: 1px solid #cccccc;
> 	border-bottom: 1px solid #cccccc;
> 	border-left: 1px solid #cccccc;
> 	width: 215px;
> 	padding: 5px;
> 	background-color: #f5f5f5;
> }
> .wikitoctitle {
> 	font-weight: bold;
> 	text-align: center;
> }
> .wikilockicon,
> .wikiediticon {
> 	height: 12px;
> 	width: 12px;
> 	margin-left: 3px;
> 	padding-right: 8px;
> 	position: relative;
> 	top: -10px;
> 	_top: -15px;
> 	background-repeat: no-repeat;
> 	background-image: url("/img/icon.edit.link.gif");
> 	overflow: hidden;
> }
> 
> .wikilockicon {
> 	background-image: url("/img/icon.locked.link.gif");	
> }
> 
> .wikilinkicon {
> 	height: 12px;
> 	width: 12px;
> 	margin-left: 3px;
> 	padding-right: 8px;
> 	position: relative;
> 	top: -4px;
> 	_top: -6px;
> 	background-repeat: no-repeat;
> 	background-image: url("/img/icon.question.red.gif");
> 	background-position: 0px 2px;
> 	_background-position: 0px 0px;
> 	overflow: hidden;
> }
> .wikisearch {
> 	padding-top: 10px;	
> }
> .wikitext {
> 	padding: 10px;
> 	padding-top: 0px;
> 	padding-bottom: 0px;
> 	background-color : #ffffff;
> 
> 
> }
> 
> .wikipreview {
> 	padding: 25px 10px 10px 10px;
> 	background-color : #eeeeee;
> 	background-position: top;
> 	background-image: url("/img/gray.shadow.top.gif");
> 	background-repeat: repeat-x;
> }
> 
> #wikitextareabanlist {
> 	font-family: Courier, Serif;
> 	line-height: 1.2;
> }
> .wikiheader {
> 	padding-top: 125px;
> 	padding-left: 10px;
> 	padding-right: 10px;
> 	background-image: url("/img/wiki.header.jpg");
> 	background-repeat: repeat-x;
> }
> .wikiheader a:link,
> .wikiheader a:visited { 
> 	color: White; 
> 	text-decoration: none;
> }
> 
> .wikiheader h1 {
> 	color: White;
> }
> .wikifooter a:link,
> .wikifooter a:visited { 
> 	color: White; 
> 	text-decoration: none;
> }
> 
> .wikiheader a:hover,
> .wikifooter a:hover {
> 	text-decoration: underline;
> }
> 
> .wikiheader,
> .wikifooter {
> 	color: Yellow;
> }
> .wikiadmin,
> .wikidiff {
> 	background-color: #ffffff;
> 	padding: 10px;
> 	overflow: auto;
> }
> .wikiadmin h2 {
> 	color: red;
> 	font-weight: bold;
> }
> .wikiadmin .wikiscriptlink:hover {
> 	color: red;
> }
> 
> .wikilinediff {
> 	background-image: url("/img/gray.shadow.top.gif");
> 	background-repeat: repeat-x;
> 	height:12px;
> }
> 
> ol, ul {
> 	margin-left: 25px;
> 	padding-top: 5px;
> 	padding-bottom: 10px;
> }
> 
> ul li {
> 	list-style-image: url("/img/bullet.fancy.gif");
> 	margin-bottom: 5px;
> }
> 
> 
> .wikifooter .wikigotobar {
> 	padding-bottom: 25px;
> 
> }
> 
> .wikifooter {
> 	padding-bottom: 25px;
> 	padding-left: 10px;
> 	padding-right: 10px;
> 	padding-top: 10px;
> 	background-image: url("/img/wiki.footer.jpg");
> 	_margin-top: -5px;
> }
> 
> .wikigotobar {
> 	font-weight: bold;
> }
> .wikilineheader {
> 	margin-top: 10px;
> 	background-image: url("/img/gray.shadow.top.gif");
> 	background-repeat: repeat-x;
> 
>   	height : 16px;
> 	margin-left: -10px;
> 	margin-right: -10px;
> }
> .wikilinefooter {
> 	background-image: url("/img/gray.shadow.bottom.gif");
> 	background-repeat: repeat-x;
>   	height : 20px;
>   	_height: 25px;
> }
> 
> 
> .wikiline {
> 	background-color: #999999;
>   	height : 1px;
>   	margin-bottom: 5px;
>   	margin-top: 5px;
> }
> 
> .wikiline1 {
> 	border: 1px solid orange;
>   	height : 10px;
> }
> 
> .wikiline2 {
> 	border: 1px solid purple;
>   	height : 10px;
> }
> .wikilinepref {
>   	height : 20px;
> }
> a:link {
> 	color: Indigo;
> 	text-decoration: none;
> }
> a:hover {
> 	text-decoration: underline;
> }
> a:visited {
> 	color: Indigo;
> }
> .wikipagelink:link,
> .wikicreatepagelink:link {
> }
> 
> .wikipagelink:visited,
> .wikicreatepagelink:visited {
> 	text-decoration: none;
> }
> .wikicreatepagelink {
>  	background-color: #red;
> }
> .wikicreatepagelink:link {
> 	color: red;
> }
> 
> .wikipageedit:hover {
> 	color: red;
> }
> .wikidiffold {
> 	background-color : orange;
> }
> .wikidiffnew {
> 	background-color : Lightgreen;
> }
> 
> 
> 
> .wikirevision {
> 	
> }
> 
> .wikiurlorimage img,
> .wikibracketurl img,
> .wikiuploadlink img,
> .wikiuploadbar img,
> .wikilogo img,
> .wikiinterpage img,
> .wikiurlorimage img {
> 	margin: 5px;
> 	padding: 3px;
> 	padding-bottom: 6px;
> 	background-color: #ffffff;
> 	border-top: 1px solid #eeeeee;
> 	border-left: 1px solid #eeeeee;
> 	border-bottom: 2px solid #cccccc;
> 	border-right: 2px solid #cccccc;
> }
> 
> 
> p img {
> 	margin-top: -3px;
> }
> 
> 
> table.wikilargelist {
> 	border-top: 1px solid #aaaaaa;
> 	border-left: 1px solid #aaaaaa;
> 	border-bottom: 1px solid #cccccc;
> 	border-right: 1px solid #cccccc;
> 	background-color: #f5f5f5;	
> }
> 
> table.wikilargelist td {
> 	vertical-align: top;
> 	padding-left: 5px;
> 	padding-right: 5px;
> 	border-bottom: 1px solid #cccccc;
> 	border-right: 1px solid #cccccc;
> 	background-color: #f5f5f5;
> }
> 
> table.wikilargelist input {
> 	margin-top: 5px;
> }
> .wikipreview table.wikilargelist th,
> table.wikilargelist th {
> 	vertical-align: top;
> 	background-color: #cccccc;
> 	padding-top: 5px;
> 	padding-left: 5px;
> 	padding-right: 10px;
> 	border-right: 1px solid #999999;
> 	font-weight: bold;
> 	border-bottom: 1px solid #999999;
> }
> 
> .wikidiff li:hover,
> .wikihistory tr:hover {
>     background-color: #ffcc00;
> }
4,49c419,571
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=right|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
< 
< [http://www.yahoo.com/ Some link goes here|title=Awesome news!|description=not relevant]
< 
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxfloat=left|description=very long description worthy of an Emmy. See more in the next line.  And also here and here and here.] 
< = Introduction =
< 
< ew other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revision
< 
< == Nations at War =
< There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America [ USA ], peered with Russia [ USSR ] and the United Kingdom Empire [ UK ].  On the opposing side are Germany, Japan, and Italy.
< 
< == Game Goal =
< Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating 
< Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
< 
< Objective Markers are also placed upon the battlefield as goals for acquisition during play which translate into victory points.  Victory points are also awarded for eliminating enemy units.  At the end of the game  usually 6 turns long  the player with the most points wins!
< 
< == The Operational Art of War =
< This game is a fanciful but detailed look at how to prosecute warfare at the operational level.  Unlike many such games that employ hundreds of unit counters to recreate such a simulation, this one focuses on the interaction of ten or twenty.  
< 
< === EPIC GAMES =
< Here are the key differences of operational level games when compared to tactical level games that deal with smaller units like men, squads, or platoons:
< 
< ==== Game Scale =
< This operational level game deals with units that are companies and battalions.  Theres about a thousand soldiers or one-hundred vehicles in a battalion.  Or, maybe it just contains 10 really humongous robots and their nervous human handlers.  
< 
< Operational level games are epic; with just a few units, these games simulate what would normally take hundreds of pieces in smaller scale games.  With this scale; battles can be waged over control of a city and its country-sides instead of just individual buildings or bridges.
< 
< ==== Zone-of-Control [ ZOC ] =
< Imagine reaching out your hands in front of you, and whirling about to cover your back.  You probably could cover about 3 feet in a radius around you; anybody coming within range would probably get smacked, or at least move cautiously by.  Now do this with a machine gun, with mortars, with cannons, with giant robot beam weapons.  And then, multiply that by several hundred or several thousand rounds of weapons fire by nearly as many soldiers or tanks covering several hundred meters all about.  Thats Zone-of-Control.
< 
< ==== Supply =
< In the scale of tactical level games, the firefights go pretty quickly; maybe five to twenty minutes pass in game-time depending on the scale of the simulation.  Ammo does run out, but probably not fuel.  You can always reload.  In operation level games, supply is critical.  Being in supply - within the distance of the supply truck convoys  can be the difference between having your units perforated, running for cover, or pressing the battle-line victoriously forward.
< 
< ==== Line-of-Command [ LOC ] =
< At the tactical level, the heroic commanders could probably shout orders to their equally heroic underlings, and maybe get some things done by all as a team.  It doesnt work that well with the units that are way across the hill, especially when each unit represents the average response of possibly hundreds of disorganized warriors awaiting instruction.  Without Line-of-Command, units will not be able to participate in the glory of taking down that mammoth tank or draw the line against the rogue sentinel robot together.
< 
< ==== Weather =
< Lastly, weather conditions become a grave concern for the force commanders in operational-level play.  At smaller scales, it may rain or snow for the duration of the battle.  Perhaps the mud conditions might prevail through-out.  However, at this larger scale; the mud may clear up as soon as day breaks.  The time to make an opportune strike can be seen just a few hours away; hold that battle-line until then!
< 
< ====== Related =
<  /WorldHistory
<  /RulesFAQ
<  /DesignNotes
<  /NewIdeas
---
> .wikipreview table.wikilargelist th {
> 	vertical-align: top;
> 	background-color: #cccccc;
> }
> 
> table.wikilargelist {
> 	width: 95%;
> 	position: relative;
> 	left: 10px;
> }
> 
> tr > .first-column {
> 	width: 250px !important;
> }
> 
> /*CUSTOM DIV*/
> .warning {
> 	padding: 20px;
> 	font-size: 12px;
> 	background-color: yellow;
> }
> 
> /*STRUCTURE*/
> #wikibar {
> 	background-image: url("/img/gray.shadow.any.gif");
>   	height : 12px;
> }
> 
> #summarytext {
> 	width: 100%;
> 	margin-bottom: 10px;
> }
> 
> #anylogo {
> 	background-image: url("/img/npg.logo.jpg");
> 	background-repeat: no-repeat;
> 	float: right;
> 	position: relative;
> 	top: -42px;
> 	margin-left: 10px;
> 	margin-bottom: -30px;
> 	height: 54px;
> 	width: 42px;
> }
> 
> 
> 
> #wikicontainer {
> 	border-right: 2px solid #333333;
> 	border-bottom: 1px solid #000000;
> 	border-left: 2px solid #aaaaaa;
> 	width: 90%;
> 	margin: 0 auto;   /* align for good browsers */
> 	text-align: left; /* counter the body center */
> 	background-color: #ffffff;
> }
> 
> .wikipreviewtitle {
> 	padding: 5px;
> 	padding-left: 10px;
> 	color: #ffffff;
> 	background-color: #ff0000;
> 	font-weight: bold;
> }
> #wikieditbar {
> 	float:right;
> 	margin-right: 10px;
> 	padding: 5px;
> }
> #searchfield:hover {
> 	border: 1px solid black;
> }
> 
> #wikitextareatext {
> 	font-family: Courier, Monospaced, Serif;
> 	line-height: 1.2;
> }
> 
> /*FORMS*/
> #wikiform {
> 	padding: 10px;
> }
> 
> 
> /*perlDiff */
> #wikidifftable {
> 	width: 100.01%;	
> 	padding: 10px;
> }
> #wikidiffdiv {
> 	margin-bottom: 20px;
> 	width: 99%;
> 	overflow: auto;
> }
> #wikidifftexttitle {
> 	margin-top: 10px;
> 	font-weight: bold;
> 	color: #ffffff;
> 	padding: 10px;
> 	background-color: #ff0000;
> }
> 
> .diff-header       { 
> 	padding-top: 20px;
> 	font-weight: bold; 
> 	font-size: 12pt; 
> 	color: #000000; 
> 	padding-left: 5px; 
> 	padding-right: 5px; 
> 	width: 45%;
> 
> } 
> .diff-para-deleted { background: #ffb6c1 }   /* deleted complete paragraphs */
> .diff-para-added   { background: #98fb98 	}  /* added complete paragraphs */
> .diff-para-ident   { background: White; }                    /* unchanged complete paragraphs */
> .diff-para-changed { background: White; 	}                    /* changed paragraphs */
> .diff-span-ident   { background: White; 	}                    /* unchanged words in changed paragraphs */
> .diff-span-added   { background: #7cfc00 }  /* added words in changed paragraphs */
> .diff-span-deleted { background: #ff4500 }    /* deleted words in changed paragraphs */
> 
> .diff-para-ident,
> .diff-para-deleted,
> .diff-para-changed,
> .diff-para-added,
> .diff-span-added,
> .diff-span-ident,
> .diff-span-deleted {
> 	font-family: Courier, Monospace, Serif;
> }
> 
> .diff-para-ident,
> .diff-para-deleted,
> .diff-para-changed,
> .diff-para-added {
> 	padding: 5px;
> 	width: 50%;
> 	line-height: 1.5;
> 	border-top: 1px solid #eeeeee;
> 	border-right: 1px solid #cccccc;
> 	border-bottom: 1px solid #cccccc;
> 	border-left: 1px solid #eeeeee;
> }
> 
> .diff-para-ident {
> 	border: none;
> }
> 
> .diff-vertical {
> 	padding: 5px;
> }
> 
> .magic { margin-top: 10px; }
> .magic h4 { margin-top: 10px; }
------
SandBox|1194211255
36a37
> 	margin-bottom: 10px;
40a42,43
> 	overflow: auto;
> 	_display: inline-block;
71c74,75
< 	margin-bottom: 6px;
---
> 	overflow: auto;
> 	_display: inline-block;
85c89
< 	background-position: -10px -200px
---
> 	background-position: -10px -200px;
126,135c129,133
< p {
< 	padding-right: 5px;
< 	padding-bottom: 5px;
< 	margin-bottom: 5px;
< }
< 
< .wikitoc {
< 	margin-top: 10px;
< 	border-top: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;
---
> .wikitext {
> 	padding: 10px;
> 	padding-top: 10px;
> 	margin-left: 160px;
> 	margin-right: 5px;
138,140c136,143
< 	width: 215px;
< 	padding: 5px;
< 	background-color: #f5f5f5;
---
> 	border-right: 1px solid #cccccc;
> 	background-color: #ffffff;
> 	
> 	white-space: pre-wrap; /* css-3 */
> 	white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */
> 	white-space: -pre-wrap; /* Opera 4-6 */
> 	white-space: -o-pre-wrap; /* Opera 7 */
> 	word-wrap: break-word; /* Internet Explorer 5.5+ */	
142,144c146,147
< .wikitoctitle {
< 	font-weight: bold;
< 	text-align: center;
---
> .wikidiff {
> 	margin-left: -5px;
146,157c149,150
< .wikilockicon,
< .wikiediticon {
< 	height: 12px;
< 	width: 12px;
< 	margin-left: 3px;
< 	padding-right: 8px;
< 	position: relative;
< 	top: -10px;
< 	_top: -15px;
< 	background-repeat: no-repeat;
< 	background-image: url("/img/icon.edit.link.gif");
< 	overflow: hidden;
---
> .wikiblurb {
> 	padding: 10px;	
160,161c152,156
< .wikilockicon {
< 	background-image: url("/img/icon.locked.link.gif");	
---
> .wikiadmin,
> .wikidiff {
> 	background-color: #ffffff;
> 	padding: 10px;
> 	overflow: auto;
164,176c158,160
< .wikilinkicon {
< 	height: 12px;
< 	width: 12px;
< 	margin-left: 3px;
< 	padding-right: 8px;
< 	position: relative;
< 	top: -4px;
< 	_top: -6px;
< 	background-repeat: no-repeat;
< 	background-image: url("/img/icon.question.red.gif");
< 	background-position: 0px 2px;
< 	_background-position: 0px 0px;
< 	overflow: hidden;
---
> .wikiadmin h2 {
> 	color: red;
> 	font-weight: bold;
178,179c162,163
< .wikisearch {
< 	padding-top: 10px;	
---
> .wikiadmin .wikiscriptlink:hover {
> 	color: red;
181,187c166,170
< .wikitext {
< 	padding: 10px;
< 	padding-top: 0px;
< 	padding-bottom: 0px;
< 	background-color : #ffffff;
< 
< 
---
> .wikiadmin, .wikidiff {
> 	border-bottom: 1px solid #cccccc;
> 	border-left: 1px solid #cccccc;
> 	border-right: 1px solid #cccccc;	
> 	margin-right: 5px;
190,195c173,174
< .wikipreview {
< 	padding: 25px 10px 10px 10px;
< 	background-color : #eeeeee;
< 	background-position: top;
< 	background-image: url("/img/gray.shadow.top.gif");
< 	background-repeat: repeat-x;
---
> p {
> 	padding-bottom: 5px;
198,200c177,187
< #wikitextareabanlist {
< 	font-family: Courier, Serif;
< 	line-height: 1.2;
---
> .wikitoc {
> 	border-top: 1px solid #cccccc;
> 	border-right: 1px solid #cccccc;
> 	border-bottom: 1px solid #cccccc;
> 	border-left: 1px solid #cccccc;
> 	width: 215px;
> 	padding: 5px;
> 	background-color: #f5f5f5;
> 	float: left;
> 	margin-right: 10px;
> 	margin-top: 0px;
202,207c189,193
< .wikiheader {
< 	padding-top: 125px;
< 	padding-left: 10px;
< 	padding-right: 10px;
< 	background-image: url("/img/wiki.header.jpg");
< 	background-repeat: repeat-x;
---
> .wikitoctitle {
> 	font-weight: bold;
> 	text-align: center;
> 	background-color: #000000;
> 	color: #ffffff;
209,212c195,206
< .wikiheader a:link,
< .wikiheader a:visited { 
< 	color: White; 
< 	text-decoration: none;
---
> .wikilockicon,
> .wikiediticon {
> 	height: 12px;
> 	width: 12px;
> 	margin-left: 3px;
> 	padding-right: 8px;
> 	position: relative;
> 	top: -10px;
> 	_top: -15px;
> 	background-repeat: no-repeat;
> 	background-image: url("/img/icon.edit.link.gif");
> 	overflow: hidden;
215,216c209,210
< .wikiheader h1 {
< 	color: White;
---
> .wikilockicon {
> 	background-image: url("/img/icon.locked.link.gif");	
218,221c213,225
< .wikifooter a:link,
< .wikifooter a:visited { 
< 	color: White; 
< 	text-decoration: none;
---
> .wikilinkicon {
> 	height: 12px;
> 	width: 12px;
> 	margin-left: 3px;
> 	padding-right: 8px;
> 	position: relative;
> 	top: -4px;
> 	_top: -6px;
> 	background-repeat: no-repeat;
> 	background-image: url("/img/icon.question.red.gif");
> 	background-position: 0px 2px;
> 	_background-position: 0px 0px;
> 	overflow: hidden;
224,226c227,228
< .wikiheader a:hover,
< .wikifooter a:hover {
< 	text-decoration: underline;
---
> .wikisearch {
> 	padding-top: 10px;	
229,231c231,238
< .wikiheader,
< .wikifooter {
< 	color: Yellow;
---
> .wikileftnavsearch {
> 	background-color: #cccccc;
> 	padding: 5px;
> 	margin-right: 5px;
> 	margin-top: -5px;
> 	border-bottom: 1px solid #999999;
> 	border-left: 1px solid #999999;
> 	border-right: 1px solid #999999;		
233,237c241,245
< .wikiadmin,
< .wikidiff {
< 	background-color: #ffffff;
< 	padding: 10px;
< 	overflow: auto;
---
> .wikipreview {
> 	padding: 25px 10px 10px 10px;
> 	background-color : #eeeeee;
> 	border-left: 1px solid #cccccc;
> 	margin-left: 150px;
239,241c248,250
< .wikiadmin h2 {
< 	color: red;
< 	font-weight: bold;
---
> #wikitextareabanlist {
> 	font-family: Courier, Serif;
> 	line-height: 1.2;
243,244c252,257
< .wikiadmin .wikiscriptlink:hover {
< 	color: red;
---
> .wikiheader {
> 	padding-top: 125px;
> 	padding-left: 10px;
> 	padding-right: 10px;
> 	background-image: url("/img/wiki.header.jpg");
> 	background-repeat: repeat-x;
247,250c259,262
< .wikilinediff {
< 	background-image: url("/img/gray.shadow.top.gif");
< 	background-repeat: repeat-x;
< 	height:12px;
---
> .wikiheader a:link,
> .wikiheader a:visited { 
> 	color: White; 
> 	text-decoration: none;
253,256c265,266
< ol, ul {
< 	margin-left: 25px;
< 	padding-top: 5px;
< 	padding-bottom: 10px;
---
> .wikiheader h1 {
> 	color: White;
259,261c268,271
< ul li {
< 	list-style-image: url("/img/bullet.fancy.gif");
< 	margin-bottom: 5px;
---
> .wikifooter a:link,
> .wikifooter a:visited { 
> 	color: White; 
> 	text-decoration: none;
265,267c274,276
< .wikifooter .wikigotobar {
< 	padding-bottom: 25px;
< 
---
> .wikiheader a:hover,
> .wikifooter a:hover {
> 	text-decoration: underline;
269a279
> .wikiheader,
271,276c281
< 	padding-bottom: 25px;
< 	padding-left: 10px;
< 	padding-right: 10px;
< 	padding-top: 10px;
< 	background-image: url("/img/wiki.footer.jpg");
< 	_margin-top: -5px;
---
> 	color: Yellow;
279,283c285
< .wikigotobar {
< 	font-weight: bold;
< }
< .wikilineheader {
< 	margin-top: 10px;
---
> .wikilinediff {
287,289c288,289
<   	height : 16px;
< 	margin-left: -10px;
< 	margin-right: -10px;
---
> 	height:12px;
> 	margin-bottom: 5px;
291,295c292,295
< .wikilinefooter {
< 	background-image: url("/img/gray.shadow.bottom.gif");
< 	background-repeat: repeat-x;
<   	height : 20px;
<   	_height: 25px;
---
> ol, ul {
> 	margin-left: 25px;
> 	padding-top: 5px;
> 	padding-bottom: 10px;
299,303c298,300
< .wikiline {
< 	background-color: #999999;
<   	height : 1px;
<   	margin-bottom: 5px;
<   	margin-top: 5px;
---
> ul li {
> 	list-style-image: url("/img/bullet.fancy.gif");
> 	margin-bottom: 5px;
306,308c304,306
< .wikiline1 {
< 	border: 1px solid orange;
<   	height : 10px;
---
> .wikifooter .wikigotobar {
> 	padding-bottom: 25px;
> 
311,313c309,315
< .wikiline2 {
< 	border: 1px solid purple;
<   	height : 10px;
---
> .wikifooter {
> 	padding-bottom: 25px;
> 	padding-left: 10px;
> 	padding-right: 10px;
> 	padding-top: 10px;
> 	background-image: url("/img/wiki.footer.jpg");
> 	_margin-top: -5px;
315,316c318,319
< .wikilinepref {
<   	height : 20px;
---
> .wikigotobar {
> 	font-weight: bold;
318,320c321,327
< a:link {
< 	color: Indigo;
< 	text-decoration: none;
---
> .wikilineheader {
> 	margin-top: 10px;
> 	background-image: url("/img/gray.shadow.top.gif");
> 	background-repeat: repeat-x;
>   	height : 16px;
> 	margin-left: -10px;
> 	margin-right: -10px;
322,323c330,334
< a:hover {
< 	text-decoration: underline;
---
> .wikilineheaderpreview {
> 	background-image: url("/img/gray.shadow.top.gif");
> 	background-repeat: repeat-x;
> 
>   	height : 16px;
325,326c336,341
< a:visited {
< 	color: Indigo;
---
> .wikilinefooter {
> 	background-image: url("/img/gray.shadow.bottom.gif");
> 	background-repeat: repeat-x;
>   	height : 20px;
>   	_height: 25px;
>   	clear:both;
328,329c344,348
< .wikipagelink:link,
< .wikicreatepagelink:link {
---
> .wikiline {
> 	background-color: #999999;
>   	height : 1px;
>   	margin-bottom: 5px;
>   	margin-top: 5px;
332,334c351,353
< .wikipagelink:visited,
< .wikicreatepagelink:visited {
< 	text-decoration: none;
---
> .wikiline1 {
> 	border: 1px solid orange;
>   	height : 10px;
336,337c356,358
< .wikicreatepagelink {
<  	background-color: #red;
---
> .wikiline2 {
> 	border: 1px solid purple;
>   	height : 10px;
339,340c360,361
< .wikicreatepagelink:link {
< 	color: red;
---
> .wikilinepref {
>   	height : 20px;
343,344c363,365
< .wikipageedit:hover {
< 	color: red;
---
> a:link {
> 	color: Indigo;
> 	text-decoration: none;
346,347c367,368
< .wikidiffold {
< 	background-color : orange;
---
> a:hover {
> 	text-decoration: underline !important;
349,350c370,372
< .wikidiffnew {
< 	background-color : Lightgreen;
---
> a:visited {
> 	color: Indigo;
> 	text-decoration: none;
355,356c374,375
< .wikirevision {
< 	
---
> .wikipagelink:link,
> .wikicreatepagelink:link {
359,373c378,380
< .wikiurlorimage img,
< .wikibracketurl img,
< .wikiuploadlink img,
< .wikiuploadbar img,
< .wikilogo img,
< .wikiinterpage img,
< .wikiurlorimage img {
< 	margin: 5px;
< 	padding: 3px;
< 	padding-bottom: 6px;
< 	background-color: #ffffff;
< 	border-top: 1px solid #eeeeee;
< 	border-left: 1px solid #eeeeee;
< 	border-bottom: 2px solid #cccccc;
< 	border-right: 2px solid #cccccc;
---
> .wikipagelink:visited,
> .wikicreatepagelink:visited {
> 	text-decoration: none;
377,378c382,383
< p img {
< 	margin-top: -3px;
---
> .wikicreatepagelink {
>  	background-color: #red;
382,387c385,386
< table.wikilargelist {
< 	border-top: 1px solid #aaaaaa;
< 	border-left: 1px solid #aaaaaa;
< 	border-bottom: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;
< 	background-color: #f5f5f5;	
---
> .wikicreatepagelink:link {
> 	color: red;
390,396c389,390
< table.wikilargelist td {
< 	vertical-align: top;
< 	padding-left: 5px;
< 	padding-right: 5px;
< 	border-bottom: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;
< 	background-color: #f5f5f5;
---
> .wikipageedit:hover {
> 	color: red;
399,400c392,393
< table.wikilargelist input {
< 	margin-top: 5px;
---
> .wikidiffold {
> 	background-color : orange;
402,411c395,396
< .wikipreview table.wikilargelist th,
< table.wikilargelist th {
< 	vertical-align: top;
< 	background-color: #cccccc;
< 	padding-top: 5px;
< 	padding-left: 5px;
< 	padding-right: 10px;
< 	border-right: 1px solid #999999;
< 	font-weight: bold;
< 	border-bottom: 1px solid #999999;
---
> .wikidiffnew {
> 	background-color : Lightgreen;
414,416c399,400
< .wikidiff li:hover,
< .wikihistory tr:hover {
<     background-color: #ffcc00;
---
> .wikirevision {
> 	
418,421c403,416
<  
< .wikipreview table.wikilargelist th {
< 	vertical-align: top;
< 	background-color: #cccccc;
---
> .wikiurlorimage img,
> .wikibracketurl img,
> .wikiuploadlink img,
> .wikiuploadbar img,
> .wikilogo img,
> .wikiinterpage img,
> .wikiurlorimage img {
> 	padding: 3px;
> 	padding-bottom: 6px;
> 	background-color: #ffffff;
> 	border-top: 1px solid #eeeeee;
> 	border-left: 1px solid #eeeeee;
> 	border-bottom: 2px solid #cccccc;
> 	border-right: 2px solid #cccccc;
424,427c419,423
< table.wikilargelist {
< 	width: 95%;
< 	position: relative;
< 	left: 10px;
---
> .wikibracketbox {
> 	border: 1px solid #cccccc;
> 	background-color: #ffffff !important;
> 	overflow: auto;
> 	padding: 5px;
430,431c426,427
< tr > .first-column {
< 	width: 250px !important;
---
> .wikibracketbox img {
> 	border: none !important;
434,438c430,438
< /*CUSTOM DIV*/
< .warning {
< 	padding: 20px;
< 	font-size: 12px;
< 	background-color: yellow;
---
> .wikibracketboxtitle {
> 	font-weight: bold;
> 	font-size: 1.2em;
> 	color: #ffffff;
> 	background-color: #000000;
> 	padding: 3px;
> 	overflow: auto;
> 
> 
441,444c440,441
< /*STRUCTURE*/
< #wikibar {
< 	background-image: url("/img/gray.shadow.any.gif");
<   	height : 12px;
---
> .imagefloatright, .imagefloatleft {
> 	margin-top: -15px !important;
447,449c444,445
< #summarytext {
< 	width: 100%;
< 	margin-bottom: 10px;
---
> .image {
> 	margin-top: 5px;
452,461c448,452
< #anylogo {
< 	background-image: url("/img/npg.logo.jpg");
< 	background-repeat: no-repeat;
< 	float: right;
< 	position: relative;
< 	top: -42px;
< 	margin-left: 10px;
< 	margin-bottom: -30px;
< 	height: 54px;
< 	width: 42px;
---
> .wikibracketboxdescription {
> 	font-style: italic;
> 	background-color: #f5f5f5;
> 	padding: 3px;
> 	overflow: auto;
466,473c455,456
< #wikicontainer {
< 	border-right: 2px solid #333333;
< 	border-bottom: 1px solid #000000;
< 	border-left: 2px solid #aaaaaa;
< 	width: 90%;
< 	margin: 0 auto;   /* align for good browsers */
< 	text-align: left; /* counter the body center */
< 	background-color: #ffffff;
---
> .floatnone {
> 	float: none;
476,481c458,461
< .wikipreviewtitle {
< 	padding: 5px;
< 	padding-left: 10px;
< 	color: #ffffff;
< 	background-color: #ff0000;
< 	font-weight: bold;
---
> .floatleft {
> 	float: left;
> 	margin-right: 10px;
> 	margin-left: 0px;
483,486c463,466
< #wikieditbar {
< 	float:right;
< 	margin-right: 10px;
< 	padding: 5px;
---
> .floatright {
> 	float: right;
> 	margin-right: 0px;
> 	margin-left: 10px;
488,489c468,469
< #searchfield:hover {
< 	border: 1px solid black;
---
> .clearright {
> 	clear: right;
492,494c471,472
< #wikitextareatext {
< 	font-family: Courier, Monospaced, Serif;
< 	line-height: 1.2;
---
> .clearleft {
> 	clear: left;
497,499c474,475
< /*FORMS*/
< #wikiform {
< 	padding: 10px;
---
> .clearboth {
> 	clear: both;
503,506c477,478
< /*perlDiff */
< #wikidifftable {
< 	width: 100.01%;	
< 	padding: 10px;
---
> .clearnone {
> 	clear: none;
508,511c481,486
< #wikidiffdiv {
< 	margin-bottom: 20px;
< 	width: 99%;
< 	overflow: auto;
---
> .clearfix:after {
>     content: "."; 
>     _display: block; 
>     height: 0; 
>     clear: both; 
>     visibility: hidden;
513,518c489,498
< #wikidifftexttitle {
< 	margin-top: 10px;
< 	font-weight: bold;
< 	color: #ffffff;
< 	padding: 10px;
< 	background-color: #ff0000;
---
> .clearfix {display: inline-block;}
> 
> /* Hides from IE-mac \*/
> * html .clearfix {height: 1%;}
> .clearfix {display: block;}
> /* End hide from IE-mac */
> 
> 
> p img {
> 	margin-top: -3px;
521,546c502,507
< .diff-header       { 
< 	padding-top: 20px;
< 	font-weight: bold; 
< 	font-size: 12pt; 
< 	color: #000000; 
< 	padding-left: 5px; 
< 	padding-right: 5px; 
< 	width: 45%;
< 
< } 
< .diff-para-deleted { background: #ffb6c1 }   /* deleted complete paragraphs */
< .diff-para-added   { background: #98fb98 	}  /* added complete paragraphs */
< .diff-para-ident   { background: White; }                    /* unchanged complete paragraphs */
< .diff-para-changed { background: White; 	}                    /* changed paragraphs */
< .diff-span-ident   { background: White; 	}                    /* unchanged words in changed paragraphs */
< .diff-span-added   { background: #7cfc00 }  /* added words in changed paragraphs */
< .diff-span-deleted { background: #ff4500 }    /* deleted words in changed paragraphs */
< 
< .diff-para-ident,
< .diff-para-deleted,
< .diff-para-changed,
< .diff-para-added,
< .diff-span-added,
< .diff-span-ident,
< .diff-span-deleted {
< 	font-family: Courier, Monospace, Serif;
---
> table.wikilargelist {
> 	border-top: 1px solid #aaaaaa;
> 	border-left: 1px solid #aaaaaa;
> 	border-bottom: 1px solid #cccccc;
> 	border-right: 1px solid #cccccc;
> 	background-color: #f5f5f5;	
549,556c510,514
< .diff-para-ident,
< .diff-para-deleted,
< .diff-para-changed,
< .diff-para-added {
< 	padding: 5px;
< 	width: 50%;
< 	line-height: 1.5;
< 	border-top: 1px solid #eeeeee;
---
> table.wikilargelist td {
> 	vertical-align: top;
> 	padding-left: 5px;
> 	padding-right: 5px;
> 	border-bottom: 1px solid #cccccc;
558,559c516
< 	border-bottom: 1px solid #cccccc;
< 	border-left: 1px solid #eeeeee;
---
> 	background-color: #f5f5f5;
562,563c519,520
< .diff-para-ident {
< 	border: none;
---
> table.wikilargelist input {
> 	margin-top: 5px;
566,567c522,531
< .diff-vertical {
< 	padding: 5px;
---
> .wikipreview table.wikilargelist th,
> table.wikilargelist th {
> 	vertical-align: top;
> 	background-color: #cccccc;
> 	padding-top: 5px;
> 	padding-left: 5px;
> 	padding-right: 10px;
> 	border-right: 1px solid #999999;
> 	font-weight: bold;
> 	border-bottom: 1px solid #999999;
570c534,707
< .magic { margin-top: 10px; }
---
> .wikidiff li:hover,
> .wikihistory tr:hover {
>     background-color: #ffcc00;
> }
>  
> .wikipreview table.wikilargelist th {
> 	vertical-align: top;
> 	background-color: #cccccc;
> }
> 
> table.wikilargelist {
> 	width: 75%;
> 	position: relative;
> 	margin-top: 10px;
> 	margin-bottom: 20px;
> }
> 
> .wikileftnav {
> 	width: 155px; 
> 	padding: 5px;
> 	float: left;
> }
> 
> .wikileftnav .wikileftnavbox {
> 	background-color: #ffffff;
> 	border-top: 1px solid #eeeeee;
> 	border-right: 1px solid #cccccc;
> 	border-bottom: 1px solid #cccccc;
> 	border-left: 1px solid #eeeeee;
> 	margin-right: 5px;
> 	_margin-right: -5px;
> 	margin-bottom: 10px;
> 	margin-top: -5px;
> }
> 
> tr > .first-column {
> 	width: 250px !important;
> }
> 
> /*CUSTOM DIV*/
> .warning {
> 	padding: 20px;
> 	font-size: 12px;
> 	background-color: yellow;
> }
> 
> /*STRUCTURE*/
> #wikibar {
> 	background-image: url("/img/gray.shadow.any.gif");
>   	height : 12px;
> }
> 
> #summarytext {
> 	width: 100%;
> 	margin-bottom: 10px;
> }
> 
> #anylogo {
> 	background-image: url("/img/npg.logo.jpg");
> 	background-repeat: no-repeat;
> 	float: right;
> 	position: relative;
> 	top: -42px;
> 	margin-left: 10px;
> 	margin-bottom: -30px;
> 	height: 54px;
> 	width: 42px;
> }
> 
> #wikicontainer {
> 	border-right: 2px solid #333333;
> 	border-bottom: 1px solid #000000;
> 	border-left: 2px solid #aaaaaa;
> 	width: 90%;
> 	margin: 0 auto;   /* align for good browsers */
> 	text-align: left; /* counter the body center */
> 	background-color: #f5f5f5;
> }
> 
> .wikipreviewtitle {
> 	padding: 5px;
> 	padding-left: 10px;
> 	color: #ffffff;
> 	background-color: #ff0000;
> 	font-weight: bold;
> }
> #wikieditbar {
> 	float:right;
> 	margin-right: 10px;
> 	padding: 5px;
> }
> #searchfield:hover {
> 	border: 1px solid black;
> }
> 
> #wikitextareatext {
> 	font-family: Courier, Monospaced, Serif;
> 	line-height: 1.2;
> }
> 
> /*FORMS*/
> #wikiform {
> 	padding: 10px;
> }
> 
> 
> /*perlDiff */
> #wikidifftable {
> 	width: 100.01%;	
> 	padding: 10px;
> }
> #wikidiffdiv {
> 	margin-bottom: 20px;
> 	width: 99%;
> 	overflow: auto;
> }
> .wikidifftexttitle {
> 	margin-top: 10px;
> 	font-weight: bold;
> 	color: #ffffff;
> 	padding: 10px;
> 	background-color: #ff0000;
> }
> 
> .diff-header       { 
> 	padding-top: 20px;
> 	font-weight: bold; 
> 	font-size: 12pt; 
> 	color: #000000; 
> 	padding-left: 5px; 
> 	padding-right: 5px; 
> 	width: 45%;
> 
> } 
> .diff-para-deleted { background: #ffb6c1 }   /* deleted complete paragraphs */
> .diff-para-added   { background: #98fb98 }  /* added complete paragraphs */
> .diff-para-ident   { background: White;  }                    /* unchanged complete paragraphs */
> .diff-para-changed { background: White;  }                    /* changed paragraphs */
> .diff-span-ident   { background: White;  }                    /* unchanged words in changed paragraphs */
> .diff-span-added   { background: #7cfc00 }  /* added words in changed paragraphs */
> .diff-span-deleted { background: #ff4500 }    /* deleted words in changed paragraphs */
> 
> .diff-para-ident,
> .diff-para-deleted,
> .diff-para-changed,
> .diff-para-added,
> .diff-span-added,
> .diff-span-ident,
> .diff-span-deleted {
> 	font-family: Courier, Monospace, Serif;
> }
> 
> .diff-para-ident,
> .diff-para-deleted,
> .diff-para-changed,
> .diff-para-added {
> 	padding: 5px;
> 	width: 50%;
> 	line-height: 1.5;
> 	border-top: 1px solid #eeeeee;
> 	border-right: 1px solid #cccccc;
> 	border-bottom: 1px solid #cccccc;
> 	border-left: 1px solid #eeeeee;
> }
> 
> .diff-para-ident {
> 	border: none;
> }
> 
> .diff-vertical {
> 	padding: 5px;
> }
> 
> .magic { padding: 10px; }
------
SandBox|1194211518
1,537c1,2
< /* The following is a sample CSS file for UseModWiki 1.0.
<    It is not pretty, but it demonstrates all of the new DIVs and
<    tag classes. */
< 
< .wikibutton {
< 	padding: 1px;
< }
< * { 
<  	font-family: Verdana, Arial, Sans-serif;
<  	line-height: 1.6em;
<  	font-size: 9pt;
< }
< 
< a {
< 	font-size: 9pt;
< }
< tt, code, pre {
< 	font-family: Courier, Serif;
< 	overflow: auto;
< }
< 
< code {
< 	color: #996666;
< 	padding: 5px;
< 	overflow:auto;
< }
< 
< pre {
< 	font-family: Courier, Serif;
< 	color: #666666;
< }
< 
< blockquote {
< 	font-family: Courier, Serif;
< 	color: #666666;
< 	margin-top: 5px;
< 	margin-bottom: 10px;
< 	padding-top: 10px;
< 	padding-left: 35px;
< 	padding-right: 35px;
< 	background: url("/img/blockquote.jpg") left top no-repeat;
< 	overflow: auto;
< 	_display: inline-block;
< }
< blockquote a:link {
< 	font-family: Courier, Serif;
< 	color: #333333;
< }
< 
< wikipreview blockquote {
< 	background: url("/img/blockquote.preview.jpg") left top no-repeat;	
< }
< body {
< 	background-image: url("/img/purple.stripe.gif");
< 	text-align: center; /* for IE */
< }
< 
< h1 { font-size: 18pt; }
< h2 { font-size: 16pt; }
< h3 { font-size: 14pt; }
< h4 { font-size: 12pt; }
< h5 { font-size: 11pt; }
< h6 { font-size: 10pt; }
< 
< h1 a{ font-size: 18pt; }
< h2 a{ font-size: 16pt; }
< h3 a{ font-size: 14pt; }
< h4 a{ font-size: 12pt; }
< h5 a{ font-size: 11pt; }
< h6 a{ font-size: 10pt; }
< 
< h1, h2, h3, h4, h5, h6 {
< 	font-weight: bold;
< 	overflow: auto;
< 	_display: inline-block;
< }
< 
< input[type="checkbox"]{
< 	margin-right: 10px;
< 	margin-bottom: 3px;
< }
< 
< .wikitext h1,
< .wikipreview h1 {
< 	font-weight: bold;
< 	color: #000000;
< 	border-bottom: 2px solid Orange;
< 	background-repeat: no-repeat;
< 	background-position: -10px -200px;
< }
< 
< .wikitext h2,
< .wikipreview h2 {
< 	border-bottom: 3px solid #cccccc;
< 	font-weight: bold;
< 	color: #000000;
< }
< .wikitext h3,
< .wikipreview h3 {
< 	border-bottom: 1px solid #cccccc;
< 	font-weight: bold;
< 	color: #000000;
< }
< .wikitext h4,
< .wikipreview h4 {
< 	font-weight: bold;
< 	padding-left: 10px;
< 	border-bottom: 1px solid #999999;
< 	color: #ffffff;
< 	background-color: #000000;
< }
< .wikitext h5,
< .wikipreview h5 {
< 	font-weight: bold;
< 	padding-left: 10px;
< 	border-bottom: 1px solid #999999;
< 	background-color: Red;
< 	color: #ffffff;
< }
< .wikitext h6,
< .wikipreview h6 {
< 	font-weight: bold;
< 	font-style: italics;
< 	margin-bottom: 0px;
< 	padding-left: 10px;
< 	color: #000000;
< 	background-color: #ff9900;
< }
< .wikitext {
< 	padding: 10px;
< 	padding-top: 10px;
< 	margin-left: 160px;
< 	margin-right: 5px;
< 	border-bottom: 1px solid #cccccc;
< 	border-left: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;
< 	background-color: #ffffff;
< 	
< 	white-space: pre-wrap; /* css-3 */
< 	white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */
< 	white-space: -pre-wrap; /* Opera 4-6 */
< 	white-space: -o-pre-wrap; /* Opera 7 */
< 	word-wrap: break-word; /* Internet Explorer 5.5+ */	
< }
< 
< .wikidiff {
< 	margin-left: -5px;
< }
< .wikiblurb {
< 	padding: 10px;	
< }
< .wikiadmin,
< .wikidiff {
< 	background-color: #ffffff;
< 	padding: 10px;
< 	overflow: auto;
< }
< .wikiadmin h2 {
< 	color: red;
< 	font-weight: bold;
< }
< .wikiadmin .wikiscriptlink:hover {
< 	color: red;
< }
< 
< .wikiadmin, .wikidiff {
< 	border-bottom: 1px solid #cccccc;
< 	border-left: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;	
< 	margin-right: 5px;
< }
< 
< p {
< 	padding-bottom: 5px;
< }
< 
< .wikitoc {
< 	border-top: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;
< 	border-bottom: 1px solid #cccccc;
< 	border-left: 1px solid #cccccc;
< 	width: 215px;
< 	padding: 5px;
< 	background-color: #f5f5f5;
< 	float: left;
< 	margin-right: 10px;
< 	margin-top: 0px;
< }
< .wikitoctitle {
< 	font-weight: bold;
< 	text-align: center;
< 	background-color: #000000;
< 	color: #ffffff;
< }
< .wikilockicon,
< .wikiediticon {
< 	height: 12px;
< 	width: 12px;
< 	margin-left: 3px;
< 	padding-right: 8px;
< 	position: relative;
< 	top: -10px;
< 	_top: -15px;
< 	background-repeat: no-repeat;
< 	background-image: url("/img/icon.edit.link.gif");
< 	overflow: hidden;
< }
< 
< .wikilockicon {
< 	background-image: url("/img/icon.locked.link.gif");	
< }
< 
< .wikilinkicon {
< 	height: 12px;
< 	width: 12px;
< 	margin-left: 3px;
< 	padding-right: 8px;
< 	position: relative;
< 	top: -4px;
< 	_top: -6px;
< 	background-repeat: no-repeat;
< 	background-image: url("/img/icon.question.red.gif");
< 	background-position: 0px 2px;
< 	_background-position: 0px 0px;
< 	overflow: hidden;
< }
< .wikisearch {
< 	padding-top: 10px;	
< }
< 
< .wikileftnavsearch {
< 	background-color: #cccccc;
< 	padding: 5px;
< 	margin-right: 5px;
< 	margin-top: -5px;
< 	border-bottom: 1px solid #999999;
< 	border-left: 1px solid #999999;
< 	border-right: 1px solid #999999;		
< }
< 
< .wikipreview {
< 	padding: 25px 10px 10px 10px;
< 	background-color : #eeeeee;
< 	border-left: 1px solid #cccccc;
< 	margin-left: 150px;
< }
< 
< #wikitextareabanlist {
< 	font-family: Courier, Serif;
< 	line-height: 1.2;
< }
< .wikiheader {
< 	padding-top: 125px;
< 	padding-left: 10px;
< 	padding-right: 10px;
< 	background-image: url("/img/wiki.header.jpg");
< 	background-repeat: repeat-x;
< }
< .wikiheader a:link,
< .wikiheader a:visited { 
< 	color: White; 
< 	text-decoration: none;
< }
< 
< .wikiheader h1 {
< 	color: White;
< }
< .wikifooter a:link,
< .wikifooter a:visited { 
< 	color: White; 
< 	text-decoration: none;
< }
< 
< .wikiheader a:hover,
< .wikifooter a:hover {
< 	text-decoration: underline;
< }
< 
< .wikiheader,
< .wikifooter {
< 	color: Yellow;
< }
< 
< 
< .wikilinediff {
< 	background-image: url("/img/gray.shadow.top.gif");
< 	background-repeat: repeat-x;
< 	height:12px;
< 	margin-bottom: 5px;
< }
< 
< ol, ul {
< 	margin-left: 25px;
< 	padding-top: 5px;
< 	padding-bottom: 10px;
< }
< 
< ul li {
< 	list-style-image: url("/img/bullet.fancy.gif");
< 	margin-bottom: 5px;
< }
< 
< 
< .wikifooter .wikigotobar {
< 	padding-bottom: 25px;
< 
< }
< 
< .wikifooter {
< 	padding-bottom: 25px;
< 	padding-left: 10px;
< 	padding-right: 10px;
< 	padding-top: 10px;
< 	background-image: url("/img/wiki.footer.jpg");
< 	_margin-top: -5px;
< }
< 
< .wikigotobar {
< 	font-weight: bold;
< }
< .wikilineheader {
< 	margin-top: 10px;
< 	background-image: url("/img/gray.shadow.top.gif");
< 	background-repeat: repeat-x;
<   	height : 16px;
< 	margin-left: -10px;
< 	margin-right: -10px;
< }
< 
< .wikilineheaderpreview {
< 	background-image: url("/img/gray.shadow.top.gif");
< 	background-repeat: repeat-x;
< 
<   	height : 16px;
< }
< .wikilinefooter {
< 	background-image: url("/img/gray.shadow.bottom.gif");
< 	background-repeat: repeat-x;
<   	height : 20px;
<   	_height: 25px;
<   	clear:both;
< }
< 
< .wikiline {
< 	background-color: #999999;
<   	height : 1px;
<   	margin-bottom: 5px;
<   	margin-top: 5px;
< }
< 
< .wikiline1 {
< 	border: 1px solid orange;
<   	height : 10px;
< }
< 
< .wikiline2 {
< 	border: 1px solid purple;
<   	height : 10px;
< }
< .wikilinepref {
<   	height : 20px;
< }
< a:link {
< 	color: Indigo;
< 	text-decoration: none;
< }
< a:hover {
< 	text-decoration: underline !important;
< }
< a:visited {
< 	color: Indigo;
< 	text-decoration: none;
< }
< .wikipagelink:link,
< .wikicreatepagelink:link {
< }
< 
< .wikipagelink:visited,
< .wikicreatepagelink:visited {
< 	text-decoration: none;
< }
< .wikicreatepagelink {
<  	background-color: #red;
< }
< .wikicreatepagelink:link {
< 	color: red;
< }
< 
< .wikipageedit:hover {
< 	color: red;
< }
< .wikidiffold {
< 	background-color : orange;
< }
< .wikidiffnew {
< 	background-color : Lightgreen;
< }
< 
< .wikirevision {
< 	
< }
< 
< .wikiurlorimage img,
< .wikibracketurl img,
< .wikiuploadlink img,
< .wikiuploadbar img,
< .wikilogo img,
< .wikiinterpage img,
< .wikiurlorimage img {
< 	padding: 3px;
< 	padding-bottom: 6px;
< 	background-color: #ffffff;
< 	border-top: 1px solid #eeeeee;
< 	border-left: 1px solid #eeeeee;
< 	border-bottom: 2px solid #cccccc;
< 	border-right: 2px solid #cccccc;
< }
< 
< .wikibracketbox {
< 	border: 1px solid #cccccc;
< 	background-color: #ffffff !important;
< 	overflow: auto;
< 	padding: 5px;
< }
< 
< .wikibracketbox img {
< 	border: none !important;
< }
< 
< .wikibracketboxtitle {
< 	font-weight: bold;
< 	font-size: 1.2em;
< 	color: #ffffff;
< 	background-color: #000000;
< 	padding: 3px;
< 	overflow: auto;
< 
< 
< }
< .imagefloatright, .imagefloatleft {
< 	margin-top: -15px !important;
< }
< 
< .image {
< 	margin-top: 5px;
< }
< 
< .wikibracketboxdescription {
< 	font-style: italic;
< 	background-color: #f5f5f5;
< 	padding: 3px;
< 	overflow: auto;
< }
< 
< .floatnone {
< 	float: none;
< }
< .floatleft {
< 	float: left;
< 	margin-right: 10px;
< 	margin-left: 0px;
< }
< .floatright {
< 	float: right;
< 	margin-right: 0px;
< 	margin-left: 10px;
< }
< .clearright {
< 	clear: right;
< }
< .clearleft {
< 	clear: left;
< }
< .clearboth {
< 	clear: both;
< }
< .clearnone {
< 	clear: none;
< }
< 
< .clearfix:after {
<     content: "."; 
<     _display: block; 
<     height: 0; 
<     clear: both; 
<     visibility: hidden;
< }
< 
< .clearfix {display: inline-block;}
< 
< /* Hides from IE-mac \*/
< * html .clearfix {height: 1%;}
< .clearfix {display: block;}
< /* End hide from IE-mac */
< 
< 
< p img {
< 	margin-top: -3px;
< }
< 
< 
< table.wikilargelist {
< 	border-top: 1px solid #aaaaaa;
< 	border-left: 1px solid #aaaaaa;
< 	border-bottom: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;
< 	background-color: #f5f5f5;	
< }
< 
< table.wikilargelist td {
< 	vertical-align: top;
< 	padding-left: 5px;
< 	padding-right: 5px;
< 	border-bottom: 1px solid #cccccc;
< 	border-right: 1px solid #cccccc;
< 	background-color: #f5f5f5;
< }
< 
< table.wikilargelist input {
< 	margin-top: 5px;
< }
< .wikipreview table.wikilargelist th,
< table.wikilargelist th {
< 	vertical-align: top;
< 	background-color: #cccccc;
< 	padding-top: 5px;
< 	padding-left: 5px;
< 	padding-right: 10px;
< 	border-right: 1px solid #999999;
< 	font-weight: bold;
< 	border-bottom: 1px solid #999999;
< }
< 
< .wikidiff li:hover,
< .wikihistory tr:hover {
<     background-color: #ffcc00;
< }
---
> ===== Edit me! =
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=oops|description=Sample Image|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
539,708c4,49
< .wikipreview table.wikilargelist th {
< 	vertical-align: top;
< 	background-color: #cccccc;
< }
< 
< table.wikilargelist {
< 	width: 75%;
< 	position: relative;
< 	margin-top: 10px;
< 	margin-bottom: 20px;
< }
< 
< .wikileftnav {
< 	width: 155px; 
< 	padding: 5px;
< 	float: left;
< }
< 
< .wikileftnav .wikileftnavbox {
< 	background-color: #ffffff;
< 	border-top: 1px solid #eeeeee;
< 	border-right: 1px solid #cccccc;
< 	border-bottom: 1px solid #cccccc;
< 	border-left: 1px solid #eeeeee;
< 	margin-right: 5px;
< 	_margin-right: -5px;
< 	margin-bottom: 10px;
< 	margin-top: -5px;
< }
< 
< tr > .first-column {
< 	width: 250px !important;
< }
< 
< /*CUSTOM DIV*/
< .warning {
< 	padding: 20px;
< 	font-size: 12px;
< 	background-color: yellow;
< }
< 
< /*STRUCTURE*/
< #wikibar {
< 	background-image: url("/img/gray.shadow.any.gif");
<   	height : 12px;
< }
< 
< #summarytext {
< 	width: 100%;
< 	margin-bottom: 10px;
< }
< 
< #anylogo {
< 	background-image: url("/img/npg.logo.jpg");
< 	background-repeat: no-repeat;
< 	float: right;
< 	position: relative;
< 	top: -42px;
< 	margin-left: 10px;
< 	margin-bottom: -30px;
< 	height: 54px;
< 	width: 42px;
< }
< 
< #wikicontainer {
< 	border-right: 2px solid #333333;
< 	border-bottom: 1px solid #000000;
< 	border-left: 2px solid #aaaaaa;
< 	width: 90%;
< 	margin: 0 auto;   /* align for good browsers */
< 	text-align: left; /* counter the body center */
< 	background-color: #f5f5f5;
< }
< 
< .wikipreviewtitle {
< 	padding: 5px;
< 	padding-left: 10px;
< 	color: #ffffff;
< 	background-color: #ff0000;
< 	font-weight: bold;
< }
< #wikieditbar {
< 	float:right;
< 	margin-right: 10px;
< 	padding: 5px;
< }
< #searchfield:hover {
< 	border: 1px solid black;
< }
< 
< #wikitextareatext {
< 	font-family: Courier, Monospaced, Serif;
< 	line-height: 1.2;
< }
< 
< /*FORMS*/
< #wikiform {
< 	padding: 10px;
< }
< 
< 
< /*perlDiff */
< #wikidifftable {
< 	width: 100.01%;	
< 	padding: 10px;
< }
< #wikidiffdiv {
< 	margin-bottom: 20px;
< 	width: 99%;
< 	overflow: auto;
< }
< .wikidifftexttitle {
< 	margin-top: 10px;
< 	font-weight: bold;
< 	color: #ffffff;
< 	padding: 10px;
< 	background-color: #ff0000;
< }
< 
< .diff-header       { 
< 	padding-top: 20px;
< 	font-weight: bold; 
< 	font-size: 12pt; 
< 	color: #000000; 
< 	padding-left: 5px; 
< 	padding-right: 5px; 
< 	width: 45%;
< 
< } 
< .diff-para-deleted { background: #ffb6c1 }   /* deleted complete paragraphs */
< .diff-para-added   { background: #98fb98 }  /* added complete paragraphs */
< .diff-para-ident   { background: White;  }                    /* unchanged complete paragraphs */
< .diff-para-changed { background: White;  }                    /* changed paragraphs */
< .diff-span-ident   { background: White;  }                    /* unchanged words in changed paragraphs */
< .diff-span-added   { background: #7cfc00 }  /* added words in changed paragraphs */
< .diff-span-deleted { background: #ff4500 }    /* deleted words in changed paragraphs */
< 
< .diff-para-ident,
< .diff-para-deleted,
< .diff-para-changed,
< .diff-para-added,
< .diff-span-added,
< .diff-span-ident,
< .diff-span-deleted {
< 	font-family: Courier, Monospace, Serif;
< }
< 
< .diff-para-ident,
< .diff-para-deleted,
< .diff-para-changed,
< .diff-para-added {
< 	padding: 5px;
< 	width: 50%;
< 	line-height: 1.5;
< 	border-top: 1px solid #eeeeee;
< 	border-right: 1px solid #cccccc;
< 	border-bottom: 1px solid #cccccc;
< 	border-left: 1px solid #eeeeee;
< }
< 
< .diff-para-ident {
< 	border: none;
< }
< 
< .diff-vertical {
< 	padding: 5px;
< }
< 
< .magic { padding: 10px; }
< .magic h4 { margin-top: 10px; }
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=right|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
> 
> [http://www.yahoo.com/ Some link goes here|title=Awesome news!|description=not relevant]
> 
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxfloat=left|description=very long description worthy of an Emmy. See more in the next line.  And also here and here and here.] 
> = Introduction =
> 
> ew other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revision
> 
> == Nations at War =
> There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America [ USA ], peered with Russia [ USSR ] and the United Kingdom Empire [ UK ].  On the opposing side are Germany, Japan, and Italy.
> 
> == Game Goal =
> Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating 
> Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
> 
> Objective Markers are also placed upon the battlefield as goals for acquisition during play which translate into victory points.  Victory points are also awarded for eliminating enemy units.  At the end of the game  usually 6 turns long  the player with the most points wins!
> 
> == The Operational Art of War =
> This game is a fanciful but detailed look at how to prosecute warfare at the operational level.  Unlike many such games that employ hundreds of unit counters to recreate such a simulation, this one focuses on the interaction of ten or twenty.  
> 
> === EPIC GAMES =
> Here are the key differences of operational level games when compared to tactical level games that deal with smaller units like men, squads, or platoons:
> 
> ==== Game Scale =
> This operational level game deals with units that are companies and battalions.  Theres about a thousand soldiers or one-hundred vehicles in a battalion.  Or, maybe it just contains 10 really humongous robots and their nervous human handlers.  
> 
> Operational level games are epic; with just a few units, these games simulate what would normally take hundreds of pieces in smaller scale games.  With this scale; battles can be waged over control of a city and its country-sides instead of just individual buildings or bridges.
> 
> ==== Zone-of-Control [ ZOC ] =
> Imagine reaching out your hands in front of you, and whirling about to cover your back.  You probably could cover about 3 feet in a radius around you; anybody coming within range would probably get smacked, or at least move cautiously by.  Now do this with a machine gun, with mortars, with cannons, with giant robot beam weapons.  And then, multiply that by several hundred or several thousand rounds of weapons fire by nearly as many soldiers or tanks covering several hundred meters all about.  Thats Zone-of-Control.
> 
> ==== Supply =
> In the scale of tactical level games, the firefights go pretty quickly; maybe five to twenty minutes pass in game-time depending on the scale of the simulation.  Ammo does run out, but probably not fuel.  You can always reload.  In operation level games, supply is critical.  Being in supply - within the distance of the supply truck convoys  can be the difference between having your units perforated, running for cover, or pressing the battle-line victoriously forward.
> 
> ==== Line-of-Command [ LOC ] =
> At the tactical level, the heroic commanders could probably shout orders to their equally heroic underlings, and maybe get some things done by all as a team.  It doesnt work that well with the units that are way across the hill, especially when each unit represents the average response of possibly hundreds of disorganized warriors awaiting instruction.  Without Line-of-Command, units will not be able to participate in the glory of taking down that mammoth tank or draw the line against the rogue sentinel robot together.
> 
> ==== Weather =
> Lastly, weather conditions become a grave concern for the force commanders in operational-level play.  At smaller scales, it may rain or snow for the duration of the battle.  Perhaps the mud conditions might prevail through-out.  However, at this larger scale; the mud may clear up as soon as day breaks.  The time to make an opportune strike can be seen just a few hours away; hold that battle-line until then!
> 
> ====== Related =
>  /WorldHistory
>  /RulesFAQ
>  /DesignNotes
>  /NewIdeas
------
WikiBugs|1194236284
4c4
< ||2007.10.14||[HomePage/RobertKurcina RobertKurcina]||List Orphans appears to list valid pages||OPEN||
---
> ||2007.10.14||[HomePage/RobertKurcina RobertKurcina]||List Orphans appears to list valid pages||FIXED-2007.11.02||
6a7
> ||2007.11.05||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||OPEN||
------
WikiBugs|1194236316
7c7
< ||2007.11.05||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||OPEN||
---
> ||2007.11.05||[HomePage/RobertKurcina RobertKurcina]||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||OPEN||
------
WikiBugs|1194236535
7c7
< ||2007.11.05||[HomePage/RobertKurcina RobertKurcina]||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||OPEN||
---
> ||2007.11.05||[HomePage/RobertKurcina RobertKurcina]||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||FIXED-2007.11.05||
------
WikiEditing|1194237823
55c55
< ====== # Related Entries =
---
> ====== Related Entries =
------
WikiImages|1194237847
86c86
< ====== # Related Entries =
---
> ====== Related Entries =
------
GRoWWII/TOandE|1194321760
93,94c93
< || ||Strategic Air||
<  
---
> || ||Strategic Air|| 
100,101c99
< || ||Technology||
<   
---
> || ||Technology||  
107,108c105
< || ||Medical||
<  
---
> || ||Medical|| 
------
SandBox|1194361689
5a6,7
> /AuthUsers
> 
------
SandBox/AuthUsers|1194361698
1c1
< Describe the new page here.
---
> RobertKurcina
------
SandBox/AuthUsers|1194362075
1d0
< RobertKurcina
2a2,5
> RobertKurcina
> RobertKurcina
> 
> 
------
SandBox/AuthUsers|1194362368
0a1,3
> <RobertKurcina>
> [RobertKurcina]
> 
2,5d4
< RobertKurcina
< RobertKurcina
< 
< 
------
SandBox/AuthUsers|1194362733
1,2c1,3
< <RobertKurcina>
< [RobertKurcina]
---
>  <RobertKurcina>
>  [RobertKurcina]
>  RalphMorgan
------
SandBox/AuthUsers|1194411859
1,4c1
<  <RobertKurcina>
<  [RobertKurcina]
<  RalphMorgan
< 
---
> > RobertKurcina
------
SandBox/AuthUsers|1194412098
1c1
< > RobertKurcina
---
> ==LisaMorgan
------
SandBox/AuthUsers|1194412137
1c1
< > RobertKurcina
---
> ==AlsBmg
------
SandBox/AuthUsers|1194412205
1c1
< ==AlsBmg
---
>  {RohnerPark}
------
SandBox/AuthUsers|1194412287
1c1
< Describe the new page here.
---
> {RymHouse}
------
SandBox/AuthUsers|1194412327
1a2
> {LordVain}
------
ErrorAuthorization|1194413712
1c1,2
< Describe the new page here.
---
> ===== ERROR! Authorization =
> You have no permissions to edit this page.
------
ErrorAuthorization|1194413723
------
ErrorAuthorization|1194413794
3c3
< You have no permissions to edit this page.
---
> You have no permissions to access this page.
------
SandBox/AuthUsers|1194415570
1,2d0
< {RymHouse}
< {LordVain}
3a2
> 
------
TourBusStop|1194448383
1c1
< Describe the new page here.
---
> #REDIRECT NobleWiki
------
NobleWiki|1194448792
51a51,52
> ||UseMod:WikiPatches/PrivateUserGroups||Modified from original.  Each user name must be on it's own line and surrounded by curly braces like <tt><nowiki>{UserName}</nowiki></tt>||
> 
53,55c54,55
< ||UseMod:WikiPatches/PrivateUserGroups width=300||want, not sure about how authors work||
< ||UseMod:WikiPatches/EmbeddedBacklinks||want||
< ||UseMod:WikiPatches/NoAnonyms||need, unsure because not sure about how authors work||
---
> ||UseMod:WikiPatches/EmbeddedBacklinks width=300||want||
> ||UseMod:WikiPatches/NoAnonyms||need; should prevent spammers|
------
NobleWiki|1194448843
55c55
< ||UseMod:WikiPatches/NoAnonyms||need; should prevent spammers|
---
> ||UseMod:WikiPatches/NoAnonyms||need; should prevent spammers||
------
GRoWWII|1194449147
41a42
>  /Acknowledgments
------
GRoWWII|1194487618
1c1,2
< = Giant Robots of World War II =
---
> <toc 225>
> = # Giant Robots of World War II =
4c5
< == Nations at War =
---
> == # Nations at War =
7c8
< == Game Goal =
---
> == # Game Goal =
13c14
< == The Operational Art of War =
---
> == # The Operational Art of War =
16c17
< === EPIC GAMES =
---
> === # EPIC GAMES =
19c20
< ==== Game Scale =
---
> ==== # Game Scale =
24c25
< ==== Zone-of-Control [ ZOC ] =
---
> ==== # Zone-of-Control [ ZOC ] =
27c28
< ==== Supply =
---
> ==== # Supply =
30c31
< ==== Line-of-Command [ LOC ] =
---
> ==== # Line-of-Command [ LOC ] =
33c34
< ==== Weather =
---
> ==== # Weather =
------
SandBox/AuthUsers|1194495511
0a1,2
> {r:RobertKurcina}
> {e:RalphMorgan}
2d3
< 
------
SandBox/AuthUsers|1194496579
1,2c1,2
< {r:RobertKurcina}
< {e:RalphMorgan}
---
>  {r:RobertKurcina}
>  {e:RalphMorgan}
------
SandBox/AuthUsers|1194496714
1,2d0
<  {r:RobertKurcina}
<  {e:RalphMorgan}
3a2,4
> {r:RobertKurcina}
> {e:FredWilma}
> 
------
SandBox/AuthUsers|1194496813
0a1,2
> {RobertKurcina}
> {FredWilma}
2,4d3
< {r:RobertKurcina}
< {e:FredWilma}
< 
------
SandBox/AuthUsers|1194496838
1,2c1,2
< {RobertKurcina}
< {FredWilma}
---
>  {RobertKurcina}
>  {FredWilma}
------
SandBox/AuthUsers|1194496964
1,2c1,2
<  {RobertKurcina}
<  {FredWilma}
---
>  {r:RobertKurcina}
>  {e:FredWilma}
------
SandBox/AuthUsers|1194497022
1,2c1,2
<  {r:RobertKurcina}
<  {e:FredWilma}
---
> {r:RobertKurcina}
> {e:FredWilma}
------
GRoWWII/RulesFAQ|1194497155
1a2
> Temp
------
SandBox/AuthUsers|1194497171
1d0
< {r:RobertKurcina}
------
SandBox/AuthUsers|1194497705
1c1,2
< {e:FredWilma}
---
> {r:FredWilma}
> {e:RobertKurcina}
------
SandBox/AuthUsers|1194500785
1,2c1,3
< {r:FredWilma}
< {e:RobertKurcina}
---
> {e:FredWilma}
> {e:DingleBerry}
> {r:SomebodyElse}
------
SandBox|1194501395
8,51d6
< [http://www.yahoo.com/ Some link goes here|title=Awesome news!|description=not relevant]
< 
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxfloat=left|description=very long description worthy of an Emmy. See more in the next line.  And also here and here and here.] 
< = Introduction =
< 
< ew other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revision
< 
< == Nations at War =
< There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America [ USA ], peered with Russia [ USSR ] and the United Kingdom Empire [ UK ].  On the opposing side are Germany, Japan, and Italy.
< 
< == Game Goal =
< Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating 
< Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
< 
< Objective Markers are also placed upon the battlefield as goals for acquisition during play which translate into victory points.  Victory points are also awarded for eliminating enemy units.  At the end of the game  usually 6 turns long  the player with the most points wins!
< 
< == The Operational Art of War =
< This game is a fanciful but detailed look at how to prosecute warfare at the operational level.  Unlike many such games that employ hundreds of unit counters to recreate such a simulation, this one focuses on the interaction of ten or twenty.  
< 
< === EPIC GAMES =
< Here are the key differences of operational level games when compared to tactical level games that deal with smaller units like men, squads, or platoons:
< 
< ==== Game Scale =
< This operational level game deals with units that are companies and battalions.  Theres about a thousand soldiers or one-hundred vehicles in a battalion.  Or, maybe it just contains 10 really humongous robots and their nervous human handlers.  
< 
< Operational level games are epic; with just a few units, these games simulate what would normally take hundreds of pieces in smaller scale games.  With this scale; battles can be waged over control of a city and its country-sides instead of just individual buildings or bridges.
< 
< ==== Zone-of-Control [ ZOC ] =
< Imagine reaching out your hands in front of you, and whirling about to cover your back.  You probably could cover about 3 feet in a radius around you; anybody coming within range would probably get smacked, or at least move cautiously by.  Now do this with a machine gun, with mortars, with cannons, with giant robot beam weapons.  And then, multiply that by several hundred or several thousand rounds of weapons fire by nearly as many soldiers or tanks covering several hundred meters all about.  Thats Zone-of-Control.
< 
< ==== Supply =
< In the scale of tactical level games, the firefights go pretty quickly; maybe five to twenty minutes pass in game-time depending on the scale of the simulation.  Ammo does run out, but probably not fuel.  You can always reload.  In operation level games, supply is critical.  Being in supply - within the distance of the supply truck convoys  can be the difference between having your units perforated, running for cover, or pressing the battle-line victoriously forward.
< 
< ==== Line-of-Command [ LOC ] =
< At the tactical level, the heroic commanders could probably shout orders to their equally heroic underlings, and maybe get some things done by all as a team.  It doesnt work that well with the units that are way across the hill, especially when each unit represents the average response of possibly hundreds of disorganized warriors awaiting instruction.  Without Line-of-Command, units will not be able to participate in the glory of taking down that mammoth tank or draw the line against the rogue sentinel robot together.
< 
< ==== Weather =
< Lastly, weather conditions become a grave concern for the force commanders in operational-level play.  At smaller scales, it may rain or snow for the duration of the battle.  Perhaps the mud conditions might prevail through-out.  However, at this larger scale; the mud may clear up as soon as day breaks.  The time to make an opportune strike can be seen just a few hours away; hold that battle-line until then!
< 
< ====== Related =
<  /WorldHistory
<  /RulesFAQ
<  /DesignNotes
<  /NewIdeas
------
SandBox/AuthUsers|1194501654
2,3c2
< {e:DingleBerry}
< {r:SomebodyElse}
---
> {r:DingleBerry}
------
SandBox/AuthUsers|1194582703
1,2d0
< {e:FredWilma}
< {r:DingleBerry}
3a2
> 
------
NobleWiki|1194582775
51c51
< ||UseMod:WikiPatches/PrivateUserGroups||Modified from original.  Each user name must be on it's own line and surrounded by curly braces like <tt><nowiki>{UserName}</nowiki></tt>||
---
> ||UseMod:WikiPatches/PrivateUserGroups||Modified from original.  Each user name must be on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName} or {r:UserName}</nowiki></tt> to indicate can edit or can read.  Otherwise an Authrization Error page will appear [ AuthError ]||
------
NobleWiki|1194582846
19c19
< ||Left Navigation||Created 2-column layout with left navigation.  This HTML content is set by the value of <tt><nowiki>$WikiLeftNavigation</nowiki></tt>||
---
> ||Left Navigation||Created 2-column layout with left navigation. Subroutine added <tt><nowiki>GetLeftNav()</nowiki></tt>.||
------
NobleWiki|1194583004
79a79,81
> ||<tt><nowiki>{{columns|color}}</nowiki></tt>||Sort of like the version use on en.wikipedia.org; specify that content following appears in one, two, or three columns.||
> ||<tt><nowiki>TOC Modification</nowiki></tt>||Allow just a single Table of Contents, and have it create entries based upon headers, numbered or otherwise.||
> 
------
TemplateHomePage|1194583240
4c4,5
< || Image || $UPLOADIMAGE$ ||
---
> || Image || 
> $UPLOADIMAGE$ ||
------
TemplateHomePage|1194583265
4,5c4
< || Image || 
< $UPLOADIMAGE$ ||
---
> || Image || $UPLOADIMAGE$ ||
------
HomePage/RobertKurcina|1194583327
2c2
< UPLOADIMAGE =  [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg]
---
> UPLOADIMAGE =  [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg|float=left|clear=both]
------
HomePage/RobertKurcina|1194583368
2c2
< UPLOADIMAGE =  [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg|float=left|clear=both]
---
> UPLOADIMAGE =  [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg|float=none|clear=both]
------
HomePage/RalphMorgan|1194583398
2c2
< UPLOADIMAGE = [LocalWiki:HomePage upload:homepage-RalphMorgan.jpg]
---
> UPLOADIMAGE = [LocalWiki:HomePage upload:homepage-RalphMorgan.jpg|clear=both]]
------
HomePage/RobertKurcina|1194583551
4c4
< SKILLS = Software Development [ Design, Documentation, Coding ], Programming Languages [ Java, Javascript, Actionscript, perl, C/C++, VBA ], Illustration [ Pen&Ink, Layout, Digital 2D, Digital 3D], Game Design [ Boardgames, Role-playing Games, Flash, AI/AL ], Writing [ Technical, Storycraft ], Digital Media [ Photoshop, Illustrator, Freehand, MS-Office ]
---
> SKILLS = Software Development, Illustration, Design, Writing
6c6
< QUOTE = Work harder <i>and</i> work smarter
---
> QUOTE = Work harder and work smarter
------
TemplateHomePage|1194583596
3,4c3,4
< !! Name !! <b>$NAME$</b> !!
< || Image || $UPLOADIMAGE$ ||
---
> !! Name !!<b>$NAME$</b> !!
> || Image ||$UPLOADIMAGE$ ||
7c7
< || Quote|| $QUOTE$ ||
---
> || Quote||$QUOTE$ ||
------
TemplateHomePage|1194583669
3,8c3,8
< !! Name !!<b>$NAME$</b> !!
< || Image ||$UPLOADIMAGE$ ||
< || Skills ||$SKILLS$ ||
< || Interests ||$INTERESTS$ ||
< || Quote||$QUOTE$ ||
< || Web site ||$WEBSITEURL$ ||
---
> !!  <b>Name</b>!!<b>$NAME$</b> !!
> ||  <b>Image</b>||$UPLOADIMAGE$ ||
> ||  <b>Skills</b>||$SKILLS$ ||
> ||  <b>Interests</b>||$INTERESTS$ ||
> ||  <b>Quote</b>||$QUOTE$ ||
> ||  <b>Web site</b>||$WEBSITEURL$ ||
------
TemplateHomePage|1194583788
3c3,4
< !!  <b>Name</b>!!<b>$NAME$</b> !!
---
> !! Information for $NAME$ ||||
> ||  <b>Name</b>||<b>$NAME$</b> ||
------
TemplateHomePage|1194583841
3,4c3
< !! Information for $NAME$ ||||
< ||  <b>Name</b>||<b>$NAME$</b> ||
---
> !!!! Information for $NAME$!!
------
GRoWWII|1194674827
5,6c5
< == # Nations at War =
< There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America [ USA ], peered with Russia [ USSR ] and the United Kingdom Empire [ UK ].  On the opposing side are Germany, Japan, and Italy.
---
> [LocalWiki:HomePage upload:nations.at.war.jpg|boxwidth=550|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
------
GRoWWII|1194675364
5c5
< [LocalWiki:HomePage upload:nations.at.war.jpg|boxwidth=550|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
---
> [LocalWiki:upload:nations.at.war.jpg upload:nations.at.war.jpg|boxwidth=550|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
------
GRoWWII|1194726630
5c5
< [LocalWiki:upload:nations.at.war.jpg upload:nations.at.war.jpg|boxwidth=550|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
---
> [LocalWiki:upload:nations.at.war.jpg upload:nations.at.war.jpg|width=400|boxwidth=410|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
------
WikiImages|1194726737
54a55,56
> ||<tt>width=NNN</tt>||Resizes the image to this width.  Works in conjunction with height; the most sensible version prevails in that no resize may create an image larger than the source||
> ||<tt>height=NNN</tt>||Resizes the image to this height.  Works in conjunction with width; the most sensible version prevails in that no resize may create an image larger than the source||
------
GRoWWII/TOandE|1194733308
252,282c252,279
< 12th Army Group [ ~5000 OP and about 100 divisions ]
< 
<  3rd United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   9th Armored Corps
<   10th Armored Corps
<   Marine Corps
<   Robot Corps
<   
<  9th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   4th Assault Corps
<   Assault Wing Corps
<   11th Armored Corps
<   14th Armored Corps
<   
<  12th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   1st Assault Corps
<   2nd Assault Corps
<   17th Armored Corps
<   Auxiliary Corps
<   
<  18th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   8th Armored Corps
<   15th Armored Corps
<   Strategic Air Corps
<   3rd Assault Corps
<   
<  49th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]
<   3rd Armored Corps
<   6th Armored Corps
<   Expeditionary Corps
<   Guardian Corps
---
> This is an example of an Army Group.  An Army group contains 4-6 Armies totaling about 100 divisions or 5000 OP. At this level, the Army Group can contain armies belonging to other nations.  Any Army Group is commanded by a 6-star Leader with a subordinate 5-star Leader for each Army beneath.
> 
> !!!!12th Army Group!!
> !!width=20!!3rd United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
> || ||9th Armored Corps||
> || ||10th Armored Corps||
> || ||Marine Corps||
> || ||Robot Corps||  
> !! !!9th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
> || ||4th Assault Corps||
> || ||Assault Wing Corps||
> || ||11th Armored Corps||
> || ||14th Armored Corps||  
> !! !!12th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
> || ||1st Assault Corps||
> || ||2nd Assault Corps||
> || ||17th Armored Corps||
> || ||Auxiliary Corps||  
> !! !!18th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
> || ||8th Armored Corps||
> || ||15th Armored Corps||
> || ||Strategic Air Corps||
> || ||3rd Assault Corps||  
> !! !!49th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
> || ||3rd Armored Corps||
> || ||6th Armored Corps||
> || ||Expeditionary Corps||
> || ||Guardian Corps||
286,320c283,313
< Supreme Headquarters Allied Expeditionary Forces (SHAEF) [ ~100 K OP and 2000 divisions ]
< 
<  European Theater Operations Group [ ~20K OP and 500 divisions ]
<   1st Army Group 
<   3rd Army Group 
<   12th Army Group 
<   17th Army Group
<   22nd Army Group
<   
<  Mediterranean Theater Operations Group [ ~20K OP and 500 divisions ]
<   2nd Army Group 
<   5th Army Group 
<   6th Army Group 
<   21st Army Group 
<    
<  Pacific Theater Operations Group [ ~20K OP and 500 divisions ]
<   4th Army Group 
<   7th Army Group
<   9th Army Group 
<   17th Army Group 
<   19th Army Group 
<   23rd Army Group
<  
<  Atlantic Theater Operations Group [ ~20K OP and 500 divisions ]
<   8th Army Group 
<   11th Army Group 
<   14th Army Group 
<  
<  Asiatic Theater Operations Group [ ~20K OP and 500 divisions ]
<   10th Army Group 
<   13th Army Group 
<   15th Army Group 
<   16th Army Group 
<   20th Army Group 
< 	
---
> The Allies have a single Supreme Forces structure that encompasses all of the allied nations.  This is led by an 8-star Leader with subordinate 7-star Leaders at a rate of one per Operations Theater reporting.  The total for each Supreme Force is about 2000 divisions or roughly 100,000 OP.
> 
> !!!!Supreme Headquarters Allied Expeditionary Forces (SHAEF)!!
> !!width=20!!European Theater Operations Group [ ~20K OP and 500 divisions ]!!
> || ||1st Army Group||
> || ||3rd Army Group||
> || ||12th Army Group||
> || ||17th Army Group||
> || ||22nd Army Group||
> !! !!Mediterranean Theater Operations Group [ ~20K OP and 500 divisions ]!!
> || ||2nd Army Group||
> || ||5th Army Group||
> || ||6th Army Group||
> || ||21st Army Group||
> !! !!Pacific Theater Operations Group [ ~20K OP and 500 divisions ]!!
> || ||4th Army Group||
> || ||7th Army Group||
> || ||9th Army Group||
> || ||17th Army Group||
> || ||19th Army Group||
> || ||23rd Army Group||
> !! !!Atlantic Theater Operations Group [ ~20K OP and 500 divisions ]!!
> || ||8th Army Group||
> || ||11th Army Group||
> || ||14th Army Group||
> !! !!Asiatic Theater Operations Group [ ~20K OP and 500 divisions ]!!
> || ||10th Army Group||
> || ||13th Army Group||
> || ||15th Army Group||
> || ||16th Army Group|| 
> || ||20th Army Group||
------
GRoWWII/TOandE|1194734321
152,204c152,203
< !!Light Infantry Regiment width=250!! [ 23 OP ] !!
< ||INF / Biluxi Regulars||[ 5 OP ]||
< ||INF / Biluxi Regulars||[ 5 OP ]||
< ||INF / Biluxi Regulars||[ 5 OP ]||
< ||INF / Sectarian Troopers||[ 8 OP ]||
< 
< !!Heavy Infantry Regiment width=250!! [ 27 OP ] !!
< ||INF / Sectarian Troopers||[ 8 OP ]||
< ||INF / Raven Battle Armor||[ 9 OP ]||
< ||INF / Biluxi Regulars||[ 5 OP ]||
< ||INF / Biluxi Regulars||[ 5 OP ]||
< 
< !!Advanced Infantry Regiment width=250!! [ 40 OP ]!!
< ||INF / Raven Battle Armor||[ 9 OP ]||
< ||INF / Feldman AT-88 Walkers||[ 8 OP ]||
< ||RBT / Orum Slaughterbots||[ 17 OP ]||
< ||WNG / Carver Recon||[ 6 OP ]||
< 
< !!Robotic Assault Regiment width=250!! [ 82 OP ]!!
< ||RBT / Orum Slaughter Bots||[ 17 OP ]||
< ||RBT / Orum Slaughter Bots||[ 17 OP ]||
< ||RBT / Halen Assault Ballistar||[ 34 OP ]||
< ||WPN / Garfield Rocket Platform||[ 14 OP ]||
< 
< !!Vanguard Infantry Regiment width=250!! [ 46 OP ]!!
< ||INF / Nabilum Rocketeers||[ 11 OP ]||
< ||INF / Nabilum Rocketeers||[ 11 OP ]||
< ||INF / Heavy Marines||[ 10 OP ]||
< ||WPN / Kennision Heavy Weapons||[ 14 OP ]||
< 
< !!Artillery Support Regiment width=250!! [ 37 OP ]!!
< ||BAT / Machron Field Artillery||[ 12 OP ]||
< ||BAT / Macrhon Field Artillery||[ 12 OP ]||
< ||BAT / Paulson Anti-air||[ 9 OP ]||
< ||WNG / Carver Recon||[ 5 OP ]||
< 
< !!Field Infantry Regiment width=250!! [ 27 OP ]!!
< ||INF / Biluxi Regulars||[ 5 OP ]||
< ||INF / Biluxi Regulars||[ 5 OP ]||
< ||INF / Heavy Marines||[ 10 OP ]||
< ||SUP / Newcomb Field Support||[ 7 OP ]||
< 
< !!Division Support Regiment width=250!! [ 33 OP ]!!
< ||HQ / FSN Command Center||[ 10 OP ]||
< ||HQ / FSN Command Center||[ 10 OP ]||
< ||SUP / FSN Support Battalion||[ 8 OP ]||
< ||SGN / Ground Hog Signals Battalion||[ 5 OP ]||
< 
< !!Armored Assault Regiment width=250!! [ 78 OP ]!!
< ||CAV / Nevadan Light Tanks||[ 17 OP ]||
< ||CAV / Nevadan Light Tanks||[ 17 OP ]||
< ||CAV / M6A4 Heavy Tanks||[ 30 OP ]||
< ||WNG / Ferguson Bombardier||[ 14 OP ]||
---
> Regiments are 4 battalions.  Usually one or two of the battalions of the four are unique or specialized.  For example, 3 of the battalions could be combat-oriented and the third would be a support unit.  This sort of variety ensures that the regiment is robust enough for incorporation into the larger division formations.  Regiments are lead by a 1-star Leader.  The total Operational Points [ OP ] value of a regiment can vary greatly; ranging from 20 OP for the typical infantry regiment to over 100 OP for a heavy armored assault regiment as the one shown below.
> 
> !!!!Light Infantry Regiment width=250!! [ 23 OP ] !!
> ||INF width=30||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Sectarian Troopers||[ 8 OP ]||
> !!!!Heavy Infantry Regiment!! [ 27 OP ] !!
> ||INF||Sectarian Troopers||[ 8 OP ]||
> ||INF||Raven Battle Armor||[ 9 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> !!!!Advanced Infantry Regiment!! [ 40 OP ]!!
> ||INF||Raven Battle Armor||[ 9 OP ]||
> ||INF||Feldman AT-88 Walkers||[ 8 OP ]||
> ||RBT||Orum Slaughterbots||[ 17 OP ]||
> ||WNG||Carver Recon||[ 6 OP ]||
> !!!!Robotic Assault Regiment!! [ 82 OP ]!!
> ||RBT||Orum Slaughter Bots||[ 17 OP ]||
> ||RBT||Orum Slaughter Bots||[ 17 OP ]||
> ||RBT||Halen Assault Ballistar||[ 34 OP ]||
> ||WPN||Garfield Rocket Platform||[ 14 OP ]||
> !!!!Vanguard Infantry Regiment!! [ 46 OP ]!!
> ||INF||Nabilum Rocketeers||[ 11 OP ]||
> ||INF||Nabilum Rocketeers||[ 11 OP ]||
> ||INF||Heavy Marines||[ 10 OP ]||
> ||WPN||Kennision Heavy Weapons||[ 14 OP ]||
> !!!!Artillery Support Regiment!! [ 37 OP ]!!
> ||BAT||Machron Field Artillery||[ 12 OP ]||
> ||BAT||Machron Field Artillery||[ 12 OP ]||
> ||BAT||Paulson Anti-air||[ 9 OP ]||
> ||WNG||Carver Recon||[ 5 OP ]||
> !!!!Field Infantry Regiment!! [ 27 OP ]!!
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Biluxi Regulars||[ 5 OP ]||
> ||INF||Heavy Marines||[ 10 OP ]||
> ||SUP||Newcomb Field Support||[ 7 OP ]||
> !!!!Division Support Regiment!! [ 33 OP ]!!
> ||HQ||FSN Command Center||[ 10 OP ]||
> ||HQ||FSN Command Center||[ 10 OP ]||
> ||SUP||FSN Support Battalion||[ 8 OP ]||
> ||SGN||Ground Hog Signals Battalion||[ 5 OP ]||
> !!!!Armored Assault Regiment!! [ 78 OP ]!!
> ||CAV||Nevadan Light Tanks||[ 17 OP ]||
> ||CAV||Nevadan Light Tanks||[ 17 OP ]||
> ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
> ||WNG||Ferguson Bombardier||[ 14 OP ]||
> !!!!Heavy Armored Assault Regiment!! [ 104 OP ]!!
> ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
> ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
> ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
> ||WNG||Ferguson Bombardier||[ 14 OP ]||
207,209c206,208
<  Divisions of the 10th Armored Corps [ 983 OP ] Leaders 20* | 8** | 3*** | 1****
< 
<  2nd Mechanized Division [ NOTE ][ 239 OP ]     4    2  1  1
---
>  Divisions of the 10th Armored Corps [ 983 OP ] Leaders 20* | 9** | 3*** | 1****
> 
>  2nd Mechanized Assault Division [ NOTE ][ 251 OP ]     4    3  1  1
211c210
<   Robotic Assault Regiment   [ 82 OP ]
---
>   Heavy Armored Assault Regiment [ 104 OP ]
------
GRoWWII/TOandE|1194734494
1,2c1,2
< <toc 280>
< == # Table of Organization and Equipment =
---
> <toc 200>
> = Table of Organization and Equipment =
7,8c7,8
< === # Construction =
< Historically, the US used square elements while the European forces used triangular elements.  That means; 2 battalions forms 1 regiment, and then 2 regiments for 1 brigade, and 2 brigades form 1 divisin.  Etc.  In the world of GROWWII, things are quadratic because of the increased numbers of available soldiers and equipment. In addition there's an assumption that well-balanced forces will be constructed with an average of 1 support unit [ HQ, Supply, Signals ] for every 4 or so combat units.
---
> == Construction =
> Historically, the US used square elements while the European forces used triangular elements.  That means; 2 battalions forms 1 regiment, and then 2 regiments for 1 brigade, and 2 brigades form 1 division.  Etc.  In the world of GROWWII, things are quadratic because of the increased numbers of available soldiers and equipment. In addition there's an assumption that well-balanced forces will be constructed with an average of 1 support unit [ HQ, Supply, Signals ] for every 4 or so combat units.
14c14
< === # Orders of Battle =
---
> == Orders of Battle =
17c17
< ==== # Simple OOB =
---
> === Simple OOB =
20c20
< ==== # Mixed OOB =
---
> === Mixed OOB =
47c47
< ==== # Complete OOB =		
---
> === Complete OOB =		
82c82
< === # Corps Organization Roles =
---
> == Corps Organization Roles =
116c116
< === # Pseudo-historical Details =
---
> == Pseudo-historical Details =
122c122
< ==== # Allohistorical LADs =
---
> === Allohistorical LADs =
125c125
< === # Leader Assignment =
---
> == Leader Assignment =
145c145
< === # Decorated Units =
---
> == Decorated Units =
148c148
< === # Sample TOEs =
---
> == Sample TOEs =
151c151
< ==== # Regimental TOEs =
---
> === Regimental TOEs =
205c205
< ==== # Corps Organization =
---
> === Corps Organization =
250c250
< ==== # Army Group =
---
> === Army Group =
280,281c280
<  
< ==== # Supreme Forces =
---
> === Supreme Forces =
------
GRoWWII/TOandE|1194736010
154,203c154,203
< !!!!Light Infantry Regiment width=250!! [ 23 OP ] !!
< ||INF width=30||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Sectarian Troopers||[ 8 OP ]||
< !!!!Heavy Infantry Regiment!! [ 27 OP ] !!
< ||INF||Sectarian Troopers||[ 8 OP ]||
< ||INF||Raven Battle Armor||[ 9 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< !!!!Advanced Infantry Regiment!! [ 40 OP ]!!
< ||INF||Raven Battle Armor||[ 9 OP ]||
< ||INF||Feldman AT-88 Walkers||[ 8 OP ]||
< ||RBT||Orum Slaughterbots||[ 17 OP ]||
< ||WNG||Carver Recon||[ 6 OP ]||
< !!!!Robotic Assault Regiment!! [ 82 OP ]!!
< ||RBT||Orum Slaughter Bots||[ 17 OP ]||
< ||RBT||Orum Slaughter Bots||[ 17 OP ]||
< ||RBT||Halen Assault Ballistar||[ 34 OP ]||
< ||WPN||Garfield Rocket Platform||[ 14 OP ]||
< !!!!Vanguard Infantry Regiment!! [ 46 OP ]!!
< ||INF||Nabilum Rocketeers||[ 11 OP ]||
< ||INF||Nabilum Rocketeers||[ 11 OP ]||
< ||INF||Heavy Marines||[ 10 OP ]||
< ||WPN||Kennision Heavy Weapons||[ 14 OP ]||
< !!!!Artillery Support Regiment!! [ 37 OP ]!!
< ||BAT||Machron Field Artillery||[ 12 OP ]||
< ||BAT||Machron Field Artillery||[ 12 OP ]||
< ||BAT||Paulson Anti-air||[ 9 OP ]||
< ||WNG||Carver Recon||[ 5 OP ]||
< !!!!Field Infantry Regiment!! [ 27 OP ]!!
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Biluxi Regulars||[ 5 OP ]||
< ||INF||Heavy Marines||[ 10 OP ]||
< ||SUP||Newcomb Field Support||[ 7 OP ]||
< !!!!Division Support Regiment!! [ 33 OP ]!!
< ||HQ||FSN Command Center||[ 10 OP ]||
< ||HQ||FSN Command Center||[ 10 OP ]||
< ||SUP||FSN Support Battalion||[ 8 OP ]||
< ||SGN||Ground Hog Signals Battalion||[ 5 OP ]||
< !!!!Armored Assault Regiment!! [ 78 OP ]!!
< ||CAV||Nevadan Light Tanks||[ 17 OP ]||
< ||CAV||Nevadan Light Tanks||[ 17 OP ]||
< ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
< ||WNG||Ferguson Bombardier||[ 14 OP ]||
< !!!!Heavy Armored Assault Regiment!! [ 104 OP ]!!
< ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
< ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
< ||CAV||M6A4 Heavy Tanks||[ 30 OP ]||
< ||WNG||Ferguson Bombardier||[ 14 OP ]||
---
> !!!!Light Infantry Regiment width=250!! 23 OP !!
> ||INF width=30||Biluxi Regulars||5 OP||
> ||INF||Biluxi Regulars||5 OP||
> ||INF||Biluxi Regulars||5 OP||
> ||INF||Sectarian Troopers||8 OP||
> !!!!Heavy Infantry Regiment!! 27 OP !!
> ||INF||Sectarian Troopers||8 OP||
> ||INF||Raven Battle Armor||9 OP||
> ||INF||Biluxi Regulars||5 OP||
> ||INF||Biluxi Regulars||5 OP||
> !!!!Advanced Infantry Regiment!! 40 OP!!
> ||INF||Raven Battle Armor||9 OP||
> ||INF||Feldman AT-88 Walkers||8 OP||
> ||RBT||Orum Slaughterbots||17 OP||
> ||WNG||Carver Recon||6 OP||
> !!!!Robotic Assault Regiment!! 82 OP!!
> ||RBT||Orum Slaughter Bots||17 OP||
> ||RBT||Orum Slaughter Bots||17 OP||
> ||RBT||Halen Assault Ballistar||34 OP||
> ||WPN||Garfield Rocket Platform||14 OP||
> !!!!Vanguard Infantry Regiment!! 46 OP!!
> ||INF||Nabilum Rocketeers||11 OP||
> ||INF||Nabilum Rocketeers||11 OP||
> ||INF||Heavy Marines||10 OP||
> ||WPN||Kennision Heavy Weapons||14 OP||
> !!!!Artillery Support Regiment!! 37 OP!!
> ||BAT||Machron Field Artillery||12 OP||
> ||BAT||Machron Field Artillery||12 OP||
> ||BAT||Paulson Anti-air||9 OP||
> ||WNG||Carver Recon||5 OP||
> !!!!Field Infantry Regiment!! 27 OP!!
> ||INF||Biluxi Regulars||5 OP||
> ||INF||Biluxi Regulars||5 OP||
> ||INF||Heavy Marines||10 OP||
> ||SUP||Newcomb Field Support||7 OP||
> !!!!Division Support Regiment!! 33 OP!!
> ||HQ||FSN Command Center||10 OP||
> ||HQ||FSN Command Center||10 OP||
> ||SUP||FSN Support Battalion||8 OP||
> ||SGN||Ground Hog Signals Battalion||5 OP||
> !!!!Armored Assault Regiment!! 78 OP!!
> ||CAV||Nevadan Light Tanks||17 OP||
> ||CAV||Nevadan Light Tanks||17 OP||
> ||CAV||M6A4 Heavy Tanks||30 OP||
> ||WNG||Ferguson Bombardier||14 OP||
> !!!!Heavy Armored Assault Regiment!! 104 OP!!
> ||CAV||M6A4 Heavy Tanks||30 OP||
> ||CAV||M6A4 Heavy Tanks||30 OP||
> ||CAV||M6A4 Heavy Tanks||30 OP||
> ||WNG||Ferguson Bombardier||14 OP||
206,212c206,236
<  Divisions of the 10th Armored Corps [ 983 OP ] Leaders 20* | 9** | 3*** | 1****
< 
<  2nd Mechanized Assault Division [ NOTE ][ 251 OP ]     4    3  1  1
<   Robotic Assault Regiment   [ 82 OP ] 
<   Heavy Armored Assault Regiment [ 104 OP ]
<   Artillery Support Regiment  [ 37 OP ] 
<   Division Support Regiment  [ 33 OP ]
---
> A Corps is the largest unit that can be represented by one "core game set" issued for GROWWII game kit since one kit will have 72 battalion counters - the number for an average-sized corps formation comprised of 4 divisions of 16 battalions each.  Corps are lead by a 4-star Leader and have 4-6 divisions; each of those lead by a 3-star Leader. The total value of a corps is dependent on how its divisions are formed, with each division comprised of 4 regiments or 16 battalions.  The average total could be said to be about 1000 OP and 64 battalions.
> 
> In the chart below is a sample Order-of-Battle [ OOB ] for an implementation of the standard TO&E template for a corps formation.  This unit is the 10th Armored Corps, and has in total 983 OP, 80 battalions arranged into 5 divisions.  There are a total of 33 Leaders.
> 
> !!!!Divisions of the 10th Armored Corps!!983 OP!!20 1-star!!9 2-star!!3 3-star!!1 4-star!!
> !!!!2nd Mechanized Assault Division NOTE!!251 OP!!4!!3!!1!!1!!
> || ||Robotic Assault Regiment||82 OP|| || || || ||
> || ||Heavy Armored Assault Regiment||104 OP|| || || || ||
> || ||Artillery Support Regiment||37 OP|| || || || ||
> || ||Division Support Regiment||33 OP|| || || || ||
> !!!!4th Mechanized Division!!230 OP!!4!!2!!1!!-!!
> || ||Robotic Assault Regiment||82 OP|| || || || ||
> || ||Armored Assault Regiment||78 OP|| || || || ||
> || ||Artillery Support Regiment||37 OP|| || || || ||
> || ||Division Support Regiment||33 OP|| || || || ||
> !!!!178th Infantry Division!!242 OP!!4!!2!!1!!-!!
> || ||Advanced Infantry Regiment||40 OP|| || || || ||
> || ||Vanguard Infantry Regiment||46 OP|| || || || ||
> || ||Armored Assault Regiment||78 OP|| || || || ||
> || ||Armored Assault Regiment||78 OP|| || || || ||
> !!!!3rd Infantry Division!!129 OP!!4!!1!!-!!-!!
> || ||Light Infantry Regiment||23 OP|| || || || ||
> || ||Light Infantry Regiment||23 OP|| || || || ||
> || ||Field Infantry Regiment|| 27 OP|| || || || ||
> || ||Vanguard Infantry Regiment||46 OP|| || || || ||
> !!!!52nd Infantry Division!!133 OP!!4!!1!!-!!-!!
> || ||Light Infantry Regiment||23 OP|| || || || ||
> || ||Heavy Infantry Regiment||27 OP|| || || || ||
> || ||Field Infantry Regiment||27 OP|| || || || ||
> || ||Vanguard Infantry Regiment||46 OP|| || || || ||
>   
214,230c238,246
<  4th Mechanized Division   [ 230 OP ]     4    2  1  -
<   Robotic Assault Regiment   [ 82 OP ] 
<   Armored Assault Regiment  [ 78 OP ]
<   Artillery Support Regiment  [ 37 OP ] 
<   Division Support Regiment  [ 33 OP ]
<   
<  178th Infantry Division   [ 242 OP ]     4    2  1  -
<   Advanced Infantry Regiment   [ 40 OP ]
<   Vanguard Infantry Regiment  [ 46 OP ]
<   Armored Assault Regiment  [ 78 OP ]
<   Armored Assault Regiment  [ 78 OP ]
<   
<  3rd Infantry Division   [ 129 OP ]     4    1  -  -
<   Light Infantry Regiment   [ 23 OP ]
<   Light Infantry Regiment   [ 23 OP ]
<   Field Infantry Regiment   [ 27 OP ]
<   Vanguard Infantry Regiment  [ 46 OP ]
---
>   <b>NOTE:</b>
>   Insignia [ +5 OP ]
>    One of the Robotic Assault Regiments of the 2nd Mechanized Division is
>    the highly-decorated 5th LAD Regiment. Two of the units within receive
>    Insignia with these effects according to the unit type boosted:
>       
>    RBT - Orum Slaughter Bots; receives Agile 1
>    RBT - Halen Assault Ballistar; receives +2 MOV
>    WPN - Garfield Rocket Platform; receives Heavy Metal 2
232,237d247
<  52nd Infantry Division   [ 133 OP ]     4    1  -  -
<   Light Infantry Regiment   [ 23 OP ]
<   Heavy Infantry Regiment   [ 27 OP ]
<   Field Infantry Regiment   [ 27 OP ]
<   Vanguard Infantry Regiment  [ 46 OP ]
<   
239,249d248
<   NOTE: 
<   Insignia [ +5 OP ]
<    One of the Robotic Assault Regiments of the 2nd Mechanized Division is
<    the highly-decorated 5th LAD Regiment. Two of the units within receive
<    Insignia with these effects according to the unit type boosted:
<       
<    RBT - Orum Slaughter Bots; receives Agile 1
<    RBT - Halen Assault Ballistar; receives +2 MOV
<    WPN - Garfield Rocket Platform; receives Heavy Metal 2
<  
<  
251c250
< This is an example of an Army Group.  An Army group contains 4-6 Armies totaling about 100 divisions or 5000 OP. At this level, the Army Group can contain armies belonging to other nations.  Any Army Group is commanded by a 6-star Leader with a subordinate 5-star Leader for each Army beneath.
---
> This is an example of an Army Group.  An Army group contains 4-6 Armies totaling about 100 divisions or 5000 OP. At this level, the Army Group can contain armies belonging to other nations.  Any Army Group is commanded by a 6-star Leader with a subordinate 5-star Leader for each Army beneath.  Each Army is then comprised of 4-7 Corps serving a variety of roles [ see above ].  The totals for an Army then is around 1000 OP and about 300 battalions; roughly 20 divisions.  Each Corps is lead by a 5-star Leader.
254c253
< !!width=20!!3rd United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
---
> !!width=20!!3rd United States Army!!
259c258
< !! !!9th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
---
> !! !!9th United States Army!!
264c263
< !! !!12th United States Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
---
> !! !!12th United States Army!!
269c268
< !! !!18th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
---
> !! !!18th British Army!!
274c273
< !! !!49th British Army  [ ~1000 OP and 300 battalions or about 20 divisions]!!
---
> !! !!49th British Army!!
281c280
< The Allies have a single Supreme Forces structure that encompasses all of the allied nations.  This is led by an 8-star Leader with subordinate 7-star Leaders at a rate of one per Operations Theater reporting.  The total for each Supreme Force is about 2000 divisions or roughly 100,000 OP.
---
> The Allies have a single Supreme Forces structure that encompasses all of the allied nations.  This is led by an 8-star Leader with subordinate 7-star Leaders at a rate of one per Operations Theater reporting.  The total for each Supreme Force is about 2000 divisions or roughly 100,000 OP.  Each Operations Theater forces totals 500 divisions and around 20,000 OP.  These are each comprised of 4-6 Army Groups; each lead by a 6-star Leader.
284c283
< !!width=20!!European Theater Operations Group [ ~20K OP and 500 divisions ]!!
---
> !!width=20!!European Theater Operations Group!!
290c289
< !! !!Mediterranean Theater Operations Group [ ~20K OP and 500 divisions ]!!
---
> !! !!Mediterranean Theater Operations Group!!
295c294
< !! !!Pacific Theater Operations Group [ ~20K OP and 500 divisions ]!!
---
> !! !!Pacific Theater Operations Group!!
302c301
< !! !!Atlantic Theater Operations Group [ ~20K OP and 500 divisions ]!!
---
> !! !!Atlantic Theater Operations Group!!
306c305
< !! !!Asiatic Theater Operations Group [ ~20K OP and 500 divisions ]!!
---
> !! !!Asiatic Theater Operations Group!!
------
GRoWWII/TOandE|1194739547
85,114c85,118
< There are four broad categories of roles; Combat Mission, Service Missions, Support Missions, and Base Missions.  The first two are near the battlefront and are separated by perhaps 100 miles.  Support Missions are usually out of the combat zones, but Base Missions are always at established cities of national origin.
< 
< !!Mission!!Role!!
< ||Combat Missions width=150||Amphibious||
< || ||Armor||
< || ||Engineers||
< || ||Infantry||
< || ||Naval Operations||
< || ||Strategic Air|| 
< ||Service Missions width=150||Logistics||
< || ||Ordnance|| 
< || ||Repair||
< || ||Robotics||
< || ||Signals||
< || ||Technology||  
< ||Support Missions width=150||Advanced Research||
< || ||Chaplain||
< || ||Command||
< || ||Electronics||
< || ||Intelligence||
< || ||Medical|| 
< ||Base Missions width=150||Construction||
< || ||Finance||
< || ||Legal||
< || ||Peace||
< || ||Police||
< || ||Public Affairs||
< || ||Research||
< || ||Training||
< || ||Transportation||
---
> There are four broad categories of roles; Combat Mission, Service Missions, Support Missions, and Base Missions.  The first two are near the battlefront and are separated by perhaps 100 miles.  Support Missions are usually out of the combat zones, but Base Missions are always at established cities of national origin. Below are a list of possible missions and roles for a wide variety of corps, followed by example names of corps.
> 
> !!Mission!!Role!!Example Unit!!
> !!!!!!Combat Missions!!
> || ||Amphibious||V Amphibious Corps||
> || ||Armor||10th Armored Corps||
> || ||Engineers||33rd Engineers Corps||
> || ||Infantry||II Infantry Corps||
> || ||Naval Operations||4th Naval Operations Corps||
> || ||Strategic Air||First Strategic Air Corps||
> !!!!!!Service Missions!!
> || ||Logistics||8th Logistics Corps||
> || ||Ordnance||22nd Ordnance Corps||
> || ||Repair||9th Repair Corps||
> || ||Robotics||XIV Robotics Corps||
> || ||Signals||Third Signals Corps||
> || ||Technology||1st Technology Corps||
> !!!!!!Support Missions!!
> || ||Advanced Research||Boston Advanced Research Corps||
> || ||Chaplain||3rd Chaplain Corps||
> || ||Command||Alpha-2 Command Corps||
> || ||Electronics||23rd Electronics Corps||
> || ||Intelligence||7th Intelligence Coprs||
> || ||Medical||5th Medical Corps||
> !!!!!!Base Missions!!
> || ||Construction||16th Construction Corps||
> || ||Finance||Third Finance Corps||
> || ||Legal||Primary Legal Corps||
> || ||Peace||Pacific Peace Corps||
> || ||Police||Group 3 Police Corps||
> || ||Public Affairs||Western Public Affairs Corps||
> || ||Research||Boston Research Corps||
> || ||Training||Biluxi Training Corps||
> || ||Transportation||East Transportation Corps||
------
WikiTables|1194919661
27c27
< ||default is left aligned||  right-aligned||  center-aligned  ||
---
> ||left aligned|width=200||  right-aligned|width=200||  center-aligned  |width=200||
32c32
< ||default is left aligned||  right-aligned||  center-aligned  ||
---
> ||left aligned|width=200||  right-aligned|width=200||  center-aligned  |width=200||
35,46c35,43
< ==== Cell Width ===
< Set a cell's width in pixels by adding a width=NNN attribute next to it's content.  The wiki engine will then strip out that key=value pair and generate the table accordingly. This works for both table headers and rows.  Once the width for a column is set, that rule will continue for all cells in the same column.
< 
< !!A width=400!!B width=100!!C width=200!!
< ||A||B||C||
< 
< The above was created using:
< 
< <pre>
< !!A width=400!!B width=100!!C width=200!!
< ||A||B||C||
< </pre>
---
> ==== Cell Option Switches ===
> There are multiple switches allowed for each cell in order to control presentation as shown below.
> 
> !!Option|width=150!!Description!!
> ||<tt><nowiki>|width=NNN</nowiki></tt>||Set the width to a certain value in pixels or percentages.  For complex tables, set this in the top-most row that should be affected by this value and all other columns beneath the row will be similarly affected.||
> ||<tt><nowiki>|style=XXXX</nowiki></tt>||Set the in-line style attribute of a cell.  Be sure to end each property with a semi-colon.  For example this entry into a cell will set the background color to red with bold white text.<tt><nowiki>|style=background-color:red;color:white;font-weight:bold;</nowiki></tt> ||
> ||<tt><nowiki>|class=XXXX</nowiki></tt>||Set the class attribute to the selectors identified.  This is the preferred way to style a cell since it will allow consistent styling according to the CSS file used.||
> ||<tt><nowiki>|align=XXXX</nowiki></tt>||Set the cell alignment.  The value used here will over-ride the value dynamically determined by the padding identified in the previous section.  As before, the alignment setting will not affect cells created with the <tt><nowiki>!!</nowiki></tt> markup for table headers.||
> 
------
WikiTables|1194920122
46,64c46
< This particular wiki allows the use HTML to create tables as well.  However, such usage should be applied judiciously since no HTML validation is provided.  When creating the table, do not use any attributes except insert class='wikilargelist' for the opening table tag.
< 
< <b>Example HTML table</b>
< <table class='wikilargelist'>
< <tr><th>Hello</th><th>2nd Column</th><th>3rd Column</th></tr>
< <tr><td>Row 1</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 2</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 3</td><td>Value 1</td><td>Value 2</td></tr>
< </table>
< 
< The above table was created using this syntax:
< <pre>
< <table class='wikilargelist'>
< <tr><th>Hello</th><th>2nd Column</th><th>3rd Column</th></tr>
< <tr><td>Row 1</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 2</td><td>Value 1</td><td>Value 2</td></tr>
< <tr><td>Row 3</td><td>Value 1</td><td>Value 2</td></tr>
< </table>
< </pre>
---
> This particular wiki DOES NOT ALLOW markup for full HTML tables.  The WikiAdmin will need to re-insert <tt>table</tt> into <tt><nowiki>@HtmlPairs</nowiki></tt> within the Wiki engine script.
------
BoardGameGeek|1194920324
1c1,4
< Describe the new page here.
---
> = Boardgame Geek Articles =
> Here's a list of interesting Boardgame Geek links.
> 
>  [http://boardgamegeek.com/thread/237845 The virtues of cards in boardgames] ~~~~ 
------
GRoWWII/TOandE|1194933260
158,159c158,159
< !!!!Light Infantry Regiment width=250!! 23 OP !!
< ||INF width=30||Biluxi Regulars||5 OP||
---
> !!!!Light Infantry Regiment|width=250!!23 OP!!
> ||INF|width=30||Biluxi Regulars||5 OP||
214c214
< !!!!Divisions of the 10th Armored Corps!!983 OP!!20 1-star!!9 2-star!!3 3-star!!1 4-star!!
---
> !!!!Divisions of the 10th Armored Corps!!983 OP!!20 x 1-star!!9 x 2-star!!3 x 3-star!!1 x 4-star!!
257c257
< !!width=20!!3rd United States Army!!
---
> !! |width=20!!3rd United States Army!!
287c287
< !!width=20!!European Theater Operations Group!!
---
> !! |width=20!!European Theater Operations Group!!
------
WikiTables|1195006437
27c26
< ||left aligned|width=200||  right-aligned|width=200||  center-aligned  |width=200||
---
> ||  right aligned|width=200||  center-aligned  |width=200||left-aligned|width=200||
32c31
< ||left aligned|width=200||  right-aligned|width=200||  center-aligned  |width=200||
---
> ||  right aligned|width=200||  center-aligned  |width=200||left-aligned|width=200||
------
WikiTables|1195007830
35c35
< There are multiple switches allowed for each cell in order to control presentation as shown below.
---
> There are multiple switches allowed for each cell in order to control presentation as shown below.  Setting any of these options will carry the values to every cell in the same column for all following rows of the same table.
------
GRoWWII/TOandE|1195015605
88,89c88
< !!!!!!Combat Missions!!
< || ||Amphibious||V Amphibious Corps||
---
> ||Combat||Amphibious||V Amphibious Corps||
95,96c94
< !!!!!!Service Missions!!
< || ||Logistics||8th Logistics Corps||
---
> ||Service||Logistics||8th Logistics Corps||
102,103c100
< !!!!!!Support Missions!!
< || ||Advanced Research||Boston Advanced Research Corps||
---
> ||Support||Advanced Research||Boston Advanced Research Corps||
109,110c106
< !!!!!!Base Missions!!
< || ||Construction||16th Construction Corps||
---
> ||Base||Construction||16th Construction Corps||
118c114
< || ||Transportation||East Transportation Corps||
---
> || ||Transportation||East Transportation Corps|| 
------
GRoWWII/TOandE|1195015726
210c210
< !!!!Divisions of the 10th Armored Corps!!983 OP!!20 x 1-star!!9 x 2-star!!3 x 3-star!!1 x 4-star!!
---
> ||||Divisions of the 10th Armored Corps!!983 OP|class=thblack||20 x 1-star|class=thblack||9 x 2-star|class=thblack||3 x 3-star|class=thblack||1 x 4-star|class=thblack||
252c252
< !!!!12th Army Group!!
---
> ||||12th Army Group|class=thblack||
282c282
< !!!!Supreme Headquarters Allied Expeditionary Forces (SHAEF)!!
---
> ||||Supreme Headquarters Allied Expeditionary Forces (SHAEF)|class=thblack||
------
GRoWWII/TOandE|1195015923
210c210
< ||||Divisions of the 10th Armored Corps!!983 OP|class=thblack||20 x 1-star|class=thblack||9 x 2-star|class=thblack||3 x 3-star|class=thblack||1 x 4-star|class=thblack||
---
> ||||Divisions of the 10th Armored Corps|class=thblack||983 OP|class=thblack||20 x 1-star|class=thblack||9 x 2-star|class=thblack||3 x 3-star|class=thblack||1 x 4-star|class=thblack ||
------
WikiTables|1195055532
35c35
< There are multiple switches allowed for each cell in order to control presentation as shown below.  Setting any of these options will carry the values to every cell in the same column for all following rows of the same table.
---
> There are multiple switches allowed for each cell in order to control presentation as shown below.  Setting any of these options will carry the values to every cell in the same column for all following rows of the same table.  Additionally, there's a bug in the regex that is used to determine the last option for the last column in a row; the fix is to add a space after that last option.
------
WikiTables|1195056658
35c35
< There are multiple switches allowed for each cell in order to control presentation as shown below.  Setting any of these options will carry the values to every cell in the same column for all following rows of the same table.  Additionally, there's a bug in the regex that is used to determine the last option for the last column in a row; the fix is to add a space after that last option.
---
> There are multiple switches allowed for each cell in order to control presentation as shown below.  Setting any of the options will carry the values to every cell in the same column for all following rows of the same table.  For the rowstyle, rowalign, and rowclass switches; setting any of those options will carry to all remaining cells in the row for every row in the table. Unset any option by giving it a value of 'clear', as in rowstyle=clear or align=clear.
43a42,47
> ||<tt><nowiki>|rowstyle=XXXX</nowiki></tt>||Set the in-line style attribute of a row.||
> ||<tt><nowiki>|rowclass=XXXX</nowiki></tt>||Set the class attribute to the selectors identified for all cells in the row.||
> ||<tt><nowiki>|rowalign=XXXX</nowiki></tt>||Set the alignment for all cells in a row.||
> 
> <tt><b>NOTE:</b></tt> There's a bug in the regex that is used to determine the last option for the last column in a row; the fix is to add a space after that last option.
> 
------
WikiTOCs|1195056784
4c4
< The Table of Contents shown above was created automatically by the wiki engine.  The generated table of contents lists headings at level 2 and below; level 1 headings are not included. To flag a header for inclusion into the TOC, it's title entry must be preceded by header markup and a '#' hash symbol.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section.  If the TOC needs to be of a specific width, insert that value in pixels right before the closing angle bracket as in <tt><nowiki><toc NNN></nowiki></tt>
---
> The Table of Contents shown above was created automatically by the wiki engine.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section.  If the TOC needs to be of a specific width, insert that value in pixels right before the closing angle bracket as in <tt><nowiki><toc NNN></nowiki></tt>
------
HomePage|1195056867
6a7
> !!Item!!Description!!
------
GRoWWII|1195092912
2c2
< = # Giant Robots of World War II =
---
> = Giant Robots of World War II =
7c7
< == # Game Goal =
---
> == Game Goal =
13c13
< == # The Operational Art of War =
---
> == The Operational Art of War =
16c16
< === # EPIC GAMES =
---
> === EPIC GAMES =
19c19
< ==== # Game Scale =
---
> ==== Game Scale =
24c24
< ==== # Zone-of-Control [ ZOC ] =
---
> ==== Zone-of-Control [ ZOC ] =
27c27
< ==== # Supply =
---
> ==== Supply =
30c30
< ==== # Line-of-Command [ LOC ] =
---
> ==== Line-of-Command [ LOC ] =
33c33
< ==== # Weather =
---
> ==== Weather =
------
WikiTables|1195109798
35c35
< There are multiple switches allowed for each cell in order to control presentation as shown below.  Setting any of the options will carry the values to every cell in the same column for all following rows of the same table.  For the rowstyle, rowalign, and rowclass switches; setting any of those options will carry to all remaining cells in the row for every row in the table. Unset any option by giving it a value of 'clear', as in rowstyle=clear or align=clear.
---
> There are multiple switches allowed for each cell in order to control presentation as shown below.  Setting any of the options will carry the values to every cell in the same column for all following rows of the same table.  For the rowstyle, rowalign, and rowclass switches; setting any of those options in the first cell of a row will carry to all remaining cells in the row for every row in the table. Unset any option by giving it a value of 'clear', as in rowstyle=clear or align=clear.
------
WikiTables|1195139597
47a48,54
> ||A|width=200|rowstyle=background-color:#cccccc;|rowalign=right||B|width=150||C|class=thblack ||
> ||1||2||3||
> ||3||4||5||
> ||5||6||7|class=clear ||
> ||D|rowstyle=clear||E||F||
> ||7||8||9||
> 
------
SandBox|1195139803
2c2
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=oops|description=Sample Image|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
---
> [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=oops|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
------
WikiTables|1195140675
48c48
< ||A|width=200|rowstyle=background-color:#cccccc;|rowalign=right||B|width=150||C|class=thblack ||
---
> ||A|width=200|rowstyle=background-color:#cccccc;|rowalign=right||B|width=150||C|class=thblack|width=100 ||
51c51
< ||5||6||7|class=clear ||
---
> ||5|rowstyle=background-color:#ffcc00;||6||7|class=clear|align=center ||
54a55,65
> The above was created using:
> 
> <pre>
> ||A|width=200|rowstyle=background-color:#cccccc;|rowalign=right||B|width=150||C|class=thblack|width=100 ||
> ||1||2||3||
> ||3||4||5||
> ||5|rowstyle=background-color:#ffcc00;||6||7|class=clear|align=center ||
> ||D|rowstyle=clear||E||F||
> ||7||8||9||
> </pre>
> 
------
NobleWiki|1195262977
33c33
< ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
---
> ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix|width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
54c54
< ||UseMod:WikiPatches/EmbeddedBacklinks width=300||want||
---
> ||UseMod:WikiPatches/EmbeddedBacklinks|width=300||want||
------
WikiTables|1195263728
34c34
< ==== Cell Option Switches ===
---
> ==== Option Switches ===
45a45,48
> ||<tt><nowiki>|tablewidth=NNN</nowiki></tt>||When provided in the first row of a table, will set the table width to this value.||
> ||<tt><nowiki>|tablestyle=XXXX</nowiki></tt>||When provided in the first row of a table, will set the table style to this value.||
> ||<tt><nowiki>|tableclass=XXXX</nowiki></tt>||When provided in the first row of a table, will set the table class to this value.  The default is <tt>wikilargelist</tt> which exists in the stylesheet.||
> 
------
SandBox|1195267104
2,4c5
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=left|float=right|title=oops|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd ] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
<  
< [http://www.yahoo.com/ upload:sample_bocage.jpg|boxwidth=350|boxfloat=right|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd] View other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisionsView other revisions
---
> #MAGIC Flash name=ufo.swf height=300 width=300
------
SandBox|1195267134
5c5
< #MAGIC Flash name=ufo.swf height=300 width=300
---
> #MAGIC ListCommands
------
SandBox|1195267159
1,4d0
< ===== Edit me! =
< 
< 
< 
7d1
< /AuthUsers
------
SandBox|1195267188
1c1,2
< #MAGIC ListCommands
---
> #MAGIC Flash name=ufo.swf height=300 width=300
> 
------
SandBox|1195267608
1c1
< #MAGIC Flash name=ufo.swf height=300 width=300
---
> #MAGIC Flash name=diceland.swf height=300 width=300
------
SandBox|1195268474
1c1
< #MAGIC Flash name=diceland.swf height=300 width=300
---
> #MAGIC Flash  name=diceland.swf height=300 width=300
------
SandBox|1195268488
1c1
< #MAGIC Flash  name=diceland.swf height=300 width=300
---
> #MAGIC Flash  name=diceland height=300 width=300
------
SandBox|1195268524
1c1
< #MAGIC Flash  name=diceland height=300 width=300
---
> #MAGIC Flash  swfname=diceland.swf height=300 width=300
------
SandBox|1195268635
1c1
< #MAGIC Flash  swfname=diceland.swf height=300 width=300
---
> #MAGIC Flash  name=diceland.swf height=300 width=300
------
SandBox|1195268841
1c1
< #MAGIC Flash  name=diceland.swf height=300 width=300
---
> #MAGIC Flash  name=diceland.swf height=400 width=300
------
SandBox|1195268850
1c1
< #MAGIC Flash  name=diceland.swf height=400 width=300
---
> #MAGIC Flash  name=diceland.swf height=300 width=400
------
SandBox|1195268889
1c1
< #MAGIC Flash  name=diceland.swf height=300 width=400
---
> #MAGIC Flash  name=dice3land.swf height=300 width=400
------
SandBox|1195269100
1c1
< #MAGIC Flash  name=dice3land.swf height=300 width=400
---
> #MAGIC Flash  name=diceland.swf height=300 width=400
------
SandBox|1195269156
1c1
< #MAGIC Flash  name=diceland.swf height=300 width=400
---
> #MAGIC Flash  name=dic44eland.swf height=300 width=400
------
SandBox|1195269172
1c1
< #MAGIC Flash  name=dic44eland.swf height=300 width=400
---
> #MAGIC Flash  name=diceland.swf height=300 width=400
------
SandBox|1195269235
0a1,2
> Some page
> 
------
SandBox|1195269243
1,2d0
< Some page
< 
4a3
> Some page
------
SandBox|1195269254
3c3
< Some page
---
> == WOW ==
------
SandBox|1195269262
------
SandBox|1195269272
3,4d2
< == WOW ==
< 
------
SandBox|1195269287
2a5,8
> #MAGIC Flash  name=diceland.swf height=300 width=400
> 
> 
> #MAGIC Flash  name=diceland.swf height=300 width=400
------
SandBox|1195269294
5,8d1
< #MAGIC Flash  name=diceland.swf height=300 width=400
< 
< 
< #MAGIC Flash  name=diceland.swf height=300 width=400
------
SandBox|1195307798
1c1,4
< #MAGIC Flash  name=diceland.swf height=300 width=400
---
> == TESTING =
> 
> 
>  #FLASH name=diceland.swf|width=200|height=150
------
WikiEditing|1195307987
46c46
<   #MAGIC @top key=value, key=value, ...
---
>   #MAGIC @top key=value key=value, ...
54a54,59
> * To include Flash SWF content.  The defaults will be set if not given to name=ufo.swf, width=400 pixels, and height=300 pixels.
> 
> <pre>
>  #FLASH name=filename.swf|width=NNN|height=NNN
> </pre>
> 
------
WikiEditing|1195308010
57c56
<  #FLASH name=filename.swf|width=NNN|height=NNN
---
>   #FLASH name=filename.swf|width=NNN|height=NNN
------
WikiEditing|1195308113
44c44
< * To utilize a Magic Content command [ effects won't show up until page is saved ]:
---
> * To utilize a Magic Content command [ effects won't show up until page is saved ] use the following syntax.
46c46
<   #MAGIC @top key=value key=value, ...
---
>   #MAGIC ModuleName param1=value1 param2=value2 ...
48a48,50
>  
>  A list of modules can be had by providing ModuleName=ListCommands
> 
------
WikiEditing|1195308444
44c44
< * To utilize a Magic Content command [ effects won't show up until page is saved ] use the following syntax.
---
> * Magic Content Pages create content based upon input parameters.  The ListOfWantedPages are an example of Magic Content.  A list of modules can be had by providing <tt><nowiki>ModuleName=ListCommands</nowiki></tt>. The effects of the Magic Content won't show up until page is saved.
48,50d48
<  
<  A list of modules can be had by providing ModuleName=ListCommands
< 
56c54
< * To include Flash SWF content.  The defaults will be set if not given to name=ufo.swf, width=400 pixels, and height=300 pixels.
---
> * Flash SWF content can be inserted into place if three parameters - name, width, and height - are provided.  The defaults will be set if not given to name=ufo.swf, width=400 pixels, and height=300 pixels.
------
NobleWiki|1195308760
21a21,22
> ||Unobtrusive Flash Object||Flash SWFs may be added using the <tt><nowiki>#FLASH</nowiki></tt> directive.||
> 
71d71
< ||<tt><nowiki>{{flash|size}}</nowiki></tt>||Will embed a flash object||
------
LoremIpsum|1195310767
3c3,25
< Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
---
> Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas non mauris. Mauris auctor ullamcorper enim. Nullam lectus risus, aliquet eget, consectetuer vel, faucibus quis, metus. Nullam at quam nec odio tristique tincidunt. Nam suscipit tellus eu urna. In sed sem at tellus varius bibendum. Phasellus non purus. Ut diam ligula, facilisis quis, posuere vitae, sollicitudin sed, turpis. Quisque tempus scelerisque sapien. Integer placerat nibh id eros. Vivamus nonummy, eros et cursus pharetra, lorem sapien vestibulum mi, ac laoreet dolor ante non urna. Nullam non neque. Donec viverra metus eu velit. Maecenas lectus. Nullam justo tellus, vulputate ut, laoreet id, ullamcorper quis, risus. Nam eu mi ac urna nonummy molestie.
> 
> Quisque ac sapien. Donec vitae turpis. Sed libero purus, posuere a, pharetra ullamcorper, suscipit eget, enim. Morbi lectus urna, laoreet in, ullamcorper sed, porta dapibus, odio. Proin turpis est, ullamcorper vel, tempus eu, convallis eu, orci. Quisque vestibulum diam at mi vulputate sollicitudin. Etiam lacinia condimentum dui. Sed id libero a lorem tincidunt pharetra. Etiam ut metus sed sapien tempus venenatis. Nam egestas varius eros. Donec nibh. Nullam blandit tempor nulla. Suspendisse eget ipsum. Sed sit amet tortor. Phasellus metus pede, porta auctor, euismod vel, mollis vitae, ipsum. Nullam viverra. Curabitur nec velit. Cras pretium, nulla non euismod fermentum, dui lectus aliquet justo, sed euismod mi erat eu urna. Donec arcu sem, accumsan eu, hendrerit vel, tincidunt at, nibh. Nulla facilisi.
> 
> Vestibulum sit amet enim id purus egestas viverra. Ut sit amet dui. Mauris metus. Aliquam eu quam et quam malesuada adipiscing. Nam interdum ligula id nisl. Donec vitae leo in purus sodales ultrices. Praesent feugiat. In diam. Sed at dui. Quisque non ligula. Pellentesque rutrum tortor vel lacus. Duis interdum dictum turpis.
> 
> Morbi id ligula. Morbi odio. In hac habitasse platea dictumst. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Praesent felis. Duis consequat augue vitae lorem. Nulla tellus. Duis eget orci eget nisi posuere scelerisque. Maecenas ultrices odio a nisl. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Donec scelerisque. Quisque dignissim dui non est.
> 
> Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
> 
> In tempus. Proin vel erat id lacus vehicula consectetuer. Aliquam condimentum eros quis odio. Sed vitae arcu vel leo molestie feugiat. Etiam tortor tortor, eleifend a, porttitor a, porttitor vestibulum, risus. Nulla facilisi. Mauris in sem. Sed nunc dolor, eleifend placerat, aliquam at, fringilla eget, mi. Phasellus vel tellus et nibh gravida rhoncus. Integer adipiscing dolor laoreet turpis. Maecenas mollis purus at neque pharetra consectetuer. Cras ut quam vitae purus mattis consectetuer. Morbi porttitor. Aenean elementum. Curabitur at tellus eget quam cursus pretium. Sed felis libero, condimentum sed, imperdiet et, tempus vitae, enim. Duis velit justo, dignissim vel, suscipit in, lobortis eu, nunc. Suspendisse tempor orci quis augue.
> 
> Vestibulum in arcu eget tellus sollicitudin pulvinar. Pellentesque ultricies. Ut convallis feugiat magna. Proin feugiat elit at ipsum. Suspendisse potenti. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Curabitur dignissim aliquet libero. Quisque interdum, enim nec feugiat mollis, sapien tellus fringilla mauris, in rhoncus sapien augue quis felis. Morbi fermentum luctus mauris. Proin viverra neque quis urna. Suspendisse fermentum suscipit orci. Nulla ac libero. Sed et sapien. Donec venenatis tincidunt enim. Duis sagittis lectus in justo. In sodales orci et neque. Maecenas dignissim fermentum quam. Pellentesque fermentum. In hac habitasse platea dictumst.
> 
> Mauris nibh ligula, facilisis ac, imperdiet vitae, ultrices sit amet, ligula. Donec tincidunt egestas dui. Morbi erat nulla, bibendum eget, molestie eget, eleifend pulvinar, velit. Donec blandit, ligula id elementum lobortis, dui ante viverra diam, a posuere massa magna et erat. Sed lacinia, dui in rhoncus ornare, sapien sapien viverra diam, vel tincidunt felis nulla eu dolor. Sed pharetra purus non nisl. Quisque tincidunt dolor quis lorem feugiat adipiscing. Maecenas tincidunt, ipsum eu venenatis aliquam, leo metus auctor lacus, eu suscipit elit nisl ac odio. Aenean sit amet orci. Cras mattis. Proin ultrices, dolor vitae malesuada adipiscing, lorem odio congue dui, sit amet accumsan sapien nibh sit amet turpis. Sed placerat felis a nisi. Nunc eu sapien.
> 
> Vestibulum aliquet tortor id risus. Nam quis ipsum. Phasellus in enim a lectus pretium mollis. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Ut malesuada erat quis nibh. Phasellus non orci eget nulla ultricies facilisis. Duis et pede. Aliquam ullamcorper. Maecenas purus. In hac habitasse platea dictumst. Phasellus eget lectus nec quam pretium gravida. Nulla luctus. Suspendisse id eros. Donec in augue.
> 
> Phasellus id sapien. Morbi sit amet turpis. Etiam at lacus. Praesent at leo. Proin sed diam. Phasellus nonummy tincidunt elit. Aenean aliquam erat eu nibh. Sed dapibus velit nec felis. Phasellus felis purus, pharetra et, laoreet nec, interdum sed, justo. Duis lorem nulla, semper in, molestie eu, sagittis eu, metus. Praesent pede nisi, aliquet vel, tempor in, tempus quis, tellus. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nunc pede lacus, mattis vitae, lobortis ac, feugiat a, turpis. Donec turpis nisl, pretium nec, commodo eu, congue vel, nisl. Phasellus malesuada volutpat nulla. Quisque posuere molestie lectus. Phasellus neque ipsum, vehicula a, sagittis sed, sollicitudin quis, ipsum. Curabitur ultricies justo eu mi.
> 
> Donec mollis. Sed quis ante. Sed est. In vel purus nec magna blandit blandit. Nunc fringilla arcu vel velit. Praesent dolor. Nam tincidunt luctus metus. Suspendisse potenti. Curabitur ut nisi. Integer ac mauris ut velit tincidunt consequat.
> 
> Etiam orci nibh, pharetra quis, pretium in, rutrum eget, neque. Cras tortor orci, laoreet condimentum, sodales semper, blandit ornare, libero. Etiam scelerisque. Curabitur ullamcorper, metus ac convallis interdum, magna nisl ullamcorper augue, et eleifend justo magna eget dolor. Phasellus orci justo, elementum vel, tempus nec, blandit non, leo. Vivamus commodo. Aliquam a velit. Suspendisse potenti. Nullam non mauris. Maecenas nec erat ac dui hendrerit rutrum. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Vivamus euismod, pede nec malesuada sollicitudin, velit augue sagittis nisi, in suscipit dolor justo id metus. 
------
WikiBugs|1195340256
7a8
> ||2007.11.16||[HomePage/RobertKurcina RobertKurcina]||The enhanced table option switches work for the last cell of a row only when it ends with a blank space||OPEN||
------
NobleWiki|1195349589
5a6,7
> <toc 225>
> 
------
WikiBugs|1195349641
8a9
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||Appears to be that bracket images within table cells fail to resolve.  See any of the home page images||OPEN||
------
WikiBugs|1195349797
9a10
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans list legitimate sub pages||OPEN||
------
NobleWiki|1195352688
0a1,2
> <toc 225>
> 
6,7d7
< <toc 225>
< 
------
CategoryWiki|1195352712
0a1,2
> <toc 225>
> 
------
WikiLists|1195352753
0a1,2
> <toc 225>
> 
------
WikiMarkup|1195352774
0a1,2
> <toc 225>
> 
------
WikiStyleGuide|1195352789
0a1,2
> <toc 225>
> 
------
WikiTables|1195352805
0a1,2
> <toc 225>
> 
------
WikiURLs|1195352816
0a1,2
> <toc 225>
> 
------
SandBox|1195437448
4c4
<  #FLASH name=diceland.swf|width=200|height=150
---
> {{flash:name=diceland.swf|width=200|height=150}}
------
SandBox|1195446327
4c4,9
< {{flash:name=diceland.swf|width=200|height=150}}
---
> {{gallery:header=Interesting Pictures|caption=From far away|description=Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas non mauris. Mauris auctor ullamcorper enim. Nullam lectus risus, aliquet eget, consectetuer vel, faucibus quis, metus. Nullam at quam nec odio tristique tincidunt. Nam suscipit tellus eu urna. In sed sem at tellus varius bibendum. Phasellus non purus. Ut diam ligula, facilisis quis, posuere vitae, sollicitudin sed, turpis. Quisque tempus scelerisque sapien. Integer placerat nibh id eros. Vivamus nonummy, eros et cursus pharetra, lorem sapien vestibulum mi, ac laoreet dolor ante non urna. Nullam non neque. Donec viverra metus eu velit. Maecenas lectus. Nullam justo tellus, vulputate ut, laoreet id, ullamcorper quis, risus. Nam eu mi ac urna nonummy molestie.
> thumb=thumb_image1.jpg|image=image11.jpg|title=pity caption for tooltip1
> thumb=thumb_image22.jpg|image=image3.jpg|title=pity caption for tooltip2
> thumb=thumb_image32.jpg|image=image13.jpg|title=pity caption for tooltip3
> thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip4
> }}
------
SandBox|1195446525
4c4
< {{gallery:header=Interesting Pictures|caption=From far away|description=Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Maecenas non mauris. Mauris auctor ullamcorper enim. Nullam lectus risus, aliquet eget, consectetuer vel, faucibus quis, metus. Nullam at quam nec odio tristique tincidunt. Nam suscipit tellus eu urna. In sed sem at tellus varius bibendum. Phasellus non purus. Ut diam ligula, facilisis quis, posuere vitae, sollicitudin sed, turpis. Quisque tempus scelerisque sapien. Integer placerat nibh id eros. Vivamus nonummy, eros et cursus pharetra, lorem sapien vestibulum mi, ac laoreet dolor ante non urna. Nullam non neque. Donec viverra metus eu velit. Maecenas lectus. Nullam justo tellus, vulputate ut, laoreet id, ullamcorper quis, risus. Nam eu mi ac urna nonummy molestie.
---
> {{gallery:header=Interesting Pictures|caption=From far away|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
9a12,18
> {{gallery:header=Another Fantastic Set of Images|caption=Another One|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
> thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
> thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
> thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
> thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
> }}
> 
------
SandBox|1195451075
4c4
< {{gallery:header=Interesting Pictures|caption=From far away|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
---
> {{gallery:
------
NobleWiki|1195451721
24a24,25
> ||<nowiki>LightBox</nowiki> Gallery||Implemented a way to view gallery images.  See WikiGallery for more information.||
> 
75d75
< ||<tt><nowiki>{{gallery|size|uploads}}</nowiki></tt>||Will utilize the <nowiki>LightBox 2.0 JavaScript</nowiki> widget||
------
WikiEditing|1195451959
54c54
< * Flash SWF content can be inserted into place if three parameters - name, width, and height - are provided.  The defaults will be set if not given to name=ufo.swf, width=400 pixels, and height=300 pixels.
---
> * Flash SWF content can be inserted into place if three parameters - name, width, and height - are provided.  The defaults will be set if not given to name=ufo.swf, width=400 pixels, and height=300 pixels.  This is a single flash object within a page, which is ideal for standalone applications.  For use of Flash multiple times within a page, see WikiFlash.
------
WikiEditing|1195452052
68a69,70
>  WikiGallery
>  WikiFlash
------
WikiTables|1195452105
81a82,83
>  WikiGallery
>  WikiFlash
------
WikiHeadings|1195452140
29a30,31
>  WikiGallery
>  WikiFlash
------
WikiImages|1195452148
96a97,98
>  WikiGallery
>  WikiFlash
------
WikiLists|1195452156
60a61,62
>  WikiGallery
>  WikiFlash
------
WikiMarkup|1195452164
101a102,103
>  WikiGallery
>  WikiFlash
------
WikiStyleGuide|1195452174
37a38,39
>  WikiGallery
>  WikiFlash
------
WikiTOCs|1195452183
46a47,48
>  WikiGallery
>  WikiFlash
------
WikiURLs|1195452191
41a42,43
>  WikiGallery
>  WikiFlash
------
CategoryWiki|1195452216
30a30,32
>  WikiGallery
>  WikiFlash
> 
------
WikiGallery|1195453167
1c1,64
< Describe the new page here.
---
> <toc 225>
> 
> == Image Gallery ==
> To display a nice image gallery, utilize the following syntax.  Ensure that a set of thumbnail images, and the larger images themselves, exist.  This gallery will display as a set of list items unless javascript is enabled.
> 
> <pre>
> {{gallery:
> thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip1
> thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip2
> thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip3
> thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip4
> }}
> </pre>
> 
> The above creates this:
> 
> {{gallery:
> thumb=thumb_image1.jpg|image=image1.jpg
> thumb=thumb_image2.jpg|image=image2.jpg
> thumb=thumb_image3.jpg|image=image3.jpg
> thumb=thumb_image4.jpg|image=image4.jpg
> }}
> 
> 
> === Robust Gallery =
> A more robust gallery can be defined by setting up the header text, caption, and description for the gallery itself.  Each image can also be provided a title that will result in a tooltip if the image is mouse-overed.
> 
> {{gallery:header=Another Fantastic Set of Images|caption=Another One|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
> thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
> thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
> thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
> thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
> }}
> 
> The above was created with:
> <pre>
> {{gallery:header=Another Fantastic Set of Images|caption=Another One|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
> thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
> thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
> thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
> thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
> }}
> </pre>
> 
> === Options Switches =
> Here is the complete list of options available for defining a gallery:
> 
> !!Option|width=150!!Description!!
> ||<tt><nowiki>|header=XXXX</nowiki></tt>||Provide a header above the gallery's thumbnail set.||
> ||<tt><nowiki>|caption=XXXX</nowiki></tt>||Provide a caption below the gallery's thumbnail set that could lead into the gallery description.||
> ||<tt><nowiki>|description=XXXX</nowiki></tt>||Provide a description below the gallery's thumbnail set.||
> ||<tt><nowiki>|thumbWidth=NNN</nowiki></tt>||Specify how wide each thumbnail in the gallery should be.  This defaults to 100 pixels.  If the desired width is not that of the provided thumbnail; the gallery will scale accordingly.||
> ||<tt><nowiki>|thumb=NNN|image=NNN</nowiki></tt>||Provide the images for the thumbnail and the zoomed-in view.  This should appear on its own line.  If none is provided, the gallery will use a default image for whatever is missing.  When providing the images, do not use the <nowiki>upload:</nowiki> prefix.  All images need to exist within the uploads directory.||
> ||<tt><nowiki>|title=XXXX</nowiki></tt>||Add this after the thumb, image= parameters to provide a toolt-tip for a thumbnail image.||
> 
> ====== Related Entries =
>  WikiStyleGuide
>  WikiMarkup
>  WikiTOCs
>  WikiHeadings
>  WikiTables
>  WikiImages
>  WikiURLs
>  WikiFlash
------
WikiFlash|1195453937
1c1,31
< Describe the new page here.
---
> <toc 225>
> 
> == Displaying Flash SWF ==
> Any number of Flash SWF files may be displayed within a page if they exists within the uploads directory. Ideally, the dimensions of the SWF file as it appears in each instance within a page is limited to at most 400 pixels wide by 300 pixels. tall.  Exceeding these dimensions is not allowed.
> 
> <pre>
> {{flash:name=diceland.swf|width=200|height=150}}
> </pre>
> 
> The above creates this:
> 
> {{flash:name=diceland.swf|width=200|height=150}}
> 
> 
> === Options Switches =
> Here is the complete list of options available for defining a gallery:
> 
> !!Option|width=150!!Description!!
> ||<tt><nowiki>|name=XXXX</nowiki></tt>||Provide the name of the SWF file as it appears in the upload directory, minus the <nowiki>upload:</nowiki> prefix.  If the name of the SWF file is not provided, ufo.swf will be used instead.||
> ||<tt><nowiki>|width=NNN</nowiki></tt>||Provide the width of the SWF file in pixels.  The default is 400 pixels if not provided; this is also the maximum size allowed.||
> ||<tt><nowiki>|height=NNN</nowiki></tt>||Provide the height of the SWF file in pixels.  The default is 300 pixels if not provided; this is also the maximum size allowed.||
> 
> ====== Related Entries =
>  WikiStyleGuide
>  WikiMarkup
>  WikiTOCs
>  WikiHeadings
>  WikiTables
>  WikiImages
>  WikiURLs
>  WikiGallery
------
WikiFlash|1195457356
7c7
< {{flash:name=diceland.swf|width=200|height=150}}
---
> {{flash:name=diceland.swf|width=400|height=300}}
12c12
< {{flash:name=diceland.swf|width=200|height=150}}
---
> {{flash:name=diceland.swf|width=400|height=300}}
------
NobleWiki|1195457785
83a83,84
> ||<tt><nowiki>{{graph|type|dimension}}</nowiki></tt>||Add support for javascript-generated graphs.  Bar graphs, line graphs, etc.||
> 
------
NobleWiki|1195522909
23c23
< ||Unobtrusive Flash Object||Flash SWFs may be added using the <tt><nowiki>#FLASH</nowiki></tt> directive.||
---
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki>#FLASH</nowiki></tt> directive. See WikiFlash for more information.||
------
NobleWiki|1195522952
12c12
< ||Negation Search||Precede the search term with '!' exclamation point and the search API will find every <em>but</em> that term.||
---
> ||Negation Search|style=background-color:#f5f5f5;||Precede the search term with '!' exclamation point and the search API will find every <em>but</em> that term.||
------
NobleWiki|1195522981
27c27
< ||Cancel button||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
---
> ||Cancel button|style=background-color:#f5f5f5;||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
37c37
< ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix|width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
---
> ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix|style=background-color:#f5f5f5;|width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
58c58
< ||UseMod:WikiPatches/EmbeddedBacklinks|width=300||want||
---
> ||UseMod:WikiPatches/EmbeddedBacklinks|style=background-color:#f5f5f5;|width=300||want||
------
NobleWiki|1195523001
66c66
< ||<tt>T(<string>)</tt>||These are removed for now to declutter the perl code.  Will return as a set of configuration files - one per language.||
---
> ||<tt>T(<string>)</tt>|style=background-color:#f5f5f5;||These are removed for now to declutter the perl code.  Will return as a set of configuration files - one per language.||
75c75
< ||<tt><nowiki>{{history|events}}</nowiki></tt>||Create a timeline using the Timeline javascript widget||
---
> ||<tt><nowiki>{{history|events}}</nowiki></tt>|style=background-color:#f5f5f5;||Create a timeline using the Timeline javascript widget||
------
HomePage|1195523012
8c8
< ||NobleMission||What to see and expect from this wiki, and how to contribute||
---
> ||NobleMission|style=background-color:#f5f5f5;||What to see and expect from this wiki, and how to contribute||
------
SandBox|1195523108
4,18c3
< {{gallery:
< thumb=thumb_image1.jpg|image=image11.jpg|title=pity caption for tooltip1
< thumb=thumb_image22.jpg|image=image3.jpg|title=pity caption for tooltip2
< thumb=thumb_image32.jpg|image=image13.jpg|title=pity caption for tooltip3
< thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip4
< }}
< 
< 
< {{gallery:header=Another Fantastic Set of Images|caption=Another One|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
< thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
< thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
< thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
< thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
< }}
< 
---
> #FLASH name=diceland.swf
------
SandBox|1195523146
3c3
< #FLASH name=diceland.swf
---
> #MAGIC flash name=diceland.swf
------
SandBox|1195523166
3c3
< #MAGIC flash name=diceland.swf
---
> #MAGIC Flash name=ufo.swf height=300 width=300
------
SandBox|1195523173
3c3
< #MAGIC Flash name=ufo.swf height=300 width=300
---
>  #MAGIC Flash name=ufo.swf height=300 width=300
------
SandBox|1195523459
3c3
<  #MAGIC Flash name=ufo.swf height=300 width=300
---
>  #MAGIC Flash name=diceland.swf height=300 width=300
------
SandBox|1195523471
3c3
<  #MAGIC Flash name=diceland.swf height=300 width=300
---
>  #MAGIC Flash name=ufo.swf height=300 width=300
------
SandBox|1195523506
1,3c1
< == TESTING =
< 
<  #MAGIC Flash name=ufo.swf height=300 width=300
---
> #MAGIC Flash  swfname=diceland.swf height=300 width=300
------
SandBox|1195523544
1c1
< #MAGIC Flash  swfname=diceland.swf height=300 width=300
---
> #MAGIC Flash name=diceland.swf height=300 width=300
------
SandBox|1195528042
1c1
< #MAGIC Flash name=diceland.swf height=300 width=300
---
> #MAGIC Flash name=diceland.swf height=300 width=200
------
SandBox|1195528052
1c1
< #MAGIC Flash name=diceland.swf height=300 width=200
---
> #MAGIC Flash name=diceland.swf height=200 width=300
------
SandBox|1195528082
1c1
< #MAGIC Flash name=diceland.swf height=200 width=300
---
> #MAGIC Flash name=diceland.swf height=200 width=320
------
SandBox|1195528098
1c1
< #MAGIC Flash name=diceland.swf height=200 width=320
---
> #MAGIC Flash name=diceland.swf height=200 width=280
------
WikiEditing|1195528173
56c57
<   #FLASH name=filename.swf|width=NNN|height=NNN
---
>   #MAGIC Flash name=diceland.swf height=300 width=200
------
WikiFlash|1195528285
22a23,29
> == Magic Flash =
> If a SWF file is of importance or great curiosity, it should be placed upon a page by itself using the Magic Content directive.  As such, the page will not have a preview feature; it must be saved in order to render the results.  Here's an example of how the syntax would appear:
> 
> <pre>
>   #MAGIC Flash name=diceland.swf height=300 width=200
> </pre>
> 
------
FlashSWF|1195528463
1c1,5
< Describe the new page here.
---
> = Flash SWF Master Page = 
> 
> Links to Flash presentations should be placed here.  The sub-pages within here should all be Magic Content Flash [ see MagicFlash ].
> 
>  /ExampleDiceland
------
FlashSWF/ExampleDiceland|1195528535
1c1,7
< Describe the new page here.
---
> #MAGIC Flash name=diceland.swf height=300 width=200
> 
> == Diceland =
> This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the Kidult game 'Dice Land'.
> 
> 
> 
------
FlashSWF/ExampleDiceland|1195528553
1c1
< #MAGIC Flash name=diceland.swf height=300 width=200
---
> #MAGIC Flash name=diceland.swf height=200 width=270
------
MagicFlash|1195528569
1c1
< Describe the new page here.
---
> #REDIRECT WikiFlash
------
FlashSWF|1195528602
5c5
<  /ExampleDiceland
---
> <subpages>
------
FlashSWF|1195528617
5c5
< <subpages>
---
>  #SUBPAGES
------
WikiFlash|1195528857
29a31,33
> == Flash Master page =
> To help organize Flash content, place any new MagicFlash pages under FlashSWF.  Non-<nowiki>MagicFlash</nowiki> SWF content can be placed anywhere, but should be linked from the master page as well.
> 
------
FlashSWF/ExampleDiceland|1195529056
4,7c4
< This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the Kidult game 'Dice Land'.
< 
< 
< 
---
> This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the [http://www.boardgamegeek.com/game/2937 DiceLand] available at [http://www.kidultgame.com/en/homepage.htm?http://www.kidultgame.com/en/diceland/diceland.htm | Kidult ]
------
FlashSWF/ExampleDiceland|1195529071
------
FlashSWF/ExampleDiceland|1195529099
5c5
< This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the [http://www.boardgamegeek.com/game/2937 DiceLand] available at [http://www.kidultgame.com/en/homepage.htm?http://www.kidultgame.com/en/diceland/diceland.htm | Kidult ]
---
> This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the [http://www.boardgamegeek.com/game/2937 DiceLand] available at [http://www.kidultgame.com/en/homepage.htm?http://www.kidultgame.com/en/diceland/diceland.htm Kidult ]
------
FlashSWF/ExampleDiceland|1195529151
5c5
< This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the [http://www.boardgamegeek.com/game/2937 DiceLand] available at [http://www.kidultgame.com/en/homepage.htm?http://www.kidultgame.com/en/diceland/diceland.htm Kidult ]
---
> This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the [http://www.boardgamegeek.com/game/2937 DiceLand] available at [http://www.kidultgame.com/en/homepage.htm?http://www.kidultgame.com/en/diceland/diceland.htm Kidult]
------
FlashSWF/ExampleTimeNow|1195529568
1c1,5
< Describe the new page here.
---
> #MAGIC Flash name=TimeNow.swf height=200 width=270
> 
> == Time Now =
> 
> This is an example of a MagicFlash.  This SWF is a simple clock.
------
FlashSWF/ExampleDiceRoller|1195529791
1c1,6
< Describe the new page here.
---
> #MAGIC Flash name=CDieD6.swf height=200 width=270
> 
> == Animated Dice Roller =
> 
> This is an example of a MagicFlash.  This SWF is a dice roller showing 6 dice in two rows of 3.
> 
------
FlashSWF/ExampleDiceRoller|1195529807
1c1
< #MAGIC Flash name=CDieD6.swf height=200 width=270
---
> #MAGIC Flash name=CDieD6.swf height=250 width=250
------
FlashSWF/ExampleDiceRoller|1195529818
1c1
< #MAGIC Flash name=CDieD6.swf height=250 width=250
---
> #MAGIC Flash name=CDieD6.swf height=250 width=200
------
ImageGallery/ExampleGallery|1195531765
1c1,8
< Describe the new page here.
---
> == ExampleGallery =
> 
> {{gallery:header=Another Fantastic Set of Images|caption=Another One|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
> thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
> thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
> thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
> thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
> }}
------
ImageGallery|1195531789
1c1,5
< Describe the new page here.
---
> = Image Gallery Master Page = 
> 
> Links to Gallery collections should be placed here and created as sub-pages.
> 
>  #SUBPAGES
------
ImageGallery/ExampleGallery|1195531801
1,2d0
< == ExampleGallery =
< 
------
ImageGallery/ExampleGallery|1195531893
1c1,8
< Describe the new page here.
---
> == Example Image Gallery =
> 
> {{gallery:header=Another Fantastic Set of Images|caption=Another One|description=Donec consectetuer, nibh ac tincidunt facilisis, nulla purus consequat ante, non feugiat sem metus vitae tortor. Quisque lacus quam, feugiat at, cursus eu, rhoncus vel, purus. Aenean eget dolor in risus facilisis euismod. Pellentesque dui est, congue a, varius ut, ultricies sed, orci. Maecenas a elit at libero volutpat sagittis. Donec lacus est, gravida euismod, gravida sit amet, cursus vel, tellus. Nullam eget odio. In hac habitasse platea dictumst. Nam eleifend, nunc id porttitor egestas, diam mi rutrum eros, vitae molestie eros leo quis sem. Etiam egestas metus id tortor posuere iaculis. Integer a turpis. Integer vitae justo ut pede interdum commodo. Ut nibh lacus, eleifend id, consectetuer et, cursus at, tellus. Fusce leo nibh, porta sed, adipiscing eu, posuere at, lectus. Nulla facilisi. Suspendisse ipsum diam, tincidunt nec, adipiscing et, ullamcorper vitae, nunc. Nam a urna. Etiam odio felis, placerat nec, sollicitudin malesuada, vulputate a, orci. Suspendisse vitae libero non arcu venenatis mollis. Vivamus vitae urna.
> thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
> thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
> thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
> thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
> }}
------
ImageGallery/ExampleGallery|1195531945
4,7c4,7
< thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
< thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
< thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
< thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
---
> thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip1
> thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip2
> thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip3
> thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip4
------
WikiContacts|1195532858
3a3,4
> Wow, should I really put some contact information here?  I think I'll just create a Web form and allow the output to go to a database for me to read at leisure.
> 
------
WikiBugs|1195532944
10a11
> ||2007.11.19||[HomePage/RobertKurcina RobertKurcina]||The various AdminBar links should be enabled or disable to match the left nav.||OPEN||
------
WikiGallery|1195533112
55a56,57
> == Common Image Gallery =
> All image gallery should be filed as sub-pages under ImageGallery in order to make their management easier.
------
FeaturedContent|1195533221
5a8,11
> == Various Galleries =
> These are currently under development, but should expand nicely.
>  /ImageGallery
>  /FlashSWF
------
FeaturedContent|1195533233
10,11c10,11
<  /ImageGallery
<  /FlashSWF
---
>  ImageGallery
>  FlashSWF
------
ExampleTemplate|1195602662
3,8c3,8
< !!!! EXAMPLE Template !!
< || Image|| $VARIABLE1$ ||
< || link|| $VARIABLE2$ ||
< || my sub-page|| $VARIABLE3$ ||
< || your sub-page ||$VARIABLE4$ ||
< || bracketed url ||$VARIABLE5$ ||
---
> !!!!EXAMPLE Template!!
> ||Image|width=100|style=background-color:#eeeeee;||$VARIABLE1$|align=left ||
> ||link||$VARIABLE2$ ||
> ||my sub-page|| $VARIABLE3$ ||
> ||your sub-page ||$VARIABLE4$ ||
> ||bracketed url ||$VARIABLE5$ ||
------
ExampleTemplate|1195602707
4c4
< ||Image|width=100|style=background-color:#eeeeee;||$VARIABLE1$|align=left ||
---
> ||Image|width=100|style=background-color:#eeeeee;font-weight:bold;||$VARIABLE1$|align=left ||
------
ExampleTemplate|1195602726
4c4
< ||Image|width=100|style=background-color:#eeeeee;font-weight:bold;||$VARIABLE1$|align=left ||
---
> ||Image|width=100|style=background-color:#eeeeee;||$VARIABLE1$|align=left ||
------
WikiTemplates|1195602875
0a1,2
> <toc 225>
> 
57a61,62
> == Organization =
> Place all templates as sub-pages under <nowiki>WikiTemplates</nowiki> as slash '/' and then the template name as in <nowiki>/Profile</nowiki>.  Or, if the templates are external to this page, prefix them with <pre>Template</pre> as the keyword.
------
WikiTemplates|1195602892
62c62
< Place all templates as sub-pages under <nowiki>WikiTemplates</nowiki> as slash '/' and then the template name as in <nowiki>/Profile</nowiki>.  Or, if the templates are external to this page, prefix them with <pre>Template</pre> as the keyword.
---
> Place all templates as sub-pages under <nowiki>WikiTemplates</nowiki> as slash '/' and then the template name as in <nowiki>/Profile</nowiki>.  Or, if the templates are external to this page, prefix them with <tt>Template</tt> as the keyword.
------
WikiTemplates/HomePage|1195602984
1d0
< Describe the new page here.
2a3,10
> !!!!Profile Information!!
> ||Image|width=100|style=background-color:#eeeeee;||$VARIABLE1$|align=left ||
> ||link||$VARIABLE2$ ||
> ||my sub-page|| $VARIABLE3$ ||
> ||your sub-page ||$VARIABLE4$ ||
> ||bracketed url ||$VARIABLE5$ ||
> 
> 
------
WikiTemplates/HomePage|1195603191
0a1,8
> ==== Profile Information =
> 
> !!!! Information for $NAME$!!
> ||<b>Image</b>|width=100|style=background-color:#eeeeee;||$UPLOADIMAGE$||
> ||<b>Skills</b>||$SKILLS$ ||
> ||<b>Interests</b>||$INTERESTS$ ||
> ||<b>Quote</b>||$QUOTE$ ||
> ||<b>Web site</b>||$WEBSITEURL$ ||
3,10d9
< !!!!Profile Information!!
< ||Image|width=100|style=background-color:#eeeeee;||$VARIABLE1$|align=left ||
< ||link||$VARIABLE2$ ||
< ||my sub-page|| $VARIABLE3$ ||
< ||your sub-page ||$VARIABLE4$ ||
< ||bracketed url ||$VARIABLE5$ ||
< 
< 
------
HomePage/RalphMorgan|1195603332
1,2c1,3
< {{template:TemplateHomePage
< UPLOADIMAGE = [LocalWiki:HomePage upload:homepage-RalphMorgan.jpg|clear=both]]
---
> = Ralph Morgan =
> 
> {{template:WikiTemplates/HomePage
3a5
> UPLOADIMAGE = upload:homepage-RalphMorgan.jpg
------
HomePage/RobertKurcina|1195603382
1,2c1,4
< {{template:TemplateHomePage
< UPLOADIMAGE =  [LocalWiki:HomePage upload:homepage-RobertKurcina.jpg|float=none|clear=both]
---
> = Robert Kurcina =
> 
> {{template:WikiTemplates/HomePage
> UPLOADIMAGE = upload:homepage-RobertKurcina.jpg
------
CategoryWiki|1195603570
1c1
< <toc 225>
---
> <toc>
10a11,15
> == Collections via <nowiki>NobleWiki</nowiki> =
>  FlashSWF
>  WikiTemplates
>  ImageGallery
> 
------
NobleWiki|1195603597
1c1
< <toc 225>
---
> <toc>
------
WikiFlash|1195603610
1c1
< <toc 225>
---
> <toc>
------
WikiGallery|1195603624
1c1
< <toc 225>
---
> <toc>
------
WikiLists|1195603634
1c1
< <toc 225>
---
> <toc>
------
WikiMarkup|1195603648
1c1
< <toc 225>
---
> <toc>
------
WikiStyleGuide|1195603659
1c1
< <toc 225>
---
> <toc>
------
WikiTables|1195603668
1c1
< <toc 225>
---
> <toc>
------
WikiTemplates|1195603677
1c1
< <toc 225>
---
> <toc>
------
WikiTemplates|1195603770
25c25
< ==== Sample Primary Page Template Data Block =
---
> ==== Parent Template =
43c43
< ==== Sample Sub-page Template Data Block =
---
> ==== Sub-page Template =
------
FlashSWF/ExampleDiceRoller|1195604603
------
|1195607041
1a2
> Things work like so!
------
|1195620508
1c1,8
< Describe the new page here.
---
>  
> 
> !!!!EXAMPLE Sub-page Template !!
> ||Image||$VARIABLE1$ ||
> ||link||$VARIABLE2$ ||
> ||my sub-page||$VARIABLE3$ ||
> ||your sub-page ||$VARIABLE4$ ||
> ||bracketed url ||$VARIABLE5$ ||
------
|1195621560
1c1,7334
< Describe the new page here.
---
> #!E:/Program Files/perl/bin/perl.exe
> # UseModWiki version 1.0 (September 12, 2003)
> # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
> # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
> # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
> #    <marcus@ira.uka.de>
> # ...which was based on
> #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
> #    and The Original WikiWikiWeb  (C) Ward Cunningham
> #        <ward@c2.com> (code reused with permission)
> # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
> #
> # This program is free software; you can redistribute it and/or modify
> # it under the terms of the GNU General Public License as published by
> # the Free Software Foundation; either version 2 of the License, or
> # (at your option) any later version.
> #
> # This program is distributed in the hope that it will be useful,
> # but WITHOUT ANY WARRANTY; without even the implied warranty of
> # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> # GNU General Public License for more details.
> #
> # You should have received a copy of the GNU General Public License
> # along with this program; if not, write to the
> #    Free Software Foundation, Inc.
> #    59 Temple Place, Suite 330
> #    Boston, MA 02111-1307 USA
> use Diff;
> use MagicContent;
> use Image::Size;
> 
> package UseModWiki;
> use strict;
> local $| = 1;    # Do not buffer output (localized for mod_perl)
> 
> # Configuration/constant variables:
> use vars qw(@RcDays @HtmlPairs @HtmlSingle
>   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
>   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
>   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
>   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
>   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
>   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
>   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
>   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
>   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
>   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
>   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
>   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
>   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
>   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
>   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
>   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
>   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
>   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine
>   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
>   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
>   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton $HomePagePrefix
>   $EditNameLink $UseMetaWiki @ImageSites $BracketImg $DisabledDir
>   $AllowInclusion $InclusionDir $NumberDatesDelim);
>   
> # Note: $NotifyDefault is kept because it was a config variable in 0.90
> # Other global variables:
> use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
>   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
>   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
>   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
>   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
>   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
>   $ConfigError $UploadPattern $WikiLineHeader $WikiLineHeaderPreview $WikiLineFooter $WikiLineDiff
>   $WikiLine $WikiLine1 $WikiLine2 $WikiLinePref $AutoMailto
>   $GLOBAL_imageCount $GLOBAL_flashCount $GLOBAL_galleryCount
>   $WikiLeftNav %TableCellDefaults $DownloadExtensions
>   );
> 
> # == Configuration =====================================================
> $DataDir = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/wiki";    # Main wiki directory
> $UseConfig = 0;    # 1 = use config file,    0 = do not look for config
> $ConfigFile = "$DataDir/config";    # Configuration file
> 
> # Default configuration (used if UseConfig is 0)
> $CookieName = "NobleWiki";          # Name for this wiki (for multi-wiki sites)
> $SiteName   = "Noble Pursuit Games Wiki";          # Name of site (used for titles)
> $HomePage   = "HomePage";           # Home page (change space to _)
> $HomePagePrefix = "HomePage";      # Which page will be linked when a valid $username is clicked in the RC history.
> $RCName     = "RecentChanges";      # Name of changes page (change space to _)
> $LogoUrl    = "";                   # URL for site logo ("" for no logo)
> $ENV{PATH}  = "/usr/bin/";          # Path used to find "diff"
> $ScriptTZ   = "";                   # Local time zone ("" means do not print)
> $RcDefault  = 7;                    # Default number of RecentChanges days
> @RcDays     = qw(1 3 7 30 90 180);  # Days for links on RecentChanges
> $KeepDays   = 14;                   # Days to keep old revisions
> $SiteBase   = "";                   # Full URL for <BASE> header
> 
> 								    # Set if the auto-detected URL is wrong
> $FullUrl    = "http://wiki.kurcina.org/cgi-bin/index.cgi";                                 
> $RedirType  = 1;                    # 1 = CGI.pm, 2 = script, 3 = no redirect
> $AdminPass  = "linhson";            # Set to non-blank to enable password(s)
> $EditPass   = "emerald";            # Like AdminPass, but for editing only
> $StyleSheet = "/css/default.css";   # URL for CSS stylesheet (like "/wiki.css")
> $NotFoundPg = "PageNotFound";       # Page for not-found links ("" for blank pg)
> $EmailFrom  = "NobleWiki";          # Text for "From: " field of email notes.
> $SendMail   = "/usr/sbin/sendmail"; # Full path to sendmail executable
> $AutoMailto = 1;					# 0 = off; 1 = convert email address automatically to mailTo:<address>
> 									# HTML for bottom of every page
> $FooterNote = "<a href='?action=editprefs'><div id='anylogo' title='access username'>&nbsp;</div></a>";                   
> 
> $EditNote   = "";                   # HTML notice above buttons on edit page
> $MaxPost    = 1024 * 5000;          # Maximum 210K posts (about 200K for pages)
> $NewText    = "";                   # New page text ("" for default message)
> $HttpCharset      = "";           # Charset for pages, like "iso-8859-2"
> 
> $InterWikiMoniker = "NobleWiki";  # InterWiki moniker for this wiki. (for RSS)
> $SiteDescription  = $SiteName;    # Description of this wiki. (for RSS)
> $RssLogoUrl       = "";           # Optional image for RSS feed
> $EarlyRules       = "";           # Local syntax rules for wiki->html (evaled)
> $LateRules        = "";           # Local syntax rules for wiki->html (evaled)
> $KeepSize         = 0;            # If non-zero, maximum size of keep file
> $BGColor          = "";           # Background color ('' to disable)
> $DiffColor1       = "#ffffaf";    # Background color of old/deleted text
> $DiffColor2       = "#cfffcf";    # Background color of new/added text
> $FavIcon          = "";           # URL of bookmark/favorites icon, or ''
> $RssDays          = 7;            # Default number of days in RSS feed
> $UserGotoBar      = "";           # HTML added to end of goto bar
> $UserGotoBar     .= "<a href='$ScriptName?WikiHelp'>Help</a>";
> 
> $UserHeader       = "";           # Optional HTML header additional content
> $UserHeader		 .= "\n<link rel='stylesheet' type='text/css' media='screen' href='/css/jquery.lightbox-0.4.css'/>";
> $UserHeader      .= "\n<script src='/js/jquery-1.2.1.js'></script>";
> $UserHeader      .= "\n<script src='/js/ufo.js'></script>";
> $UserHeader		 .= "\n<script src='/js/jquery.lightbox-0.4.js'></script>";
> 
> $UserBody         = "";           # Optional <BODY> tag additional content
> $StartUID         = 1001;         # Starting number for user IDs
> 								  # Full path (like /foo/www/uploads) for files
> $UploadDir        = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/docs/attachments";
> 								  # Full URL (like http://foo.com/uploads)
> $UploadUrl        = "http://wiki.kurcina.org/attachments";
> $DisabledDir      = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/disabled";
>       
> @ImageSites       = qw();         # Url prefixes of good image sites: ()=all
> 
> # Major options:
> $UseSubpage  = 1;             # 1 = use subpages,       0 = do not use subpages
> $UseCache    = 0;             # 1 = cache HTML pages,   0 = generate every page
> $EditAllowed = 1;             # 1 = editing allowed,    0 = read-only
> $RawHtml     = 0;             # 1 = allow <HTML> tag,   0 = no raw HTML in pages
> $HtmlTags    = 1;             # 1 = "unsafe" HTML tags, 0 = only minimal tags
> $UseDiff     = 1;             # 1 = use diff features,  0 = do not use diff
> $FreeLinks   = 1;             # 1 = use [[word]] links, 0 = LinkPattern only
> $WikiLinks   = 1;             # 1 = use LinkPattern,    0 = use [[word]] only
> $AdminDelete = 1;             # 1 = Admin only deletes, 0 = Editor can delete
> $RunCGI      = 1;             # 1 = Run script as CGI,  0 = Load but do not run
> $EmailNotify = 0;             # 1 = use email notices,  0 = no email on changes
> $EmbedWiki   = 0;             # 1 = no headers/footers, 0 = normal wiki pages
> $DeletedPage = "DeletedPage"; # 0 = disable, 'PageName' = tag to delete page
> $ReplaceFile = "ReplaceFile"; # 0 = disable, 'PageName' = indicator tag
> @ReplaceableFiles = ();       # List of allowed server files to replace
> $TableSyntax      = 1;        # 1 = wiki syntax tables, 0 = no table syntax
> $NewFS            = 1;        # 1 = new multibyte $FS,  0 = old $FS
> $UseUpload        = 1;        # 1 = allow uploads,      0 = no uploads
> $AllowInclusion = 1;          # 1 = files (*.txt,*.html) may be included by include:file.html,
> 	                          # 0 = files will not be included
> 	                          # from where shall the files be included?
> $InclusionDir = "$DataDir/includes-data"; 
>   
> # Minor options:
> $LogoLeft     = 1;    # 1 = logo on left,       0 = logo on right
> $RecentTop    = 1;    # 1 = recent on top,      0 = recent on bottom
> $UseDiffLog   = 1;    # 1 = save diffs to log,  0 = do not save diffs
> $KeepMajor    = 1;    # 1 = keep major rev,     0 = expire all revisions
> $KeepAuthor   = 1;    # 1 = keep author rev,    0 = expire all revisions
> $ShowEdits    = 0;    # 1 = show minor edits,   0 = hide edits by default
> $HtmlLinks    = 1;    # 1 = allow A HREF links, 0 = no raw HTML links
> $SimpleLinks  = 0;    # 1 = only letters,       0 = allow _ and numbers
> $NonEnglish   = 0;    # 1 = extra link chars,   0 = only A-Za-z chars
> $ThinLine     = 0;    # 1 = fancy <hr> tags,    0 = classic wiki <hr>
> $BracketText  = 1;    # 1 = allow [URL text],   0 = no link descriptions
> $UseAmPm      = 0;    # 1 = use am/pm in times, 0 = use 24-hour times
> $UseIndex     = 0;    # 1 = use index file,     0 = slow/reliable method
> $UseHeadings  = 1;    # 1 = allow = h1 text =,  0 = no header formatting
> $NetworkFile  = 1;    # 1 = allow remote file:, 0 = no file:// links
> $BracketWiki  = 1;    # 1 = [WikiLnk txt] link, 0 = no local descriptions
> $UseLookup    = 1;    # 1 = lookup host names,  0 = skip lookup (IP only)
> $FreeUpper    = 1;    # 1 = force upper case,   0 = do not force case
> $FastGlob     = 1;    # 1 = new faster code,    0 = old compatible code
> $MetaKeywords = 1;    # 1 = Google-friendly,    0 = search-engine averse
> $NamedAnchors = 1;    # 0 = no anchors, 1 = enable anchors,
>                       # 2 = enable but suppress display
> $SlashLinks   = 0;    # 1 = use script/action links, 0 = script?action
> $UpperFirst   = 1;    # 1 = free links start uppercase, 0 = no ucfirst
> $AdminBar     = 1;    # 1 = admins see admin links, 0 = no admin bar
> $RepInterMap  = 0;    # 1 = intermap is replacable, 0 = not replacable
> $ConfirmDel   = 1;    # 1 = delete link confirm page, 0 = immediate delete
> $MaskHosts    = 0;    # 1 = mask hosts/IPs,      0 = no masking
> $LockCrash    = 0;    # 1 = crash if lock stuck, 0 = auto clear locks
> $HistoryEdit  = 0;    # 1 = edit links on history page, 0 = no edit links
> $OldThinLine  = 0;    # 1 = old ==== thick line, 0 = ------ for thick line
> $NumberDates  = 1;    # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
> $NumberDatesDelim = "-"; # If $NumberDates is 1, this character separate the year, month, day
> $ParseParas   = 1;    # 1 = new paragraph markup, 0 = old markup
> $AuthorFooter = 1;    # 1 = show last author in footer, 0 = do not show
> $AllUpload    = 0;    # 1 = anyone can upload,   0 = only editor/admins
> $LimitFileUrl = 1;    # 1 = limited use of file: URLs, 0 = no limits
> $MaintTrimRc  = 1;    # 1 = maintain action trims RC, 0 = only maintainrc
> $SearchButton = 1;    # 1 = search button on page, 0 = old behavior
> $EditNameLink = 0;    # 1 = edit links use name (CSS), 0 = '?' links
> $UseMetaWiki  = 0;    # 1 = add MetaWiki search links, 0 = no MW links
> $BracketImg   = 1;    # 1 = [url url.gif] becomes image link, 0 = no img
> 
> $WikiLineHeader = "\n<div class='wikilineheader'></div>";
> $WikiLineHeaderPreview = "\n<div class='wikilineheaderpreview'></div>";
> $WikiLineFooter = "\n<div class='wikilinefooter'></div>";
> $WikiLineDiff   = "\n<div class='wikilinediff'></div>";
> $WikiLinePref   = "\n<div class='wikilinepref'></div>";
> $WikiLine       = "\n<div class='wikiline'></div>";
> $WikiLine1      = "\n<div class='wikiline1'></div>";
> $WikiLine2      = "\n<div class='wikiline2'></div>";
> 
> # Names of sites.  (The first entry is used for the number link.)
> @IsbnNames = ( 'bn.com', 'amazon.com', 'search' );
> 
> # Full URL of each site before the ISBN
> @IsbnPre = (
> 	"http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=",
> 	"http://www.amazon.com/exec/obidos/ISBN=",
> 	"http://www.pricescan.com/books/BookDetail.asp?isbn="
> );
> 
> # Rest of URL of each site after the ISBN (usually '')
> @IsbnPost = ( "", "", "" );
> 
> # HTML tag lists, enabled if $HtmlTags is set.
> # Scripting is currently possible with these tags,
> # so they are *not* particularly "safe".
> # Tags that must be in <tag> ... </tag> pairs:
> @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
>   em s strike strong tt var div center blockquote ol ul dl caption);
> 
> # Single tags (that do not require a closing /tag)
> @HtmlSingle = qw(br p hr li dt dd tr td th);
> @HtmlPairs  = ( @HtmlPairs, @HtmlSingle );     # All singles can also be pairs
> 
> # == You should not have to change anything below this line. =============
> $IndentLimit = 20;                             # Maximum depth of nested lists
> $PageDir     = "$DataDir/page-data";           # Stores page data
> $HtmlDir     = "$DataDir/html-version";        # Stores HTML versions
> $UserDir     = "$DataDir/user-data";           # Stores user data
> $KeepDir     = "$DataDir/keep-data";           # Stores kept (old) page data
> $TempDir     = "$DataDir/temp-files";          # Temporary files and locks
> $LockDir     = "$TempDir/lock-dir";            # DB is locked if this exists
> $InterFile   = "$DataDir/intermap";            # Interwiki site->url map
> $RcFile      = "$DataDir/recent-log";          # New RecentChanges logfile
> $RcOldFile   = "$DataDir/oldrecent-log";       # Old RecentChanges logfile
> $IndexFile   = "$DataDir/page-index";          # List of all pages
> $EmailFile   = "$DataDir/email-list";          # Email notification lists
> if ($RepInterMap) {
> 	push @ReplaceableFiles, $InterFile;
> }
> 
> # The "main" program, called at the end of this script file.
> sub DoWikiRequest {
> 	if ( $UseConfig && ( -f $ConfigFile ) ) {
> 		$ConfigError = "";
> 		if ( !do $ConfigFile ) {               # Some error occurred
> 			$ConfigError = $@;
> 			if ( $ConfigError eq "" ) {
> 
> 			  # Unfortunately, if the last expr returns 0, one will get a false
> 			  # error above.  To remain compatible with existing installs the
> 			  # wiki must not report an error unless there is error text in $@.
> 			  # (Errors in "use strict" may not have error text.)
> 			  # Uncomment the line below if you want to catch use strict errors.
> 			  #       $ConfigError = "Unknown Error (no error text)";
> 			}
> 		}
> 	}
> 	&InitLinkPatterns();
> 	if ( !&DoCacheBrowse() ) {
> 		eval $BrowseCode;
> 		&InitRequest() or return;
> 		if ( !&DoBrowseRequest() ) {
> 			eval $OtherCode;
> 			&DoOtherRequest();
> 		}
> 	}
> }
> 
> # == Common and cache-browsing code ====================================
> sub InitLinkPatterns {
> 	my ( $UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim );
> 
> 	# Field separators are used in the URL-style patterns below.
> 	if ($NewFS) {
> 		$FS = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
> 	}
> 	else {
> 		$FS = "\xb3";                # The FS character is a superscript "3"
> 	}
> 	$FS1         = $FS . "1";  # The FS values are used to separate fields
> 	$FS2         = $FS . "2";  # in stored hashtables and other data structures.
> 	$FS3         = $FS . "3";  # The FS character is not allowed in user data.
> 	$UpperLetter = "[A-Z";
> 	$LowerLetter = "[a-z";
> 	$AnyLetter   = "[A-Za-z";
> 	if ($NonEnglish) {
> 		$UpperLetter .= "\xc0-\xde";
> 		$LowerLetter .= "\xdf-\xff";
> 		if ($NewFS) {
> 			$AnyLetter .= "\x80-\xff";
> 		}
> 		else {
> 			$AnyLetter .= "\xc0-\xff";
> 		}
> 	}
> 	if ( !$SimpleLinks ) {
> 		$AnyLetter .= "_0-9";
> 	}
> 	$UpperLetter .= "]";
> 	$LowerLetter .= "]";
> 	$AnyLetter   .= "]";
> 
> 	# Main link pattern: lowercase between uppercase, then anything
> 	$LpA =
> 	  $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
> 
> 	# Optional subpage link pattern: uppercase, lowercase, then anything
> 	$LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
> 	if ($UseSubpage) {
> 
> 		# Loose pattern: If subpage is used, subpage may be simple name
> 		$LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
> 
> 		# Strict pattern: both sides must be the main LinkPattern
> 		# $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
> 	}
> 	else {
> 		$LinkPattern = "($LpA)";
> 	}
> 	$QDelim = '(?:"")?';    # Optional quote delimiter (not in output)
> 	$AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
> 	$LinkPattern .= $QDelim;
> 
> 	# Inter-site convention: sites must start with uppercase letter
> 	# (Uppercase letter avoids confusion with URLs)
> 	$InterSitePattern = $UpperLetter . $AnyLetter . "+";
> 	$InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
> 	if ($FreeLinks) {
> 
> 		# Note: the - character must be first in $AnyLetter definition
> 		if ($NonEnglish) {
> 			if ($NewFS) {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
> 			}
> 			else {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
> 			}
> 		}
> 		else {
> 			$AnyLetter = "[-,.()' _0-9A-Za-z]";
> 		}
> 	}
> 	$FreeLinkPattern = "($AnyLetter+";
> 	if ($UseSubpage) {
> 		$FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+";
> 	}
> 	
> 	if ($NamedAnchors){
> 		$FreeLinkPattern .= "(?:#(?:\\w+))?)";
> 	}
> 	else {
> 		$FreeLinkPattern .= ")";
> 	}
> 	
> 	$FreeLinkPattern .= $QDelim;
> 
> 	# Url-style links are delimited by one of:
> 	#   1.  Whitespace                           (kept in output)
> 	#   2.  Left or right angle-bracket (< or >) (kept in output)
> 	#   3.  Right square-bracket (])             (kept in output)
> 	#   4.  A single double-quote (")            (kept in output)
> 	#   5.  A $FS (field separator) character    (kept in output)
> 	#   6.  A double double-quote ("")           (removed from output)
> 	$UrlProtocols    = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|prospero|telnet|gopher";
> 	$UrlProtocols   .= '|file' if ( $NetworkFile || !$LimitFileUrl );
> 	
> 	$UrlPattern      = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
> 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
> 	$DownloadExtensions = "(pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)";
> 	$RFCPattern      = "RFC\\s?(\\d+)";
> 	$ISBNPattern     = "ISBN:?([0-9- xX]{10,})";
> 	$UploadPattern   = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
> }
> 
> # Simple HTML cache
> sub DoCacheBrowse {
> 	my ( $query, $idFile, $text );
> 	return 0 if ( !$UseCache );
> 	$query = $ENV{'QUERY_STRING'};
> 	if ( ( $query eq "" ) && ( $ENV{'REQUEST_METHOD'} eq "GET" ) ) {
> 		$query = $HomePage;    # Allow caching of home page.
> 	}
> 	if ( !( $query =~ /^$LinkPattern$/ ) ) {
> 		if ( !( $FreeLinks && ( $query =~ /^$FreeLinkPattern$/ ) ) ) {
> 			return 0;          # Only use cache for simple links
> 		}
> 	}
> 	$idFile = &GetHtmlCacheFile($query);
> 	if ( -f $idFile ) {
> 		local $/ = undef;      # Read complete files
> 		open( INFILE, "<$idFile" ) or return 0;
> 		$text = <INFILE>;
> 		close INFILE;
> 		print $text;
> 		return 1;
> 	}
> 	return 0;
> }
> 
> sub GetHtmlCacheFile {
> 	my ($id) = @_;
> 	return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
> }
> 
> sub GetPageDirectory {
> 	my ($id) = @_;
> 	if ( $id =~ /^([a-zA-Z])/ ) {
> 		return uc($1);
> 	}
> 	return "other";
> }
> 
> sub T {
> 	my ($text) = @_;
> 	if ( defined( $Translate{$text} ) && ( $Translate{$text} ne "" ) ) {
> 		return $Translate{$text};
> 	}
> 	return $text;
> }
> 
> sub Ts {
> 	my ( $text, $string ) = @_;
> 	$text = T($text);
> 	$text =~ s/\%s/$string/;
> 	return $text;
> }
> 
> sub Tss {
> 	my $text = @_[0];
> 	$text = T($text);
> 	$text =~ s/\%([1-9])/$_[$1]/ge;
> 	return $text;
> }
> 
> # == Normal page-browsing and RecentChanges code =======================
> $BrowseCode = "";    # Comment next line to always compile (slower)
> 
> #$BrowseCode = <<'#END_OF_BROWSE_CODE';
> use CGI;
> use CGI::Carp qw(fatalsToBrowser);
> 
> sub InitRequest {
> 	my @ScriptPath = split( '/', "$ENV{SCRIPT_NAME}" );
> 	$CGI::POST_MAX = $MaxPost;
> 	
> 	if ($UseUpload) {
> 		$CGI::DISABLE_UPLOADS = 0;    # allow uploads
> 	}
> 	else {
> 		$CGI::DISABLE_UPLOADS = 1;    # no uploads
> 	}
> 	
> 	if ($SlashLinks && length($ENV{'PATH_INFO'}>1)){
> 		$ENV{'QUERY_STRING'} .= '&' if($ENV{'QUERY_STRING'});
> 		$ENV{'QUERY_STRING'} .= substr($ENV{'PATH_INFO'},1);
> 	}
> 	
> 	$q = new CGI();
> 	
> 	if ($SlashLinks){
> 		my $numberOfSlashes = ($ENV{'PATH_INFO'} = tr[/][/]);
> 		$ScriptName = ('../' x $numberOfSlashes) . $ScriptName;
> 	}
> 
> 	# Fix some issues with editing UTF8 pages (if charset specified)
> 	if ( $HttpCharset ne "" ) {
> 		$q->charset($HttpCharset);
> 	}
> 	$Now           = time;                # Reset in case script is persistent
> 	$ScriptName    = pop(@ScriptPath);    # Name used in links
> 		
> 	$IndexInit     = 0;                   # Must be reset for each request
> 	$InterSiteInit = 0;
> 	%InterSite     = ();
> 	$MainPage     = ".";    # For subpages only, the name of the top-level page
> 	$OpenPageName = "";     # Currently open page
> 	&CreateDir($DataDir);   # Create directory if it doesn't exist
> 
> 	if ( !-d $DataDir ) {
> 		&ReportError( "Could not create $DataDir : $!" );
> 		return 0;
> 	}
> 	&InitCookie();          # Reads in user data
> 	return 1;
> }
> 
> sub InitCookie {
> 	%SetCookie      = ();
> 	$TimeZoneOffset = 0;
> 	undef $q->{'.cookies'};    # Clear cache if it exists (for SpeedyCGI)
> 	%UserData   = ();                        # Fix for persistent environments.
> 	%UserCookie = $q->cookie($CookieName);
> 	$UserID     = $UserCookie{'id'};
> 	$UserID =~ s/\D//g;                      # Numeric only
> 	if ( $UserID < 200 ) {
> 		$UserID = 111;
> 	}
> 	else {
> 		&LoadUserData($UserID);
> 	}
> 	if ( $UserID > 199 ) {
> 		if (   ( $UserData{'id'} != $UserCookie{'id'} )
> 			|| ( $UserData{'randkey'} != $UserCookie{'randkey'} ) )
> 		{
> 			$UserID   = 113;
> 			%UserData = ();    # Invalid.  Consider warning message.
> 		}
> 	}
> 	if ( $UserData{'tzoffset'} != 0 ) {
> 		$TimeZoneOffset = $UserData{'tzoffset'} * ( 60 * 60 );
> 	}
> }
> 
> sub DoBrowseRequest {
> 	my ( $id, $action, $text );
> 	if ( !$q->param ) {        # No parameter
> 		&BrowsePage($HomePage);
> 		return 1;
> 	}
> 	$id = &GetParam( 'keywords', "" );
> 	if ($id) {                 # Just script?PageName
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	$action = lc( &GetParam( 'action', "" ) );
> 	$id = &GetParam( 'id', "" );
> 	if ( $action eq 'browse' ) {
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	elsif ( $action eq 'rc' ) {
> 		&BrowsePage($RCName);
> 		return 1;
> 	}
> 	elsif ( $action eq 'random' ) {
> 		&DoRandom();
> 		return 1;
> 	}
> 	elsif ($action eq 'orphans') {
> 		&DoOrphanList();
> 		return 1;
> 	} 
> 	elsif ($action eq 'history') {
> 		&DoHistory($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	return 0;    # Request not handled
> }
> 
> sub BrowsePage {
> 	my ($id) = @_;
> 	my ( $fullHtml, $oldId, $allDiff, $showDiff, $openKept );
> 	my ( $revision, $goodRevision, $diffRevision, $newText );
> 	my ( $fragHtml );
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$openKept = 0;
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	$goodRevision = $revision;    # Non-blank only if exists
> 
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		$openKept = 1;
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$goodRevision = "";
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 		}
> 	}
> 
> 	# Raw mode: just untranslated wiki text
> 	if ( &GetParam( 'raw', 0 ) ) {
> 		print &GetHttpHeader('text/plain');
> 		print $Text{'text'};
> 		return;
> 	}
> 	$newText = $Text{'text'};              # For differences
> 	                                       # Handle a single-level redirect
> 	$oldId   = &GetParam( 'oldid', "" );
> 	if (   ( $oldId eq "" )
> 		&& ( substr( $Text{'text'}, 0, 10 ) eq '#REDIRECT ' ) )
> 	{
> 		$oldId = $id;
> 		if ( ($FreeLinks) && ( $Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/ ) ) {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/ );
> 			$id = &FreeToNormal($id);
> 		}
> 		else {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+(\S+)/ );
> 		}
> 		if ( &ValidId($id) eq "" ) {
> 
> 			# Consider revision in rebrowse?
> 			&ReBrowsePage( $id, $oldId, 0 );
> 			return;
> 		}
> 		else {    # Not a valid target, so continue as normal page
> 			$id    = $oldId;
> 			$oldId = "";
> 		}
> 	}
> 	$MainPage = $id;
> 	$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 	$fullHtml = &GetHeader( $id, &QuoteHtml($id), $oldId );
> 
> 	unless( $id eq $RCName ){ $fullHtml .= &GetLeftNav($id); }
> 	if ( $UseDiff && $showDiff ) {
> 		$fullHtml .= "\n<div class='wikiadmin'>";
> 	}
> 	else {
> 		unless ($id eq $RCName){ $fullHtml .= "\n<div class='wikitext'>"; }
> 		else { $fullHtml .= "\n<div class='wikiadmin'>"; }
> 	}
> 	
> 		if ( $revision ne "" ) {
> 		if ( ( $revision eq $Page{'revision'} ) || ( $goodRevision ne "" ) ) {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Showing revision $revision.</div>";
> 		}
> 		else {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Revision $revision not available, showing current revision instead.</div>";
> 		}
> 	}
> 	
> 	$fullHtml .= $fragHtml;
> 	
> 	$allDiff = &GetParam( 'alldiff', 0 );
> 	if ( $allDiff != 0 ) {
> 		$allDiff = &GetParam( 'defaultdiff', 1 );
> 	}
> 	
> 	if (
> 		(
> 			( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName )
> 		)
> 		&& &GetParam( 'norcdiff', 1 )
> 	  )
> 	{
> 		$allDiff = 0;    # Only show if specifically requested
> 	}
> 	
> 	$showDiff = &GetParam( 'diff', $allDiff );
> 	
> 	if ( $UseDiff && $showDiff ) {
> 		$diffRevision = $goodRevision;
> 		$diffRevision = &GetParam( 'diffrevision', $diffRevision );
> 
> 		# Eventually try to avoid the following keep-loading if possible?
> 		&OpenKeptRevisions('text_default') if ( !$openKept );
> 		$fullHtml .= &GetDiffHTML( $showDiff, $id, $diffRevision, $revision, $newText );
> 		$fullHtml .= $fragHtml;
> 
> 	}
> 
> 	# magiccontent patch - tarquin
> 	# Refactored and added position functionality --DavidClaughton.
> 	my ($magiccommand, $magicpos, $magicparams);
> 	my ($magicHTML, $magicDiv, $wikiHTML) = ("", "", "");
> 	if ( ($magicpos, $magiccommand, $magicparams) = $Text{'text'} =~ m[^\#MAGIC\s*(?:\@(top|bottom))?\s*(\w*)\s*(.*)\n] ){
> 		$Text{'text'} =~ s/^\#MAGIC.*\n//; # kill the magic command line in source
> 		$wikiHTML = &WikiToHTML($Text{'text'});
> 		
> 		#$magicDiv = "\n<hr>\n"; # Remove if using CSS.
> 		
> 		# call: MakeSection( current page, magic module, line of parameters)
> 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
> 		
> 		if (lc $magicpos eq "top"){
> 			$fullHtml .= $magicHTML . $magicDiv . $wikiHTML;
> 		}
> 		else {
> 			$fullHtml .= $wikiHTML . $magicDiv . $magicHTML;
> 		}
> 	}
> 	else {
> 		$fullHtml .= &WikiToHTML($Text{'text'});
> 	}
> 	
> 	if ( !&GetParam( 'embed', $EmbedWiki ) ) {
> 		$fullHtml .= "</div>";
> 		$fullHtml .= $WikiLineFooter;
> 	}
> 
> 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) )
> 	{
> 		print $fullHtml;
> 		print $WikiLineDiff;
> 		print &GetLeftNav($id);
> 		print "\n<div class='wikidiff'>";
> 		&DoRc(1);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter" if ( !&GetParam( 'embed', $EmbedWiki ) );
> 
> 		print &GetFooterText( $id, $goodRevision );
> 		print "\n</div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$fullHtml .= &GetFooterText( $id, $goodRevision );
> 	$fullHtml .= "</div></div></body></html>";
> 	print $fullHtml;
> 	
> 	return
> 	
> 	if ( $showDiff || ( $revision ne "" ) );    # Don't cache special version
> 	&UpdateHtmlCache( $id, $fullHtml ) if ( $UseCache && ( $oldId eq "" ) );
> }
> 
> sub ReBrowsePage {
> 	my ( $id, $oldId, $isEdit ) = @_;
> 	if ( $oldId ne "" ) {    
> 		# Target of #REDIRECT (loop breaking)
> 		print &GetRedirectPage( "action=browse&id=$id&oldid=$oldId", $id, $isEdit );
> 	}
> 	else {
> 		print &GetRedirectPage( $id, $id, $isEdit );
> 	}
> }
> 
> sub DoRc {
> 	my ($rcType) = @_;       # 0 = RSS, 1 = HTML
> 	my ( $fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly );
> 	my ( @fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML );
> 	my $starttime = 0;
> 	my $showbar   = 0;
> 	if ( 0 == $rcType ) {
> 		$showHTML = 0;
> 	}
> 	else {
> 		$showHTML = 1;
> 	}
> 	if ( &GetParam( "from", 0 ) ) {
> 		$starttime = &GetParam( "from", 0 );
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print "\nUpdates since " . &TimeToText($starttime);
> 			print "\n</h2>";
> 		}
> 	}
> 	else {
> 		$daysago = &GetParam( "days", 0 );
> 		$daysago = &GetParam( "rcdays", 0 ) if ( $daysago == 0 );
> 		if ($daysago) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $daysago );
> 			if ($showHTML) {
> 				print "\n<h2>";
> 				print Ts( 'Updates in the last %s day' . ( ( $daysago != 1 ) ? "s" : "" ), $daysago );
> 				print "\n</h2>";
> 			}
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('Updates in the last %s days', '');
> 		}
> 	}
> 	if ( $starttime == 0 ) {
> 		if ( 0 == $rcType ) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RssDays );
> 		}
> 		else {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RcDefault );
> 		}
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print Ts('Updates in the last %s day'. ( ( $RcDefault != 1 ) ? "s" : "" ),$RcDefault );
> 			print "\n</h2>";
> 		}
> 
> 		# Translation of above line is identical to previous version
> 	}
> 
> 	# Read rclog data (and oldrclog data if needed)
> 	( $status, $fileData ) = &ReadFile($RcFile);
> 	$errorText = "";
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>";
> 		$errorText .= "Could not open $RCName log file";
> 		$errorText .= ":</strong> $RcFile</p>";
> 		$errorText .= "Error was ";
> 		$errorText .= ":<pre>$!</pre><p>";
> 		$errorText .= "Note: This error is normal if no changes have been made.";
> 
> 	}
> 	@fullrc = split( /\n/, $fileData );
> 	$firstTs = 0;
> 	if ( @fullrc > 0 ) {    # Only false if no lines in file
> 		($firstTs) = split( /$FS3/, $fullrc[0] );
> 	}
> 	if ( ( $firstTs == 0 ) || ( $starttime <= $firstTs ) ) {
> 		( $status, $oldFileData ) = &ReadFile($RcOldFile);
> 		if ($status) {
> 			@fullrc = split( /\n/, $oldFileData . $fileData );
> 		}
> 		else {
> 			if ( $errorText ne "" ) {    
> 			
> 				# could not open either rclog file
> 				print $errorText;
> 				print "\n<p><strong>";
> 				print "\nCould not open old $RCName log file";
> 				print "\n:</strong> $RcOldFile</p>";
> 				print "\nError was";
> 				print "\n:<pre>$!</pre>";
> 				
> 				return;
> 			}
> 		}
> 	}
> 	$lastTs = 0;
> 	if ( @fullrc > 0 ) {                 
> 		# Only false if no lines in file
> 		($lastTs) = split( /$FS3/, $fullrc[$#fullrc] );
> 	}
> 	$lastTs++ if ( ( $Now - $lastTs ) > 5 );    # Skip last unless very recent
> 	$idOnly = &GetParam( "rcidonly", "" );
> 	if ( $idOnly && $showHTML ) {
> 		print "\n<b>(";
> 		print "\nfor ";
> 		print &ScriptLink( $idOnly, $idOnly );
> 		print "\n only";
> 		print "\n)</b><br>";
> 	}
> 	if ($showHTML) {
> 		foreach $i (@RcDays) {
> 			print "\n | " if $showbar;
> 			$showbar = 1;
> 			print &ScriptLink( "action=rc&days=$i",
> 				Ts( '%s day' . ( ( $i != 1 ) ? 's' : '' ), $i ) );
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('%s days', '');
> 		}
> 		print "\n<br><br>";
> 		print &ScriptLink( "action=rc&from=$lastTs", "List new changes starting from" );
> 		print "\n " . &TimeToText($lastTs);
> 		print "\n<br><br>";
> 	}
> 	
> 	$i = 0;
> 	while ( $i < @fullrc ) {    
> 		# Optimization: skip old entries quickly
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		if ( $ts >= $starttime ) {
> 			$i -= 1000 if ( $i > 0 );
> 			last;
> 		}
> 		$i += 1000;
> 	}
> 	
> 	$i -= 1000 if ( ( $i > 0 ) && ( $i >= @fullrc ) );
> 	for ( ; $i < @fullrc ; $i++ ) {
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	if ( $i == @fullrc && $showHTML ) {
> 		print "\n<br><strong>";
> 		print "\nNo updates since ";
> 		print &TimeToText($starttime);
> 		print "\n</strong><br>";
> 	}
> 	else {
> 		splice( @fullrc, 0, $i );    # Remove items before index $i
> 		
> 		# Consider an end-time limit (items older than X)
> 		if ( 0 == $rcType ) {
> 			print &GetRcRss(@fullrc);
> 		}
> 		else {
> 			print &GetRcHtml(@fullrc);
> 		}
> 	}
> 	if ($showHTML) {
> 		print "\nPage generated ";
> 		print &TimeToText($Now);
> 		print "\n<br>";
> 	}
> }
> 
> sub GetRc {
> 	my $rcType = shift;
> 	my @outrc  = @_;
> 	my ( $rcline,   $date, $newtop, $author, $inlist,   $result );
> 	my ( $showedit, $link, $all,    $idOnly, $headItem, $item );
> 	my ( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp );
> 	my ( $rcchangehist, $tEdit, $tChanges, $tDiff );
> 	my ( $headList, $historyPrefix, $diffPrefix );
> 	my %extra      = ();
> 	my %changetime = ();
> 	my %pagecount  = ();
> 
> 	# Slice minor edits
> 	$showedit = &GetParam( "rcshowedit", $ShowEdits );
> 	$showedit = &GetParam( "showedit",   $showedit );
> 	if ( $showedit != 1 ) {
> 		my @temprc = ();
> 		foreach $rcline (@outrc) {
> 			( $ts, $pagename, $summary, $isEdit, $host ) =
> 			  split( /$FS3/, $rcline );
> 			if ( $showedit == 0 ) {    # 0 = No edits
> 				push( @temprc, $rcline ) if ( !$isEdit );
> 			}
> 			else {                     # 2 = Only edits
> 				push( @temprc, $rcline ) if ($isEdit);
> 			}
> 		}
> 		@outrc = @temprc;
> 	}
> 
> 	# Optimize param fetches out of main loop
> 	$rcchangehist = &GetParam( "rcchangehist", 1 );
> 
> 	# Optimize translations out of main loop
> 	$tEdit         = "(edit)";
> 	$tDiff         = "(diff)";
> 	$tChanges      = "changes";
> 	$diffPrefix    = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
> 	$historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
> 	
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename ) = split( /$FS3/, $rcline );
> 		$pagecount{$pagename}++;
> 		$changetime{$pagename} = $ts;
> 	}
> 	
> 	$date     = "";
> 	$all      = &GetParam( "rcall", 0 );
> 	$all      = &GetParam( "all", $all );
> 	$newtop   = &GetParam( "rcnewtop", $RecentTop );
> 	$newtop   = &GetParam( "newtop", $newtop );
> 	$idOnly   = &GetParam( "rcidonly", "" );
> 	$inlist   = 0;
> 	$headList = "";
> 	$result   = "";
> 	@outrc    = reverse @outrc if ($newtop);
> 
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp ) =
> 		  split( /$FS3/, $rcline );
> 		next if ( ( !$all ) && ( $ts < $changetime{$pagename} ) );
> 		next if ( ( $idOnly ne "" ) && ( $idOnly ne $pagename ) );
> 		%extra = split( /$FS2/, $extraTemp, -1 );
> 		if ( $date ne &CalcDay($ts) ) {
> 			$date = &CalcDay($ts);
> 			if ( 1 == $rcType ) {    # HTML
> 				                     # add date, properly closing lists first
> 				if ($inlist) {
> 					$result .= "</ul>";
> 					$inlist = 0;
> 				}
> 				$result .= "\n<p><strong>" . $date . "</strong></p>";
> 				if ( !$inlist ) {
> 					$result .= "\n<ul>";
> 					$inlist = 1;
> 				}
> 			}
> 		}
> 		if ( 0 == $rcType ) {        # RSS
> 			( $headItem, $item ) = &GetRssRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $diffPrefix,
> 				$historyPrefix
> 			);
> 			$headList .= $headItem;
> 			$result   .= $item;
> 		}
> 		else {                       # HTML
> 			$result .= &GetHtmlRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $tEdit,
> 				$tDiff,             $tChanges,
> 				$all,               $rcchangehist
> 			);
> 		}
> 	}
> 	if ( 1 == $rcType ) {
> 		$result .= "</ul>" if ($inlist);    # Close final tag
> 	}
> 	return ( $headList, $result );            # Just ignore headList for HTML
> }
> 
> sub GetRcHtml {
> 	my ( $html, $extra );
> 	( $extra, $html ) = &GetRc( 1, @_ );
> 	return $html;
> }
> 
> sub GetHtmlRcLine {
> 	my (
> 		$pagename, $timestamp, $host,      $userName, $userID,
> 		$summary,  $isEdit,    $pagecount, $revision, $tEdit,
> 		$tDiff,    $tChanges,  $all,       $rcchangehist
> 	  )
> 	  = @_;
> 	my ( $author, $sum, $edit, $count, $link, $html );
> 	
> 	$html = "";
> 	$host = &QuoteHtml($host);
> 	if ( defined($userName) && defined($userID) ) {
> 		$author = &GetAuthorLink( $host, $userName, $userID );
> 	}
> 	else {
> 		$author = &GetAuthorLink( $host, "", 0 );
> 	}
> 	
> 	$sum = "";
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);
> 		$sum     = "<strong>[$summary]</strong> ";
> 	}
> 	
> 	$edit  = "";
> 	$edit  = "<em>$tEdit</em> " if ($isEdit);
> 	$count = "";	
> 	if ( ( !$all ) && ( $pagecount > 1 ) ) {
> 		$count = "($pagecount ";
> 		if ($rcchangehist) {
> 			$count .= &GetHistoryLink( $pagename, $tChanges, "Click to view revision history" );
> 		}
> 		else {
> 			$count .= $tChanges;
> 		}
> 		$count .= ") ";
> 	}
> 	
> 	$link = "";
> 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) {
> 		$link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  ";
> 	}
> 	$link .= &GetPageLink($pagename);
> 	$html .= "\n<li>$link ";
> 	$html .= &CalcTime($timestamp) . " : $count$edit" . " $sum";
> 	$html .= ". . . . . $author";
> 	return $html;
> }
> 
> sub GetRcRss {
> 	my ( $rssHeader, $headList, $items );
> 
> 	# Normally get URL from script, but allow override
> 	$FullUrl         = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$QuotedFullUrl   = &QuoteHtml($FullUrl);
> 	$SiteDescription = &QuoteHtml($SiteDescription);
> 	my $ChannelAbout =
> 	  &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
> 	$rssHeader = <<RSS ;
> <?xml version="1.0" encoding="ISO-8859-1"?>
> <rdf:RDF
>     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
>     xmlns="http://purl.org/rss/1.0/"
>     xmlns:dc="http://purl.org/dc/elements/1.1/"
>     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
> >
>     <channel rdf:about="$ChannelAbout">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
>         <description>${\(&QuoteHtml($SiteDescription))}</description>
>         <wiki:interwiki>
>             <rdf:Description link="$QuotedFullUrl">
>                 <rdf:value>$InterWikiMoniker</rdf:value>
>             </rdf:Description>
>         </wiki:interwiki>
>         <items>
>             <rdf:Seq>
> RSS
> 	( $headList, $items ) = &GetRc( 0, @_ );
> 	$rssHeader .= $headList;
> 	return <<RSS ;
> $rssHeader
>             </rdf:Seq>
>         </items>
>     </channel>
>     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <url>$RssLogoUrl</url>
>         <link>$QuotedFullUrl</link>
>     </image>
> $items
> </rdf:RDF>
> RSS
> }
> 
> sub GetRssRcLine {
> 	my (
> 		$pagename, $timestamp,  $host,   $userName,
> 		$userID,   $summary,    $isEdit, $pagecount,
> 		$revision, $diffPrefix, $historyPrefix
> 	  )
> 	  = @_;
> 	my (
> 		$itemID,     $description, $authorLink, $author, $status,
> 		$importance, $date,        $item,       $headItem
> 	);
> 
> 	# Add to list of items in the <channel/>
> 	$itemID = $FullUrl
> 	  . &ScriptLinkChar()
> 	  . &GetOldPageParameters( 'browse', $pagename, $revision );
> 	$itemID   = &QuoteHtml($itemID);
> 	$headItem = "                <rdf:li rdf:resource=\"$itemID\"/>";
> 
> 	# Add to list of items proper.
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$description = &QuoteHtml($summary);
> 	}
> 	$host = &QuoteHtml($host);
> 	if ($userName) {
> 		$author     = &QuoteHtml($userName);
> 		$authorLink = "link=\"$QuotedFullUrl?$author\"";
> 	}
> 	else {
> 		$author = $host;
> 	}
> 	$status     = ( 1 == $revision ) ? 'new'   : 'updated';
> 	$importance = $isEdit            ? 'minor' : 'major';
> 	$timestamp += $TimeZoneOffset;
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($timestamp);
> 	$year += 1900;
> 	$date = sprintf( "%4d-%02d-%02dT%02d:%02d:%02d+%02d:00", $year, $mon + 1, $mday, $hour, $min, $sec, $TimeZoneOffset / ( 60 * 60 ) );
> 	$pagename = &QuoteHtml($pagename);
> 
> 	# Write it out longhand
> 	$item = <<RSS ;
>     <item rdf:about="$itemID">
>         <title>$pagename</title>
>         <link>$QuotedFullUrl?$pagename</link>
>         <description>$description</description>
>         <dc:date>$date</dc:date>
>         <dc:contributor>
>             <rdf:Description wiki:host="$host" $authorLink>
>                 <rdf:value>$author</rdf:value>
>             </rdf:Description>
>         </dc:contributor>
>         <wiki:status>$status</wiki:status>
>         <wiki:importance>$importance</wiki:importance>
>         <wiki:diff>$diffPrefix$pagename</wiki:diff>
>         <wiki:version>$revision</wiki:version>
>         <wiki:history>$historyPrefix$pagename</wiki:history>
>     </item>
> RSS
> 	return ( $headItem, $item );
> }
> 
> sub DoRss {
> 	print "\nContent-type: text/xml\n\n";
> 	&DoRc(0);
> }
> 
> sub DoRandom {
> 	my ( $id, @pageList );
> 	
> 	@pageList = &AllPagesList();                              # Optimize?
> 	$id       = $pageList[ int( rand( $#pageList + 1 ) ) ];
> 	
> 	&ReBrowsePage( $id, "", 0 );
> }
>    
> sub DoHistory {
> 	my ($id) = @_;
> 	my ( $html, $canEdit, $row, $newText );
> 
> 	print &GetHeader( "", Ts( 'History of %s', $id ), "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikiadmin'>";
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$newText = $Text{'text'};
> 	$canEdit = 0;
> 	$canEdit = &UserCanEdit($id) if ($HistoryEdit);
> 		
> 	if ($UseDiff) {
>       print "\n<form id='wikiform' action='$ScriptName' method='get'>";
>       print "\n<input type='hidden' name='action' value='browse'/>";
>       print "\n<input type='hidden' name='diff' value='1'/>";
>       print "\n<input type='hidden' name='id' value=\"$id\"/>";
>       print "\n<table class='wikihistory' border='0' width='90%'>";
> 	}
> 	
> 	$html = &GetHistoryLine( $id, $Page{'text_default'}, $canEdit, $row++ );
> 	&OpenKeptRevisions('text_default');
> 	
> 	foreach ( reverse sort { $a <=> $b } keys %KeptRevisions ) {
> 		next if ( $_ eq "" );    # (needed?)
> 		$html .= &GetHistoryLine( $id, $KeptRevisions{$_}, $canEdit, $row++ );
> 	}
> 	
> 	print $html;
> 	
> 	if ($UseDiff) {
> 		my $label = "Compare";
> 		
> 		print "\n<tr><td align='center'><br>";
> 		print "\n<input type='submit' value='$label'/>&nbsp;&nbsp;</td></tr></table></form>";
> 		print &GetDiffHTML( &GetParam( 'defaultdiff', 1 ), $id, "", "", $newText );
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetMaskedHost {
> 	my ($text) = @_;
> 	my ($logText);
> 	if ( !$MaskHosts ) {
> 		return $text;
> 	}
> 	$logText = "(logged)";
> 	if ( !( $text =~ s/\d+$/$logText/ ) ) { # IP address (ending numbers masked)
> 		$text =~ s/^[^\.\(]+/$logText/;     # Host name: mask until first .
> 	}
> 	return $text;
> }
> 
> sub GetHistoryLine {
> 	my ( $id, $section, $canEdit, $row ) = @_;
> 	my ( $html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor );
> 	my ( %sect, %revtext );
> 	%sect = split( /$FS2/, $section, -1 );
> 	%revtext = split( /$FS3/, $sect{'data'} );
> 	$rev     = $sect{'revision'};
> 	$summary = $revtext{'summary'};
> 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) {
> 		$host = $sect{'host'};
> 	}
> 	else {
> 		$host = $sect{'ip'};
> 	}
> 	$host     = &GetMaskedHost($host);
> 	$user     = $sect{'username'};
> 	$uid      = $sect{'id'};
> 	$ts       = $sect{'ts'};
> 	$minor    = "";
> 	$minor    = "<i>(edited) </i>" if ( $revtext{'minor'} );
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 
> 	if ($UseDiff) {
> 		my ( $c1, $c2 );
> 		$c1 = "checked='checked'" if 1 == $row;
> 		$c2 = "checked='checked'" if 0 == $row;
> 		$html .= "\n<tr>";
> 		$html .= "\n<td align='center'>";
> 		$html .= "\n<input type='radio' name='diffrevision' value='$rev' $c1/>";
> 		$html .= "\n<input type='radio' name='revision' value='$rev' $c2/>";
> 		$html .= "</td><td>";
> 	}
> 	if ( 0 == $row ) {    
> 		# current revision
> 		$html .= &GetPageLinkText( $id, Ts( 'RevisionB %s', $rev ) ) . ' ';
> 		
> 		if ($canEdit) {
> 			$html .= &GetEditLink( $id, "Edit" ) . ' ';
> 		}
> 	}
> 	else {
> 		$html .= &GetOldPageLink( 'browse', $id, $rev, Ts( 'RevisionA %s', $rev ) ) . ' ';
> 		if ($canEdit) {
> 			$html .= &GetOldPageLink( 'edit', $id, $rev, "Edit" ) . ' ';
> 		}
> 	}
> 	$html .= "\n<td>" . &TimeToText($ts) . "</td>";
> 	$html .= "\n<td> by " . &GetAuthorLink( $host, $user, $uid ) . " $minor</td>";
> 	
> 	if ( defined($summary) && ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);    # Thanks Sunir! :-)
> 		$html .= "\n<td>[$summary]</td>";
> 	}
> 	else {
> 		$html .= "\n<td>&nbsp;</td>";
> 	}
> 	$html .= $UseDiff ? "</tr>" : "\n<br>";
> 	return $html;
> }
> 
> # ==== HTML and page-oriented functions ====
> sub ScriptLinkChar {
> 	if ($SlashLinks) {
> 		return '/';
> 	}
> 	return '?';
> }
> 
> sub ScriptLink {
> 	my ( $action, $text ) = @_;
> 	
> 	return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\" class='wikiscriptlink' title='Click to visit page'>$text</a>";
> }
> 
> sub ScriptLinkClass {
> 	my ( $action, $text, $class, $title ) = @_;
> 	
> 	return "<a href='$ScriptName"
> 	  . &ScriptLinkChar()
> 	  . "$action' class='$class' title='$title'>$text</a>";
> }
> 
> sub ScriptLinkLeftNav {
> 	my ($id, $action, $target, $label, $type) = @_;
> 	my $html;
> 	my $title;
> 	my $class;	
> 	
> 	if ($type eq "1"){
> 		if ($action eq $target){ $html .= "\n<li class='disabled'>$label</li>"; }
> 		else { $html .= "\n<li><a class='wikipagelink' title='Click to visit this page.' href='\?action=$target'>$label</a></li>"; }	
> 		
> 	}
> 	else {
> 		my $authtype = &CheckIsAuthUser($target);
> 		
> 		if ($authtype eq ""){
> 			$title = "This page is private.";
> 			$class = "wikipagelink private";
> 			$label .= "!";
> 		}
> 		elsif ( $authtype eq "1"){
> 			$title = "Click to visit this locked page.";
> 			$class = "wikipagelink locked";
> 			$label .= "&not;";
> 		}
> 		else {
> 			$title = "Click to visit this page.";
> 			$class = "wikipagelink";		
> 		}
> 		
> 		if ($id eq $target){ $html .= "\n<li class='selected'>$label</li>"; }
> 		else { $html .= "\n<li><a class='$class' title='$title' href='\?$target'>$label</a></li>"; }		
> 	}
> }
> 
> sub GetOrphanLink {
> 	return &ScriptLink("action=orphans", T('Orphans'));
> }
> 
> sub DoOrphanList {
> 	print &GetHeader("", &QuoteHtml(T('Full Orphan List')), "");
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print &PrintPageList( "", &GetOrphanList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetOrphanList {
> 	my @found;	
> 	my %seen = ();
> 	my @pglist = &AllPagesList();
> 	
> 	foreach my $name (@pglist) {
> 		$seen{$name} = 0;
> 	}
> 	
> 	# pages linked from menu bar aren't orphans
> 	$seen{$HomePage} = 1;
> 	$seen{$RCName} = 1;
> 	
> 	foreach my $name (@pglist) {
> 		my @links = &GetPageLinks($name, 1, 0, 0, 0);
> 		
> 		foreach my $link (@links) {
> 			#don't include self links
> 			unless ($link eq $name) {
> 				$seen{$link}++ if exists $seen{$link};
> 			}
> 		}
> 	}
> 	
> 	foreach my $name (sort keys %seen) {
> 		push(@found, $name) if $seen{$name} < 1;
> 	}
> 	return @found;
> }
> 
> 
> sub GetPageLinkText {
> 	my ( $id, $name ) = @_;
> 	$id =~ s|^/|$MainPage/|;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 
> 	if ($authtype eq ""){
> 		return &ScriptLinkClass( $id, "$name!", 'wikipagelink private', 'This page is private.' );
> 	}
> 		
> 	if ( -f &GetLockedPageFile($id) || $authtype eq "1"){
> 		return &ScriptLinkClass( $id, "$name&not;", 'wikipagelink locked', 'Click to visit this locked page' );
> 	}
> 	
> 	return &ScriptLinkClass( $id, $name, 'wikipagelink', 'Click to visit page' );
> }
> 
> sub GetPageLink {
> 	my ($id) = @_;
> 	return &GetPageLinkText( $id, $id );
> }
> 
> sub GetEditLink {
> 	my ( $id, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	return &ScriptLinkClass( "action=edit&id=$id", $name, 'wikipageedit', 'Click to edit page' );
> }
> 
> sub GetCreateNewLink {
> 	my ( $id, $name ) = @_;
> 	my ( $html );
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	$html  = "<a href='$ScriptName";
> 	$html .= &ScriptLinkChar();
> 	$html .= "action=edit&id=$id' class='wikicreatepagelink' title='Create this entry'>";
> 	$html .= $name;
> 	$html .= "<span class='wikilinkicon'>&nbsp;</span>";
> 	$html .= "</a>";
> 	
> 	return $html;
> }
> 
> sub GetDeleteLink {
> 	my ( $id, $name, $confirm ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	return &ScriptLink( "action=delete&id=$id&confirm=$confirm", $name );
> }
> 
> sub GetOldPageParameters {
> 	my ( $kind, $id, $revision ) = @_;
> 	$id = &FreeToNormal($id) if $FreeLinks;
> 	return "action=$kind&id=$id&revision=$revision";
> }
> 
> sub GetOldPageLink {
> 	my ( $kind, $id, $revision, $name ) = @_;
> 	$name =~ s/_/ /g if $FreeLinks;
> 	return &ScriptLink( &GetOldPageParameters( $kind, $id, $revision ), $name );
> }
> 
> sub GetPageOrEditAnchoredLink {
> 	my ( $id, $anchor, $name ) = @_;
> 	my ( @temp, $exists );
> 	my $NamedFreeLink = 0;
> 	
> 	if ( $name eq "" ) {
> 		$name = $id;
> 		if ($FreeLinks) {
> 			$name =~ s/_/ /g;
> 		}
> 	}
> 	else {
> 		$NamedFreeLink = 1;
> 	}
> 	
> 	$id =~ s|^/|$MainPage/|;
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	$exists = 0;
> 	
> 	if ($UseIndex) {
> 		if ( !$IndexInit ) {
> 			@temp = &AllPagesList();    # Also initializes hash
> 		}
> 		$exists = 1 if ( $IndexHash{$id} );
> 	}
> 	elsif ( -f &GetPageFile($id) ) {    # Page file exists
> 		$exists = 1;
> 	}
> 	
> 	if ($exists) {
> 		$id = "$id#$anchor" if $anchor;
> 		$name = "$name#$anchor"  if $anchor && $NamedAnchors != 2 && !$NamedFreeLink;
> 		
> 		return &GetPageLinkText( $id, $name );
> 	}
> 	if ( $FreeLinks && !$EditNameLink ) {
> 		if ( $name =~ m| | ) {          # Not a single word
> 			$name = "[$name]";          # Add brackets so boundaries are obvious
> 		}
> 	}
> 	if ($EditNameLink) {
> 		return &GetEditLink( $id, $name );
> 	}
> 	else {
> 		return &GetCreateNewLink( $id, $name );
> 	}
> }
> 
> sub GetPageOrEditLink {
> 	my ( $id, $name ) = @_;
> 	my ($link, $anchor) = split( /#/, $id, 2);
> 	
> 	return &GetPageOrEditAnchoredLink($link, $anchor, $name);
> }
> 
> sub GetBackLinksSearchLink {
> 	my ($id) = @_;
> 	my $name = $id;
> 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
> 	
> 	if ($FreeLinks) {
> 		$name =~ s/_/ /g;    # Display with spaces
> 		$id   =~ s/_/+/g;    # Search for url-escaped spaces
> 	}
> 	return &ScriptLinkTitle( "back=$id", $name, "Click to see which pages link to this one" );
> }
> 
> sub GetPrefsLink {
> 	return &ScriptLink( "action=editprefs", "Preferences" );
> }
> 
> sub GetRandomLink {
> 	return &ScriptLink( "action=random", "Random Page" );
> }
> 
> sub ScriptLinkDiff {
> 	my ( $diff, $id, $text, $rev ) = @_;
> 	
> 	$rev = "&revision=$rev" if ( $rev ne "" );
> 	$diff = &GetParam( "defaultdiff", 1 ) if ( $diff == 4 );
> 	
> 	return &ScriptLinkTitle( "action=browse&diff=$diff&id=$id$rev", $text, "Click to view last revision" );
> }
> 
> sub GetUploadLink {
> 	return &ScriptLink( 'action=upload', "Upload" );
> }
> 
> sub ScriptLinkTitle {
> 	my ( $action, $text, $title ) = @_;
> 	if ($FreeLinks) {
> 		$action =~ s/ /_/g;
> 	}
> 	return "<a href=\"$ScriptName"
> 	  . &ScriptLinkChar()
> 	  . "$action\" title=\"$title\" class='wikiscriptlinktitle'>$text</a>";
> }
> 
> sub GetAuthorLink {
> 	my ( $host, $userName, $uid ) = @_;
> 	my ( $html, $title, $userNameShow );
> 	$userNameShow = $userName;
> 	
> 	if ($FreeLinks) {
> 		$userName     =~ s/ /_/g;
> 		$userNameShow =~ s/_/ /g;
> 	}
> 	if ( &ValidId($userName) ne "" ) {    # Invalid under current rules
> 		$userName = "";                   # Just pretend it isn't there.
> 	}
> 	if ( ( $uid > 0 ) && ( $userName ne "" ) ) {
> 		$html = &ScriptLinkTitle( "$HomePagePrefix/$userName", $userNameShow, Ts( 'ID %s', $uid ) . ' ' . Ts( 'from %s', $host ) );
> 	}
> 	else {
> 		$html = $host;
> 	}
> 	return $html;
> }
> 
> sub GetHistoryLink {
> 	my ( $id, $text, $title ) = @_;
> 	if ($FreeLinks) {
> 		$id =~ s/ /_/g;
> 	}
> 	return &ScriptLinkTitle( "action=history&id=$id", $text, $title );
> }
> 
> sub GetHeader {
> 	my ( $id, $title, $oldId ) = @_;
> 	my $header    = "";
> 	my $logoImage = "";
> 	my $result    = "";
> 	my $embed     = &GetParam( 'embed', $EmbedWiki );
> 	my $altText   = "[Home]";
> 	my $temp      = "";
> 	
> 	$result = &GetHttpHeader("");
> 	
> 	if ($FreeLinks) {
> 		$title =~ s/_/ /g;    # Display as spaces
> 	}
> 	
> 	$result .= &GetHtmlHeader("$SiteName: $title", $id);
> 	
> 	return $result if ($embed);
> 	$result .= "<div class='wikiheader'>";
> 	
> 	if ( $oldId ne "" ) {
> 		$result .=
> 		  $q->h3( '(' . Ts( 'redirected from %s', &GetEditLink( $oldId, $oldId ) )  . ')' );
> 	}
> 	
> 	if ( ( !$embed ) && ( $LogoUrl ne "" ) ) {
> 		$logoImage = "img class='wikilogo' src=\"$LogoUrl\" alt=\"$altText\" border=0";
> 		
> 		if ( !$LogoLeft ) {
> 			$logoImage .= " align=\"right\"";
> 		}
> 		$header = &ScriptLink( $HomePage, "\n<$logoImage>" );
> 	}
> 	
> 	if ( $id ne "" ) {
> 		my $authtype = &CheckIsAuthUser($id);
> 		if (&PageIsLocked($id, 1) || $authtype eq "1"){
> 			$temp = "<span class='wikilockicon' title='This page is locked.'>&nbsp;</span>";
> 		}
> 		else {	
> 			if ( -f &GetLockedPageFile($id) ) {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='This page locked for others. Click to edit page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 			else {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='Click to edit this page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 		}		
> 		$result .= $q->h1( $header . &GetBackLinksSearchLink($id) . $temp );
> 	}
> 	else {
> 		$result .= $q->h1( $header . $title );
> 	}
> 	
> 
> 	if ( &GetParam( "toplinkbar", 1 ) ) {		
> 		$result .= &GetGotoBar($id);
> 		$result .= $WikiLineHeader;
> 	}
> 	$result .= "</div>";	
> 	return $result;
> }
> 
> sub GetHttpHeader {
> 	my ($type) = @_;
> 	my $cookie;
> 	$type = "text/html" if ( $type eq "" );
> 	if ( defined( $SetCookie{'id'} ) ) {
> 		$cookie =
> 		   "$CookieName=" . "rev&"
> 		  . $SetCookie{'rev'} . "&id&"
> 		  . $SetCookie{'id'}
> 		  . "&randkey&"
> 		  . $SetCookie{'randkey'};
> 		$cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
> 		if ( $HttpCharset ne "" ) {
> 			return $q->header(
> 				-cookie => $cookie,
> 				-type   => "$type; charset=$HttpCharset"
> 			);
> 		}
> 		return $q->header( -cookie => $cookie );
> 	}
> 	if ( $HttpCharset ne "" ) {
> 		return $q->header( -type => "$type; charset=$HttpCharset" );
> 	}
> 	return $q->header( -type => $type );
> }
> 
> sub GetHtmlHeader {
> 	my ($title, $id) = @_;
> 	my ( $dtd, $html, $bodyExtra, $stylesheet );
> 	
> 	$html  = "";
> 	$dtd   = "-//IETF//DTD HTML//EN";
> 	$html  = qq(<!DOCTYPE HTML PUBLIC "$dtd">);
> 	$title = $q->escapeHTML($title);
> 	$html .= "\n<html><head><title>$title</title>";
> 	
> 	if ( $FavIcon ne "" ) {
> 		$html .= "<link rel='SHORTCUT ICON' href='$FavIcon'>";
> 	}
> 	
> 	if ($MetaKeywords) {
> 		my $keywords = $OpenPageName;
> 		$keywords =~ s/([a-z])([A-Z])/$1, $2/g;
> 		$html .= "\n<meta name='keywords' content='$keywords'/>" if $keywords;
> 	}
> 	
> 	if ( $SiteBase ne "" ) {
> 		$html .= qq(<base href="$SiteBase">);
> 	}
> 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
> 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
> 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
> 	
> 	if ( $stylesheet ne "" ) {
> 		$html .= qq(<link rel="stylesheet" href="$stylesheet">);
> 	}
> 
>    my $bots = "";
>    # actions and non-existant page views don't get indexed or followed by robots
>    if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
>    $bots = $bots . 'index,' . $bots . 'follow';
>    $html .= qq(<meta name="robots" content="$bots" />\n);
> 	
> 	$html .= $UserHeader;
> 	$bodyExtra = "";
> 	
> 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
> 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
> 	
> 	$html .= "</head><body$bodyExtra>";
> 	$html .= "\n<div id='wikicontainer'>";
> 	
> 	return $html;
> }
> 
> sub GetLeftNav {
> 	my $id = shift;
> 	my $action = &GetParam( "action", "" );
> 	my $html = "";
> 	
> 	$html .= "\n<div class='wikileftnav'>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'HomePage', 'Home page', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'NobleWiki', 'Wiki Info', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'CategoryCategory', 'Contents', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'FeaturedContent', 'Featured', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'random', 'Random Article', "1");	
> 	
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>	";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'RecentChanges', 'Recent changes', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'ListOfWantedPages', 'Wanted Pages', "");
> 					
> 	if ($id ne ""){
> 		unless ($id eq 'ListOfWantedPages' or $id eq 'RecentChanges'){	
> 			if (&UserCanEdit( $id, 0 )){ $html .= "\n<li><a href='?action=edit&id=$id'>Edit this Page</a></li>";	}
> 			else { $html .= "\n<li class='disabled'>Edit this Page</li>"; }
> 							
> 			if ($action eq 'history'){ $html .= "\n<li class='disabled'>Version History</li>"; }
> 			else { $html .= "\n<li><a href='?action=history&id=$id'>Version History</a></li>"; }
> 		}
> 		else {
> 			$html .= "\n<li class='disabled'>Edit this Page</li>"; 
> 			$html .= "\n<li class='disabled'>Version History</li>"; 
> 		}
> 	}
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'SandBox', 'SandBox', "");
> 	
> 	$html .= "\n	</ul></div>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'editprefs', 'Preferences', "1");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiContacts', 'Contact Us', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiHelp', 'Help', "");
> 		
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>";
> 	$html .= "\n	<div class='wikileftnavsearch' style='text-align:right;'>";
> 	$html .= "\n		<form>";
> 	$html .= "\n			<div class='wikisearchlabel' style='text-align:left;'><b>Search</b></div>";
> 	$html .= "\n			<input type='text' title='Enter ! before search term for exclusion' name='search' id='searchterm' />";
> 	$html .= "\n			<input type='submit' value='Go!' name='dosearch' title='Click to perform your search request.' />";
> 	$html .= "\n		</form></div>";
> 	$html .= "\n</div>";
> 	
> 	return $html;	
> }
> 
> sub GetFooterText {
> 	my ( $id, $rev ) = @_;
> 	my $result;
> 	
> 	if ( &GetParam( 'embed', $EmbedWiki ) ) {
> 		return "";
> 	}
> 	
> 	$result = "<div class='wikifooter'>";
> 	$result .= &GetGotoBar($id);
> 	$result .= "<div class='wikirevision'>";
> 	
> 	if ($id ne ""){
> 		if ( &UserCanEdit( $id, 0 )) {
> 			if ( $rev ne "" ) {
> 				$result .=
> 				  &GetOldPageLink( 'edit', $id, $rev, Ts( 'Edit revision %s of this page', $rev ) );
> 			}
> 			else {
> 				$result .= &GetEditLink( $id, "Edit text of this page" );
> 			}
> 		}
> 		else {
> 			$result .= "This page is read-only";
> 		}
> 	}
> 	
> 	if ($id ne ""){ $result .= " | " . &GetHistoryLink( $id, "View other revisions", "Click to view revision history" ); }	
> 	if ( $rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
> 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?$id' class='wikiusemetalink'>Search MetaWiki</a>"; }
> 	
> 	$result .= "</div>";
> 	
> 	if ($id ne ""){ 
> 		if ( $Section{'revision'} > 0 ) {
> 			$result .= "<div class='wikirevision'>";		
> 			$result .= "Created " . &TimeToText($Page{'tscreate'});
> 			
> 			if ($Page{'authorcreate'}) { $result .= " by " . $Page{'authorcreate'}; } 
> 			
> 			$result .= " | ";	
> 			if ( $rev eq "" ) { $result .= "Last edited"; }
> 			else { $result .= "Edited"; }
> 			
> 			$result .= " " . &TimeToText( $Section{ts} );
> 				
> 			if ($AuthorFooter) { $result .= " by " . &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}); }
> 		}
> 		
> 		if ($UseDiff) { $result .= " " . &ScriptLinkDiff( 4, $id, "(diff)", $rev ); }
> 	}
> 	
> 	$result .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$result .= &GetSearchForm();	
> 	if ( $DataDir =~ m|/tmp/| ) {
> 		$result .= "\n<br><b>";
> 		$result .= "Warning";
> 		$result .= ":</b> ";
> 		$result .= "Database is stored in temporary directory $DataDir";
> 		$result .= "\n<br>";
> 	}
> 	
> 	if ( $ConfigError ne "" ) {
> 		$result .= "\n<br>";
> 		$result .= "\n<b>Config file error:</b>";
> 		$result .= "$ConfigError <br>";
> 	}
> 	
> 	$result .= "</form>";
> 	$result .= &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { $result .= &GetAdminBar($id, ""); }
> 	$result .= "</div>";
> 		
> 	return $result;
> }
> 
> sub getFooterNote {
> 	my $html;
> 	my $userid = &GetParam("username", "");
> 	my $access = "Guest ";
> 	my $username = "Anonymous";
> 
> 	if (UserIsAdmin()){
> 		$access = "Admin ";
> 	}
> 	elsif (UserIsEditor()){
> 		$access = "Editor ";
> 	}
> 	
> 	if ($userid ne ""){
> 		$username = $userid;
> 	}
> 	
> 	if ($FooterNote ne ""){
> 		$html = $FooterNote;
> 		$html =~ s/access/$access/;
> 		$html =~ s/username/$userid/;
> 	}
> 	
> 	return $html;
> }
> 
> sub GetCommonFooter {
> 	my ($html);
> 	my $id = &GetParam( "id",     "" );
> 	
> 	$html = $WikiLineFooter;
> 	$html .= "\n<div class='wikifooter'>";
> 	$html .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$html .= &GetGotoBar("");
> 	$html .= &GetSearchForm();
> 	$html .= "</form>";	
> 	$html .= &getFooterNote();
> 	
> 	if ( $AdminBar && &UserIsAdmin() ) { $html .= &GetAdminBar($id, "class='wikirevision'"); }
> 	$html .= "\n<div>"; ## ??NEEDED ??
> 	
> 	return $html;
> }
> 
> sub GetGotoBar {
> 	my ($id) = @_;
> 	my ( $main, $bartext );
> 	
> 	$bartext = "\n<div class='wikigotobar'>";
> 	$bartext .= &GetPageLink($HomePage);
> 	
> 	if ( $id =~ m|/| ) {
> 		$main = $id;
> 		$main =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		unless ($main eq $HomePage){
> 			$bartext .= " | " . &GetPageLink($main);
> 		}
> 	}
> 	
> 	$bartext .= " | " . &GetPageLink($RCName);
> 	$bartext .= " | " . &GetPrefsLink();
> 	
> 	if ( $UseUpload && &UserCanUpload() ) {
> 		$bartext .= " | " . &GetUploadLink();
> 	}
> 	
> 	$bartext .= " | " . &ScriptLink( "action=listfiles&filter=sample", "List Assets" );
> 	
> 	if ( &GetParam( "linkrandom", 0 ) ) {
> 		$bartext .= " | " . &GetRandomLink();
> 	}
> 	
> 	if ( $UserGotoBar ne "" ) {
> 		$bartext .= " | " . $UserGotoBar;
> 	}
> 	
> 	$bartext .= "</div>";
> 	
> 	return $bartext;
> }
> 
> sub GetSearchForm {
> 	my ($html);
> 	
> 	$html =  "\n<div class='wikisearch'>";
> 	$html .= "\n<div class='wikisearchlabel'>Search:</div>";
> 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";	
> 	if ($SearchButton) {
> 		$html .= " " . $q->submit( 'dosearch', "Go!" );
> 	}
> 	else {
> 		$html .= &GetHiddenValue( "dosearch", 1 );
> 	}
> 	
> 	$html .= "</div>";
> 	return $html;
> }
> 
> sub GetRedirectPage {
> 	my ( $newid, $name, $isEdit ) = @_;
> 	my ( $url, $html );
> 	my ($nameLink);
> 
> 	# Normally get URL from script, but allow override.
> 	$FullUrl  = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$url      = $FullUrl . &ScriptLinkChar() . $newid;
> 	$nameLink = "<a href='$url' class='wikiredirect'>$name</a>";
> 	
> 	if ( $RedirType < 3 ) {
> 		if ( $RedirType == 1 ) {    # Use CGI.pm
> 			 # NOTE: do NOT use -method (does not work with old CGI.pm versions)
> 			 # Thanks to Daniel Neri for fixing this problem.
> 			$html = $q->redirect( -uri => $url );
> 		}
> 		else {    # Minimal header
> 			$html = "Status: 302 Moved\n";
> 			$html .= "Location: $url\n";
> 			$html .= "Content-Type: text/html\n";   # Needed for browser failure
> 		}
> 		$html .= " Your browser should go to the $newid page.";
> 		$html .= " If it does not, click $nameLink to continue.";
> 	}
> 	else {
> 		if ($isEdit) {
> 			$html  = &GetHeader( "", "Thanks for editing...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
>  			$html .= "Thank you for editing $nameLink ";
> 		}
> 		else {
> 			$html = &GetHeader( "", "Link to another page...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
> 		}
> 		
> 		$html .= "Follow the $nameLink link to continue.";
> 		$html .= "</div>";
> 		$html .= "</div></div></body></html>";	
> 	}
> 	
> 	return $html;
> }
> 
> # ==== Common wiki markup ====
> sub RestoreSavedText {
> 	my ($text) = @_;
> 	
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
> }
> 
> sub RemoveFS {
> 	my ($text) = @_;
> 
> 	# Note: must remove all $FS, and $FS may be multi-byte/char separator
> 	$text =~ s/($FS)+(\d)/$2/g;
> 	
> 	return $text;
> }
> 
> sub WikiToHTML {
> 	my ($pageText) = @_;
> 	$TableMode       = 0;
> 	%SaveUrl         = ();
> 	%SaveNumUrl      = ();
> 	$SaveUrlIndex    = 0;
> 	$SaveNumUrlIndex = 0;
> 	$pageText        = &RemoveFS($pageText);
> 	
> 	if ($RawHtml) {
> 		$pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
> 	}
> 	
> 	$pageText = &QuoteHtml($pageText);
> 	$pageText =~ s/\\ *\r?\n/ /g;    # Join lines with backslash at end
> 		
> 	if ($ParseParas) {
> 
> 		# Note: The following 3 rules may span paragraphs, so they are
> 		#       copied from CommonMarkup
> 		$pageText =~ s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 		$pageText =~ s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		$pageText =~ s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		$pageText =~ s/\{{template:(\w+\s*.*?)}}/&StoreTemplate($1)/iges;
> 		$pageText =~ s/\{{flash:\s*(.*?)}}/&StoreRaw(&GetFlash($1))/iges;
> 		$pageText =~ s/\{{gallery:\s*(.*?)}}/&StoreRaw(&GetGallery($1))/iges;
> 		
> 		$pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
> 		$pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
> 		
> 	}
> 	else {
> 		$pageText = &WikiLinesToHtml($pageText);         # Line-oriented markup
> 		$pageText = &CommonMarkup( $pageText, 1, 0 );    # Multi-line markup
> 
> 	}
> 	
> 	while (@HeadingNumbers) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$pageText =~ s/&lt;toc&gt;/<div class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/&lt;toc ((\d)+)?&gt;/<div style='width: $1;' class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/\#SUBPAGES\s+(\w+.*?)/&StoreRaw("\n<h6>" . Ts('Subpages of: %s', &QuoteHtml($1)) . "<\/h6>" . &GetPageList(&GetSubpages($1)))/ige;
> 	$pageText =~ s/\#SUBPAGES/&StoreRaw("\n<h6>" . Ts('Subpages for %s', $MainPage) . "<\/h6>" . &GetPageList(&GetSubpages($MainPage)))/ige;
> 	
> 	if ( $LateRules ne "" ) {
> 		$pageText = &EvalLocalRules( $LateRules, $pageText, 0 );
> 	}
> 	
> 	return &RestoreSavedText($pageText);
> }
> 
> sub CommonMarkup {
> 	my ( $text, $useImage, $doLines ) = @_;
> 	local $_ = $text;
> 	
> 	if ( $doLines < 2 ) {    # 2 = do line-oriented only
> 		
> 		while ( m!\#INCLUDE\s*((\w+\.?\w*|/)+)!gi and $AllowInclusion ) {		
> 			my $FileName = $1;
> 			
> 			open FILE, "$InclusionDir/$FileName"
> 			or &ReportError(T("Cannot open $FileName: $!"));
> 			
> 			local $/;			
> 			my $FileContent = <FILE>;
> 			
> 			close FILE
> 			or &ReportError(T("Cannot close $FileName: $!"));
> 			s!\#INCLUDE\s*$FileName!$FileContent!i unless $FileName !~ /(html?|txt)$/i;
> 		}
>   
> 		# The <nowiki> tag stores text with no markup (except quoting HTML)
> 		s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 
> 		# The <pre> tag wraps the stored text with the HTML <pre> tag
> 		s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		
> 		if ( $EarlyRules ne "" ) {
> 			$_ = &EvalLocalRules( $EarlyRules, $_, !$useImage );
> 		}
> 		
> 		s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
> 		
> 		if ($HtmlTags) {
> 			my ($t);
> 			foreach $t (@HtmlPairs) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
> 			}
> 			foreach $t (@HtmlSingle) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
> 			}
> 		}
> 		else {
> 
> 			# Note that these tags are restricted to a single line
> 			s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
> 			s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
> 			s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
> 			s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
> 		}
> 
> 		# Auto signature if use ~~~~ ; useful for quick comments
> 	    my $id = &GetParam("username", "");
> 		my $idLink = "$HomePagePrefix/$id";
> 		my $timestamp = &TimeToText($Now);
> 		my $finalText = "";
> 		
> 		$id =~ s/ /_/g;
> 
> 		if ($id){
> 			$finalText = &StorePageOrEditLink($idLink, $id);
> 			s/\~\~\~\~/<i>\[$finalText]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$finalText at $timestamp]<\/i>/gi;
> 		}
> 		else {
> 			$id = "Guest";			
> 			s/\~\~\~\~/<i>\[$id at $timestamp]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$id at $timestamp]<\/i>/gi;
> 		}
> 		
> 		s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;    # <tt> (MeatBall)
> 		s/\&lt;br\&gt;/<br>/gi;    # Allow simple line break anywhere
> 		
> 		if ($HtmlLinks) {
> 			s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
> 		}
> 		
> 		if ($FreeLinks) {
> 
> 			# Consider: should local free-link descriptions be conditional?
> 			# Also, consider that one could write [[Bad Page|Good Page]]?
> 			s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
> 			s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
> 		}
> 		
> 		if ($BracketText) {        
> 			# Links like [URL text of link]
> 			s/\[$UrlPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketUrl($1, $2, $useImage, $3)/geos;
> 			s/\[$InterLinkPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketInterPage($1, $2, $useImage, $3)/geos;
> 			
> 			if ( $WikiLinks && $BracketWiki ) {    # Local bracket-links
> 				s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
> 				s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1, $2, $3)/geos if $NamedAnchors;
> 			}
> 		}
> 		
> 		s/\[$UrlPattern(\|(.*))?\]/&StoreBracketUrl($1, "", 0, "")/geo;
> 		s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0, "")/geo;
> 		s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
> 		s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
> 		
> 		if ($WikiLinks) {
> 			s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1, $2, ""))/geo if $NamedAnchors;
> 
> 			# CAA: Putting \b in front of $LinkPattern breaks /SubPage links
> 			#      (subpage links without the main page)
> 			s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
> 		}
> 		s/\b$RFCPattern/&StoreRFC($1)/geo;
> 		s/\b$ISBNPattern/&StoreISBN($1)/geo;
> 		
> 		if ($UseUpload) {
> 			s/$UploadPattern/&StoreUpload($1)/geo;
> 		}
> 		
> 		if ($ThinLine) {
> 			if ($OldThinLine) {   
> 				# Backwards compatible, conflicts with headers
> 				s/====+/$WikiLine2/g;
> 			}
> 			else {                
> 				# New behavior--no conflict
> 				s/------+/$WikiLine2/g;
> 			}
> 			s/----+/$WikiLine1/g;
> 		}
> 		else {
> 			s/----+/$WikiLine/g;
> 		}
> 		
> 		if ($AutoMailto) {
> 			s/([A-z0-9-_]+(?:\.[A-z0-9-_]+)*)\@([A-z0-9-_]+(?:\.[A-z0-9-_]+)*(?:\.[A-z]{2,})+)/<a href="mailto:$1\@$2">$1\@$2<\/a>/g;
> 		}
> 	}
> 	
> 	if ($doLines) {    
> 			# 0 = no line-oriented, 1 or 2 = do line-oriented
> 		    # The quote markup patterns avoid overlapping tags (with 5 quotes)
> 		    # by matching the inner quotes for the strong pattern.
> 		s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g; #'REMARK
> 		s/''(.*?)''/<em>$1<\/em>/g;
> 		
> 		if ($UseHeadings) {
> 		 ## s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
> 			s/(^|\n)\s*(\=+)\s*(#)?\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $4, $3)/geo;
> 		}
> 		
> 		if ($TableMode == 1) {
> 			my @cells = split(/\|\|/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\|\|)+([^\|<]+)/) {	
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\|\|)+)/"<\/td><td $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;
> 			} 
> 			s/(\|\w*=\w*)+([^\|<]+)//g;   
> 		}
> 		elsif  ($TableMode == 2) {
> 			my @cells = split(/\!\!/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\!\!)+([^\!<]+)/) {			
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\!\!)+)/"<\/th><th $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;				
> 			}
> 			s/(\|\w*=\w*)+([^\!<]+)//g;
> 		}
> 	}
> 	
> 	return $_;
> }
> 
> sub GetTableCellModifiers {
> 	my ($given, $initialCell, $cellIndex) = @_;	
> 	my ($options) = $given;
> 
> 	/^(\s*(\w+)\s*)\|/;
> 	my $align = $2;
> 	if ($initialCell ne ""){ $align = $initialCell; }
> 		
> 	$align = $align =~ /^  / ? ($align =~ /  $/ ? 'center' : 'right') : 'left';
> 	$align = "align='$align'";
> 	
> 	my ($options) = $options =~ /(\|\S*=\S*)+/g;
> 	my %options = &GetOptions($options);
> 
> 	my $class;
> 	my $style;
> 	my $width;	
> 	my $rowclass;
> 	my $rowstyle;
> 	my $rowalign;
> 	my $tablewidth;
> 	my $tableclass;
> 	my $tablestyle;
> 		
> 	if ($TableCellDefaults{"rowclass"} =~ /clear/){ $TableCellDefaults{"rowclass"} = ""; }
> 	if ($TableCellDefaults{"rowstyle"} =~ /clear/){ $TableCellDefaults{"rowstyle"} = ""; }
> 	if ($TableCellDefaults{"rowalign"} =~ /clear/){ $TableCellDefaults{"rowalign"} = ""; }
> 				
> 	if ($TableCellDefaults{"rowclass"}){ $rowclass = $TableCellDefaults{"rowclass"}; }
> 	if ($TableCellDefaults{"rowstyle"}){ $rowstyle = $TableCellDefaults{"rowstyle"}; }
> 	if ($TableCellDefaults{"rowalign"}){ $rowalign = $TableCellDefaults{"rowalign"}; }
> 		
> 	if ($options{'rowclass'}){ $rowclass = "class='" . $options{'rowclass'} . "'"; $TableCellDefaults{"rowclass"} = $rowclass; }
> 	if ($options{'rowstyle'}){ $rowstyle = "style='" . $options{'rowstyle'} . "'"; $TableCellDefaults{"rowstyle"} = $rowstyle; }
> 	if ($options{'rowalign'}){ $rowalign = "align='" . $options{'rowalign'} . "'"; $TableCellDefaults{"rowalign"} = $rowalign; }
> 	
> 	if ($rowclass){ $class = $rowclass; }
> 	if ($rowstyle){ $style = $rowstyle; }
> 	if ($rowalign){ $align = $rowalign; }
> 
> 	if ($TableCellDefaults{"class$cellIndex"} =~ /clear/){ $TableCellDefaults{"class$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"style$cellIndex"} =~ /clear/){ $TableCellDefaults{"style$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"align$cellIndex"} =~ /clear/){ $TableCellDefaults{"align$cellIndex"} = ""; }
> 			
> 	if ($TableCellDefaults{"class$cellIndex"}){ $class = $TableCellDefaults{"class$cellIndex"}; }
> 	if ($TableCellDefaults{"style$cellIndex"}){ $style = $TableCellDefaults{"style$cellIndex"}; }
> 	if ($TableCellDefaults{"align$cellIndex"}){ $align = $TableCellDefaults{"align$cellIndex"}; }
> 
> 	if ($options{'class'}){ $class = "class='" . $options{'class'} . "'"; $TableCellDefaults{"class$cellIndex"} = $class; }
> 	if ($options{'style'}){ $style = "style='" . $options{'style'} . "'"; $TableCellDefaults{"style$cellIndex"} = $style; }
> 	if ($options{'align'}){ $align = "align='" . $options{'align'} . "'"; $TableCellDefaults{"align$cellIndex"} = $align; }
> 	if ($options{'width'}){ $width = "width='" . $options{'width'} . "'"; }
> 	if ($options{'tablewidth'}){ $tablewidth = "width='" . $options{'tablewidth'} . "'"; }
> 	if ($options{'tablestyle'}){ $tablestyle = "style='" . $options{'tablestyle'} . "'"; }
> 	if ($options{'tableclass'}){ $tableclass = "class='" . $options{'tableclass'} . "'"; } else { $tableclass = "class='wikilargelist'"; }
> 					
> 	return ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass);				
> }
> 
> sub WikiLinesToHtml {
> 	my ($pageText) = @_;
> 	my ( $pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode );
> 	
> 	@htmlStack = ();
> 	$depth     = 0;
> 	$pageHtml  = "";
> 	
> 	foreach ( split( /\r?\n/, $pageText ) ) {    # Process lines one-at-a-time
> 		$code           = "";
> 		$codeAttributes = "";
> 		$TableMode      = 0;
> 		$_ .= "\n";
> 		
> 		if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\:+)/<dt><dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\*+)/<li>/) {
> 			$code  = "ul";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\#+)/<li>/) {
> 			$code  = "ol";
> 			$depth = length $1;
> 		}
> 		elsif ($TableSyntax && /^(\!\!)+.*\!\!\s*$/) {
> 			/^(\!\!)+([^\!]+)/;
> 			
> 			%TableCellDefaults = {};
> 			
> 			my $switches = $2;
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, "", 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/th><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 2;
> 			$depth = 1;
> 		}
> 		elsif ($TableSyntax && /^(\|\|)+.*\|\|\s*$/) {
> 			/^((\|\|)+)(.*?)\|\|/;	
> 	
> 			my ($alignInitial) = $3;
> 			my $switches = $3;
> 			($alignInitial) = $alignInitial =~ /(.*)\|/;	
> 
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, $alignInitial, 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/td><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 1;
> 			$depth = 1;
> 		}
> 		elsif (/^[ \t].*\S/) {
> 			$code  = "pre";
> 			$depth = 1;
> 		}
> 		else {
> 			$depth = 0;
> 		}
> 		
> 		while ( @htmlStack > $depth ) {    
> 			# Close tags as needed
> 			$pageHtml .= "</" . pop(@htmlStack) . ">";
> 		}
> 		
> 		if ( $depth > 0 ) {
> 			$depth = $IndentLimit if ( $depth > $IndentLimit );
> 			if (@htmlStack) {              
> 				# Non-empty stack
> 				$oldCode = pop(@htmlStack);
> 				
> 				if ( $oldCode ne $code ) {
> 					$pageHtml .= "</$oldCode><$code>";
> 				}
> 				push( @htmlStack, $code );
> 			}
> 			
> 			while ( @htmlStack < $depth ) {
> 				push( @htmlStack, $code );
> 				$pageHtml .= "\n<$code $codeAttributes>";
> 			}
> 		}
> 		
> 		if ( !$ParseParas ) {
> 			s/^\s*$/<p>\n/;    # Blank lines become <p> tags
> 		}
> 		$pageHtml .= &CommonMarkup( $_, 1, 2 );    # Line-oriented common markup
> 	}
> 	
> 	while ( @htmlStack > 0 ) {                     
> 		# Clear stack
> 		$pageHtml .= "</" . pop(@htmlStack) . ">";
> 	}
> 	
> 	return $pageHtml;
> }
> 
> sub EvalLocalRules {
> 	my ( $rules, $origText, $isDiff ) = @_;
> 	my ( $text, $reportError, $errorText );
> 	
> 	$text        = $origText;
> 	$reportError = 1;
> 
> 	# Basic idea: the $rules should change $text, possibly with different
> 	# behavior if $isDiff is true (no images or color changes?)
> 	# Note: for fun, the $rules could also change $reportError and $origText
> 	if ( !eval $rules ) {
> 		$errorText = $@;
> 		
> 		if ( $errorText eq "" ) {
> 
> 		  # Search for "Unknown Error" for the reason the next line is commented
> 		  #     $errorText = "Unknown Error (no error text)";
> 		}
> 		if ( $errorText ne "" ) {
> 			$text = $origText;    # Consider: should partial results be kept?
> 			
> 			if ($reportError) {
> 				$text .= "\n<hr>";
> 				$text .= "<b>";
> 				$text .= "Local rule error:";
> 				$text .= "</b><br>";
> 				$text .= &QuoteHtml($errorText);
> 			}
> 		}
> 	}
> 	
> 	return $text;
> }
> 
> sub QuoteHtml {
> 	my ($html) = @_;
> 	
> 	$html =~ s/&/&amp;/g;
> 	$html =~ s/</&lt;/g;
> 	$html =~ s/>/&gt;/g;
> 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
> 	
> 	return $html;
> }
> 
> sub ParseParagraph {
> 	my ($text) = @_;
> 	
> 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
> 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
> 	
> 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
> 	return "\n<p>$text</p>";
> }
> 
> sub StoreInterPage {
> 	my ( $id, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &InterPageLink( $id, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
> }
> 
> sub InterPageLink {
> 	my ( $id, $useImage ) = @_;
> 	my ( $name, $site, $remotePage, $url, $punct );
> 	
> 	( $id, $punct ) = &SplitUrlPunct($id);
> 	$name = $id;
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$url = &GetSiteUrl($site);
> 	
> 	return ( "", $id . $punct ) if ( $url eq "" );
> 	
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url .= $remotePage;
> 	
> 	return ( &UrlLinkOrImage( $url, $name, $useImage ), $punct );
> }
> 
> sub StoreBracketInterPage {
> 	my ( $id, $text, $useImage, $options ) = @_;
> 	my ( $site, $remotePage, $url, $index );
> 	
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url = &GetSiteUrl($site);
> 	
> 	if ( $text ne "" ) {
> 		return "[$id $text]" if ( $url eq "" );
> 	}
> 	else {
> 		return "[$id]" if ( $url eq "" );
> 		$text = &GetBracketUrlIndex($id);
> 	}
> 	
> 	$url .= $remotePage;
> 	
> 	$text = StoreBracketUrl( $url, $text, $useImage, $options);
> 	
> 	return $text;
> }
> 
> sub GetBracketUrlIndex {
> 	my ($id) = @_;
> 	my ( $index, $key );
> 
> 	# Consider plain array?
> 	if ( $SaveNumUrl{$id} > 0 ) {
> 		return $SaveNumUrl{$id};
> 	}
> 	
> 	$SaveNumUrlIndex++;    # Start with 1
> 	$SaveNumUrl{$id} = $SaveNumUrlIndex;
> 	
> 	return $SaveNumUrlIndex;
> }
> 
> sub GetSiteUrl {
> 	my ($site) = @_;
> 	my ( $data, $status );
> 	
> 	if ( !$InterSiteInit ) {
> 		( $status, $data ) = &ReadFile($InterFile);
> 		
> 		if ($status) {
> 			%InterSite = split( /\s+/, $data );    # Consider defensive code
> 		}
> 
> 		# Check for definitions to allow file to override automatic settings
> 		if ( !defined( $InterSite{'LocalWiki'} ) ) {
> 			$InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		if ( !defined( $InterSite{'Local'} ) ) {
> 			$InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		$InterSiteInit = 1;                        # Init only once per request
> 	}
> 	
> 	return $InterSite{$site} if ( defined( $InterSite{$site} ) );
> 	return "";
> }
> 
> sub StoreRaw {
> 	my ($html) = @_;
> 	
> 	$SaveUrl{$SaveUrlIndex} = $html;
> 	
> 	return $FS . $SaveUrlIndex++ . $FS;
> }
> 
> sub StorePre {
> 	my ( $html, $tag ) = @_;
> 	
> 	return &StoreRaw( "<$tag>" . $html . "</$tag>" );
> }
> 
> sub ReadWikiFile {
> 	my ($fileName) = @_;
> 	my ($fileData, %tempPage, %tempSection, %tempText);
> 	
> 	return unless -f $fileName;
> 	
> 	$fileData = &ReadFileOrDie($fileName);
> 	%tempPage = split(/$FS1/, $fileData, -1);
> 	%tempSection = split(/$FS2/, $tempPage{'text_default'}, -1);
> 	%tempText = split(/$FS3/, $tempSection{'data'}, -1);
> 	
> 	return $tempText{'text'};
> }
> 
> sub WikiFileToHTML {
> 	my ($text) = @_;
> 	my ($output);
> 	my ($mySaveUrlIndex, $mySaveNumUrlIndex, $myTableMode, %mySaveUrl, %mySaveNumUrl);
> 	
> 	return unless $text;
> 	
> 	# Global variables do not help this code. Nasty, but easiest solution.
> 	%mySaveUrl= %SaveUrl;
> 	%mySaveNumUrl= %SaveNumUrl;
> 	$mySaveUrlIndex= $SaveUrlIndex;
> 	$mySaveNumUrlIndex = $SaveNumUrlIndex;
> 	$myTableMode= $TableMode;
> 	
> 	$output = &WikiToHTML($text);
> 	
> 	%SaveUrl = %mySaveUrl;
> 	%SaveNumUrl = %mySaveNumUrl;
> 	$SaveUrlIndex = $mySaveUrlIndex;
> 	$SaveNumUrlIndex = $mySaveNumUrlIndex;
> 	$TableMode = $myTableMode;
> 	
> 	return $output;
> }
> 
> sub StoreTemplate {
> 	my ($params) = @_;
> 	my ($templateId, $templateFile, $templateText, $output, %substitutes);
> 	
> 	$params =~ s/^\s*(\S+)\s*/$templateId=$1,''/e;
> 	return &StoreRaw(T('No template name')) unless $templateId;
> 	
> 	$templateFile = &GetPageFile($templateId);
> 	return &StoreRaw(Ts('Template %s not found', $templateId)) unless -f $templateFile;
> 	
> 	while ($params =~ /^(\S+)\s*=(.*)$/gm) {
> 		$substitutes{$1} = $2;
> 	}
> 	
> 	$templateText = &ReadWikiFile($templateFile);
> 	$templateText =~ s/\$(\S+)\$/$substitutes{$1}/gi;
> 	$templateText =~ s/{{//g; # Avoid nesting.
> 	$output = &WikiFileToHTML($templateText);
> 	
> 	return &StoreRaw($output);
> }
> 
> sub StoreHref {
> 	my ( $anchor, $text ) = @_;
> 	
> 	return "<a" . &StoreRaw($anchor) . ">$text</a>";
> }
> 
> sub StoreUrl {
> 	my ( $name, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &UrlLink( $name, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
> }
> 
> sub UrlLink {
> 	my ( $rawname, $useImage ) = @_;
> 	my ( $name, $punct );
> 	
> 	( $name, $punct ) = &SplitUrlPunct($rawname);
> 	
> 	if ( $LimitFileUrl && ( $NetworkFile && $name =~ m|^file:| ) ) {
> 
> 		# Only do remote file:// links. No file:///c|/windows.
> 		if ( $name =~ m|^file://[^/]| ) {
> 			return ( "<a href='$name' class='wikiurllink'>$name</a>", $punct );
> 		}
> 		
> 		return ( $rawname, "" );
> 	}
> 	
> 	return ( &UrlLinkOrImage( $name, $name, $useImage ), $punct );
> }
> 
> sub UrlLinkOrImage {
> 	my ( $url, $name, $useImage ) = @_;
> 	
> 	# Restricted image URLs so that mailto:foo@bar.gif is not an image
> 	if ( $useImage && &ImageAllowed($url) ) {
> 		return "<a href='$url' class='wikiurlorimage' target='_blank'><img class='wikiurlorimage' src='$url'></a>";
> 	}
> 	
> 	return "<a href='$url' class='wikiurlorimage'>$name</a>";
> }
> 
> sub ImageAllowed {
> 	my ($url) = @_;
> 	my ( $site, $imagePrefixes );
> 	
> 	$imagePrefixes = 'http:|https:|ftp:|upload:';
> 	$imagePrefixes .= '|file:' if ( !$LimitFileUrl );
> 	
> 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
> 	return 0 if ( $url =~ /"/ );    #" No HTML-breaking quotes allowed
> 	return 1 if ( @ImageSites < 1 );    # Most common case: () means all allowed
> 	return 0 if ( $ImageSites[0] eq 'none' );    # Special case: none allowed
> 
> 	foreach $site (@ImageSites) {
> 		return 1
> 		  if ( $site eq substr( $url, 0, length($site) ) );    # Match prefix
> 	}
> 	
> 	return 0;
> }
> 
> sub ExtensionAllowed {
> 	my ($file) = @_;
> 	
> 	return 1 if ( $file =~ m/\.(jpg|bmp|pdf|gif|psd|ai|xls|ppt|js|css|doc|txt)$/ );
> 	
> 	return 0;	
> }
> 
> sub GetUploadUrl {
> 	my ($url) = @_;
> 	
> 	&StoreRaw($url);
> }
> 
> sub GetOptions {
> 	my ($text) = @_;
> 	my %options;
> 	
> 	foreach my $pair (split(/\|/, $text)){
> 		my @keyvalues = split (/=/, $pair);
> 		$options{$keyvalues[0]} = $keyvalues[1];
> 	}
> 	
> 	return %options;	
> }
> 
> sub ComputeImageRatio {
> 	my ($imageName, $desiredWidth, $desiredHeight, $okayLarger) = @_;
> 	my $filepath = "$UploadDir/$imageName";
> 	my ($imageWidth, $imageHeight) = Image::Size::imgsize($filepath);
> 	
> 	my $ratioWidth = 1;
> 	my $ratioHeight = 1;
> 	my $ratioFinal = 1;
> 	
> 	if ($desiredWidth){ $ratioWidth = $desiredWidth/$imageWidth; }
> 	if ($desiredHeight){ $ratioHeight = $desiredHeight/$imageHeight; }
> 	
> 	if ($okayLarger){
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioWidth; }
> 		else { $ratioFinal = $ratioHeight; }
> 	}
> 	else {
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioHeight; }
> 		else { $ratioFinal = $ratioWidth; }
> 	
> 	}
> 	
> 	my $finalWidth = int($ratioFinal * $imageWidth);
> 	my $finalHeight = int($ratioFinal * $imageHeight);
> 	
> 	return ($finalWidth, $finalHeight);
> }
> 
> sub StoreBracketUrl {
> 	my ( $url, $text, $useImage, $options ) = @_;
> 	my %options = &GetOptions($options);
> 	my $imageFloat;
> 	my $imageClear = "\n<br class='clear$options{clear}'/>";
> 	my $boxFloat = " float" . $options{'boxfloat'};
> 	my $boxClear = "\n<br class='clear$options{boxclear}'/>";
> 	my $width;
> 	my $height;
> 	my $title;
> 	my $caption;
> 	my $description;
> 	my $imageLink;
> 	my $boxWidth = "style='width: 300px !important;'";
> 
> 	if ( $text eq "" ) { $text = &GetBracketUrlIndex($url); }
> 
> 	if ($options{'float'}){ $imageFloat = "float" . $options{'float'}; }
> 	if ($options{'clear'}){ $imageClear = "\n<br class='clear$options{clear}'/>"; }
> 	if ($options{'title'}){ $title = $options{title}; } else { $title = $text; }
> 	if ($options{'width'}){ $width = $options{'width'}; }
> 	if ($options{'height'}){ $height = $options{'height'}; }
> 			
> 	if ($options{'boxfloat'}){ $boxFloat = "float" . $options{'boxfloat'}; }
> 	if ($options{'boxclear'}){ $boxClear = "\n<br class='clear$options{boxclear}'/>"; }
> 	if ($options{'boxwidth'}){ $boxWidth = "style='width: $options{boxwidth} !important;'"; }
> 	if ($options{'caption'}){ 
> 		if ($options{'description'}){ $description = $options{description}; } 
> 		else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 		
> 		$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div><div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 	}
> 	
> 	if ($url =~ /$UploadPattern/){ $url = "$UploadUrl/$1"; }	
> 	if ( $BracketImg && $useImage && &ImageAllowed($text) ) {		
> 		if ($text =~ /$UploadPattern/){
> 			my $imageName = $1;
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($imageName, $width, $height, "");
> 			my $imageStyle = "style='width: $imageWidth; height: $imageHeight;'";
> 			
> 			$imageLink = "$UploadUrl/" . &GetUploadUrl($1);			
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' $imageStyle src='$imageLink'></a>";
> 		}
> 		else {
> 			$imageLink = $text;
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' src='$imageLink'></a>";
> 		}
> 		my $expandlink =  "<a target='_blank' class='wikiexpandimageicon' href='$imageLink' title='View source image'>&nbsp;</a>";
> 		
> 		if ($options{'caption'}){ 
> 			if ($options{'description'}){ $description = $options{description}; } 
> 			else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 			
> 			$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div>$expandlink<div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 		}
> 			
> 		if ($imageClear){ $text .= $imageClear; }		
> 					
> 		if ($caption){
> 			$text = "\n<div title='$title' class='wikibracketbox $boxFloat' $boxWidth>$text$caption</div>";		
> 		}
> 		else {
> 			$text = "\n<div title='$title' class='$boxFloat'>$text</div>";	
> 		}
> 		
> 		if ($boxClear){ $text .= $boxClear; }
> 	}
> 	else {
> 		$text = "<a href='$url' title='$title' class='wikibracketurl'>[$text]</a>";
> 	}
> 	
> 	return &StoreRaw($text);
> }
> 
> sub StoreBracketLink {
> 	my ( $name, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( $name, "[$text]" ) );
> }
> 
> sub StoreBracketAnchoredLink {
> 	my ( $name, $anchor, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( "$name#$anchor", "[$text]" ) );
> }
> 
> sub StorePageOrEditLink {
> 	my ( $page, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$page =~ s/^\s+//;        # Trim extra spaces
> 		$page =~ s/\s+$//;
> 		$page =~ s|\s*/\s*|/|;    # ...also before/after subpages
> 	}
> 	$name =~ s/^\s+//;
> 	$name =~ s/\s+$//;
> 	
> 	return &StoreRaw( &GetPageOrEditLink( $page, $name ) );
> }
> 
> sub StoreRFC {
> 	my ($num) = @_;
> 	return &StoreRaw( &RFCLink($num) );
> }
> 
> sub RFCLink {
> 	my ($num) = @_;
> 	return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\" class='wikirfclink'>RFC $num</a>";
> }
> 
> sub StoreUpload {
> 	my ($url) = @_;
> 	return &StoreRaw( &UploadLink($url) );
> }
> 
> sub UploadLink {
> 	my ($filename) = @_;
> 	my ( $html, $url );
> 	
> 	return $filename if ( $UploadUrl eq "" );    # No bad links if misconfigured
> 	
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$url  = $UploadUrl . $filename;
> 	$html = "<a href='$url' class='wikiuploadlink' target='_blank'>";
> 	
> 	if ( &ImageAllowed($url) ) {
> 		$html .= "<img class='wikiuploadlink' src='$url' alt='upload:$filename'>";
> 	}
> 	else {
> 		$html .= "upload:$filename";
> 	}
> 	$html .= "</a>";
> 	
> 	return $html;
> }
> 
> sub StoreISBN {
> 	my ($num) = @_;
> 	
> 	return &StoreRaw( &ISBNLink($num) );
> }
> 
> sub ISBNALink {
> 	my ( $num, $pre, $post, $text ) = @_;
> 	
> 	return "<a href='$pre$num$post' class='wikiisbnalink'>$text</a>";
> }
> 
> sub ISBNLink {
> 	my ($rawnum) = @_;
> 	my ( $rawprint, $html, $num, $numSites, $i );
> 	
> 	$num      = $rawnum;
> 	$rawprint = $rawnum;
> 	$rawprint =~ s/ +$//;
> 	$num      =~ s/[- ]//g;
> 	$numSites = scalar @IsbnNames;    # Number of entries
> 	
> 	if ( ( length($num) != 10 ) || ( $numSites < 1 ) ) {
> 		return "ISBN $rawnum";
> 	}
> 	
> 	$html = &ISBNALink( $num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint );
> 	
> 	if ( $numSites > 1 ) {
> 		$html .= " (";
> 		$i = 1;
> 		while ( $i < $numSites ) {
> 			$html .=
> 			  &ISBNALink( $num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i] );
> 			if ( $i < ( $numSites - 1 ) ) {    # Not the last site
> 				$html .= ", ";
> 			}
> 			$i++;
> 		}
> 		$html .= ")";
> 	}
> 	
> 	$html .= " " if ( $rawnum =~ / $/ );    # Add space if old ISBN had space.
> 	
> 	return $html;
> }
> 
> sub SplitUrlPunct {
> 	my ($url) = @_;
> 	my ($punct);
> 	
> 	if ( $url =~ s/\"\"$// ) {  #"REMARK
> 		return ( $url, "" );    # Delete double-quote delimiters here
> 	}
> 	
> 	$punct = "";
> 	if ($NewFS) {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	else {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	
> 	return ( $url, $punct );
> }
> 
> sub StripUrlPunct {
> 	my ($url) = @_;
> 	my ($junk);
> 	
> 	( $url, $junk ) = &SplitUrlPunct($url);
> 	
> 	return $url;
> }
> 
> sub WikiHeadingNumber {
> 	my ( $depth, $text, $useNumber) = @_;
> 	#my ( $depth, $text ) = @_;
> 	my ( $anchor, $number );
> 	
> 	return "" unless --$depth > 0;    # Don't number H1s because it looks stupid
> 		
> 	while ( scalar @HeadingNumbers < ( $depth - 1 ) ) {
> 		push @HeadingNumbers, 1;
> 		$TableOfContents .= "<dl><dt></dt><dd>";
> 	}
> 	
> 	if ( scalar @HeadingNumbers < $depth ) {
> 		push @HeadingNumbers, 0;
> 		$TableOfContents .= "<dl><dt></dt><dd>";
> 	}
> 	
> 	while ( scalar @HeadingNumbers > $depth ) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$HeadingNumbers[$#HeadingNumbers]++;
> 	$number = ( join '.', @HeadingNumbers ) . '. ';
> 
> 	# Remove embedded links. THIS IS FRAGILE!
> 	$text = &RestoreSavedText($text);
> 	$text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si;        # No such page syntax
> 	$text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
> 
> 	# Cook anchor by canonicalizing $text.
> 	$anchor = $text;
> 	$anchor =~ s/\<.*?\>//g;
> 	$anchor =~ s/\W/_/g;
> 	$anchor =~ s/__+/_/g;
> 	$anchor =~ s/^_//;
> 	$anchor =~ s/_$//;
> 
> 	# Last ditch effort
> 	$anchor = "_" . ( join '_', @HeadingNumbers ) unless $anchor;
> 	$TableOfContents .= ('&nbsp;' x (2 * $depth)) . $number;
> 	$TableOfContents .= &ScriptLink( "$OpenPageName#$anchor", $text );
> 	$TableOfContents .= "</dd><dt>";
> 	$TableOfContents .= "</dt><dd>";
> 	  
> 	## return &StoreHref(" name='$anchor'") . $number;
> 	if ($useNumber) {
> 		return &StoreHref(" name='$anchor'") . $number;
> 	} else {
> 		return &StoreHref(" name='$anchor'");
> 	}
> }
> 
> sub WikiHeading {
> 	## my ( $pre, $depth, $text ) = @_;
> 	my ($pre, $depth, $text, $useNumber) = @_;
> 	$depth = length($depth);
> 	$depth = 6 if ( $depth > 6 );
> 	##$text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e;    # $' == $POSTMATCH
> 	if ($useNumber) {
> 		$text = &WikiHeadingNumber($depth,$text, 1) . $text;
> 	} else {
> 		$text = &WikiHeadingNumber($depth,$text, 0) . $text;
> 	}	
> 	return $pre . "<H$depth>$text</H$depth>";
> }
> 
> # ==== Difference markup and HTML ====
> sub GetDiffHTML {
> 	my ( $diffType, $id, $revOld, $revNew, $newText ) = @_;
> 	my ( $html, $diffText, $diffTextTwo, $priorName, $links, $usecomma );
> 	my ( $major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName );
> 	
> 	$links     = " (";
> 	$usecomma  = 0;
> 	$major     = &ScriptLinkDiff( 1, $id, "major diff", "" );
> 	$minor     = &ScriptLinkDiff( 2, $id, "minor diff", "" );
> 	$author    = &ScriptLinkDiff( 3, $id, "author diff", "" );
> 	$useMajor  = 1;
> 	$useMinor  = 1;
> 	$useAuthor = 1;
> 	$diffType  = &GetParam( "defaultdiff", 1 ) if ( $diffType == 4 );
> 	
> 	if ( $diffType == 1 ) {
> 		$priorName = "major";
> 		$cacheName = "major";
> 		$useMajor  = 0;
> 	}
> 	elsif ( $diffType == 2 ) {
> 		$priorName = "minor";
> 		$cacheName = "minor";
> 		$useMinor  = 0;
> 	}
> 	elsif ( $diffType == 3 ) {
> 		$priorName = "author";
> 		$cacheName = "author";
> 		$useAuthor = 0;
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 
> 		# Note: OpenKeptRevisions must have been done by caller.
> 		# Eventually optimize if same as cached revision
> 		$diffText = &GetKeptDiff( $newText, $revOld, 1 );    # 1 = get lock
> 		if ( $diffText eq "" ) {
> 			$diffText = "(The revisions are identical or unavailable.)";
> 		}
> 	}
> 	else {
> 		$diffText = &GetCacheDiff($cacheName);
> 	}
> 	
> 	$useMajor = 0 if ( $useMajor && ( $diffText eq &GetCacheDiff("major") ) );
> 	$useMinor = 0 if ( $useMinor && ( $diffText eq &GetCacheDiff("minor") ) );
> 	$useAuthor = 0 if ( $useAuthor && ( $diffText eq &GetCacheDiff("author") ) );
> 	$useMajor = 0 if ( ( !defined( &GetPageCache('oldmajor') ) ) || ( &GetPageCache("oldmajor") < 1 ) );
> 	$useAuthor = 0 if ( ( !defined( &GetPageCache('oldauthor') ) ) || ( &GetPageCache("oldauthor") < 1 ) );
> 	
> 	if ($useMajor) {
> 		$links .= $major;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useMinor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $minor;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useAuthor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $author;
> 	}
> 	
> 	if ( !( $useMajor || $useMinor || $useAuthor ) ) {
> 		$links .= "no other diffs";
> 	}
> 	$links .= ")";
> 	
> 	if ( ( !defined($diffText) ) || ( $diffText eq "" ) ) {
> 		$diffText = "No diff available.";
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 		my $currentRevision = "current revision";
> 		
> 		$currentRevision = "revision $revNew " if $revNew;
> 		$html .= "<h4>Difference (from revision $revOld to $currentRevision)</h4>";
> 		$html .= "$links<br><br>";
> 		$html .= &DiffToHTML($diffText);
> 	}
> 	else {
> 		if (
> 			( $diffType != 2 )
> 			&& (   ( !defined( &GetPageCache("old$cacheName") ) )
> 				|| ( &GetPageCache("old$cacheName") < 1 ) )
> 		  )
> 		{
> 			$html .= "<h4>No diff available -- this is the first $priorName revision.</h4>";
> 			$html .= "$links<br><br>";
> 		}
> 		else {
> 			$html .= "<h4>Difference from prior $priorName revision</h4>";
> 			$html .= "$links<br><br>";
> 			$html .= &DiffToHTML($diffText);
> 		}
> 	}
> 	@HeadingNumbers  = ();
> 	$TableOfContents = "";
> 		
> 	return $html;
> }
> 
> sub GetCacheDiff {
> 	my ($type) = @_;
> 	my ($diffText);
> 	$diffText = &GetPageCache("diff_default_$type");
> 	$diffText = &GetCacheDiff('minor') if ( $diffText eq "1" );
> 	$diffText = &GetCacheDiff('major') if ( $diffText eq "2" );
> 	return $diffText;
> }
> 
> # Must be done after minor diff is set and OpenKeptRevisions called
> sub GetKeptDiff {
> 	my ( $newText, $oldRevision, $lock ) = @_;
> 	my ( %sect, %data, $oldText );
> 	$oldText = "";
> 	if ( defined( $KeptRevisions{$oldRevision} ) ) {
> 		%sect = split( /$FS2/, $KeptRevisions{$oldRevision}, -1 );
> 		%data = split( /$FS3/, $sect{'data'}, -1 );
> 		$oldText = $data{'text'};
> 	}
> 	return "" if ( $oldText eq "" );    # Old revision not found
> 	return &GetDiff( $oldText, $newText, $lock );
> }
> 
> sub GetDiff {
>   my $textOld = shift;
>   my $textNew = shift;
> 
>   my %format = (
>     paraIdent     => '<tr valign=top><td class="diff-para-ident">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident">%text%</td></tr>',
>     paraAdded     => '<tr valign=top><td class="diff-para-ident"></td><td class="diff-vertical"></td><td class="diff-para-added">%text%</td></tr>',
>     paraDeleted   => '<tr valign=top><td class="diff-para-deleted">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident"></td></tr>',
>     paraChanged   => '<tr valign=top><td class="diff-para-changed-old">%text%</td><td class="diff-vertical"></td><td class="diff-para-changed-new">%text%</td></tr>',
>     paraReplaced  => '<tr valign=top><td class="diff-para-deleted">%textDeleted%</td><td class="diff-vertical"></td><td class="diff-para-added">%textAdded%</td></tr>',
>   
>     changeContext => 1,
>     changeHeader  => '<tr valign=top><td class="diff-header">Paragraph %oldFrom%</td><td class="diff-vertical">&nbsp;</td><td class="diff-header">Paragraph %newFrom%</td></tr>',
>   
>     spanIdent     => '<span class="diff-span-ident">%text%</span>',
>     spanAdded     => '<span class="diff-span-added">%text%</span>',
>     spanDeleted   => '<span class="diff-span-deleted">%text%</span>',
> 
>     processText => sub {
> 
>       my $text = shift;
> 
>       $text =~ s[&]               [&amp;]g;
>       $text =~ s[<]               [&lt;]g;
>       $text =~ s[>]               [&gt;]g;
>       $text =~ s[\n]              [<br>\n]g;
>       $text =~ s[\r]              []g;
>       $text =~ s[([\t ]+)([\t ])] [('&nbsp;' x length($1)) . $2]ge;
>       $text =~ s[^[\t ]]          [&nbsp;];
> 
>       return $text;
>     }
>   );
> 
>   my $diff = Diff::diffText($textOld, $textNew, %format);
>   
>   if ($diff ne "") {
>     $diff =~ s[<td class="diff-para-changed-old">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-added">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>     
>     $diff =~ s[<td class="diff-para-changed-new">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-deleted">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>   
>     $diff = qq[<div id=wikidiffdiv><table id=wikidifftable>$diff</table></div>];
>   }
> 
>   return $diff;
> }
> 
> sub DiffToHTML { shift }
> 
> 
> 
> # ==== Database (Page, Section, Text, Kept, User) functions ====
> sub OpenNewPage {
> 	my ($id) = @_;
> 	%Page             = ();
> 	$Page{'version'}  = 3;       # Data format version
> 	$Page{'revision'} = 0;       # Number of edited times
> 	$Page{'tscreate'} = $Now;    # Set once at creation
> 	$Page{'ts'}       = $Now;    # Updated every edit
> 	$Page{'authorcreate'} = GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
> }
> 
> sub OpenNewSection {
> 	my ( $name, $data ) = @_;
> 	%Section             = ();
> 	$Section{'name'}     = $name;
> 	$Section{'version'}  = 1;                   # Data format version
> 	$Section{'revision'} = 0;                   # Number of edited times
> 	$Section{'tscreate'} = $Now;                # Set once at creation
> 	$Section{'ts'}       = $Now;                # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'host'} 	 = "";        # Updated only for real edits (can be slow)
> 	$Section{'id'}   	 = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} 		 = join( $FS2, %Section );    # Replace with save?
> 	$Page{'authorcreate'}= GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
> }
> 
> sub OpenNewText {
> 	my ($name) = @_;                          # Name of text (usually "default")
> 	%Text = ();
> 	
> 	if ( $NewText ne "" ) {
> 		$Text{'text'} = $NewText;
> 	}
> 	else {
> 		$Text{'text'} = "Describe the new page here.";
> 	}
> 	
> 	$Text{'text'} .= "\n" if ( substr( $Text{'text'}, -1, 1 ) ne "\n" );
> 	$Text{'minor'}     = 0;                   # Default as major edit
> 	$Text{'newauthor'} = 1;                   # Default as new author
> 	$Text{'summary'}   = "";
> 	
> 	&OpenNewSection( "text_$name", join( $FS3, %Text ) );
> }
> 
> sub GetPageFile {
> 	my ($id) = @_;
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
> }
> 
> sub OpenPage {
> 	my ($id) = @_;
> 	my ( $fname, $data );
> 	
> 	if (!CheckIsAuthUser($id)) { $id = "AuthError"; } #auth patch
> 	if ( $OpenPageName eq $id ) { return; }
> 	
> 	%Section = ();
> 	%Text    = ();
> 	$fname   = &GetPageFile($id);
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		%Page = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	}
> 	else {
> 		&OpenNewPage($id);
> 	}
> 	
> 	if ( $Page{'version'} != 3 ) {
> 		&UpdatePageVersion();
> 	}
> 	
> 	$OpenPageName = $id;
> }
> 
> sub OpenSection {
> 	my ($name) = @_;
> 	if ( !defined( $Page{$name} ) ) {
> 		&OpenNewSection( $name, "" );
> 	}
> 	else {
> 		%Section = split( /$FS2/, $Page{$name}, -1 );
> 	}
> }
> 
> sub OpenText {
> 	my ($name) = @_;
> 	if ( !defined( $Page{"text_$name"} ) ) {
> 		&OpenNewText($name);
> 	}
> 	else {
> 		&OpenSection("text_$name");
> 		%Text = split( /$FS3/, $Section{'data'}, -1 );
> 	}
> }
> 
> sub OpenDefaultText {
> 	&OpenText('default');
> }
> 
> # Called after OpenKeptRevisions
> sub OpenKeptRevision {
> 	my ($revision) = @_;
> 	%Section = split( /$FS2/, $KeptRevisions{$revision}, -1 );
> 	%Text = split( /$FS3/, $Section{'data'}, -1 );
> }
> 
> sub GetPageCache {
> 	my ($name) = @_;
> 	return $Page{"cache_$name"};
> }
> 
> # Always call SavePage within a lock.
> sub SavePage {
> 	my $file = &GetPageFile($OpenPageName);
> 	$Page{'revision'} += 1;    # Number of edited times
> 	$Page{'ts'} = $Now;        # Updated every edit
> 	&CreatePageDir( $PageDir, $OpenPageName );
> 	&WriteStringToFile( $file, join( $FS1, %Page ) );
> }
> 
> sub SaveSection {
> 	my ( $name, $data ) = @_;
> 	$Section{'revision'} += 1;    # Number of edited times
> 	$Section{'ts'}       = $Now;                          # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'id'}       = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} = join( $FS2, %Section );
> }
> 
> sub SaveText {
> 	my ($name) = @_;
> 	&SaveSection( "text_$name", join( $FS3, %Text ) );
> }
> 
> sub SaveDefaultText {
> 	&SaveText('default');
> }
> 
> sub SetPageCache {
> 	my ( $name, $data ) = @_;
> 	$Page{"cache_$name"} = $data;
> }
> 
> sub UpdatePageVersion {
> 	&ReportError( "Bad page version (or corrupt page)." );
> }
> 
> sub KeepFileName {
> 	return $KeepDir . "/"
> 	  . &GetPageDirectory($OpenPageName)
> 	  . "/$OpenPageName.kp";
> }
> 
> sub SaveKeepSection {
> 	my $file = &KeepFileName();
> 	my $data;
> 	return if ( $Section{'revision'} < 1 );    # Don't keep "empty" revision
> 	$Section{'keepts'} = $Now;
> 	$data = $FS1 . join( $FS2, %Section );
> 	&CreatePageDir( $KeepDir, $OpenPageName );
> 	&AppendStringToFileLimited( $file, $data, $KeepSize );
> }
> 
> sub ExpireKeepFile {
> 	my ( $fname, $data, @kplist, %tempSection, $expirets );
> 	my ( $anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev );
> 	my ( $oldMajor, $oldAuthor );
> 	$fname = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );    # Also empty
> 	
> 	shift(@kplist) if ( $kplist[0] eq "" );    # First can be empty
> 	return if ( length(@kplist) < 1 );         # Also empty
> 	
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;                                # Bad keep file
> 	}
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	return if ( $tempSection{'keepts'} >= $expirets );    # Nothing old enough
> 	
> 	$anyExpire = 0;
> 	$anyKeep   = 0;
> 	%keepFlag  = ();
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	foreach ( reverse @kplist ) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		$expire      = 0;
> 		
> 		if ( $sectName eq "text_default" ) {
> 			if (   ( $KeepMajor && ( $sectRev == $oldMajor ) )
> 				|| ( $KeepAuthor && ( $sectRev == $oldAuthor ) ) )
> 			{
> 				$expire = 0;
> 			}
> 			elsif ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		else {
> 			if ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		if ( !$expire ) {
> 			$keepFlag{ $sectRev . "," . $sectName } = 1;
> 			$anyKeep = 1;
> 		}
> 		else {
> 			$anyExpire = 1;
> 		}
> 	}
> 	if ( !$anyKeep ) {    # Empty, so remove file
> 		unlink($fname);
> 		return;
> 	}
> 	return if ( !$anyExpire );    # No sections expired
> 	
> 	open( OUT, ">$fname" ) or die( Ts( 'cant write %s', $fname ) . ": $!" );
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		
> 		if ( $keepFlag{ $sectRev . "," . $sectName } ) {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
> }
> 
> sub OpenKeptList {
> 	my ( $fname, $data );
> 	@KeptList = ();
> 	$fname    = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@KeptList = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> }
> 
> sub OpenKeptRevisions {
> 	my ($name) = @_;    # Name of section
> 	my ( $fname, $data, %tempSection );
> 	
> 	%KeptRevisions = ();
> 	&OpenKeptList();
> 	
> 	foreach (@KeptList) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		next if ( $tempSection{'name'} ne $name );
> 		$KeptRevisions{ $tempSection{'revision'} } = $_;
> 	}
> }
> 
> sub LoadUserData {
> 	my ( $data, $status );
> 	%UserData = ();
> 	( $status, $data ) = &ReadFile( &UserDataFilename($UserID) );
> 	
> 	if ( !$status ) {
> 		$UserID = 112;    # Could not open file.  Consider warning message?
> 		return;
> 	}
> 	%UserData = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> }
> 
> sub UserDataFilename {
> 	my ($id) = @_;
> 	if ($id =~ /(\d+)/){
> 		$id = $1;
> 	}
> 	else { die "The userid must be a positive integer"; }
> 	
> 	return "" if ( $id < 1 );
> 	return $UserDir . "/" . ( $id % 10 ) . "/$id.db";
> }
> 
> # ==== Misc. functions ====
> sub ReportError {
> 	my ($errmsg) = @_;
> 	
> 	print &GetHeader( "", "ERROR!", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>$errmsg</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub ValidId {
> 	my ($id) = @_;
> 	if ( length($id) > 120 ) {
> 		return Ts( 'Page name is too long: %s', $id );
> 	}
> 	
> 	if ( $id =~ m| | ) {
> 		return Ts( 'Page name may not contain space characters: %s', $id );
> 	}
> 	
> 	if ($UseSubpage) {
> 		if ( $id =~ m|.*/.*/| ) {
> 			return Ts( 'Too many / characters in page %s', $id );
> 		}
> 		if ( $id =~ /^\// ) {
> 			return Ts( 'Invalid Page %s (subpage without main page)', $id );
> 		}
> 		if ( $id =~ /\/$/ ) {
> 			return Ts( 'Invalid Page %s (missing subpage name)', $id );
> 		}
> 	}
> 	
> 	if ($FreeLinks) {
> 		$id =~ s/ /_/g;
> 		if ( !$UseSubpage ) {
> 			if ( $id =~ /\// ) {
> 				return Ts( 'Invalid Page %s (/ not allowed)', $id );
> 			}
> 		}
> 		if ( !( $id =~ m|^$FreeLinkPattern$| ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 		if ( $id =~ m|\.db$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .db)', $id );
> 		}
> 		if ( $id =~ m|\.lck$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .lck)', $id );
> 		}
> 		return "";
> 	}
> 	else {
> 		if ( !( $id =~ /^$LinkPattern$/ ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 	}
> 	
> 	return "";
> }
> 
> sub ValidIdOrDie {
> 	my ($id) = @_;
> 	my $error;
> 	
> 	$error = &ValidId($id);
> 	
> 	if ( $error ne "" ) {
> 		&ReportError($error);
> 		return 0;
> 	}
> 	return 1;
> }
> 
> sub UserCanEdit {
> 	my ( $id, $deepCheck ) = @_;
> 	my $authtype = &CheckIsAuthUser($id);
> 	
> 	# Optimized for the "everyone can edit" case (don't check passwords)
> 	if ( ( $id ne "" ) && ( -f &GetLockedPageFile($id) ) ) {
> 		return 1 if ( &UserIsAdmin() );    # Requires more privledges
> 		     # Consider option for editor-level to edit these pages?
> 		return 0;
> 	}
> 	if ( !$EditAllowed ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ( -f "$DataDir/noedit" ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ($deepCheck) {    # Deeper but slower checks (not every page)
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0 if ( &UserIsBanned() );
> 	}
> 	return 1;
> }
> 
> sub UserIsBanned {
> 	my ( $host, $ip, $data, $status );
> 	( $status, $data ) = &ReadFile("$DataDir/banlist");
> 	return 0 if ( !$status );    # No file exists, so no ban
> 	$data =~ s/\r//g;
> 	$ip   = $ENV{'REMOTE_ADDR'};
> 	$host = &GetRemoteHost(0);
> 	
> 	foreach ( split( /\n/, $data ) ) {
> 		next if ( (/^\s*$/) || (/^#/) );    # Skip empty, spaces, or comments
> 		return 1 if ( $ip   =~ /$_/i );
> 		return 1 if ( $host =~ /$_/i );
> 	}
> 	return 0;
> }
> 
> sub UserIsAdmin {
> 	my ( @pwlist, $userPassword );
> 	
> 	return 0 if ( $AdminPass eq "" );
> 	$userPassword = &GetParam( "adminpw", "" );
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $AdminPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
> }
> 
> sub UserIsEditor {
> 	my ( @pwlist, $userPassword );
> 	
> 	return 1 if ( &UserIsAdmin() );    # Admin includes editor
> 	return 0 if ( $EditPass eq "" );
> 	$userPassword = &GetParam( "password", "" );    # Used for both
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $EditPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
> }
> 
> sub UserIsEditorOrAdmin {
> 	return (UserIsEditor || UserIsAdmin);	
> }
> 
> sub UserCanUpload {
> 	return 1 if ( &UserIsEditor() );
> 	return $AllUpload;
> }
> 
> sub GetLockedPageFile {
> 	my ($id) = @_;
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
> }
> 
> sub RequestLockDir {
> 	my ( $name, $tries, $wait, $errorDie ) = @_;
> 	my ( $lockName, $n );
> 	&CreateDir($TempDir);
> 	$lockName = $LockDir . $name;
> 	$n        = 0;
> 	while ( mkdir( $lockName, 0555 ) == 0 ) {
> 		if ( $! != 17 ) {
> 			die( Ts( 'can not make %s', $LockDir ) . ": $!\n" ) if $errorDie;
> 			return 0;
> 		}
> 		return 0 if ( $n++ >= $tries );
> 		sleep($wait);
> 	}
> 	return 1;
> }
> 
> sub ReleaseLockDir {
> 	my ($name) = @_;
> 	rmdir( $LockDir . $name );
> }
> 
> sub RequestLock {
> 
> 	# 10 tries, 3 second wait, possibly die on error
> 	return &RequestLockDir( "main", 10, 3, $LockCrash );
> }
> 
> sub ReleaseLock {
> 	&ReleaseLockDir('main');
> }
> 
> sub ForceReleaseLock {
> 	my ($name) = @_;
> 	my $forced;
> 
> 	# First try to obtain lock (in case of normal edit lock)
> 	# 5 tries, 3 second wait, do not die on error
> 	$forced = !&RequestLockDir( $name, 5, 3, 0 );
> 	&ReleaseLockDir($name);    # Release the lock, even if we didn't get it.
> 	return $forced;
> }
> 
> sub RequestCacheLock {
> 
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'cache', 4, 2, 0 );
> }
> 
> sub ReleaseCacheLock {
> 	&ReleaseLockDir('cache');
> }
> 
> sub RequestDiffLock {
> 
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'diff', 4, 2, 0 );
> }
> 
> sub ReleaseDiffLock {
> 	&ReleaseLockDir('diff');
> }
> 
> # Index lock is not very important--just return error if not available
> sub RequestIndexLock {
> 
> 	# 1 try, 2 second wait, do not die on error
> 	return &RequestLockDir( 'index', 1, 2, 0 );
> }
> 
> sub ReleaseIndexLock {
> 	&ReleaseLockDir('index');
> }
> 
> sub ReadFile {
> 	my ($fileName) = @_;
> 	my ($data);
> 	local $/ = undef;    # Read complete files
> 	if ( open( IN, "<$fileName" ) ) {
> 		$data = <IN>;
> 		close IN;
> 		return ( 1, $data );
> 	}
> 	return ( 0, "" );
> }
> 
> sub ReadFileOrDie {
> 	my ($fileName) = @_;
> 	my ( $status, $data );
> 	( $status, $data ) = &ReadFile($fileName);
> 	if ( !$status ) {
> 		die( Ts( 'Can not open %s', $fileName ) . ": $!" );
> 	}
> 	return $data;
> }
> 
> sub WriteStringToFile {
> 	my ( $file, $string ) = @_;
> 	open( OUT, ">$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
> }
> 
> sub AppendStringToFile {
> 	my ( $file, $string ) = @_;
> 	open( OUT, ">>$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
> }
> 
> sub AppendStringToFileLimited {
> 	my ( $file, $string, $limit ) = @_;
> 	if ( ( $limit < 1 ) || ( ( ( -s $file ) + length($string) ) <= $limit ) ) {
> 		&AppendStringToFile( $file, $string );
> 	}
> }
> 
> sub CreateDir {
> 	my ($newdir) = @_;
> 	mkdir( $newdir, 0775 ) if ( !( -d $newdir ) );
> }
> 
> sub CreatePageDir {
> 	my ( $dir, $id ) = @_;
> 	my $subdir;
> 	&CreateDir($dir);    # Make sure main page exists
> 	$subdir = $dir . "/" . &GetPageDirectory($id);
> 	&CreateDir($subdir);
> 	if ( $id =~ m|([^/]+)/| ) {
> 		$subdir = $subdir . "/" . $1;
> 		&CreateDir($subdir);
> 	}
> }
> 
> sub UpdateHtmlCache {
> 	my ( $id, $html ) = @_;
> 	my $idFile;
> 	$idFile = &GetHtmlCacheFile($id);
> 	&CreatePageDir( $HtmlDir, $id );
> 	if ( &RequestCacheLock() ) {
> 		&WriteStringToFile( $idFile, $html );
> 		&ReleaseCacheLock();
> 	}
> }
> 
> sub GenerateAllPagesList {
> 	my ( @pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId );
> 	@pages = ();
> 	if ($FastGlob) {
> 
> 		# The following was inspired by the FastGlob code by Marc W. Mengel.
> 		# Thanks to Bob Showalter for pointing out the improvement.
> 		opendir( PAGELIST, $PageDir );
> 		@dirs = readdir(PAGELIST);
> 		closedir(PAGELIST);
> 		@dirs = sort(@dirs);
> 		foreach $dir (@dirs) {
> 			next
> 			  if ( substr( $dir, 0, 1 ) eq '.' );  # No ., .., or .dirs or files
> 			opendir( PAGELIST, "$PageDir/$dir" );
> 			@pageFiles = readdir(PAGELIST);
> 			closedir(PAGELIST);
> 			foreach $id (@pageFiles) {
> 				next if ( ( $id eq '.' ) || ( $id eq '..' ) );
> 				if ( substr( $id, -3 ) eq '.db' ) {
> 					push( @pages, substr( $id, 0, -3 ) );
> 				}
> 				elsif ( substr( $id, -4 ) ne '.lck' ) {
> 					opendir( PAGELIST, "$PageDir/$dir/$id" );
> 					@subpageFiles = readdir(PAGELIST);
> 					closedir(PAGELIST);
> 					foreach $subId (@subpageFiles) {
> 						if ( substr( $subId, -3 ) eq '.db' ) {
> 							push( @pages, "$id/" . substr( $subId, 0, -3 ) );
> 						}
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		# Old slow/compatible method.
> 		@dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
> 		
> 		foreach $dir (@dirs) {
> 			if ( -e "$PageDir/$dir" ) {    # Thanks to Tim Holt
> 				while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
> 					s|^$PageDir/||;
> 					m|^[^/]+/(\S*).db|;
> 					$id = $1;
> 					push( @pages, $id );
> 				}
> 			}
> 		}
> 	}
> 	
> 	return sort(@pages);
> }
> 
> sub AllPagesList {
> 	my ( $rawIndex, $refresh, $status );
> 	
> 	if ( !$UseIndex ) {
> 		return &GenerateAllPagesList();
> 	}
> 	
> 	$refresh = &GetParam( "refresh", 0 );
> 	if ( $IndexInit && !$refresh ) {
> 
> 		# Note for mod_perl: $IndexInit is reset for each query
> 		# Eventually consider some timestamp-solution to keep cache?
> 		return @IndexList;
> 	}
> 	
> 	if ( ( !$refresh ) && ( -f $IndexFile ) ) {
> 		( $status, $rawIndex ) = &ReadFile($IndexFile);
> 		
> 		if ($status) {
> 			%IndexHash = split( /\s+/, $rawIndex );
> 			@IndexList = sort( keys %IndexHash );
> 			$IndexInit = 1;
> 			
> 			return @IndexList;
> 		}
> 
> 		# If open fails just refresh the index
> 	}
> 	@IndexList = ();
> 	%IndexHash = ();
> 	@IndexList = &GenerateAllPagesList();
> 	
> 	foreach (@IndexList) {
> 		$IndexHash{$_} = 1;
> 	}
> 	$IndexInit = 1;    # Initialized for this run of the script
> 	                   # Try to write out the list for future runs
> 	&RequestIndexLock() or return @IndexList;
> 	&WriteStringToFile( $IndexFile, join( " ", %IndexHash ) );
> 	&ReleaseIndexLock();
> 	
> 	return @IndexList;
> }
> 
> sub AllSubPagesList {
> 	my $GivenPage = shift;
> 	my @PageList = &AllPagesList();
> 	my @Results;
> 	
> 	foreach (@PageList){
> 		if (/^$GivenPage\//i){
> 			push @Results, $_;	
> 		}
> 	}
> 	
> 	return @Results;
> }
> 
> sub CalcDay {
> 	my ($ts) = @_;
> 	
> 	$ts += $TimeZoneOffset;
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	
> 	if ($NumberDates) {
> 		$year = $year + 1900;
> 		$mon = $mon + 1;
> 		if ($mon < 10){ $mon = "0$mon"; }
> 		if ($mday < 10){ $mday = "0$mday"; }
> 		
> 		return "$year$NumberDatesDelim$mon$NumberDatesDelim$mday";
> 	}
> 	
> 	return (
> 		"January",   "February", "March",    "April",
> 		"May",       "June",     "July",     "August",
> 		"September", "October",  "November", "December"
> 	  )[$mon]
> 	  . " "
> 	  . $mday . ", "
> 	  . ( $year + 1900 );
> }
> 
> sub CalcTime {
> 	my ($ts) = @_;
> 	my ( $ampm, $mytz );
> 	
> 	$ts += $TimeZoneOffset;
> 	
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	$mytz = "";
> 	
> 	if ( ( $TimeZoneOffset == 0 ) && ( $ScriptTZ ne "" ) ) {
> 		$mytz = " " . $ScriptTZ;
> 	}
> 	$ampm = "";
> 	
> 	if ($UseAmPm) {
> 		$ampm = " am";
> 		if ( $hour > 11 ) {
> 			$ampm = " pm";
> 			$hour = $hour - 12;
> 		}
> 		$hour = 12 if ( $hour == 0 );
> 	}
> 	
> 	$min = "0" . $min if ( $min < 10 );
> 	
> 	return $hour . ":" . $min . $ampm . $mytz;
> }
> 
> sub TimeToText {
> 	my ($t) = @_;
> 	
> 	return &CalcDay($t) . " " . &CalcTime($t);
> }
> 
> sub GetParam {
> 	my ( $name, $default ) = @_;
> 	my $result;
> 	
> 	$result = $q->param($name);
> 	
> 	if ( !defined($result) ) {
> 		if ( defined( $UserData{$name} ) ) {
> 			$result = $UserData{$name};
> 		}
> 		else {
> 			$result = $default;
> 		}
> 	}
> 	
> 	return $result;
> }
> 
> sub GetHiddenValue {
> 	my ( $name, $value ) = @_;
> 	
> 	$q->param( $name, $value );
> 	
> 	return $q->hidden($name);
> }
> 
> sub GetRemoteHost {
> 	my ($doMask) = @_;
> 	my ( $rhost, $iaddr );
> 	
> 	$rhost = $ENV{REMOTE_HOST};
> 	
> 	if ( $UseLookup && ( $rhost eq "" ) ) {
> 
> 		# Catch errors (including bad input) without aborting the script
> 		eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
> 		  . '$rhost = gethostbyaddr($iaddr, AF_INET)';
> 	}
> 	
> 	if ( $rhost eq "" ) {
> 		$rhost = $ENV{REMOTE_ADDR};
> 	}
> 	
> 	$rhost = &GetMaskedHost($rhost) if ($doMask);
> 	
> 	return $rhost;
> }
> 
> sub FreeToNormal {
> 	my ($id) = @_;
> 	
> 	$id =~ s/ /_/g;
> 	$id = ucfirst($id) if ( $UpperFirst || $FreeUpper );
> 	
> 	if ( index( $id, '_' ) > -1 ) {    # Quick check for any space/underscores
> 		$id =~ s/__+/_/g;
> 		$id =~ s/^_//;
> 		$id =~ s/_$//;
> 		
> 		if ($UseSubpage) {
> 			$id =~ s|_/|/|g;
> 			$id =~ s|/_|/|g;
> 		}
> 	}
> 	
> 	if ($FreeUpper) {
> 
> 		# Note that letters after ' are *not* capitalized
> 		if ( $id =~ m|[-_.,\(\)/][a-z]| ) { # Quick check for non-canonical case
> 			$id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
> 		}
> 	}
> 	
> 	return $id;
> }
> 
> #END_OF_BROWSE_CODE
> # == Page-editing and other special-action code ========================
> $OtherCode = "";    # Comment next line to always compile (slower)
> 
> #$OtherCode = <<'#END_OF_OTHER_CODE';
> sub DoOtherRequest {
> 	my ( $id, $action, $filter, $text, $search );
> 	
> 	$action = &GetParam( "action", "" );
> 	$id     = &GetParam( "id",     "" );
> 	$filter = &GetParam( "filter", "" );
> 	
> 	if ( $action ne "" ) {
> 		$action = lc($action);
> 		
> 		if ( $action eq "edit" ) {
> 			&DoEdit( $id, 0, 0, "", 0 ) if &ValidIdOrDie($id);
> 		}
> 		elsif ( $action eq "unlock" ) {
> 			&DoUnlock();
> 		}
> 		elsif ( $action eq "index" ) {
> 			&DoIndex();
> 		}
> 		elsif ( $action eq "links" ) {
> 			&DoLinks();
> 		}
> 		elsif ( $action eq "maintain" ) {
> 			&DoMaintain();
> 		}
> 		elsif ( $action eq "pagelock" ) {
> 			&DoPageLock();
> 		}
> 		elsif ( $action eq "editlock" ) {
> 			&DoEditLock();
> 		}
> 		elsif ( $action eq "editprefs" ) {
> 			&DoEditPrefs();
> 		}
> 		elsif ( $action eq "editbanned" ) {
> 			&DoEditBanned();
> 		}
> 		elsif ( $action eq "editlinks" ) {
> 			&DoEditLinks();
> 		}
> 		elsif ( $action eq "login" ) {
> 			&DoEnterLogin();
> 		}
> 		elsif ( $action eq "newlogin" ) {
> 			$UserID = 0;
> 			&DoEditPrefs();    # Also creates new ID
> 		}
> 		elsif ( $action eq "version" ) {
> 			&DoShowVersion();
> 		}
> 		elsif ( $action eq "rss" ) {
> 			&DoRss();
> 		}
> 		elsif ( $action eq "delete" ) {
> 			&DoDeletePage($id);
> 		}
> 		elsif ( $UseUpload && ( $action eq "upload" ) ) {
> 			&DoUpload();
> 		}
> 		elsif ( $action eq "maintainrc" ) {
> 			&DoMaintainRc();
> 		}
> 		elsif ( $action eq "convert" ) {
> 			&DoConvert();
> 		}
> 		elsif ( $action eq "trimusers" ) {
> 			&DoTrimUsers();
> 		}
> 		elsif ( $action eq "listfiles" ) {
> 			&DoListFiles($id, $filter, 0);	
> 		}
> 		elsif ( $action eq "listdisabled" ) {
> 			&DoListFiles($id, $filter, 1);	
> 		}
> 		else {
> 			&ReportError( Ts( 'Invalid action parameter %s', $action ) );
> 		}
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_prefs", 0 ) ) {
> 		&DoUpdatePrefs();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_ban", 0 ) ) {
> 		&DoUpdateBanned();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "enter_login", 0 ) ) {
> 		&DoLogin();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_links", 0 ) ) {
> 		&DoUpdateLinks();
> 		return;
> 	}
> 	
> 	if ( $UseUpload && ( &GetParam( "upload", 0 ) ) ) {
> 		&SaveUpload();
> 		return;
> 	}
> 	
> 	$search = &GetParam( "search", "" );
> 	
> 	if ( ( $search ne "" ) || ( &GetParam( "dosearch", "" ) ne "" ) ) {
> 		&DoSearch($search, $filter);
> 		return;
> 	}
> 	else {
> 		$search = &GetParam( "back", "" );
> 		if ( $search ne "" ) {
> 			&DoBackLinks($search, $filter);
> 			
> 			return;
> 		}
> 	}
> 
> 	# Handle posted pages
> 	if ( &GetParam( "oldtime", "" ) ne "" ) {
> 		$id = &GetParam( "title", "" );
> 		&DoPost() if &ValidIdOrDie($id);
> 		
> 		return;
> 	}
> 	
> 	&ReportError( "Invalid URL." );
> }
> 
> sub PageIsLocked {
> 	my ($id, $deepedit) = @_;
> 	my ($result) = 0;
> 	
> 	if ( !&UserCanEdit( $id, $deepedit ) ) {
> 			$result = 1;
> 		if ( &UserIsBanned() ) {
> 			$result = 2;
> 		}
> 		else {
> 			$result = 3;
> 		}
> 	}
> 	
> 	return $result;
> }
> 
> sub DoEdit {
> 	my ( $id, $isConflict, $oldTime, $newText, $preview ) = @_;
> 	my ( $header, $editRows, $editCols, $userName, $revision, $oldText );
> 	my ( $summary, $isEdit, $pageTime, $isLocked );
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 	if (!$authtype) { $id = "AuthError"; } #auth patch	
> 	if ($FreeLinks) { $id = &FreeToNormal($id); }   # Take care of users like Markus Lude :-)	
> 	
> 	$isLocked = &PageIsLocked( $id, 1 );
> 	
> 	if ( $isLocked > 0 or $authtype eq "" || $authtype eq "1") {
> 		print &GetHeader( "", "Editing Denied", "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		
> 		if ( $isLocked == 2 ) {
> 			print "\n<h2>Editing not allowed: user, ip, or network is blocked.</h2>";
> 			print "\nContact the wiki administrator for more information.";
> 		}
> 		else {
> 			print "\n<h2>Editing not allowed: $id is read-only.</h2>";
> 		}
> 		
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";
> 			
> 		return;
> 	}
> 
> 	# Consider sending a new user-ID cookie if user does not have one
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$pageTime = $Section{'ts'};
> 	$header   = Ts( 'Editing %s', $id );
> 
> 	# Old revision handling
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$revision = "";
> 
> 			# Consider better solution like error message?
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 			$header = Ts( 'Editing revision %s of ', $revision ) . $id;
> 		}
> 	}
> 	
> 	$oldText = $Text{'text'};
> 	
> 	if ( $preview && !$isConflict ) {
> 		$oldText = $newText;
> 	}
> 	
> 	$editRows = &GetParam( "editrows", 20 );
> 	$editCols = &GetParam( "editcols", 65 );
> 	print &GetHeader( "", &QuoteHtml($header), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $revision ne "" ) {
> 		print "\n<b>Editing old revision $revision. Saving this page will replace the latest revision with this text.</b><br>";
> 	}
> 	
> 	if ($isConflict) {
> 		$editRows -= 10 if ( $editRows > 19 );
> 		print "\n<H1>Edit Conflict!</H1>";
> 		
> 		if ( $isConflict > 1 ) {
> 
> 			# The main purpose of a new warning is to display more text
> 			# and move the save button down from its old location.
> 			print "\n<h2>(This is a new conflict)</h2>";
> 		}
> 		
> 		print "\n<p><strong>";
> 		print "\nSomeone saved this page after you started editing. ";
> 		print "\nThe top textbox contains the saved text. ";
> 		print "\nOnly the text in the top textbox will be saved.";
> 		print "\n</strong></p><br>";
> 		print "\nScroll down to see your edited text.";
> 		print "\n<br>";
> 		print "\nLast save time: ";
> 		print &TimeToText($oldTime);
> 		print "\n(Current time is: ";
> 		print &TimeToText($Now);
> 		print "\n)<br>";
> 	}
> 	print "\n<div id='wikieditbar'>";
> 	print "<a href='$ScriptName?WikiStyleGuide'>WikiStyleGuide</a> | ";
> 	print "<a href='$ScriptName?WikiHeadings'>WikiHeadings</a> | ";
> 	print "<a href='$ScriptName?WikiGallery'>WikiGallery</a>| ";
> 	print "<a href='$ScriptName?WikiFlash'>WikiFlash</a>| ";
> 	print "<a href='$ScriptName?WikiTOCs'>WikiTOCs</a> | ";
> 	print "<a href='$ScriptName?WikiURLs'>WikiURLs</a> | ";
> 	print "<a href='$ScriptName?WikiImages'>WikiImages</a> | ";
> 	print "<a href='$ScriptName?WikiTables'>WikiTables</a> | ";
> 	print "<a href='$ScriptName?WikiLists'>WikiLists</a> | ";
> 	print "<a href='$ScriptName?WikiMarkup'>WikiMarkup</a>";
> 	print "\n</div>";
> 	
> 	print "\n<br>";
> 	print "\n<form id='wikiform' action='$ScriptName#preview-anchor' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "title",   $id );
> 	print &GetHiddenValue( "oldtime",     $pageTime );
> 	print &GetHiddenValue( "oldconflict", $isConflict );
> 	  
> 	if ( $revision ne "" ) {
> 		print &GetHiddenValue( "revision", $revision );
> 	}
> 	
> 	print &GetTextArea( 'text', $oldText, $editRows, $editCols );
> 	$summary = &GetParam( "summary", "*" );
> 	
> 	print "\n<br><br><div id='wikisaveedit'>Summary:";
> 	print
> 	  $q->textfield(
> 		-name      => 'summary',
> 		-id		   => 'summarytext',
> 		-default   => $summary,
> 		-override  => 1,
> 		-size      => 60,
> 		-maxlength => 200
> 	  );
> 	  
> 	if ( &GetParam("recent_edit") eq "on" ) {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name    => 'recent_edit',
> 			-checked => 1,
> 			-label   => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	else {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name  => 'recent_edit',
> 			-checked => 0,
> 			-label => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n&nbsp;&nbsp;&nbsp;"
> 		  . $q->checkbox(
> 			-name  => 'do_email_notify',
> 			-label =>
> 			  Ts( 'Send email notification that %s has been changed.', $id )
> 		  );
> 	}
> 	
> 	print "\n<br>";
> 	
> 	if ( $EditNote ne "" ) {
> 		print $EditNote . '<br>';
> 	}
> 	$userName = &GetParam( "username", "" );
> 	print $q->submit( -name => 'Preview', -value => 'Preview' );
> 	print $q->button( -name => 'Cancel', -value => 'Cancel', -onclick => 'window.location="' . $ScriptName . '?' . $id . '";' );
> 	print $q->submit( -name => 'Save', -value => "Save" );	
> 	
> 	if ( $userName ne "" ) {
> 		print "\n (Your user name is ";
> 		print &GetPageLinkText($HomePagePrefix . '/' . $userName, $userName);
> 		print "\n )";
> 	}
> 	else {
> 		print ' (', Ts( 'Visit %s to set your user name.', &GetPrefsLink() ), ') ';
> 	}
> 
> 	if ($isConflict) {
> 		print "\n<br><hr><p><strong>";
> 		print "\nThis is the text you submitted:";
> 		print  "</strong><p>";
> 		print &GetTextArea( 'newtext', $newText, $editRows, $editCols );
> 	}
> 	
> 	print "\n</div>";
> 	print "\n</form>";
> 	print "<a name='preview-anchor'></a>";
> 	print "\n</div>";			
> 	print "\n$WikiLineFooter";
> 	
> 	if ($preview) {
> 		
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print $WikiLineHeaderPreview;
> 		print "\n<div id='wikipreview' class='wikipreview'>";				
> 		if ($isConflict) {
> 			print "\n<b>NOTE: This preview shows the revision of the other author.</b><hr>";
> 		}
> 		
> 		$MainPage = $id;
> 		$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		print &WikiToHTML($oldText);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter";
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print "\n<div id='wikibar'>&nbsp</div>";
> 	}
> 
> 	print "\n<div class='wikifooter'>";	
> 	print "<div class='wikirevision'>";
> 	print &GetHistoryLink( $id, "View other revisions<br>", "Click to view revision history");
> 	print "</div>";
> 	print &GetGotoBar($id);
> 	print &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }		
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetTextArea {
> 	my ( $name, $text, $rows, $cols ) = @_;
> 	my ( $html );
> 	
> 	$html = "\n<div style='width: 100%;'>";
> 	if ( &GetParam( "editwide", 1 ) ) {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-style    => 'width:100%',
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	else {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	
> 	$html .= "</div>";
> 	
> 	return $html;
> }
> 
> sub DoEditPrefs {
> 	my ( $check, $recentName, %labels );
> 	
> 	$recentName = $RCName;
> 	$recentName =~ s/_/ /g;
> 	
> 	&DoNewLogin() if ( $UserID < 400 );
> 	
> 	print &GetHeader( "", "Editing Preferences", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikidiff'>";
> 	print "\n<h2>Access Controls</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "edit_prefs", 1 );
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th colspan='2'><b>User Information </b></th></tr>";
> 	print "\n<tr><td>Your User ID number </td><td>$UserID</td></tr>";
> 	print "\n<tr><td>UserName</td>";
> 	print "\n<td>" . &GetFormText( 'username', "", 30, 50 );
> 	print "\n<br>(blank to remove, or valid page name)</td></tr>";
> 	print "\n<tr><td>Set Password </td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => '*',
> 		-size      => 30,
> 		-maxlength => 50
> 	  );
> 	 print "\n<br>(blank to remove password)";
> 	 print "\n<br>Passwords allow sharing preferences between multiple systems. Passwords are completely optional. ";
> 	 print "\n</td></tr>";
> 
> 
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		print "\n<tr><td>Administrator Password </td>";
> 		print "\n<td>";
> 		print
> 		  $q->password_field(
> 			-name      => 'p_adminpw',
> 			-value     => '*',
> 			-size      => 30,
> 			-maxlength => 50
> 		  );
> 		print "\n<br>(blank to remove password)";
> 		print "\n<br>(Administrator passwords are used for special maintenance.)";
> 		print "\n</td></tr>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n<tr><td>Email Address</td>";
> 		print "\n<td>" . &GetFormText( 'email', "", 30, 60 );
> 		print "\n<br>" . &GetFormCheck( 'notify', 1, "Include this address in the site email list." );
> 		print "\n<br>(Uncheck the box to remove the address.) ";
> 		
> 		print "\n</td></tr>";
> 	}
> 	
> 	print "\n</table>";
> 	
> 	print "\n$WikiLinePref<b>$recentName:</b>";
> 	print "\n<br>Default days to display: ";
> 	print &GetFormText( 'rcdays', $RcDefault, 4, 9 );
> 	print "\n<br>", &GetFormCheck( 'rcnewtop', $RecentTop, "Most recent changes on top" );
> 	print "\n<br>", &GetFormCheck( 'rcall', 0, "Show all changes (not just most recent)" );
> 	
> 	%labels = (
> 		0 => "Hide minor edits",
> 		1 => "Show minor edits",
> 		2 => "Show only minor edits"
> 	);
> 	
> 	print "\n<br>Minor edit display: ";
> 	print $q->popup_menu(
> 		-name   => 'p_rcshowedit',
> 		-values => [ 0, 1, 2 ],
> 		-labels => \%labels,
> 		-default => &GetParam( "rcshowedit", $ShowEdits )
> 	);
> 	
> 	print "\n<br>", &GetFormCheck( 'rcchangehist', 1, "Use 'changes' as link to history" );
> 
> 	if ($UseDiff) {
> 		print "\n$WikiLinePref<b>Differences:</b>";
> 		print "\n<br>", &GetFormCheck( 'diffrclink', 1, "Show (diff) links on $recentName " );
> 		print "\n<br>", &GetFormCheck( 'alldiff', 0, "Show differences on all pages" );
> 		print "\n  (", &GetFormCheck( 'norcdiff', 1, "No differences on $recentName " ), ")";
> 		%labels = ( 1 => "Major", 2 => "Minor", 3 => "Author" );
> 		print "\n<br>Default difference type: ";
> 		print $q->popup_menu(
> 			-name   => 'p_defaultdiff',
> 			-values => [ 1, 2, 3 ],
> 			-labels => \%labels,
> 			-default => &GetParam( "defaultdiff", 1 )
> 		);
> 	}
> 	
> 	print "\n$WikiLinePref<b>Misc:</b>";
> 
> 	# Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
> 	print "\n<br>";
> 	print "\nServer time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print &GetFormText( 'tzoffset', 0, 4, 9 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'editwide', 1, "Use 100% wide edit area (if supported)" );
> 	print "\n<br>";
> 	print "\nEdit area rows: ";
> 	print &GetFormText( 'editrows', 20, 4, 4 );
> 	print "\n columns: ";
> 	print &GetFormText( 'editcols', 65, 4, 4 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'toplinkbar', 1, "Show link bar on top" );
> 	print "\n<br>";
> 	print &GetFormCheck( 'linkrandom', 0, "Add 'Random Page' link to link bar" );
> 	print "\n<br>";
> 	print "\nStyleSheet URL: ";
> 	print &GetFormText( 'stylesheet', "", 30, 150 );
> 	print "\n<br><br>";
> 	print "\n<input type='button' name='Cancel' value='Cancel' onclick='history.go(-1);' style='margin-right: 20px;'>";
> 	print "\n<input type='reset' name='Reset'> ";
> 	print $q->submit( -name => 'Save', -value => "Save" );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print "\n$WikiLineFooter";
> 	print "\n<div class='wikifooter'>";
> 	print &GetGotoBar("");
> 
> 	print &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetFormText {
> 	my ( $name, $default, $size, $max ) = @_;
> 	my $text = &GetParam( $name, $default );
> 	
> 	return $q->textfield(
> 		-name      => "p_$name",
> 		-default   => $text,
> 		-override  => 1,
> 		-size      => $size,
> 		-maxlength => $max
> 	);
> }
> 
> sub GetFormCheck {
> 	my ( $name, $default, $label ) = @_;
> 	my $checked = ( &GetParam( $name, $default ) > 0 );
> 	
> 	return $q->checkbox(
> 		-name     => "p_$name",
> 		-override => 1,
> 		-checked  => $checked,
> 		-label    => $label
> 	);
> }
> 
> sub DoUpdatePrefs {
> 	my ( $username, $password, $stylesheet );
> 
> 	# All link bar settings should be updated before printing the header
> 	&UpdatePrefCheckbox("toplinkbar");
> 	&UpdatePrefCheckbox("linkrandom");
> 	
> 	print &GetHeader( "", "Saving Preferences" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $UserID < 1001 ) {
> 		print "\n<h2>Invalid UserID $UserID, preferences not saved.</h2>";
> 		
> 		if ( $UserID == 111 ) {
> 			print "\n<br>(Preferences require cookies, but no cookie was sent.)";
> 		}
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$username = &GetParam( "p_username", "" );
> 	
> 	if ($FreeLinks) {
> 		$username =~ s/^\[\[(.+)\]\]/$1/;    # Remove [[ and ]] if added
> 		$username = &FreeToNormal($username);
> 		$username =~ s/_/ /g;
> 	}
> 	
> 	if ( $username eq "" ) {
> 		print "\n<h2>UserName removed.</h2>";
> 		undef $UserData{'username'};
> 	}
> 	elsif ( ( !$FreeLinks ) && ( !( $username =~ /^$LinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( $FreeLinks && ( !( $username =~ /^$FreeLinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( length($username) > 50 ) {    # Too long
> 		print "\n<h2>UserName must be 50 characters or less. (not saved)</h2>";
> 	}
> 	else {
> 		print "\n<h2>UserName $username saved.</h2>";
> 		$UserData{'username'} = $username;
> 	}
> 	
> 	$password = &GetParam( "p_password", "" );
> 	
> 	if ( $password eq "" ) {
> 		print "\nPassword removed.<br>";
> 		undef $UserData{'password'};
> 	}
> 	elsif ( $password ne "*" ) {
> 		print "\nPassword changed.<br>";
> 		$UserData{'password'} = $password;
> 	}
> 	
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		$password = &GetParam( "p_adminpw", "" );
> 		if ( $password eq "" ) {
> 			print "\nAdministrator password removed.<br>";
> 			undef $UserData{'adminpw'};
> 		}
> 		elsif ( $password ne "*" ) {
> 			print "\nAdministrator password changed.<br>";
> 			$UserData{'adminpw'} = $password;
> 			
> 			if ( &UserIsAdmin() ) {
> 				print "\nUser has administrative abilities.<br>";
> 			}
> 			elsif ( &UserIsEditor() ) {
> 				print "\nUser has editor abilities.<br>";
> 			}
> 			else {
> 				print "\nUser does not have administrative abilities. (Password does not match administrative password(s).) <br>";
> 			}
> 		}
> 	}
> 	if ($EmailNotify) {
> 		&UpdatePrefCheckbox("notify");
> 		&UpdateEmailList();
> 	}
> 	
> 	&UpdatePrefNumber( "rcdays", 0, 0, 999999 );
> 	&UpdatePrefCheckbox("rcnewtop");
> 	&UpdatePrefCheckbox("rcall");
> 	&UpdatePrefCheckbox("rcchangehist");
> 	&UpdatePrefCheckbox("editwide");
> 	
> 	if ($UseDiff) {
> 		&UpdatePrefCheckbox("norcdiff");
> 		&UpdatePrefCheckbox("diffrclink");
> 		&UpdatePrefCheckbox("alldiff");
> 		&UpdatePrefNumber( "defaultdiff", 1, 1, 3 );
> 	}
> 	
> 	&UpdatePrefNumber( "rcshowedit", 1, 0,    2 );
> 	&UpdatePrefNumber( "tzoffset",   0, -999, 999 );
> 	&UpdatePrefNumber( "editrows",   1, 1,    999 );
> 	&UpdatePrefNumber( "editcols",   1, 1,    999 );
> 	
> 	print "\n<br>Server time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print "\n<br>";
> 	$TimeZoneOffset = &GetParam( "tzoffset", 0 ) * ( 60 * 60 );
> 	
> 	print"Local time: ";
> 	print &TimeToText($Now);
> 	print "\n<br>";
> 	$stylesheet = &GetParam( 'p_stylesheet', "" );
> 
> 	if ( $stylesheet eq "" ) {
> 		if ( &GetParam( 'stylesheet', "" ) ne "" ) {
> 			print "\nStyleSheet URL removed.<br>";
> 		}
> 		undef $UserData{'stylesheet'};
> 	}
> 	else {
> 		$stylesheet =~ s/[">]//g;  # Remove characters that would cause problems"
> 		$UserData{'stylesheet'} = $stylesheet;
> 		print "\nStyleSheet setting saved.<br>";
> 	}
> 	
> 	&SaveUserData();
> 	
> 	print "\n<br><b>Preferences saved.</b>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # add or remove email address from preferences to $EmailFile
> sub UpdateEmailList {
> 	my (@old_emails);
> 	local $/ = "\n";               # don't slurp whole files in this sub.
> 	
> 	if ( my $new_email = $UserData{'email'} = &GetParam( "p_email", "" ) ) {
> 		my $notify = $UserData{'notify'};
> 		if ( -f $EmailFile ) {
> 			open( NOTIFY, $EmailFile ) or die( Ts( 'Could not read from %s:', $EmailFile ) . " $!\n" );
> 			@old_emails = <NOTIFY>;
> 			close(NOTIFY);
> 		}
> 		else {
> 			@old_emails = ();
> 		}
> 		
> 		my $already_in_list = grep /$new_email/, @old_emails;
> 		
> 		if ( $notify and ( not $already_in_list ) ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">>$EmailFile" ) ) {
> 				&ReleaseLock();    # Don't leave hangling locks
> 				die( "Could not append to $EmailFile : $!\n" );
> 			}
> 			
> 			print NOTIFY $new_email, "\n";
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 		elsif ( ( not $notify ) and $already_in_list ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">$EmailFile" ) ) {
> 				&ReleaseLock();
> 				die( "Could not overwrite $EmailFile : $!\n" );
> 			}
> 			foreach (@old_emails) {
> 				print NOTIFY "$_" unless /$new_email/;
> 			}
> 			
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 	}
> }
> 
> sub UpdatePrefCheckbox {
> 	my ($param) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	$UserData{$param} = 1 if ( $temp eq "on" );
> 	$UserData{$param} = 0 if ( $temp eq "*" );
> 
> 	# It is possible to skip updating by using another value, like "2"
> }
> 
> sub UpdatePrefNumber {
> 	my ( $param, $integer, $min, $max ) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	return if ( $temp eq "*" );
> 	
> 	$temp =~ s/[^-\d\.]//g;
> 	$temp =~ s/\..*// if ($integer);
> 	
> 	return if ( $temp eq "" );
> 	return if ( ( $temp < $min ) || ( $temp > $max ) );
> 	
> 	$UserData{$param} = $temp;
> }
> 
> sub DoIndex {
> 	print &GetHeader( "", "Index of all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( "", &AllPagesList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Create a new user file/cookie pair
> sub DoNewLogin {
> 
> 	# Consider warning if cookie already exists
> 	# (maybe use "replace=1" parameter)
> 	&CreateUserDir();
> 	$SetCookie{'id'}      = &GetNewUserId();
> 	$SetCookie{'randkey'} = int( rand(1000000000) );
> 	$SetCookie{'rev'}     = 1;
> 	%UserCookie           = %SetCookie;
> 	$UserID               = $SetCookie{'id'};
> 
> 	# The cookie will be transmitted in the next header
> 	%UserData               = %UserCookie;
> 	$UserData{'createtime'} = $Now;
> 	$UserData{'createip'}   = $ENV{REMOTE_ADDR};
> 	&SaveUserData();
> }
> 
> sub DoEnterLogin {
> 	print &GetHeader( "", "Login", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>Enter UserID</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( 'enter_login', 1 );
> 	print "\n<table><tr>";
> 	print "\n<td>User ID number &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->textfield(
> 		-name      => 'p_userid',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n<tr>";
> 	print "\n<td>Password  &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n</tr></table><br>";
> 	print $q->submit( -name => 'Login', -value => 'Login' );
> 	print "\n<br></form></div>";
> 	print &GetCommonFooter();
> 	print "\n</div></body></html>";	
> }
> 
> sub DoLogin {
> 	my ( $uid, $password, $success );
> 	
> 	$success = 0;
> 	$uid = &GetParam( "p_userid", "" );
> 	$uid =~ s/\D//g;
> 	$password = &GetParam( "p_password", "" );
> 	
> 	print &GetHeader( "", "Login Results", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( ( $uid > 199 ) && ( $password ne "" ) && ( $password ne "*" ) ) {
> 		$UserID = $uid;
> 		&LoadUserData();
> 		if ( $UserID > 199 ) {
> 			if ( defined( $UserData{'password'} ) && ( $UserData{'password'} eq $password ) ) {
> 				$SetCookie{'id'}      = $uid;
> 				$SetCookie{'randkey'} = $UserData{'randkey'};
> 				$SetCookie{'rev'}     = 1;
> 				$success              = 1;
> 			}
> 			else {
> 				print "\nUserID Account Undefined<br>";
> 			}
> 		}
> 		else {
> 			print "\nUserID must be above 199<br>";
> 		}
> 	}
> 	
> 	
> 	if ($success) {
> 		print "\n<h2>Login for user ID $uid complete.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Login for user ID $uid failed.</h2>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter;
> 	print "\n</div></body></html>";	
> }
> 
> sub GetNewUserId {
> 	my ($id);
> 	
> 	$id = $StartUID;
> 	
> 	while ( -f &UserDataFilename( $id + 1000 ) ) {
> 		$id += 1000;
> 	}
> 	
> 	while ( -f &UserDataFilename( $id + 100 ) ) {
> 		$id += 100;
> 	}
> 	
> 	while ( -f &UserDataFilename( $id + 10 ) ) {
> 		$id += 10;
> 	}
> 	
> 	&RequestLock() or die( "Could not get user-ID lock" );
> 	while ( -f &UserDataFilename($id) ) {
> 		$id++;
> 	}
> 	
> 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
> 	&ReleaseLock();
> 	
> 	return $id;
> }
> 
> # Consider user-level lock?
> sub SaveUserData {
> 	my ( $userFile, $data );
> 	
> 	&CreateUserDir();
> 	$userFile = &UserDataFilename($UserID);
> 	$data = join( $FS1, %UserData );
> 	&WriteStringToFile( $userFile, $data );
> }
> 
> sub CreateUserDir {
> 	my ( $n, $subdir );
> 	
> 	if ( !( -d "$UserDir/0" ) ) {
> 		&CreateDir($UserDir);
> 		foreach $n ( 0 .. 9 ) {
> 			$subdir = "$UserDir/$n";
> 			&CreateDir($subdir);
> 		}
> 	}
> }
> 
> sub DoSearch {
> 	my ($string, $filter) = @_;
> 	my ( $title );
> 	if ( $string eq "" ) {
> 		&DoIndex();
> 		return;
> 	}
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( "Search for: $title %s", $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( $filter, &SearchTitleAndBody($string, $filter) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='search' value='$string'>";
> 	print "\n<input type='hidden' name='dosearch' value='1'>";	
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoBackLinks {
> 	my ($string, $filter) = @_;
> 	my ($title);
> 	
> 	$title = $string;
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( 'Backlinks for: %s', $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	# At this time the backlinks are mostly a renamed search.
> 	# An initial attempt to match links only failed on subpages and free links.
> 	# Escape some possibly problematic characters:
> 	
> 	$string =~ s/([_ ])/( |_)/g;
> 	$string =~ s/([-'(),])/\\$1/g; #'REMARK
> 	$string =~ m,/, ? "\\b$string\\b" : "$string\\b";
> 	
> 	print PrintPageList( grep($_ !~ $title, $filter, &SearchTitleAndBody($string, $filter, "")) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='back' value='$string'>";
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub PrintPageList {
> 	my ($filter, @results) = @_;
> 	my $term;
>     my $pagename;
>     my $html = "";
>     my $pagecount = scalar(@results);
>     my $currentInitial = "";
>     my $thisInitial;
>     my $lastInitial;
>     my $letterGrouping = ($pagecount > 25);
>     my $currentParent = "";
>     my $linktext = "";
>     my $notFirst;
> 
> 	if ($filter ne ""){ $term = " using filter '<em>$filter</em>'"; }
> 	$html .= "<h2>" . ( scalar(@results) ) . " pages found: $term</h2>";
>     #$html .= "<ol>\n" if ($letterGrouping ne 1); # commented to keep a 'original' usemod look
>     
>     if ($letterGrouping) {
>         $html .= "<h3 class='lettergroup'>";
>         foreach $pagename (@results) {
>             $thisInitial = substr($pagename,0,1);
>             if ($thisInitial ne $lastInitial) {
>                     $html .= "<a href=\"#letter".$thisInitial."\">".$thisInitial."</a> ";
>                     $lastInitial = $thisInitial;
>             }
>         }
>         $html .= "</h3>";
>     }
>     
>     foreach $pagename (@results) {
>         if ($letterGrouping) {
>             $thisInitial = substr($pagename,0,1);
>             if ($currentInitial ne $thisInitial) {
>                 #$html .= "</ol>" if ($currentInitial ne ""); # commented to keep a 'original' usemod look
>                 $html .= "\n<br><br><h3 class='lettergroup'><a name=\"letter$thisInitial\"> $thisInitial </h3>\n$WikiLine\n";
>                 #$html .= "<ol>\n"; # commented to keep a 'original' usemod look
>                 $currentInitial = $thisInitial; 
>                 $notFirst = 0;
>             }
>         }
>         #$html .= "<li>"; # commented to keep a 'original' usemod look
>         $html .= "   ";
>         if (not($pagename =~ m|(.*)/(.*)|)) {
>             $currentParent = $pagename;
>             $linktext = $pagename;
>         } 
>         else {
>             if ($1 eq $currentParent) {
>                 if ($letterGrouping){  $linktext = "$currentParent/$2";}
>                 else { $html .= "... "; $linktext = "/$2";}                
>             } 
>             else {
>                 $linktext = $pagename;
>             }
>         }
>         if ($notFirst){ $notFirst = 1; $linktext = ", $linktext"; }
>         $html .= &GetPageLinkText($pagename,$linktext);
> 
>         if ($letterGrouping){ $html .= ", "; }
>         else { $html .= "\n<br>"; }
>     }
>     #$html .= "</ol>\n"; # commented to keep a 'original' usemod look
>     $html .= "\n<br>";
>     
>     return $html;
> }
> 
> sub DoLinks {	
> 	print &GetHeader( "", &QuoteHtml( "Full Link List" ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<hr><pre>\n\n\n\n";    # Extra lines to get below the logo
> 
> 	print &PrintLinkList(&GetFullLinkList(
> 		&GetParam("unique", 1),
> 		&GetParam("sort", 1),
> 		&GetParam("page", 1),
> 		&GetParam("inter", 0),
> 		&GetParam("url", 0),
> 		&GetParam("exists", 2),
> 		&GetParam("empty", 0),
> 		&GetParam("search", "")
> 	));
> 	
> 	print "\n</pre>";
> 	print "\n</div>";
> 	print "\n</div></div></body></html>";	
> }
> 
> sub PrintLinkList {
> 	my ( $pagelines, $page,  $names, $editlink );
> 	my ( $link, $text, $extra, @links, %pgExists );
> 	
> 	%pgExists = ();
> 	
> 	foreach $page ( &AllPagesList() ) {
> 		$pgExists{$page} = 1;
> 	}
> 	
> 	$names    = &GetParam( "names",    1 );
> 	$editlink = &GetParam( "editlink", 0 );
> 	
> 	foreach $pagelines (@_) {
> 		@links = ();
> 		
> 		foreach $page ( split( ' ', $pagelines ) ) {
> 			if ( $page =~ /\:/ ) {    # URL or InterWiki form
> 				if ( $page =~ /$UrlPattern/ ) {
> 					( $link, $extra ) = &UrlLink( $page, 0 );    # No images
> 				}
> 				else {
> 					( $link, $extra ) = &InterPageLink( $page, 0 );  # No images
> 				}
> 			}
> 			else {
> 				if ( $pgExists{$page} ) {
> 					$link = &GetPageLink($page);
> 				}
> 				else {
> 					$link = $page;
> 					if ($editlink) {
> 						$link .= &GetEditLink( $page, "?" );
> 					}
> 				}
> 			}
> 			
> 			push( @links, $link );
> 		}
> 		if ( !$names ) {
> 			shift(@links);
> 		}
> 		
> 		$text .= join(' ', @links) . "\n";
> 	}
> 	
> 	return $text;
> }
> 
> sub GetFullLinkList {
> 	my ($unique, $sort, $pagelink, $interlink, $urllink, $exists, $empty, $search, $listWantedPages )= @_ ;
> 	my ($name, $link ); # foreach iterators (though why not use $_ ?)
> 	#my ($name, $unique, $sort, $exists, $empty, $link, $search);
> 	#my ($pagelink, $interlink, $urllink);
> 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
> 	
> 	#$unique = &GetParam("unique", 1);
> 	#$sort = &GetParam("sort", 1);
> 	#$pagelink = &GetParam("page", 1);
> 	#$interlink = &GetParam("inter", 0);
> 	#$urllink = &GetParam("url", 0);
> 	#$exists = &GetParam("exists", 2);
> 	#$empty = &GetParam("empty", 0);
> 	#$search = &GetParam("search", "");
> 	
> 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) {
> 		$pagelink = 0;
> 	}
> 	%pgExists = ();
> 	@pglist   = &AllPagesList();
> 	
> 	foreach $name (@pglist) {
> 		$pgExists{$name} = 1;
> 	}
> 	%seen = ();
> 	
> 	foreach $name (@pglist) {
> 		@newlinks = ();
> 		if ( $unique != 2 ) {
> 			%seen = ();
> 		}
> 		
> 		@links = &GetPageLinks($name, $pagelink, $interlink, $urllink, $listWantedPages);
> 	
> 	    foreach $link (@links) {
> 			if ($link =~ m/^\//){
> 				$name =~ m/(.*)\//;
> 				
> 				if ($1){ $link = $1 . $link; }
> 				else { $link = $name . $link; }
> 			}
> 			
> 			$seen{$link}++;
> 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) {
> 				next;
> 			}
> 			push( @newlinks, $link );
> 		}
> 		
> 		@links = @newlinks;
> 		if ($sort) {
> 			@links = sort(@links);
> 		}
> 		unshift( @links, $name );
> 		
> 		if ( $empty || ( $#links > 0 ) ) {    # If only one item, list is empty.
> 			push( @found, join( ' ', @links ) );
> 		}
> 	}
> 	return @found;
> }
> 
> sub GetSubpages {
> 	my ($parentPage) = @_;
> 	my ($dir, @subpageFiles, @pages, $subId);
> 	
> 	return "" unless $parentPage;
> 	$dir = GetPageDirectory($parentPage);
> 	
> 	opendir(PAGELIST, "$PageDir/$dir/$parentPage") or return "";
> 	@subpageFiles = readdir(PAGELIST);
> 	closedir(PAGELIST);
> 	
> 	foreach $subId (@subpageFiles) {
> 		if (substr($subId, -3) eq '.db') {
> 		  push(@pages, "$parentPage/" . substr($subId, 0, -3));
> 		}
> 	}
> 	return @pages;
> }
> 
> sub GetPageList {
> 	my ($pagename, $retval);
> 	my (@list) = @_;
> 
> 	foreach $pagename (@list) {
> 	##	$retval .= ".... " if ($pagename =~ m|/|);
> 		$retval .= "&nbsp;" . &GetPageLink($pagename) . "<br>";
> 	}
> 
> 	return $retval;
> }
> 
> sub GetPageLinks {
> 	my ( $name, $pagelink, $interlink, $urllink, $listWantedPages ) = @_;
> 	my ( $text, @links );
> 	
> 	@links = ();
> 	&OpenPage($name);
> 	&OpenDefaultText();
> 	
> 	$text = $Text{'text'};
> 	$text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
> 	$text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
> 	$text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
> 	$text =~ s/<tt>(.|\n)*?\<\/tt>/ /ig;
> 	
> 	if ($interlink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to inter-site links
> 		$text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$InterLinkPattern/ /g;
> 	}
> 	
> 	if ($urllink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to URLs
> 		$text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$UrlPattern/ /g;
> 	}
> 	
> 	if ($pagelink) {
> 		if ($FreeLinks) {
> 			my $f2 = $FreeLinkPattern;
> 			
> 			$text =~ s/\[\[$f2\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 			$text =~ s/\[\[$f2\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 		}
> 		
> 		if ($listWantedPages){ $text =~ s/\[((.|\n)*?)\]/ /ig; }
> 			
> 		if ($WikiLinks) {
> 			$text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 		}
> 	}
> 	
> 	return @links;
> }
> 
> sub DoPost {
> 	my ( $editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user );
> 	my $string      = &GetParam( "text",        undef );
> 	my $id          = &GetParam( "title",       "" );
> 	my $summary     = &GetParam( "summary",     "" );
> 	my $oldtime     = &GetParam( "oldtime",     "" );
> 	my $oldconflict = &GetParam( "oldconflict", "" );
> 	my $isEdit      = 0;
> 	my $editTime    = $Now;
> 	my $authorAddr  = $ENV{REMOTE_ADDR};
> 	
> 	if ($id =~ /($LinkPattern)/){
> 		$id = $1;
> 	}
> 	else {
> 		die "The page name $id is not valid";
> 	}
> 	
> 	if ($FreeLinks){
> 		$id = &FreeToNormal($id);
> 	}
> 	
> 	if ( !&UserCanEdit( $id, 1 ) ) {
> 		# This is an internal interface--we don't need to explain
> 		&ReportError( Ts( 'Editing not allowed for %s.', $id ) );
> 		return;
> 	}
> 	
> 	if (   ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'Sample_Undefined_Page' )
> 		|| ( $id eq 'Sample_Undefined_Page' ) )
> 	{
> 		&ReportError( " $id cannot be defined." );
> 		return;
> 	}
> 	
> 	$string  = &RemoveFS($string);
> 	$summary = &RemoveFS($summary);
> 	$summary =~ s/[\r\n]//g;
> 	
> 	if ( length($summary) > 300 ) {    # Too long (longer than form allows)
> 		$summary = substr( $summary, 0, 300 );
> 	}
> 
> 	# Add a newline to the end of the string (if it doesn't have one)
> 	$string .= "\n" if ( !( $string =~ /\n$/ ) );
> 
> 
> 	# Lock before getting old page to prevent races
> 	# Consider extracting lock section into sub, and eval-wrap it?
> 	# (A few called routines can die, leaving locks.)
> 	if ($LockCrash) {
> 		&RequestLock() or die( "Could not get editing lock" );
> 	}
> 	else {
> 		if ( !&RequestLock() ) {
> 			&ForceReleaseLock('main');
> 		}
> 
> 		# Clear all other locks.
> 		&ForceReleaseLock('cache');
> 		&ForceReleaseLock('diff');
> 		&ForceReleaseLock('index');
> 	}
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$old     = $Text{'text'};
> 	$oldrev  = $Section{'revision'};
> 	$pgtime  = $Section{'ts'};
> 	$preview = 0;
> 	$preview = 1 if ( &GetParam( "Preview", "" ) ne "" );
> 	
> 	if ( !$preview && ( $old eq $string ) ) {    # No changes (ok for preview)
> 		&ReleaseLock();
> 		&ReBrowsePage( $id, "", 1 );
> 		return;
> 	}
> 	
> 	if ( ( $UserID > 399 ) || ( $Section{'id'} > 399 ) ) {
> 		$newAuthor = ( $UserID ne $Section{'id'} );    # known user(s)
> 	}
> 	else {
> 		$newAuthor = ( $Section{'ip'} ne $authorAddr );    # hostname fallback
> 	}
> 	$newAuthor = 1 if ( $oldrev == 0 );    # New page
> 	$newAuthor = 0 if ( !$newAuthor );     # Standard flag form, not empty
> 	                                       # Detect editing conflicts and resubmit edit
> 	                                       
> 	if ( ( $oldrev > 0 ) && ( $newAuthor && ( $oldtime != $pgtime ) ) ) {
> 		&ReleaseLock();
> 		if ( $oldconflict > 0 ) {    # Conflict again...
> 			&DoEdit( $id, 2, $pgtime, $string, $preview );
> 		}
> 		else {
> 			&DoEdit( $id, 1, $pgtime, $string, $preview );
> 		}
> 		return;
> 	}
> 	
> 	if ($preview) {
> 		&ReleaseLock();
> 		&DoEdit( $id, 0, $pgtime, $string, 1 );
> 		return;
> 	}
> 	
> 	$user = &GetParam( "username", "" );
> 
> 	# If the person doing editing chooses, send out email notification
> 	if ($EmailNotify) {
> 		&EmailNotify( $id, $user )
> 		  if &GetParam( "do_email_notify", "" ) eq 'on';
> 	}
> 	
> 	if ( &GetParam( "recent_edit", "" ) eq 'on' ) {
> 		$isEdit = 1;
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'oldmajor', $Section{'revision'} );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'oldauthor', $Section{'revision'} );
> 	}
> 	
> 	&SaveKeepSection();
> 	&ExpireKeepFile();
> 	
> 	if ($UseDiff) {
> 		&UpdateDiffs( $id, $editTime, $old, $string, $isEdit, $newAuthor );
> 	}
> 	
> 	$Text{'text'}      = $string;
> 	$Text{'minor'}     = $isEdit;
> 	$Text{'newauthor'} = $newAuthor;
> 	$Text{'summary'}   = $summary;
> 	$Section{'host'}   = &GetRemoteHost(1);
> 	
> 	&SaveDefaultText();
> 	&SavePage();
> 	&WriteRcLog( $id, $summary, $isEdit, $editTime, $Section{'revision'}, $user,
> 		$Section{'host'} );
> 
> 	if ($UseCache) {
> 		&UnlinkHtmlCache($id);    # Old cached copy is invalid
> 		if ( $Page{'revision'} < 2 ) {    # If this is a new page...
> 			&NewPageCacheClear($id);      # ...uncache pages linked to this one.
> 		}
> 	}
> 	
> 	if ( $UseIndex && ( $Page{'revision'} == 1 ) ) {
> 		unlink($IndexFile);               # Regenerate index on next request
> 	}
> 	&ReleaseLock();
> 	&ReBrowsePage( $id, "", 1 );
> }
> 
> sub UpdateDiffs {
> 	my ( $id, $editTime, $old, $new, $isEdit, $newAuthor ) = @_;
> 	my ( $editDiff, $oldMajor, $oldAuthor );
> 	
> 	$editDiff  = &GetDiff( $old, $new, 0 );    # 0 = already in lock
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	if ($UseDiffLog) {
>   		my $editDiff = Diff::diffClassic($old, $new);  # add this line
>   		&WriteDiff($id, $editTime, $editDiff);
> 	}
> 	
> 	&SetPageCache( 'diff_default_minor', $editDiff );
> 	if ( $isEdit || !$newAuthor ) {
> 		&OpenKeptRevisions('text_default');
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'diff_default_major', "1" );
> 	}	
> 	else {
> 		&SetPageCache( 'diff_default_major',
> 			&GetKeptDiff( $new, $oldMajor, 0 ) );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'diff_default_author', "1" );
> 	}	
> 	elsif ( $oldMajor == $oldAuthor ) {
> 		&SetPageCache( 'diff_default_author', "2" );
> 	}
> 	else {
> 		&SetPageCache( 'diff_default_author',
> 			&GetKeptDiff( $new, $oldAuthor, 0 ) );
> 	}
> }
> 
> # Translation note: the email messages are still sent in English
> # Send an email message.
> sub SendEmail {
> 	my ( $to, $from, $reply, $subject, $message ) = @_;
> 
> 	# sendmail options:
> 	#    -odq : send mail to queue (i.e. later when convenient)
> 	#    -oi  : do not wait for "." line to exit
> 	#    -t   : headers determine recipient.
> 	open( SENDMAIL, "| $SendMail -oi -t " ) or die "Can't send email: $!\n";
> 	print SENDMAIL "From: $from\n";
> 	print SENDMAIL "To: $to\n";
> 	print SENDMAIL "Reply-to: $reply\n";
> 	print SENDMAIL "Subject: $subject\n";
> 	print SENDMAIL "$message\n";
> 	close(SENDMAIL) or warn "sendmail didn't close nicely";
> }
> ## Email folks who want to know a note that a page has been modified. - JimM.
> sub EmailNotify {
> 	local $/ = "\n";    # don't slurp whole files in this sub.
> 	
> 	if ($EmailNotify) {
> 		my ( $id, $user ) = @_;
> 		
> 		if ($user) {
> 			$user = " by $user";
> 		}
> 		
> 		my $address;
> 		
> 		return if ( !-f $EmailFile );    # No notifications yet
> 		
> 		open( EMAIL, $EmailFile )
> 		  or die "Can't open $EmailFile: $!\n";
> 		$address = join ",", <EMAIL>;
> 		$address =~ s/\n//g;
> 		close(EMAIL);
> 		
> 		my $home_url        = $q->url();
> 		my $page_url        = $home_url . "?$id";
> 		my $editors_summary = $q->param("summary");
> 
> 		if ( ( $editors_summary eq "*" ) or ( $editors_summary eq "" ) ) {
> 			$editors_summary = "";
> 		}
> 		else {
> 			$editors_summary = " Summary: $editors_summary";
> 		}
> 		
> 		my $content = <<"END_MAIL_CONTENT";
> 
>  The $SiteName page $id at
>    $page_url
>  has been changed$user to revision $Page{revision}. $editors_summary
> 
>  (Replying to this notification will
>   send email to the entire mailing list,
>   so only do that if you mean to.
> 
>   To remove yourself from this list, visit
>   ${home_url}?action=editprefs .)
> END_MAIL_CONTENT
> 		my $subject = "The $id page at $SiteName has been changed.";
> 
> 		# I'm setting the "reply-to" field to be the same as the "to:" field
> 		# which seems appropriate for a mailing list, especially since the
> 		# $EmailFrom string needn't be a real email address.
> 		&SendEmail( $address, $EmailFrom, $address, $subject, $content );
> 	}
> }
> 
> sub SearchTitleAndBody {
> 	my ($term, $filter) = @_;
> 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
> 	
> 	#If the search term has a !preceding it, strip it and set the exclusion flag
> 	if ($term =~ m/^\!/){ 
> 		$excludeTerm = 1;
> 		$term = substr($term, 1);	
> 	}
> 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
> 	if ($filter =~ m/^\!/){ 
> 		$excludeFilter = 1;
> 		$filter = substr($filter, 1);	
> 	}
> 
> 	foreach $name ( &AllPagesList() ) {
> 		if ($excludeFilter){
> 			if ($filter) { next if ($name =~ m/$filter/); }
> 		}
> 		else {
> 			if ($filter) { next unless ($name =~ m/$filter/); }
> 
> 		}
> 		
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if (!$excludeTerm){  
> 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( $freeName =~ /$term/i ) {
> 					push( @found, $name );
> 				}
> 			}
> 		}
> 		else { 
> 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( ! ($freeName =~ /$term/i) ) {
> 					push( @found, $name );
> 				}
> 			}			
> 		}
> 	}
> 	
> 	return @found;
> }
> 
> sub SearchBody {
> 	my ($string) = @_;
> 	my ( $name, @found );
> 	
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if ( $Text{'text'} =~ /$string/i ) {
> 			push( @found, $name );
> 		}
> 	}
> 	
> 	return @found;
> }
> 
> sub UnlinkHtmlCache {
> 	my ($id) = @_;
> 	my $idFile;
> 	
> 	$idFile = &GetHtmlCacheFile($id);
> 	
> 	if ( -f $idFile ) {
> 		unlink($idFile);
> 	}
> }
> 
> sub NewPageCacheClear {
> 	my ($id) = @_;
> 	my $name;
> 	
> 	return if ( !$UseCache );
> 	
> 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
> 	                    # The following code used to search the body for the $id
> 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
> 		&UnlinkHtmlCache($name);
> 	}
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub DoUnlock {
> 	my $LockMessage = "Normal Unlock.";
> 	
> 	print &GetHeader( "", "Removing edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>This operation may take several seconds...</h2>\n";
> 	
> 	if ( &ForceReleaseLock('main') ) {
> 		$LockMessage = "Forced Unlock.";
> 	}
> 	
> 	&ForceReleaseLock('cache');
> 	&ForceReleaseLock('diff');
> 	&ForceReleaseLock('index');
> 	
> 	print "\n<br><h2>$LockMessage</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub WriteRcLog {
> 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
> 	my ( $extraTemp, %extra );
> 	
> 	%extra = ();
> 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
> 	$extra{'name'}     = $name     if ( $name ne "" );
> 	$extra{'revision'} = $revision if ( $revision ne "" );
> 	$extraTemp = join( $FS2, %extra );
> 
> 	# The two fields at the end of a line are kind and extension-hash
> 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
> 	
> 	if ( !open( OUT, ">>$RcFile" ) ) {
> 		die( Ts( '%s log error:', $RCName ) . " $!" );
> 	}
> 	
> 	print OUT $rc_line . "\n";
> 	close(OUT);
> }
> 
> sub WriteDiff {
> 	my ( $id, $editTime, $diffString ) = @_;
> 	
> 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
> 	print OUT "------\n" . $id . "|" . $editTime . "\n";
> 	print OUT $diffString;
> 	close(OUT);
> }
> 
> # Actions are vetoable if someone edits the page before
> # the keep expiry time. For example, page deletion. If
> # no one edits the page by the time the keep expiry time
> # elapses, then no one has vetoed the last action, and the
> # action is accepted.
> # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
> sub ProcessVetos {
> 	my ($expirets);
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	
> 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
> 	
> 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
> 		&DeletePage( $OpenPageName, 1, 1 );
> 		return ( 1, "(deleted)" );
> 	}
> 	
> 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
> 		my $fname = $1;
> 
> 		# Only replace an allowed, existing file.
> 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
> 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
> 				my $string = $1;
> 				
> 				$string =~ s/\r\n/\n/gms;
> 				open( OUT, ">$fname" ) or return 0;
> 				print OUT $string;
> 				close OUT;
> 				
> 				return ( 0, "(replaced)" );
> 			}
> 		}
> 	}
> 	return ( 0, "(done)" );
> }
> 
> sub DoMaintain {
> 	my ( $name, $fname, $data, $message, $status );
> 	
> 	print &GetHeader( "", "Maintenance on all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	$fname = "$DataDir/maintain";
> 	
> 	if ( !&UserIsAdmin() ) {
> 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
> 			print "\nMaintenance not done. ";
> 			print "\n(Maintenance can only be done once every 12 hours.)";
> 			print "\nRemove the 'maintain' file or wait.";
> 			print "\n</div>";
> 			print &GetCommonFooter();
> 			print "\n</div></div></body></html>";
> 			
> 			return;
> 		}
> 	}
> 	
> 	&RequestLock() or die( "Could not get maintain-lock" );
> 
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		( $status, $message ) = &ProcessVetos();
> 		&ExpireKeepFile() unless $status;
> 		
> 		print "\n.... " if ( $name =~ m|/| );
> 		print &GetPageLink($name);
> 		print "\n $message<br>";
> 	}
> 
> 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
> 	&ReleaseLock();
> 
> 	# Do any rename/deletion commands
> 	# (Must be outside lock because it will grab its own lock)
> 	$fname = "$DataDir/editlinks";
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		print "\n<hr>Processing rename/delete commands:<br>";
> 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
> 		unlink("$fname.old");
> 		rename( $fname, "$fname.old" );
> 	}
> 	
> 	if ($MaintTrimRc) {
> 		&RequestLock() or die( "Could not get lock for RC maintenance" );
> 		$status = &TrimRc();                # Consider error messages?
> 		&ReleaseLock();
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Must be called within a lock.
> # Thanks to Alex Schroeder for original code
> sub TrimRc {
> 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
> 
> 	# Determine the number of days to go back
> 	$days = 0;
> 	
> 	foreach (@RcDays) {
> 		$days = $_ if $_ > $days;
> 	}
> 	$starttime = $Now - $days * 24 * 60 * 60;
> 	return 1 if ( !-f $RcFile );    # No work if no file exists
> 	( $status, $data ) = &ReadFile($RcFile);
> 	
> 	if ( !$status ) {
> 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
> 		
> 		return 0;
> 	}
> 
> 	# Move the old stuff from rc to temp
> 	@rc = split( /\n/, $data );
> 	
> 	for ( $i = 0 ; $i < @rc ; $i++ ) {
> 		($ts) = split( /$FS3/, $rc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	
> 	return 1 if ( $i < 1 );    # No lines to move from new to old
> 	
> 	@temp = splice( @rc, 0, $i );
> 
> 	# Write new files and backups
> 	if ( !open( OUT, ">>$RcOldFile" ) ) {
> 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
> 		return 0;
> 	}
> 	print OUT join( "\n", @temp ) . "\n";
> 	close(OUT);
> 	
> 	&WriteStringToFile( $RcFile . '.old', $data );
> 	$data = join( "\n", @rc );
> 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
> 	&WriteStringToFile( $RcFile, $data );
> 	
> 	return 1;
> }
> 
> sub DoMaintainRc {
> 	print &GetHeader( "", "Maintaining RC log", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	&RequestLock() or die( "Could not get lock for RC maintenance" );
> 	
> 	if ( &TrimRc() ) {
> 		print "\n<br>RC maintenance done.<br>";
> 	}
> 	else {
> 		print "\n<br>RC maintenance not done.<br>";
> 	}
> 	&ReleaseLock();
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub UserIsEditorOrError {
> 	if ( !&UserIsEditor() ) {
> 		print "\n<h2>This operation is restricted to site editors only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></body></html>";
> 			
> 		return 0;
> 	}
> 	
> 	return 1;
> }
> 
> sub UserIsAdminOrError {
> 	if ( !&UserIsAdmin() ) {
> 		print "\n<h2>This operation is restricted to administrators only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></body></html>";	
> 		return 0;
> 	}
> 	
> 	return 1;
> }
> 
> sub CheckIsAuthUser {
> 	my ($id) = @_;
> 	my $auth = ""; 
> 	my $found = 0;
> 	my $authtype;
> 	my $authname; 
> 	my $aname;
> 	my $afname;
> 	my $linecount = 0;
> 
> 	if (!(&UserIsAdmin())) {
> 		$aname = $id;
> 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
> 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
> 		
> 		if (-r $afname) {			
> 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
> 			
> 			open (AFN,"<$afname");
> 			while (<AFN>) {
> 				if (/$FS1/) { next; }       	# skip header and footer
> 				if (/^>\s[^\w]/) { next; }  	# skip comments	
> 				if (/diff-/){ next; }		
> 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
> 					$authtype = $1;
> 					$authname = $2; 
> 					
> 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
> 					elsif ($authtype eq "r"){ $authtype = "1"; }
> 					else { $authtype = "1"; }
> 					
> 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
> 				}
> 			}
> 			close AFN;
> 			if ($linecount == 0){ $auth = "3"; }
> 			elsif ($found == 0) { $auth = ""; }
> 		}
> 		else {
> 			$auth = "3";
> 		}
> 	}
> 	else {
> 		$auth = "3";
> 	}
> 	return $auth;
> }
> 
> sub DoEditLock {
> 	my ($fname);
> 	
> 	print &GetHeader( "", "Set or Remove global edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	$fname = "$DataDir/noedit";
> 
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 	
> 	if ( -f $fname ) {
> 		print "\n<h2>Edit lock created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Edit lock removed.</h2>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoPageLock {
> 	my ( $fname, $id );
> 	
> 	print &GetHeader( "", "Set or Remove page edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	# Consider allowing page lock/unlock at editor level?
> 	return if ( !&UserIsAdminOrError() );
> 		
> 	$id = &GetParam( "id", "" );
> 	if ( $id eq "" ) {
> 		print "\n<p>Missing page id to lock/unlock...</p>";
> 		
> 		return;
> 	}
> 	
> 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
> 	$fname = &GetLockedPageFile($id);
> 	
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 
> 	if ( -f $fname ) {
> 		print "\n<h2>Lock for '$id' created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Lock for '$id' removed.</h2>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoEditBanned {
> 	my ( $banList, $status );
> 	
> 	print &GetHeader( "", "Editing Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	return if ( !&UserIsAdminOrError() );
> 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
> 	$banList = "" if ( !$status );
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_ban", 1 );
> 	print "\n<h2> Banned IP/network/host list:</h2>";
> 	print "\nEach entry is either a commented line (starting with #), ";
> 	print "\nor a Perl regular expression (matching either an IP address or ";
> 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
> 	print "\ngive up your admin access (remove password in Preferences).";
> 	print "\n<p><br><b>Example:</b><br><br>";
> 	print "\n# blocks hosts ending with .foocorp.com<br>";
> 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
> 	print "\n# blocks exact IP address<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
> 	print "\n# blocks whole 123.21.3.* IP network<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
> 	print &GetTextArea( 'banlist', $banList, 12, 50 );
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Save' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	;
> }
> 
> sub DoUpdateBanned {
> 	my ( $newList, $fname );
> 	
> 	print &GetHeader( "", "Updating Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$fname = "$DataDir/banlist";
> 	$newList = &GetParam( "banlist", "#Empty file" );
> 	
> 	if ( $newList eq "" ) {
> 		print "\n<p>Empty banned list or error.</p>";
> 		print "\n<p>Resubmit with at least one space character to remove.</p>";
> 	}
> 	elsif ( $newList =~ /^\s*$/s ) {
> 		unlink($fname);
> 		print "\n<p>Removed banned list</p>";
> 	}
> 	else {
> 		&WriteStringToFile( $fname, $newList );
> 		print "\n<p>Updated banned list</p>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # ==== Editing/Deleting pages and links ====
> sub DoEditLinks {
> 	print &GetHeader( "", "Editing Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_links", 1 );
> 	print "\n<h2>Editing/Deleting page titles:</h2>";
> 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
> 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
> 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
> 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
> 	print &GetTextArea( 'commandlist', "", 12, 50 );
> 	print "\n<br><br>";
> 	print $q->checkbox(
> 		-name     => "p_changerc",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Edit $RCName"
> 	);
> 	print "\n<br>";
> 	print $q->checkbox(
> 		-name     => "p_changetext",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Substitute text for rename"
> 	);
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Process Command' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub UpdateLinksList {
> 	my ( $commandList, $doRC, $doText ) = @_;
> 	
> 	if ($doText) {
> 		&BuildLinkIndex();
> 	}
> 	&RequestLock() or die "UpdateLinksList could not get main lock";
> 	unlink($IndexFile) if ($UseIndex);
> 	
> 	foreach ( split( /\n/, $commandList ) ) {
> 		s/\s+$//g;
> 		
> 		next if ( !(/^[=!|?]/) );    # Only valid commands.
> 		print "\nProcessing $_<br>\n";
> 		
> 		if (/^\!(.+)/) {
> 			&DeletePage( $1, $doRC, $doText );
> 		}
> 		elsif (/^\?(.+)/){
> 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
> 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
> 			print "\n<br><br>";
> 		}
> 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
>       		my $GivenPage = $1;
>       		my $GivenNewName = $2;
>       
>       		if ($GivenPage =~ s[\/\*][]) {
>        			print "\nRenaming subpages of $GivenPage too...<br>";
>         
>         		foreach (&AllSubPagesList($GivenPage)) {
> 					my $NewSubName = $_;
> 					
> 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
> 					print "\nrenaming $_ to $NewSubName<br>";
> 					&RenamePage($_, $NewSubName, $doRC, $doText);
> 		        }
>       		}
> 		      # rename the page itself
> 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
> 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
> 		}
> 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
> 			&RenameTextLinks( $1, $2 );
> 		}
> 	}
> 	
> 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
> 	unlink($IndexFile) if ($UseIndex);
> 	&ReleaseLock();
> }
> 
> sub BuildLinkIndex {
> 	my ( @pglist, $page, @links, $link, %seen );
> 	
> 	@pglist    = &AllPagesList();
> 	%LinkIndex = ();
> 	
> 	foreach $page (@pglist) {
> 		&BuildLinkIndexPage($page);
> 	}
> }
> 
> sub BuildLinkIndexPage {
> 	my ($page) = @_;
> 	my ( @links, $link, %seen );
> 	
> 	@links = &GetPageLinks( $page, 1, 0, 0 );
> 	%seen = ();
> 	
> 	foreach $link (@links) {
> 		if ( defined( $LinkIndex{$link} ) ) {
> 			if ( !$seen{$link} ) {
> 				$LinkIndex{$link} .= " " . $page;
> 			}
> 		}
> 		else {
> 			$LinkIndex{$link} .= " " . $page;
> 		}
> 		$seen{$link} = 1;
> 	}
> }
> 
> sub DoUpdateLinks {
> 	my ( $commandList, $doRC, $doText );
> 	
> 	print &GetHeader( "", "Updating Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$commandList = &GetParam( "commandlist", "" );
> 	$doRC        = &GetParam( "p_changerc",  "0" );
> 	$doRC = 1 if ( $doRC eq "on" );
> 	$doText = &GetParam( "p_changetext", "0" );
> 	$doText = 1 if ( $doText eq "on" );
> 	
> 	if ( $commandList eq "" ) {
> 		print "\n<p>Empty command list or error.</p>";
> 	}
> 	else {
> 		&UpdateLinksList( $commandList, $doRC, $doText );
> 		print "\n<p>Finished command list.</p>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub EditRecentChanges {
> 	my ( $action, $old, $new ) = @_;
> 	
> 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
> 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
> }
> 
> sub EditRecentChangesFile {
> 	my ( $fname, $action, $old, $new, $printError ) = @_;
> 	my ( $status, $fileData, $errorText, $rcline, @rclist );
> 	my ( $outrc, $ts, $page, $junk );
> 	
> 	( $status, $fileData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
> 		print $errorText if ($printError);
> 		
> 		return;
> 	}
> 	
> 	$outrc = "";
> 	@rclist = split( /\n/, $fileData );
> 	
> 	foreach $rcline (@rclist) {
> 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
> 		if ( $page eq $old ) {
> 			if ( $action == 1 ) {    # Delete
> 				;                    # Do nothing (don't add line to new RC)
> 			}
> 			elsif ( $action == 2 ) {
> 				$junk = $rcline;
> 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
> 				$outrc .= $junk . "\n";
> 			}
> 		}
> 		else {
> 			$outrc .= $rcline . "\n";
> 		}
> 	}
> 	
> 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
> 	&WriteStringToFile( $fname, $outrc );
> }
> 
> # Delete and rename must be done inside locks.
> sub DeletePage {
> 	my ( $page, $doRC, $doText ) = @_;
> 	my ( $fname, $status );
> 	
> 	$page =~ s/ /_/g;
> 	$page =~ s/\[+//;
> 	$page =~ s/\]+//;
> 	$status = &ValidId($page);
> 	
> 	if ( $status ne "" ) {
> 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$fname = &GetPageFile($page);
> 	unlink($fname) if ( -f $fname );
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	unlink($fname)     if ( -f $fname );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
> 	       # Currently don't do anything with page text
> }
> 
> # Given text, returns substituted text
> sub SubstituteTextLinks {
> 	my ( $old, $new, $text ) = @_;
> 
> 	# Much of this is taken from the common markup
> 	%SaveUrl      = ();
> 	$SaveUrlIndex = 0;
> 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
> 	
> 	if ($RawHtml) {
> 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
> 	}
> 	
> 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
> 	
> 	if ($FreeLinks) {
> 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
> 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
> 	}
> 	
> 	if ($BracketText) {         # Links like [URL text of link]
> 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 	}
> 	
> 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
> 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
> 	
> 	if ($WikiLinks) {
> 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
> 	}
> 
> 	# Thanks to David Claughton for the following fix
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
> }
> 
> sub SubFreeLink {
> 	my ( $link, $name, $old, $new ) = @_;
> 	my ($oldlink);
> 	
> 	$oldlink = $link;
> 	$link =~ s/^\s+//;
> 	$link =~ s/\s+$//;
> 	
> 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
> 	{
> 		$link = $new;
> 	}
> 	
> 	else {
> 		$link = $oldlink;    # Preserve spaces if no match
> 	}
> 	
> 	$link = "[[$link";
> 	
> 	if ( $name ne "" ) {
> 		$link .= "|$name";
> 	}
> 	
> 	$link .= "]]";
> 	
> 	return &StoreRaw($link);
> }
> 
> sub SubWikiLink {
> 	my ( $link, $old, $new ) = @_;
> 	my ($newBracket);
> 	
> 	$newBracket = 0;
> 	
> 	if ( $link eq $old ) {
> 		$link = $new;
> 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
> 			$link = "[[$link]]";
> 		}
> 	}
> 	
> 	return &StoreRaw($link);
> }
> 
> # Rename is mostly copied from expire
> sub RenameKeepText {
> 	my ( $page, $old, $new ) = @_;
> 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
> 	my ( $sectName, $newText );
> 	
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	return if ( !( -f $fname ) );
> 	( $status, $data ) = &ReadFile($fname);
> 	return if ( !$status );
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;
> 	}
> 
> 	# First pass: optimize for nothing changed
> 	$changed = 0;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$changed = 1 if ( $Text{'text'} ne $newText );
> 		}
> 	}
> 	
> 	return if ( !$changed );    # No sections changed
> 	open( OUT, ">$fname" ) or return;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$Text{'text'} = $newText;
> 			$tempSection{'data'} = join( $FS3, %Text );
> 			print OUT $FS1, join( $FS2, %tempSection );
> 		}
> 		else {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
> }
> 
> sub RenameTextLinks {
> 	my ( $old, $new ) = @_;
> 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
> 	my ( $oldCanonical, @pageList );
> 	$old =~ s/ /_/g;
> 	$oldCanonical = &FreeToNormal($old);
> 	$new =~ s/ /_/g;
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$old =~ s/_/ /g;
> 	$new =~ s/_/ /g;
> 
> 	# Note: the LinkIndex must be built prior to this routine
> 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
> 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
> 	foreach $page (@pageList) {
> 		$changed = 0;
> 		&OpenPage($page);
> 		foreach $section ( keys %Page ) {
> 			if ( $section =~ /^text_/ ) {
> 				&OpenSection($section);
> 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
> 				$oldText = $Text{'text'};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Text{'text'} = $newText;
> 					$Section{'data'} = join( $FS3, %Text );
> 					$Page{$section} = join( $FS2, %Section );
> 					$changed = 1;
> 				}
> 			}
> 			elsif ( $section =~ /^cache_diff/ ) {
> 				$oldText = $Page{$section};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Page{$section} = $newText;
> 					$changed = 1;
> 				}
> 			}
> 
> 			# Add other text-sections (categories) here
> 		}
> 		if ($changed) {
> 			$file = &GetPageFile($page);
> 			&WriteStringToFile( $file, join( $FS1, %Page ) );
> 		}
> 		&RenameKeepText( $page, $old, $new );
> 	}
> }
> 
> sub RenamePage {
> 	my ( $old, $new, $doRC, $doText ) = @_;
> 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
> 	
> 	$old =~ s/ /_/g;
> 	$new    = &FreeToNormal($new);
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$newfname = &GetPageFile($new);
> 	if ( -f $newfname ) {
> 		print "\nRename: new page $new already exists--not renamed.<br>";
> 		return;
> 	}
> 	$oldfname = &GetPageFile($old);
> 	if ( !( -f $oldfname ) ) {
> 		print "\nRename: old page $old does not exist--nothing done.<br>";
> 		return;
> 	}
> 	
> 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
> 	rename( $oldfname, $newfname );
> 	&CreatePageDir( $KeepDir, $new );
> 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
> 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
> 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
> 	rename( $oldkeep, $newkeep );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
> 
> 	if ($doText) {
> 		&BuildLinkIndexPage($new);          # Keep index up-to-date
> 		&RenameTextLinks( $old, $new );
> 	}
> }
> 
> sub DoShowVersion {
> 	print &GetHeader( "", "Displaying Wiki Version", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>NobleWiki</h2>";
> 	print "\n<p>derived from UseModWiki version 1.0</p>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
> 	my ( $id, $status, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
> }
> sub GetGallery {
> 	my ($params) = @_;
> 	my @lines = split(/\r?\n/, $params);
> 	my $lineNum = 0;
> 	my $imageNum = 0;
> 	my %options;
> 	my $images = "";
> 	my $text = "";
> 	
> 	my $defaultImage = "image1.jpg";
> 	my $defaultThumb = "thumb_image1.jpg";
> 	my $image;
> 	my $thumb;
> 	my $title;
> 	my $header;
> 	my $caption;
> 	my $description;
> 	my $thumbWidth = 100;
> 	
> 	$GLOBAL_galleryCount++;
> 		
> 	foreach my $line (@lines){
> 		%options = &GetOptions($line);
> 		
> 		if ($lineNum == 0){
> 			$lineNum++;
> 			
> 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
> 			if ($options{'description'}){ $description = $options{'description'}; }
> 			if ($options{'header'}){ $header = $options{'header'}; }
> 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
> 			
> 			next;	
> 		}
> 		else {		
> 			if ($options{'image'}){ $image = $options{'image'}; }
> 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
> 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
> 			
> 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
> 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
> 			
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
> 				
> 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
> 		}
> 	}
> 	
> 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
> 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
> 	
> 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
> 	
> 	$text .= "\n	    <ul>";	
> 	$text .= $images;
> 	$text .= "\n	    </ul>";
> 	
> 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
> 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
> 	
> 	$text .= "\n	</div>";		
> 	
> 	return $text;
> }
> 
> sub GetFlash {
> 	my ($options) = @_;
> 	my %options = &GetOptions($options);	
> 	my $fpath = "$UploadUrl/";
> 	my $defaultSWF = 'ufo.swf';
> 	my $maxWidth = 400;
> 	my $maxHeight = 300;
> 	my $ratio = 1;
> 	
> 	my $text = "";
> 	
> 	my $fname;
> 	my $fwidth;
> 	my $fheight;
> 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
> 	my $idFO = "FO_$GLOBAL_flashCount";
> 
> 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
> 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
> 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
> 	
> 	if ($fwidth > $maxWidth){
> 		$ratio = $maxWidth / $fwidth;
> 		$fwidth = $maxWidth;
> 		$fheight = int ($ratio * $fheight);
> 	}
> 	elsif ($fheight > $maxHeight){
> 		$ratio = $maxHeight / $fheight;
> 		$fheight = $maxHeight;
> 		$fwidth = int ($ratio * $fwidth);
> 	}
> 			
> 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
> 	
> 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
> 	$text .= "\n<script type='text/javascript'>";
> 	$text .= "\n			var fpath = '$fpath';";
> 	$text .= "\n			var fname = '$fname';";
> 	$text .= "\n			var fwidth = $fwidth;";
> 	$text .= "\n			var fheight = $fheight;";
> 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
> 	$text .= "\n			\$(window).load(function () {";
> 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
> 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
> 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
> 	$text .= "\n		    });";
> 	$text .= "\n		</script>";		
> 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
> 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
> 	$text .= "\n		<p style='clear: both;'></p>";
> 	$text .= "\n	</div>";
> 
> 	$GLOBAL_flashCount++;
> 	
> 	return $text;		
> }
> sub GetAdminBar {
> 	my ($id, $cssClass) = @_;
> 	my ($result);
> 
> 	$result .= "\n<div $cssClass>";
> 	$result .= "Administration: ";
> 	
> 	my ($notValid) = $id =~ /^\d*$/;
> 	
> 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
> 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
> 	} 
> 		
> 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
> 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
> 	
> 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
> 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
> 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
> 	$result .= " | " . &ScriptLink("action=orphans", "List Orphans" );
> 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
> 			
> 	if ( -f "$DataDir/noedit" ) {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
> 	}
> 	else {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
> 	}
> 	
> 	$result .= "</div>";
> 	
> 	return $result;
> }
> 
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
> 	my ($id) = @_;
> 	
> 	return if ( !&ValidIdOrDie($id) );
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
> 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		print "\n<h2>Delete Page?</h2>";
> 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
> 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";	
> 		
> 		return;
> 	}
> 	
> 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
> 	print &GetLeftNav("");	
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $id eq $HomePage ) {
> 		print Ts( '%s can not be deleted.', $HomePage );
> 	}
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) {
> 			print Ts( '%s can not be deleted because it is locked.', $id );
> 		}
> 		else {
> 
> 			# Must lock because of RC-editing
> 			&RequestLock() or die( "Could not get editing lock" );
> 			DeletePage( $id, 1, 1 );
> 			&ReleaseLock();
> 			print Ts( '%s has been deleted.', $id );
> 		}
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
> 	print &GetHeader( "", "File Upload Page", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<h2>Select File</h2>";
> 	print "\nThe current upload size limit is $MaxPost.<br>";
> 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
> 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
> 	print "\n<input type='hidden' name='upload' value='1' />";
> 	print "\nFile to Upload: ";
> 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
> 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub SaveUpload {
> 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
> 	print &GetHeader( "", "Upload Finished", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$filename = $q->param('file');
> 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
> 	
> 	$uploadFilehandle = $filename;
> 	open UPLOADFILE, ">$UploadDir$filename";
> 	binmode(UPLOADFILE);	
> 	while (<$uploadFilehandle>) { print UPLOADFILE; }
> 	close UPLOADFILE;
> 	
> 
> 	print "\n<h2>Upload Completed</h2>";
> 	print "\nThe wiki link to your file is:<br><br>";
> 	
> 	$printFilename = $filename;
> 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
> 	$fileUrl = $UploadUrl . $printFilename;
> 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
> 
> 	if ( $filename =~ /${ImageExtensions}$/ ) {
> 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub ConvertFsFile {
> 	my ( $oldFS, $newFS, $fname ) = @_;
> 	my ( $oldData, $newData, $status );
> 	
> 	return if ( !-f $fname );           # Convert only existing regular files
> 	( $status, $oldData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
> 		
> 		return;
> 	}
> 	
> 	$newData = $oldData;
> 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
> 	
> 	return if ( $oldData eq $newData );    # Do not write if the same
> 	&WriteStringToFile( $fname, $newData );
> 
> 	# print $fname . '<br>';    # progress report
> }
> 
> # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
> # Note that top level directory (page/keep/user) contains only dirs
> sub ConvertFsDir {
> 	my ( $oldFS, $newFS, $topDir ) = @_;
> 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	@dirs = sort(@dirs);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$topDir/$dir" );             # Top level directories only
> 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
> 		
> 		opendir( DIRLIST, "$topDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
> 			$fname = "$topDir/$dir/$file";
> 			if ( -f $fname ) {
> 				# print $fname . '<br>';   # progress
> 				&ConvertFsFile( $oldFS, $newFS, $fname );
> 			}
> 			elsif ( -d $fname ) {
> 				opendir( DIRLIST, $fname );
> 				@subFiles = readdir(DIRLIST);
> 				closedir(DIRLIST);
> 				
> 				foreach $subFile (@subFiles) {
> 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
> 					$subFname = "$fname/$subFile";
> 					if ( -f $subFname ) {
> 						# print $subFname . '<br>';   # progress
> 						&ConvertFsFile( $oldFS, $newFS, $subFname );
> 					}
> 				}
> 			}
> 		}
> 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
> 	}
> }
> 
> sub ConvertFsCleanup {
> 	my ($topDir) = @_;
> 	my ( @dirs, $dir );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-f "$topDir/$dir" );             # Remove only files...
> 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
> 		unlink "$topDir/$dir";
> 	}
> }
> 
> sub DoConvert {
> 	my $oldFS = "\xb3";
> 	my $newFS = "\x1e\xff\xfe\x1e";
> 	
> 	print &GetHeader( "", "Convert wiki DB", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";	
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $FS ne $newFS ) {
> 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
> 		return;
> 	}
> 	
> 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
> 	print "\nWiki DB locked for conversion.<br>";
> 	print "\nConverting Wiki DB...<br>";
> 	
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
> 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
> 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
> 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
> 	&ConvertFsCleanup($PageDir);
> 	&ConvertFsCleanup($KeepDir);
> 	&ConvertFsCleanup($UserDir);
> 	
> 	print "\nFinished converting wiki DB.<br>";
> 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Remove user-id files if no useful preferences set
> sub DoTrimUsers {
> 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
> 	my ( @dirs, @files, $dir, $file, $item );
> 	
> 	print &GetHeader( "", "Trim wiki users", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$removed = 0;
> 	$maxID   = 1001;
> 	opendir( DIRLIST, $UserDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
> 		
> 		opendir( DIRLIST, "$UserDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
> 				$id    = $1;
> 				$maxID = $id if ( $id > $maxID );
> 				%Data  = ();
> 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
> 				
> 				if ($status) {
> 					%Data =
> 					  split( /$FS1/, $data, -1 )
> 					  ;    # -1 keeps trailing null fields
> 					$keep = 0;
> 					
> 					foreach $item (qw(username password adminpw stylesheet)) {
> 						$keep = 1
> 						  if ( defined( $Data{$item} )
> 							&& ( $Data{$item} ne "" ) );
> 					}
> 					
> 					if ( !$keep ) {
> 						unlink "$UserDir/$dir/$file";
> 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
> 						$removed += 1;
> 					}
> 				}
> 			}
> 		}
> 	}
> 	print Ts( 'Removed %s files.', $removed ) . '<br>';
> 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoAssetsToc {
> 	## Check $DataDir and see if assets-toc exists
> 	## -- if not, then build TOC
> 	## -- if does, but is older than 1 minute, rebuild TOC
> 	## Return TOC	
> }
> sub DoFilterToc {
> 	## Given @filters, pageIndex, pageSize
> 	## Get TOC from DoAssetsTOC
> 	## Apply @filters; sort, apply pageIndex * pageSize as offset
> 	## Return FilteredTOC	
> }
> sub DoListFiles {
> 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
> 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
> 	my ( $id, $filter, $managedisabled ) = @_;
> 
> 	if ($managedisabled){ 
> 		$targetDir = "$DisabledDir";
> 	}
> 	else {
> 		$targetDir = "$UploadDir";
> 	}
> 
> 	# CREATE array of filters
> 	$filter = lc($filter);
> 	$filter =~ s/\s//go;
> 	if ($filter ne ""){ 
> 		if ($filter =~ m/,/){
> 			@filters = split(',', $filter);
> 			
> 		}
> 		else {
> 			push (@filters, $filter);
> 		}
> 		$term = "using '<em>$filter</em>'";
> 	}
> 		
> 	# READ DIRECTORY	
> 	opendir( DIRLIST, $targetDir );
> 	@list = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	# RUN INCLUSIVE FILTERS
> 	foreach $file (@list){		
> 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
> 		
> 		if ($filter eq ""){  push @includes, $file; next; }
> 		
> 		$qualifies = 0;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;
> 			$include = $item;
> 					
> 			if ($item =~ m/^\!/){ next; }
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
> 		}
> 		
> 		if ($qualifies){ push @includes, $file; }
> 	}
> 
> 	# RUN EXCLUSIVE FILTERS
> 
> 	foreach $file (@includes){
> 		if ($filter eq ""){  push @files, $file; next; }
> 				
> 		$qualifies = 1;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;					
> 			unless ($item =~ m/^\!/){ next; }
> 			$include = substr($item, 1);
> 
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
> 		}
> 		
> 		if ($qualifies){ push @files, $file; }
> 	}
> 	
> 	print &GetHeader( "", "Manage Assets", "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikidiff'>";
> 	
> 	#return if ( !&UserIsEditorOrError() );
> 		
> 	if ($managedisabled){
> 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
> 		
> 		# MOVE file to disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $keeppath){
> 				if (-w $UploadDir){
> 					if (rename($keeppath, $uploadpath)){
> 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
> 		
> 		# MOVE file from disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $uploadpath){
> 				if (-w $DisabledDir){
> 					if (rename($uploadpath, $keeppath)){
> 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
> 	
> 	foreach $file (@files) {
> 		$filecount++;
> 		$linkname = "upload:$file";
> 		
> 		@links = SearchTitleAndBody($file, "", "");
> 		$numlinks = scalar(@links);
> 
> 		$title = "";
> 		$action = "";
> 			
> 		if ($managedisabled){			
> 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td>$file</td>";
> 			print "\n<td>$size</td>";			
> 			
> 			if ( &UserIsEditorOrAdmin() ){
> 				$title = "Click to re-enable file.";
> 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
> 			}
> 		}
> 		else {		
> 			$uploadpath = "$UploadUrl/$file";
> 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
> 			print "\n<td>$size</td>";
> 			
> 			if ($numlinks > 0){
> 				$title = "Click to see what pages link to this file.";
> 				$action = "href='$ScriptName?back=$file'";
> 			}
> 			elsif ( &UserIsEditorOrAdmin() ){
> 				$numlinks = "0";
> 				$title = "Click to disable file.";
> 				$action = "href='$ScriptName?action=listfiles&id=$file'";
> 			}		
> 		}
> 
> 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
> 		print "\n</tr>";
> 	}
> 	
> 	if (scalar(@files) == 0){
> 		print "\n<td colspan='4'>No files available</td></tr>";
> 	}
> 	print "\n</table>";
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
> 	print "\n<input type='submit' value='Apply Filter'>";
> 	
> 	
> 	if ($managedisabled){
> 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
> 	}
> 	else {
> 		print "\n<input type='hidden' name='action' value='listfiles'>";
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
> 	}
> 	print "\nUse ! to exclude a term, separate terms with a comma";
> 	print "\n</form>";
> 	print "\n</div>";
> 	print $WikiLineFooter;
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";				
> }
> 
> 
> #END_OF_OTHER_CODE
> &DoWikiRequest() if ( $RunCGI && ( $_ ne 'nocgi' ) );    # Do everything.
> 1;    # In case we are loaded from elsewhere
> 
> # == End of UseModWiki script. ===========================================
------
SandBox|1195622119
1c1,7334
< #MAGIC Flash name=diceland.swf height=200 width=280
---
> #!E:/Program Files/perl/bin/perl.exe
> # UseModWiki version 1.0 (September 12, 2003)
> # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
> # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
> # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
> #    <marcus@ira.uka.de>
> # ...which was based on
> #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
> #    and The Original WikiWikiWeb  (C) Ward Cunningham
> #        <ward@c2.com> (code reused with permission)
> # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
> #
> # This program is free software; you can redistribute it and/or modify
> # it under the terms of the GNU General Public License as published by
> # the Free Software Foundation; either version 2 of the License, or
> # (at your option) any later version.
> #
> # This program is distributed in the hope that it will be useful,
> # but WITHOUT ANY WARRANTY; without even the implied warranty of
> # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> # GNU General Public License for more details.
> #
> # You should have received a copy of the GNU General Public License
> # along with this program; if not, write to the
> #    Free Software Foundation, Inc.
> #    59 Temple Place, Suite 330
> #    Boston, MA 02111-1307 USA
> use Diff;
> use MagicContent;
> use Image::Size;
> 
> package UseModWiki;
> use strict;
> local $| = 1;    # Do not buffer output (localized for mod_perl)
> 
> # Configuration/constant variables:
> use vars qw(@RcDays @HtmlPairs @HtmlSingle
>   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
>   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
>   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
>   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
>   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
>   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
>   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
>   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
>   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
>   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
>   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
>   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
>   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
>   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
>   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
>   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
>   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
>   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine
>   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
>   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
>   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton $HomePagePrefix
>   $EditNameLink $UseMetaWiki @ImageSites $BracketImg $DisabledDir
>   $AllowInclusion $InclusionDir $NumberDatesDelim);
>   
> # Note: $NotifyDefault is kept because it was a config variable in 0.90
> # Other global variables:
> use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
>   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
>   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
>   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
>   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
>   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
>   $ConfigError $UploadPattern $WikiLineHeader $WikiLineHeaderPreview $WikiLineFooter $WikiLineDiff
>   $WikiLine $WikiLine1 $WikiLine2 $WikiLinePref $AutoMailto
>   $GLOBAL_imageCount $GLOBAL_flashCount $GLOBAL_galleryCount
>   $WikiLeftNav %TableCellDefaults $DownloadExtensions
>   );
> 
> # == Configuration =====================================================
> $DataDir = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/wiki";    # Main wiki directory
> $UseConfig = 0;    # 1 = use config file,    0 = do not look for config
> $ConfigFile = "$DataDir/config";    # Configuration file
> 
> # Default configuration (used if UseConfig is 0)
> $CookieName = "NobleWiki";          # Name for this wiki (for multi-wiki sites)
> $SiteName   = "Noble Pursuit Games Wiki";          # Name of site (used for titles)
> $HomePage   = "HomePage";           # Home page (change space to _)
> $HomePagePrefix = "HomePage";      # Which page will be linked when a valid $username is clicked in the RC history.
> $RCName     = "RecentChanges";      # Name of changes page (change space to _)
> $LogoUrl    = "";                   # URL for site logo ("" for no logo)
> $ENV{PATH}  = "/usr/bin/";          # Path used to find "diff"
> $ScriptTZ   = "";                   # Local time zone ("" means do not print)
> $RcDefault  = 7;                    # Default number of RecentChanges days
> @RcDays     = qw(1 3 7 30 90 180);  # Days for links on RecentChanges
> $KeepDays   = 14;                   # Days to keep old revisions
> $SiteBase   = "";                   # Full URL for <BASE> header
> 
> 								    # Set if the auto-detected URL is wrong
> $FullUrl    = "http://wiki.kurcina.org/cgi-bin/index.cgi";                                 
> $RedirType  = 1;                    # 1 = CGI.pm, 2 = script, 3 = no redirect
> $AdminPass  = "linhson";            # Set to non-blank to enable password(s)
> $EditPass   = "emerald";            # Like AdminPass, but for editing only
> $StyleSheet = "/css/default.css";   # URL for CSS stylesheet (like "/wiki.css")
> $NotFoundPg = "PageNotFound";       # Page for not-found links ("" for blank pg)
> $EmailFrom  = "NobleWiki";          # Text for "From: " field of email notes.
> $SendMail   = "/usr/sbin/sendmail"; # Full path to sendmail executable
> $AutoMailto = 1;					# 0 = off; 1 = convert email address automatically to mailTo:<address>
> 									# HTML for bottom of every page
> $FooterNote = "<a href='?action=editprefs'><div id='anylogo' title='access username'>&nbsp;</div></a>";                   
> 
> $EditNote   = "";                   # HTML notice above buttons on edit page
> $MaxPost    = 1024 * 5000;          # Maximum 210K posts (about 200K for pages)
> $NewText    = "";                   # New page text ("" for default message)
> $HttpCharset      = "";           # Charset for pages, like "iso-8859-2"
> 
> $InterWikiMoniker = "NobleWiki";  # InterWiki moniker for this wiki. (for RSS)
> $SiteDescription  = $SiteName;    # Description of this wiki. (for RSS)
> $RssLogoUrl       = "";           # Optional image for RSS feed
> $EarlyRules       = "";           # Local syntax rules for wiki->html (evaled)
> $LateRules        = "";           # Local syntax rules for wiki->html (evaled)
> $KeepSize         = 0;            # If non-zero, maximum size of keep file
> $BGColor          = "";           # Background color ('' to disable)
> $DiffColor1       = "#ffffaf";    # Background color of old/deleted text
> $DiffColor2       = "#cfffcf";    # Background color of new/added text
> $FavIcon          = "";           # URL of bookmark/favorites icon, or ''
> $RssDays          = 7;            # Default number of days in RSS feed
> $UserGotoBar      = "";           # HTML added to end of goto bar
> $UserGotoBar     .= "<a href='$ScriptName?WikiHelp'>Help</a>";
> 
> $UserHeader       = "";           # Optional HTML header additional content
> $UserHeader		 .= "\n<link rel='stylesheet' type='text/css' media='screen' href='/css/jquery.lightbox-0.4.css'/>";
> $UserHeader      .= "\n<script src='/js/jquery-1.2.1.js'></script>";
> $UserHeader      .= "\n<script src='/js/ufo.js'></script>";
> $UserHeader		 .= "\n<script src='/js/jquery.lightbox-0.4.js'></script>";
> 
> $UserBody         = "";           # Optional <BODY> tag additional content
> $StartUID         = 1001;         # Starting number for user IDs
> 								  # Full path (like /foo/www/uploads) for files
> $UploadDir        = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/docs/attachments";
> 								  # Full URL (like http://foo.com/uploads)
> $UploadUrl        = "http://wiki.kurcina.org/attachments";
> $DisabledDir      = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/disabled";
>       
> @ImageSites       = qw();         # Url prefixes of good image sites: ()=all
> 
> # Major options:
> $UseSubpage  = 1;             # 1 = use subpages,       0 = do not use subpages
> $UseCache    = 0;             # 1 = cache HTML pages,   0 = generate every page
> $EditAllowed = 1;             # 1 = editing allowed,    0 = read-only
> $RawHtml     = 0;             # 1 = allow <HTML> tag,   0 = no raw HTML in pages
> $HtmlTags    = 1;             # 1 = "unsafe" HTML tags, 0 = only minimal tags
> $UseDiff     = 1;             # 1 = use diff features,  0 = do not use diff
> $FreeLinks   = 1;             # 1 = use [[word]] links, 0 = LinkPattern only
> $WikiLinks   = 1;             # 1 = use LinkPattern,    0 = use [[word]] only
> $AdminDelete = 1;             # 1 = Admin only deletes, 0 = Editor can delete
> $RunCGI      = 1;             # 1 = Run script as CGI,  0 = Load but do not run
> $EmailNotify = 0;             # 1 = use email notices,  0 = no email on changes
> $EmbedWiki   = 0;             # 1 = no headers/footers, 0 = normal wiki pages
> $DeletedPage = "DeletedPage"; # 0 = disable, 'PageName' = tag to delete page
> $ReplaceFile = "ReplaceFile"; # 0 = disable, 'PageName' = indicator tag
> @ReplaceableFiles = ();       # List of allowed server files to replace
> $TableSyntax      = 1;        # 1 = wiki syntax tables, 0 = no table syntax
> $NewFS            = 1;        # 1 = new multibyte $FS,  0 = old $FS
> $UseUpload        = 1;        # 1 = allow uploads,      0 = no uploads
> $AllowInclusion = 1;          # 1 = files (*.txt,*.html) may be included by include:file.html,
> 	                          # 0 = files will not be included
> 	                          # from where shall the files be included?
> $InclusionDir = "$DataDir/includes-data"; 
>   
> # Minor options:
> $LogoLeft     = 1;    # 1 = logo on left,       0 = logo on right
> $RecentTop    = 1;    # 1 = recent on top,      0 = recent on bottom
> $UseDiffLog   = 1;    # 1 = save diffs to log,  0 = do not save diffs
> $KeepMajor    = 1;    # 1 = keep major rev,     0 = expire all revisions
> $KeepAuthor   = 1;    # 1 = keep author rev,    0 = expire all revisions
> $ShowEdits    = 0;    # 1 = show minor edits,   0 = hide edits by default
> $HtmlLinks    = 1;    # 1 = allow A HREF links, 0 = no raw HTML links
> $SimpleLinks  = 0;    # 1 = only letters,       0 = allow _ and numbers
> $NonEnglish   = 0;    # 1 = extra link chars,   0 = only A-Za-z chars
> $ThinLine     = 0;    # 1 = fancy <hr> tags,    0 = classic wiki <hr>
> $BracketText  = 1;    # 1 = allow [URL text],   0 = no link descriptions
> $UseAmPm      = 0;    # 1 = use am/pm in times, 0 = use 24-hour times
> $UseIndex     = 0;    # 1 = use index file,     0 = slow/reliable method
> $UseHeadings  = 1;    # 1 = allow = h1 text =,  0 = no header formatting
> $NetworkFile  = 1;    # 1 = allow remote file:, 0 = no file:// links
> $BracketWiki  = 1;    # 1 = [WikiLnk txt] link, 0 = no local descriptions
> $UseLookup    = 1;    # 1 = lookup host names,  0 = skip lookup (IP only)
> $FreeUpper    = 1;    # 1 = force upper case,   0 = do not force case
> $FastGlob     = 1;    # 1 = new faster code,    0 = old compatible code
> $MetaKeywords = 1;    # 1 = Google-friendly,    0 = search-engine averse
> $NamedAnchors = 1;    # 0 = no anchors, 1 = enable anchors,
>                       # 2 = enable but suppress display
> $SlashLinks   = 0;    # 1 = use script/action links, 0 = script?action
> $UpperFirst   = 1;    # 1 = free links start uppercase, 0 = no ucfirst
> $AdminBar     = 1;    # 1 = admins see admin links, 0 = no admin bar
> $RepInterMap  = 0;    # 1 = intermap is replacable, 0 = not replacable
> $ConfirmDel   = 1;    # 1 = delete link confirm page, 0 = immediate delete
> $MaskHosts    = 0;    # 1 = mask hosts/IPs,      0 = no masking
> $LockCrash    = 0;    # 1 = crash if lock stuck, 0 = auto clear locks
> $HistoryEdit  = 0;    # 1 = edit links on history page, 0 = no edit links
> $OldThinLine  = 0;    # 1 = old ==== thick line, 0 = ------ for thick line
> $NumberDates  = 1;    # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
> $NumberDatesDelim = "-"; # If $NumberDates is 1, this character separate the year, month, day
> $ParseParas   = 1;    # 1 = new paragraph markup, 0 = old markup
> $AuthorFooter = 1;    # 1 = show last author in footer, 0 = do not show
> $AllUpload    = 0;    # 1 = anyone can upload,   0 = only editor/admins
> $LimitFileUrl = 1;    # 1 = limited use of file: URLs, 0 = no limits
> $MaintTrimRc  = 1;    # 1 = maintain action trims RC, 0 = only maintainrc
> $SearchButton = 1;    # 1 = search button on page, 0 = old behavior
> $EditNameLink = 0;    # 1 = edit links use name (CSS), 0 = '?' links
> $UseMetaWiki  = 0;    # 1 = add MetaWiki search links, 0 = no MW links
> $BracketImg   = 1;    # 1 = [url url.gif] becomes image link, 0 = no img
> 
> $WikiLineHeader = "\n<div class='wikilineheader'></div>";
> $WikiLineHeaderPreview = "\n<div class='wikilineheaderpreview'></div>";
> $WikiLineFooter = "\n<div class='wikilinefooter'></div>";
> $WikiLineDiff   = "\n<div class='wikilinediff'></div>";
> $WikiLinePref   = "\n<div class='wikilinepref'></div>";
> $WikiLine       = "\n<div class='wikiline'></div>";
> $WikiLine1      = "\n<div class='wikiline1'></div>";
> $WikiLine2      = "\n<div class='wikiline2'></div>";
> 
> # Names of sites.  (The first entry is used for the number link.)
> @IsbnNames = ( 'bn.com', 'amazon.com', 'search' );
> 
> # Full URL of each site before the ISBN
> @IsbnPre = (
> 	"http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=",
> 	"http://www.amazon.com/exec/obidos/ISBN=",
> 	"http://www.pricescan.com/books/BookDetail.asp?isbn="
> );
> 
> # Rest of URL of each site after the ISBN (usually '')
> @IsbnPost = ( "", "", "" );
> 
> # HTML tag lists, enabled if $HtmlTags is set.
> # Scripting is currently possible with these tags,
> # so they are *not* particularly "safe".
> # Tags that must be in <tag> ... </tag> pairs:
> @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
>   em s strike strong tt var div center blockquote ol ul dl caption);
> 
> # Single tags (that do not require a closing /tag)
> @HtmlSingle = qw(br p hr li dt dd tr td th);
> @HtmlPairs  = ( @HtmlPairs, @HtmlSingle );     # All singles can also be pairs
> 
> # == You should not have to change anything below this line. =============
> $IndentLimit = 20;                             # Maximum depth of nested lists
> $PageDir     = "$DataDir/page-data";           # Stores page data
> $HtmlDir     = "$DataDir/html-version";        # Stores HTML versions
> $UserDir     = "$DataDir/user-data";           # Stores user data
> $KeepDir     = "$DataDir/keep-data";           # Stores kept (old) page data
> $TempDir     = "$DataDir/temp-files";          # Temporary files and locks
> $LockDir     = "$TempDir/lock-dir";            # DB is locked if this exists
> $InterFile   = "$DataDir/intermap";            # Interwiki site->url map
> $RcFile      = "$DataDir/recent-log";          # New RecentChanges logfile
> $RcOldFile   = "$DataDir/oldrecent-log";       # Old RecentChanges logfile
> $IndexFile   = "$DataDir/page-index";          # List of all pages
> $EmailFile   = "$DataDir/email-list";          # Email notification lists
> if ($RepInterMap) {
> 	push @ReplaceableFiles, $InterFile;
> }
> 
> # The "main" program, called at the end of this script file.
> sub DoWikiRequest {
> 	if ( $UseConfig && ( -f $ConfigFile ) ) {
> 		$ConfigError = "";
> 		if ( !do $ConfigFile ) {               # Some error occurred
> 			$ConfigError = $@;
> 			if ( $ConfigError eq "" ) {
> 
> 			  # Unfortunately, if the last expr returns 0, one will get a false
> 			  # error above.  To remain compatible with existing installs the
> 			  # wiki must not report an error unless there is error text in $@.
> 			  # (Errors in "use strict" may not have error text.)
> 			  # Uncomment the line below if you want to catch use strict errors.
> 			  #       $ConfigError = "Unknown Error (no error text)";
> 			}
> 		}
> 	}
> 	&InitLinkPatterns();
> 	if ( !&DoCacheBrowse() ) {
> 		eval $BrowseCode;
> 		&InitRequest() or return;
> 		if ( !&DoBrowseRequest() ) {
> 			eval $OtherCode;
> 			&DoOtherRequest();
> 		}
> 	}
> }
> 
> # == Common and cache-browsing code ====================================
> sub InitLinkPatterns {
> 	my ( $UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim );
> 
> 	# Field separators are used in the URL-style patterns below.
> 	if ($NewFS) {
> 		$FS = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
> 	}
> 	else {
> 		$FS = "\xb3";                # The FS character is a superscript "3"
> 	}
> 	$FS1         = $FS . "1";  # The FS values are used to separate fields
> 	$FS2         = $FS . "2";  # in stored hashtables and other data structures.
> 	$FS3         = $FS . "3";  # The FS character is not allowed in user data.
> 	$UpperLetter = "[A-Z";
> 	$LowerLetter = "[a-z";
> 	$AnyLetter   = "[A-Za-z";
> 	if ($NonEnglish) {
> 		$UpperLetter .= "\xc0-\xde";
> 		$LowerLetter .= "\xdf-\xff";
> 		if ($NewFS) {
> 			$AnyLetter .= "\x80-\xff";
> 		}
> 		else {
> 			$AnyLetter .= "\xc0-\xff";
> 		}
> 	}
> 	if ( !$SimpleLinks ) {
> 		$AnyLetter .= "_0-9";
> 	}
> 	$UpperLetter .= "]";
> 	$LowerLetter .= "]";
> 	$AnyLetter   .= "]";
> 
> 	# Main link pattern: lowercase between uppercase, then anything
> 	$LpA =
> 	  $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
> 
> 	# Optional subpage link pattern: uppercase, lowercase, then anything
> 	$LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
> 	if ($UseSubpage) {
> 
> 		# Loose pattern: If subpage is used, subpage may be simple name
> 		$LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
> 
> 		# Strict pattern: both sides must be the main LinkPattern
> 		# $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
> 	}
> 	else {
> 		$LinkPattern = "($LpA)";
> 	}
> 	$QDelim = '(?:"")?';    # Optional quote delimiter (not in output)
> 	$AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
> 	$LinkPattern .= $QDelim;
> 
> 	# Inter-site convention: sites must start with uppercase letter
> 	# (Uppercase letter avoids confusion with URLs)
> 	$InterSitePattern = $UpperLetter . $AnyLetter . "+";
> 	$InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
> 	if ($FreeLinks) {
> 
> 		# Note: the - character must be first in $AnyLetter definition
> 		if ($NonEnglish) {
> 			if ($NewFS) {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
> 			}
> 			else {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
> 			}
> 		}
> 		else {
> 			$AnyLetter = "[-,.()' _0-9A-Za-z]";
> 		}
> 	}
> 	$FreeLinkPattern = "($AnyLetter+";
> 	if ($UseSubpage) {
> 		$FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+";
> 	}
> 	
> 	if ($NamedAnchors){
> 		$FreeLinkPattern .= "(?:#(?:\\w+))?)";
> 	}
> 	else {
> 		$FreeLinkPattern .= ")";
> 	}
> 	
> 	$FreeLinkPattern .= $QDelim;
> 
> 	# Url-style links are delimited by one of:
> 	#   1.  Whitespace                           (kept in output)
> 	#   2.  Left or right angle-bracket (< or >) (kept in output)
> 	#   3.  Right square-bracket (])             (kept in output)
> 	#   4.  A single double-quote (")            (kept in output)
> 	#   5.  A $FS (field separator) character    (kept in output)
> 	#   6.  A double double-quote ("")           (removed from output)
> 	$UrlProtocols    = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|prospero|telnet|gopher";
> 	$UrlProtocols   .= '|file' if ( $NetworkFile || !$LimitFileUrl );
> 	
> 	$UrlPattern      = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
> 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
> 	$DownloadExtensions = "(pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)";
> 	$RFCPattern      = "RFC\\s?(\\d+)";
> 	$ISBNPattern     = "ISBN:?([0-9- xX]{10,})";
> 	$UploadPattern   = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
> }
> 
> # Simple HTML cache
> sub DoCacheBrowse {
> 	my ( $query, $idFile, $text );
> 	return 0 if ( !$UseCache );
> 	$query = $ENV{'QUERY_STRING'};
> 	if ( ( $query eq "" ) && ( $ENV{'REQUEST_METHOD'} eq "GET" ) ) {
> 		$query = $HomePage;    # Allow caching of home page.
> 	}
> 	if ( !( $query =~ /^$LinkPattern$/ ) ) {
> 		if ( !( $FreeLinks && ( $query =~ /^$FreeLinkPattern$/ ) ) ) {
> 			return 0;          # Only use cache for simple links
> 		}
> 	}
> 	$idFile = &GetHtmlCacheFile($query);
> 	if ( -f $idFile ) {
> 		local $/ = undef;      # Read complete files
> 		open( INFILE, "<$idFile" ) or return 0;
> 		$text = <INFILE>;
> 		close INFILE;
> 		print $text;
> 		return 1;
> 	}
> 	return 0;
> }
> 
> sub GetHtmlCacheFile {
> 	my ($id) = @_;
> 	return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
> }
> 
> sub GetPageDirectory {
> 	my ($id) = @_;
> 	if ( $id =~ /^([a-zA-Z])/ ) {
> 		return uc($1);
> 	}
> 	return "other";
> }
> 
> sub T {
> 	my ($text) = @_;
> 	if ( defined( $Translate{$text} ) && ( $Translate{$text} ne "" ) ) {
> 		return $Translate{$text};
> 	}
> 	return $text;
> }
> 
> sub Ts {
> 	my ( $text, $string ) = @_;
> 	$text = T($text);
> 	$text =~ s/\%s/$string/;
> 	return $text;
> }
> 
> sub Tss {
> 	my $text = @_[0];
> 	$text = T($text);
> 	$text =~ s/\%([1-9])/$_[$1]/ge;
> 	return $text;
> }
> 
> # == Normal page-browsing and RecentChanges code =======================
> $BrowseCode = "";    # Comment next line to always compile (slower)
> 
> #$BrowseCode = <<'#END_OF_BROWSE_CODE';
> use CGI;
> use CGI::Carp qw(fatalsToBrowser);
> 
> sub InitRequest {
> 	my @ScriptPath = split( '/', "$ENV{SCRIPT_NAME}" );
> 	$CGI::POST_MAX = $MaxPost;
> 	
> 	if ($UseUpload) {
> 		$CGI::DISABLE_UPLOADS = 0;    # allow uploads
> 	}
> 	else {
> 		$CGI::DISABLE_UPLOADS = 1;    # no uploads
> 	}
> 	
> 	if ($SlashLinks && length($ENV{'PATH_INFO'}>1)){
> 		$ENV{'QUERY_STRING'} .= '&' if($ENV{'QUERY_STRING'});
> 		$ENV{'QUERY_STRING'} .= substr($ENV{'PATH_INFO'},1);
> 	}
> 	
> 	$q = new CGI();
> 	
> 	if ($SlashLinks){
> 		my $numberOfSlashes = ($ENV{'PATH_INFO'} = tr[/][/]);
> 		$ScriptName = ('../' x $numberOfSlashes) . $ScriptName;
> 	}
> 
> 	# Fix some issues with editing UTF8 pages (if charset specified)
> 	if ( $HttpCharset ne "" ) {
> 		$q->charset($HttpCharset);
> 	}
> 	$Now           = time;                # Reset in case script is persistent
> 	$ScriptName    = pop(@ScriptPath);    # Name used in links
> 		
> 	$IndexInit     = 0;                   # Must be reset for each request
> 	$InterSiteInit = 0;
> 	%InterSite     = ();
> 	$MainPage     = ".";    # For subpages only, the name of the top-level page
> 	$OpenPageName = "";     # Currently open page
> 	&CreateDir($DataDir);   # Create directory if it doesn't exist
> 
> 	if ( !-d $DataDir ) {
> 		&ReportError( "Could not create $DataDir : $!" );
> 		return 0;
> 	}
> 	&InitCookie();          # Reads in user data
> 	return 1;
> }
> 
> sub InitCookie {
> 	%SetCookie      = ();
> 	$TimeZoneOffset = 0;
> 	undef $q->{'.cookies'};    # Clear cache if it exists (for SpeedyCGI)
> 	%UserData   = ();                        # Fix for persistent environments.
> 	%UserCookie = $q->cookie($CookieName);
> 	$UserID     = $UserCookie{'id'};
> 	$UserID =~ s/\D//g;                      # Numeric only
> 	if ( $UserID < 200 ) {
> 		$UserID = 111;
> 	}
> 	else {
> 		&LoadUserData($UserID);
> 	}
> 	if ( $UserID > 199 ) {
> 		if (   ( $UserData{'id'} != $UserCookie{'id'} )
> 			|| ( $UserData{'randkey'} != $UserCookie{'randkey'} ) )
> 		{
> 			$UserID   = 113;
> 			%UserData = ();    # Invalid.  Consider warning message.
> 		}
> 	}
> 	if ( $UserData{'tzoffset'} != 0 ) {
> 		$TimeZoneOffset = $UserData{'tzoffset'} * ( 60 * 60 );
> 	}
> }
> 
> sub DoBrowseRequest {
> 	my ( $id, $action, $text );
> 	if ( !$q->param ) {        # No parameter
> 		&BrowsePage($HomePage);
> 		return 1;
> 	}
> 	$id = &GetParam( 'keywords', "" );
> 	if ($id) {                 # Just script?PageName
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	$action = lc( &GetParam( 'action', "" ) );
> 	$id = &GetParam( 'id', "" );
> 	if ( $action eq 'browse' ) {
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	elsif ( $action eq 'rc' ) {
> 		&BrowsePage($RCName);
> 		return 1;
> 	}
> 	elsif ( $action eq 'random' ) {
> 		&DoRandom();
> 		return 1;
> 	}
> 	elsif ($action eq 'orphans') {
> 		&DoOrphanList();
> 		return 1;
> 	} 
> 	elsif ($action eq 'history') {
> 		&DoHistory($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	return 0;    # Request not handled
> }
> 
> sub BrowsePage {
> 	my ($id) = @_;
> 	my ( $fullHtml, $oldId, $allDiff, $showDiff, $openKept );
> 	my ( $revision, $goodRevision, $diffRevision, $newText );
> 	my ( $fragHtml );
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$openKept = 0;
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	$goodRevision = $revision;    # Non-blank only if exists
> 
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		$openKept = 1;
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$goodRevision = "";
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 		}
> 	}
> 
> 	# Raw mode: just untranslated wiki text
> 	if ( &GetParam( 'raw', 0 ) ) {
> 		print &GetHttpHeader('text/plain');
> 		print $Text{'text'};
> 		return;
> 	}
> 	$newText = $Text{'text'};              # For differences
> 	                                       # Handle a single-level redirect
> 	$oldId   = &GetParam( 'oldid', "" );
> 	if (   ( $oldId eq "" )
> 		&& ( substr( $Text{'text'}, 0, 10 ) eq '#REDIRECT ' ) )
> 	{
> 		$oldId = $id;
> 		if ( ($FreeLinks) && ( $Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/ ) ) {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/ );
> 			$id = &FreeToNormal($id);
> 		}
> 		else {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+(\S+)/ );
> 		}
> 		if ( &ValidId($id) eq "" ) {
> 
> 			# Consider revision in rebrowse?
> 			&ReBrowsePage( $id, $oldId, 0 );
> 			return;
> 		}
> 		else {    # Not a valid target, so continue as normal page
> 			$id    = $oldId;
> 			$oldId = "";
> 		}
> 	}
> 	$MainPage = $id;
> 	$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 	$fullHtml = &GetHeader( $id, &QuoteHtml($id), $oldId );
> 
> 	unless( $id eq $RCName ){ $fullHtml .= &GetLeftNav($id); }
> 	if ( $UseDiff && $showDiff ) {
> 		$fullHtml .= "\n<div class='wikiadmin'>";
> 	}
> 	else {
> 		unless ($id eq $RCName){ $fullHtml .= "\n<div class='wikitext'>"; }
> 		else { $fullHtml .= "\n<div class='wikiadmin'>"; }
> 	}
> 	
> 		if ( $revision ne "" ) {
> 		if ( ( $revision eq $Page{'revision'} ) || ( $goodRevision ne "" ) ) {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Showing revision $revision.</div>";
> 		}
> 		else {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Revision $revision not available, showing current revision instead.</div>";
> 		}
> 	}
> 	
> 	$fullHtml .= $fragHtml;
> 	
> 	$allDiff = &GetParam( 'alldiff', 0 );
> 	if ( $allDiff != 0 ) {
> 		$allDiff = &GetParam( 'defaultdiff', 1 );
> 	}
> 	
> 	if (
> 		(
> 			( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName )
> 		)
> 		&& &GetParam( 'norcdiff', 1 )
> 	  )
> 	{
> 		$allDiff = 0;    # Only show if specifically requested
> 	}
> 	
> 	$showDiff = &GetParam( 'diff', $allDiff );
> 	
> 	if ( $UseDiff && $showDiff ) {
> 		$diffRevision = $goodRevision;
> 		$diffRevision = &GetParam( 'diffrevision', $diffRevision );
> 
> 		# Eventually try to avoid the following keep-loading if possible?
> 		&OpenKeptRevisions('text_default') if ( !$openKept );
> 		$fullHtml .= &GetDiffHTML( $showDiff, $id, $diffRevision, $revision, $newText );
> 		$fullHtml .= $fragHtml;
> 
> 	}
> 
> 	# magiccontent patch - tarquin
> 	# Refactored and added position functionality --DavidClaughton.
> 	my ($magiccommand, $magicpos, $magicparams);
> 	my ($magicHTML, $magicDiv, $wikiHTML) = ("", "", "");
> 	if ( ($magicpos, $magiccommand, $magicparams) = $Text{'text'} =~ m[^\#MAGIC\s*(?:\@(top|bottom))?\s*(\w*)\s*(.*)\n] ){
> 		$Text{'text'} =~ s/^\#MAGIC.*\n//; # kill the magic command line in source
> 		$wikiHTML = &WikiToHTML($Text{'text'});
> 		
> 		#$magicDiv = "\n<hr>\n"; # Remove if using CSS.
> 		
> 		# call: MakeSection( current page, magic module, line of parameters)
> 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
> 		
> 		if (lc $magicpos eq "top"){
> 			$fullHtml .= $magicHTML . $magicDiv . $wikiHTML;
> 		}
> 		else {
> 			$fullHtml .= $wikiHTML . $magicDiv . $magicHTML;
> 		}
> 	}
> 	else {
> 		$fullHtml .= &WikiToHTML($Text{'text'});
> 	}
> 	
> 	if ( !&GetParam( 'embed', $EmbedWiki ) ) {
> 		$fullHtml .= "</div>";
> 		$fullHtml .= $WikiLineFooter;
> 	}
> 
> 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) )
> 	{
> 		print $fullHtml;
> 		print $WikiLineDiff;
> 		print &GetLeftNav($id);
> 		print "\n<div class='wikidiff'>";
> 		&DoRc(1);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter" if ( !&GetParam( 'embed', $EmbedWiki ) );
> 
> 		print &GetFooterText( $id, $goodRevision );
> 		print "\n</div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$fullHtml .= &GetFooterText( $id, $goodRevision );
> 	$fullHtml .= "</div></div></body></html>";
> 	print $fullHtml;
> 	
> 	return
> 	
> 	if ( $showDiff || ( $revision ne "" ) );    # Don't cache special version
> 	&UpdateHtmlCache( $id, $fullHtml ) if ( $UseCache && ( $oldId eq "" ) );
> }
> 
> sub ReBrowsePage {
> 	my ( $id, $oldId, $isEdit ) = @_;
> 	if ( $oldId ne "" ) {    
> 		# Target of #REDIRECT (loop breaking)
> 		print &GetRedirectPage( "action=browse&id=$id&oldid=$oldId", $id, $isEdit );
> 	}
> 	else {
> 		print &GetRedirectPage( $id, $id, $isEdit );
> 	}
> }
> 
> sub DoRc {
> 	my ($rcType) = @_;       # 0 = RSS, 1 = HTML
> 	my ( $fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly );
> 	my ( @fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML );
> 	my $starttime = 0;
> 	my $showbar   = 0;
> 	if ( 0 == $rcType ) {
> 		$showHTML = 0;
> 	}
> 	else {
> 		$showHTML = 1;
> 	}
> 	if ( &GetParam( "from", 0 ) ) {
> 		$starttime = &GetParam( "from", 0 );
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print "\nUpdates since " . &TimeToText($starttime);
> 			print "\n</h2>";
> 		}
> 	}
> 	else {
> 		$daysago = &GetParam( "days", 0 );
> 		$daysago = &GetParam( "rcdays", 0 ) if ( $daysago == 0 );
> 		if ($daysago) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $daysago );
> 			if ($showHTML) {
> 				print "\n<h2>";
> 				print Ts( 'Updates in the last %s day' . ( ( $daysago != 1 ) ? "s" : "" ), $daysago );
> 				print "\n</h2>";
> 			}
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('Updates in the last %s days', '');
> 		}
> 	}
> 	if ( $starttime == 0 ) {
> 		if ( 0 == $rcType ) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RssDays );
> 		}
> 		else {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RcDefault );
> 		}
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print Ts('Updates in the last %s day'. ( ( $RcDefault != 1 ) ? "s" : "" ),$RcDefault );
> 			print "\n</h2>";
> 		}
> 
> 		# Translation of above line is identical to previous version
> 	}
> 
> 	# Read rclog data (and oldrclog data if needed)
> 	( $status, $fileData ) = &ReadFile($RcFile);
> 	$errorText = "";
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>";
> 		$errorText .= "Could not open $RCName log file";
> 		$errorText .= ":</strong> $RcFile</p>";
> 		$errorText .= "Error was ";
> 		$errorText .= ":<pre>$!</pre><p>";
> 		$errorText .= "Note: This error is normal if no changes have been made.";
> 
> 	}
> 	@fullrc = split( /\n/, $fileData );
> 	$firstTs = 0;
> 	if ( @fullrc > 0 ) {    # Only false if no lines in file
> 		($firstTs) = split( /$FS3/, $fullrc[0] );
> 	}
> 	if ( ( $firstTs == 0 ) || ( $starttime <= $firstTs ) ) {
> 		( $status, $oldFileData ) = &ReadFile($RcOldFile);
> 		if ($status) {
> 			@fullrc = split( /\n/, $oldFileData . $fileData );
> 		}
> 		else {
> 			if ( $errorText ne "" ) {    
> 			
> 				# could not open either rclog file
> 				print $errorText;
> 				print "\n<p><strong>";
> 				print "\nCould not open old $RCName log file";
> 				print "\n:</strong> $RcOldFile</p>";
> 				print "\nError was";
> 				print "\n:<pre>$!</pre>";
> 				
> 				return;
> 			}
> 		}
> 	}
> 	$lastTs = 0;
> 	if ( @fullrc > 0 ) {                 
> 		# Only false if no lines in file
> 		($lastTs) = split( /$FS3/, $fullrc[$#fullrc] );
> 	}
> 	$lastTs++ if ( ( $Now - $lastTs ) > 5 );    # Skip last unless very recent
> 	$idOnly = &GetParam( "rcidonly", "" );
> 	if ( $idOnly && $showHTML ) {
> 		print "\n<b>(";
> 		print "\nfor ";
> 		print &ScriptLink( $idOnly, $idOnly );
> 		print "\n only";
> 		print "\n)</b><br>";
> 	}
> 	if ($showHTML) {
> 		foreach $i (@RcDays) {
> 			print "\n | " if $showbar;
> 			$showbar = 1;
> 			print &ScriptLink( "action=rc&days=$i",
> 				Ts( '%s day' . ( ( $i != 1 ) ? 's' : '' ), $i ) );
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('%s days', '');
> 		}
> 		print "\n<br><br>";
> 		print &ScriptLink( "action=rc&from=$lastTs", "List new changes starting from" );
> 		print "\n " . &TimeToText($lastTs);
> 		print "\n<br><br>";
> 	}
> 	
> 	$i = 0;
> 	while ( $i < @fullrc ) {    
> 		# Optimization: skip old entries quickly
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		if ( $ts >= $starttime ) {
> 			$i -= 1000 if ( $i > 0 );
> 			last;
> 		}
> 		$i += 1000;
> 	}
> 	
> 	$i -= 1000 if ( ( $i > 0 ) && ( $i >= @fullrc ) );
> 	for ( ; $i < @fullrc ; $i++ ) {
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	if ( $i == @fullrc && $showHTML ) {
> 		print "\n<br><strong>";
> 		print "\nNo updates since ";
> 		print &TimeToText($starttime);
> 		print "\n</strong><br>";
> 	}
> 	else {
> 		splice( @fullrc, 0, $i );    # Remove items before index $i
> 		
> 		# Consider an end-time limit (items older than X)
> 		if ( 0 == $rcType ) {
> 			print &GetRcRss(@fullrc);
> 		}
> 		else {
> 			print &GetRcHtml(@fullrc);
> 		}
> 	}
> 	if ($showHTML) {
> 		print "\nPage generated ";
> 		print &TimeToText($Now);
> 		print "\n<br>";
> 	}
> }
> 
> sub GetRc {
> 	my $rcType = shift;
> 	my @outrc  = @_;
> 	my ( $rcline,   $date, $newtop, $author, $inlist,   $result );
> 	my ( $showedit, $link, $all,    $idOnly, $headItem, $item );
> 	my ( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp );
> 	my ( $rcchangehist, $tEdit, $tChanges, $tDiff );
> 	my ( $headList, $historyPrefix, $diffPrefix );
> 	my %extra      = ();
> 	my %changetime = ();
> 	my %pagecount  = ();
> 
> 	# Slice minor edits
> 	$showedit = &GetParam( "rcshowedit", $ShowEdits );
> 	$showedit = &GetParam( "showedit",   $showedit );
> 	if ( $showedit != 1 ) {
> 		my @temprc = ();
> 		foreach $rcline (@outrc) {
> 			( $ts, $pagename, $summary, $isEdit, $host ) =
> 			  split( /$FS3/, $rcline );
> 			if ( $showedit == 0 ) {    # 0 = No edits
> 				push( @temprc, $rcline ) if ( !$isEdit );
> 			}
> 			else {                     # 2 = Only edits
> 				push( @temprc, $rcline ) if ($isEdit);
> 			}
> 		}
> 		@outrc = @temprc;
> 	}
> 
> 	# Optimize param fetches out of main loop
> 	$rcchangehist = &GetParam( "rcchangehist", 1 );
> 
> 	# Optimize translations out of main loop
> 	$tEdit         = "(edit)";
> 	$tDiff         = "(diff)";
> 	$tChanges      = "changes";
> 	$diffPrefix    = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
> 	$historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
> 	
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename ) = split( /$FS3/, $rcline );
> 		$pagecount{$pagename}++;
> 		$changetime{$pagename} = $ts;
> 	}
> 	
> 	$date     = "";
> 	$all      = &GetParam( "rcall", 0 );
> 	$all      = &GetParam( "all", $all );
> 	$newtop   = &GetParam( "rcnewtop", $RecentTop );
> 	$newtop   = &GetParam( "newtop", $newtop );
> 	$idOnly   = &GetParam( "rcidonly", "" );
> 	$inlist   = 0;
> 	$headList = "";
> 	$result   = "";
> 	@outrc    = reverse @outrc if ($newtop);
> 
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp ) =
> 		  split( /$FS3/, $rcline );
> 		next if ( ( !$all ) && ( $ts < $changetime{$pagename} ) );
> 		next if ( ( $idOnly ne "" ) && ( $idOnly ne $pagename ) );
> 		%extra = split( /$FS2/, $extraTemp, -1 );
> 		if ( $date ne &CalcDay($ts) ) {
> 			$date = &CalcDay($ts);
> 			if ( 1 == $rcType ) {    # HTML
> 				                     # add date, properly closing lists first
> 				if ($inlist) {
> 					$result .= "</ul>";
> 					$inlist = 0;
> 				}
> 				$result .= "\n<p><strong>" . $date . "</strong></p>";
> 				if ( !$inlist ) {
> 					$result .= "\n<ul>";
> 					$inlist = 1;
> 				}
> 			}
> 		}
> 		if ( 0 == $rcType ) {        # RSS
> 			( $headItem, $item ) = &GetRssRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $diffPrefix,
> 				$historyPrefix
> 			);
> 			$headList .= $headItem;
> 			$result   .= $item;
> 		}
> 		else {                       # HTML
> 			$result .= &GetHtmlRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $tEdit,
> 				$tDiff,             $tChanges,
> 				$all,               $rcchangehist
> 			);
> 		}
> 	}
> 	if ( 1 == $rcType ) {
> 		$result .= "</ul>" if ($inlist);    # Close final tag
> 	}
> 	return ( $headList, $result );            # Just ignore headList for HTML
> }
> 
> sub GetRcHtml {
> 	my ( $html, $extra );
> 	( $extra, $html ) = &GetRc( 1, @_ );
> 	return $html;
> }
> 
> sub GetHtmlRcLine {
> 	my (
> 		$pagename, $timestamp, $host,      $userName, $userID,
> 		$summary,  $isEdit,    $pagecount, $revision, $tEdit,
> 		$tDiff,    $tChanges,  $all,       $rcchangehist
> 	  )
> 	  = @_;
> 	my ( $author, $sum, $edit, $count, $link, $html );
> 	
> 	$html = "";
> 	$host = &QuoteHtml($host);
> 	if ( defined($userName) && defined($userID) ) {
> 		$author = &GetAuthorLink( $host, $userName, $userID );
> 	}
> 	else {
> 		$author = &GetAuthorLink( $host, "", 0 );
> 	}
> 	
> 	$sum = "";
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);
> 		$sum     = "<strong>[$summary]</strong> ";
> 	}
> 	
> 	$edit  = "";
> 	$edit  = "<em>$tEdit</em> " if ($isEdit);
> 	$count = "";	
> 	if ( ( !$all ) && ( $pagecount > 1 ) ) {
> 		$count = "($pagecount ";
> 		if ($rcchangehist) {
> 			$count .= &GetHistoryLink( $pagename, $tChanges, "Click to view revision history" );
> 		}
> 		else {
> 			$count .= $tChanges;
> 		}
> 		$count .= ") ";
> 	}
> 	
> 	$link = "";
> 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) {
> 		$link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  ";
> 	}
> 	$link .= &GetPageLink($pagename);
> 	$html .= "\n<li>$link ";
> 	$html .= &CalcTime($timestamp) . " : $count$edit" . " $sum";
> 	$html .= ". . . . . $author";
> 	return $html;
> }
> 
> sub GetRcRss {
> 	my ( $rssHeader, $headList, $items );
> 
> 	# Normally get URL from script, but allow override
> 	$FullUrl         = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$QuotedFullUrl   = &QuoteHtml($FullUrl);
> 	$SiteDescription = &QuoteHtml($SiteDescription);
> 	my $ChannelAbout =
> 	  &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
> 	$rssHeader = <<RSS ;
> <?xml version="1.0" encoding="ISO-8859-1"?>
> <rdf:RDF
>     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
>     xmlns="http://purl.org/rss/1.0/"
>     xmlns:dc="http://purl.org/dc/elements/1.1/"
>     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
> >
>     <channel rdf:about="$ChannelAbout">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
>         <description>${\(&QuoteHtml($SiteDescription))}</description>
>         <wiki:interwiki>
>             <rdf:Description link="$QuotedFullUrl">
>                 <rdf:value>$InterWikiMoniker</rdf:value>
>             </rdf:Description>
>         </wiki:interwiki>
>         <items>
>             <rdf:Seq>
> RSS
> 	( $headList, $items ) = &GetRc( 0, @_ );
> 	$rssHeader .= $headList;
> 	return <<RSS ;
> $rssHeader
>             </rdf:Seq>
>         </items>
>     </channel>
>     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <url>$RssLogoUrl</url>
>         <link>$QuotedFullUrl</link>
>     </image>
> $items
> </rdf:RDF>
> RSS
> }
> 
> sub GetRssRcLine {
> 	my (
> 		$pagename, $timestamp,  $host,   $userName,
> 		$userID,   $summary,    $isEdit, $pagecount,
> 		$revision, $diffPrefix, $historyPrefix
> 	  )
> 	  = @_;
> 	my (
> 		$itemID,     $description, $authorLink, $author, $status,
> 		$importance, $date,        $item,       $headItem
> 	);
> 
> 	# Add to list of items in the <channel/>
> 	$itemID = $FullUrl
> 	  . &ScriptLinkChar()
> 	  . &GetOldPageParameters( 'browse', $pagename, $revision );
> 	$itemID   = &QuoteHtml($itemID);
> 	$headItem = "                <rdf:li rdf:resource=\"$itemID\"/>";
> 
> 	# Add to list of items proper.
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$description = &QuoteHtml($summary);
> 	}
> 	$host = &QuoteHtml($host);
> 	if ($userName) {
> 		$author     = &QuoteHtml($userName);
> 		$authorLink = "link=\"$QuotedFullUrl?$author\"";
> 	}
> 	else {
> 		$author = $host;
> 	}
> 	$status     = ( 1 == $revision ) ? 'new'   : 'updated';
> 	$importance = $isEdit            ? 'minor' : 'major';
> 	$timestamp += $TimeZoneOffset;
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($timestamp);
> 	$year += 1900;
> 	$date = sprintf( "%4d-%02d-%02dT%02d:%02d:%02d+%02d:00", $year, $mon + 1, $mday, $hour, $min, $sec, $TimeZoneOffset / ( 60 * 60 ) );
> 	$pagename = &QuoteHtml($pagename);
> 
> 	# Write it out longhand
> 	$item = <<RSS ;
>     <item rdf:about="$itemID">
>         <title>$pagename</title>
>         <link>$QuotedFullUrl?$pagename</link>
>         <description>$description</description>
>         <dc:date>$date</dc:date>
>         <dc:contributor>
>             <rdf:Description wiki:host="$host" $authorLink>
>                 <rdf:value>$author</rdf:value>
>             </rdf:Description>
>         </dc:contributor>
>         <wiki:status>$status</wiki:status>
>         <wiki:importance>$importance</wiki:importance>
>         <wiki:diff>$diffPrefix$pagename</wiki:diff>
>         <wiki:version>$revision</wiki:version>
>         <wiki:history>$historyPrefix$pagename</wiki:history>
>     </item>
> RSS
> 	return ( $headItem, $item );
> }
> 
> sub DoRss {
> 	print "\nContent-type: text/xml\n\n";
> 	&DoRc(0);
> }
> 
> sub DoRandom {
> 	my ( $id, @pageList );
> 	
> 	@pageList = &AllPagesList();                              # Optimize?
> 	$id       = $pageList[ int( rand( $#pageList + 1 ) ) ];
> 	
> 	&ReBrowsePage( $id, "", 0 );
> }
>    
> sub DoHistory {
> 	my ($id) = @_;
> 	my ( $html, $canEdit, $row, $newText );
> 
> 	print &GetHeader( "", Ts( 'History of %s', $id ), "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikiadmin'>";
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$newText = $Text{'text'};
> 	$canEdit = 0;
> 	$canEdit = &UserCanEdit($id) if ($HistoryEdit);
> 		
> 	if ($UseDiff) {
>       print "\n<form id='wikiform' action='$ScriptName' method='get'>";
>       print "\n<input type='hidden' name='action' value='browse'/>";
>       print "\n<input type='hidden' name='diff' value='1'/>";
>       print "\n<input type='hidden' name='id' value=\"$id\"/>";
>       print "\n<table class='wikihistory' border='0' width='90%'>";
> 	}
> 	
> 	$html = &GetHistoryLine( $id, $Page{'text_default'}, $canEdit, $row++ );
> 	&OpenKeptRevisions('text_default');
> 	
> 	foreach ( reverse sort { $a <=> $b } keys %KeptRevisions ) {
> 		next if ( $_ eq "" );    # (needed?)
> 		$html .= &GetHistoryLine( $id, $KeptRevisions{$_}, $canEdit, $row++ );
> 	}
> 	
> 	print $html;
> 	
> 	if ($UseDiff) {
> 		my $label = "Compare";
> 		
> 		print "\n<tr><td align='center'><br>";
> 		print "\n<input type='submit' value='$label'/>&nbsp;&nbsp;</td></tr></table></form>";
> 		print &GetDiffHTML( &GetParam( 'defaultdiff', 1 ), $id, "", "", $newText );
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetMaskedHost {
> 	my ($text) = @_;
> 	my ($logText);
> 	if ( !$MaskHosts ) {
> 		return $text;
> 	}
> 	$logText = "(logged)";
> 	if ( !( $text =~ s/\d+$/$logText/ ) ) { # IP address (ending numbers masked)
> 		$text =~ s/^[^\.\(]+/$logText/;     # Host name: mask until first .
> 	}
> 	return $text;
> }
> 
> sub GetHistoryLine {
> 	my ( $id, $section, $canEdit, $row ) = @_;
> 	my ( $html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor );
> 	my ( %sect, %revtext );
> 	%sect = split( /$FS2/, $section, -1 );
> 	%revtext = split( /$FS3/, $sect{'data'} );
> 	$rev     = $sect{'revision'};
> 	$summary = $revtext{'summary'};
> 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) {
> 		$host = $sect{'host'};
> 	}
> 	else {
> 		$host = $sect{'ip'};
> 	}
> 	$host     = &GetMaskedHost($host);
> 	$user     = $sect{'username'};
> 	$uid      = $sect{'id'};
> 	$ts       = $sect{'ts'};
> 	$minor    = "";
> 	$minor    = "<i>(edited) </i>" if ( $revtext{'minor'} );
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 
> 	if ($UseDiff) {
> 		my ( $c1, $c2 );
> 		$c1 = "checked='checked'" if 1 == $row;
> 		$c2 = "checked='checked'" if 0 == $row;
> 		$html .= "\n<tr>";
> 		$html .= "\n<td align='center'>";
> 		$html .= "\n<input type='radio' name='diffrevision' value='$rev' $c1/>";
> 		$html .= "\n<input type='radio' name='revision' value='$rev' $c2/>";
> 		$html .= "</td><td>";
> 	}
> 	if ( 0 == $row ) {    
> 		# current revision
> 		$html .= &GetPageLinkText( $id, Ts( 'RevisionB %s', $rev ) ) . ' ';
> 		
> 		if ($canEdit) {
> 			$html .= &GetEditLink( $id, "Edit" ) . ' ';
> 		}
> 	}
> 	else {
> 		$html .= &GetOldPageLink( 'browse', $id, $rev, Ts( 'RevisionA %s', $rev ) ) . ' ';
> 		if ($canEdit) {
> 			$html .= &GetOldPageLink( 'edit', $id, $rev, "Edit" ) . ' ';
> 		}
> 	}
> 	$html .= "\n<td>" . &TimeToText($ts) . "</td>";
> 	$html .= "\n<td> by " . &GetAuthorLink( $host, $user, $uid ) . " $minor</td>";
> 	
> 	if ( defined($summary) && ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);    # Thanks Sunir! :-)
> 		$html .= "\n<td>[$summary]</td>";
> 	}
> 	else {
> 		$html .= "\n<td>&nbsp;</td>";
> 	}
> 	$html .= $UseDiff ? "</tr>" : "\n<br>";
> 	return $html;
> }
> 
> # ==== HTML and page-oriented functions ====
> sub ScriptLinkChar {
> 	if ($SlashLinks) {
> 		return '/';
> 	}
> 	return '?';
> }
> 
> sub ScriptLink {
> 	my ( $action, $text ) = @_;
> 	
> 	return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\" class='wikiscriptlink' title='Click to visit page'>$text</a>";
> }
> 
> sub ScriptLinkClass {
> 	my ( $action, $text, $class, $title ) = @_;
> 	
> 	return "<a href='$ScriptName"
> 	  . &ScriptLinkChar()
> 	  . "$action' class='$class' title='$title'>$text</a>";
> }
> 
> sub ScriptLinkLeftNav {
> 	my ($id, $action, $target, $label, $type) = @_;
> 	my $html;
> 	my $title;
> 	my $class;	
> 	
> 	if ($type eq "1"){
> 		if ($action eq $target){ $html .= "\n<li class='disabled'>$label</li>"; }
> 		else { $html .= "\n<li><a class='wikipagelink' title='Click to visit this page.' href='\?action=$target'>$label</a></li>"; }	
> 		
> 	}
> 	else {
> 		my $authtype = &CheckIsAuthUser($target);
> 		
> 		if ($authtype eq ""){
> 			$title = "This page is private.";
> 			$class = "wikipagelink private";
> 			$label .= "!";
> 		}
> 		elsif ( $authtype eq "1"){
> 			$title = "Click to visit this locked page.";
> 			$class = "wikipagelink locked";
> 			$label .= "&not;";
> 		}
> 		else {
> 			$title = "Click to visit this page.";
> 			$class = "wikipagelink";		
> 		}
> 		
> 		if ($id eq $target){ $html .= "\n<li class='selected'>$label</li>"; }
> 		else { $html .= "\n<li><a class='$class' title='$title' href='\?$target'>$label</a></li>"; }		
> 	}
> }
> 
> sub GetOrphanLink {
> 	return &ScriptLink("action=orphans", T('Orphans'));
> }
> 
> sub DoOrphanList {
> 	print &GetHeader("", &QuoteHtml(T('Full Orphan List')), "");
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print &PrintPageList( "", &GetOrphanList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetOrphanList {
> 	my @found;	
> 	my %seen = ();
> 	my @pglist = &AllPagesList();
> 	
> 	foreach my $name (@pglist) {
> 		$seen{$name} = 0;
> 	}
> 	
> 	# pages linked from menu bar aren't orphans
> 	$seen{$HomePage} = 1;
> 	$seen{$RCName} = 1;
> 	
> 	foreach my $name (@pglist) {
> 		my @links = &GetPageLinks($name, 1, 0, 0, 0);
> 		
> 		foreach my $link (@links) {
> 			#don't include self links
> 			unless ($link eq $name) {
> 				$seen{$link}++ if exists $seen{$link};
> 			}
> 		}
> 	}
> 	
> 	foreach my $name (sort keys %seen) {
> 		push(@found, $name) if $seen{$name} < 1;
> 	}
> 	return @found;
> }
> 
> 
> sub GetPageLinkText {
> 	my ( $id, $name ) = @_;
> 	$id =~ s|^/|$MainPage/|;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 
> 	if ($authtype eq ""){
> 		return &ScriptLinkClass( $id, "$name!", 'wikipagelink private', 'This page is private.' );
> 	}
> 		
> 	if ( -f &GetLockedPageFile($id) || $authtype eq "1"){
> 		return &ScriptLinkClass( $id, "$name&not;", 'wikipagelink locked', 'Click to visit this locked page' );
> 	}
> 	
> 	return &ScriptLinkClass( $id, $name, 'wikipagelink', 'Click to visit page' );
> }
> 
> sub GetPageLink {
> 	my ($id) = @_;
> 	return &GetPageLinkText( $id, $id );
> }
> 
> sub GetEditLink {
> 	my ( $id, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	return &ScriptLinkClass( "action=edit&id=$id", $name, 'wikipageedit', 'Click to edit page' );
> }
> 
> sub GetCreateNewLink {
> 	my ( $id, $name ) = @_;
> 	my ( $html );
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	$html  = "<a href='$ScriptName";
> 	$html .= &ScriptLinkChar();
> 	$html .= "action=edit&id=$id' class='wikicreatepagelink' title='Create this entry'>";
> 	$html .= $name;
> 	$html .= "<span class='wikilinkicon'>&nbsp;</span>";
> 	$html .= "</a>";
> 	
> 	return $html;
> }
> 
> sub GetDeleteLink {
> 	my ( $id, $name, $confirm ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	return &ScriptLink( "action=delete&id=$id&confirm=$confirm", $name );
> }
> 
> sub GetOldPageParameters {
> 	my ( $kind, $id, $revision ) = @_;
> 	$id = &FreeToNormal($id) if $FreeLinks;
> 	return "action=$kind&id=$id&revision=$revision";
> }
> 
> sub GetOldPageLink {
> 	my ( $kind, $id, $revision, $name ) = @_;
> 	$name =~ s/_/ /g if $FreeLinks;
> 	return &ScriptLink( &GetOldPageParameters( $kind, $id, $revision ), $name );
> }
> 
> sub GetPageOrEditAnchoredLink {
> 	my ( $id, $anchor, $name ) = @_;
> 	my ( @temp, $exists );
> 	my $NamedFreeLink = 0;
> 	
> 	if ( $name eq "" ) {
> 		$name = $id;
> 		if ($FreeLinks) {
> 			$name =~ s/_/ /g;
> 		}
> 	}
> 	else {
> 		$NamedFreeLink = 1;
> 	}
> 	
> 	$id =~ s|^/|$MainPage/|;
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	$exists = 0;
> 	
> 	if ($UseIndex) {
> 		if ( !$IndexInit ) {
> 			@temp = &AllPagesList();    # Also initializes hash
> 		}
> 		$exists = 1 if ( $IndexHash{$id} );
> 	}
> 	elsif ( -f &GetPageFile($id) ) {    # Page file exists
> 		$exists = 1;
> 	}
> 	
> 	if ($exists) {
> 		$id = "$id#$anchor" if $anchor;
> 		$name = "$name#$anchor"  if $anchor && $NamedAnchors != 2 && !$NamedFreeLink;
> 		
> 		return &GetPageLinkText( $id, $name );
> 	}
> 	if ( $FreeLinks && !$EditNameLink ) {
> 		if ( $name =~ m| | ) {          # Not a single word
> 			$name = "[$name]";          # Add brackets so boundaries are obvious
> 		}
> 	}
> 	if ($EditNameLink) {
> 		return &GetEditLink( $id, $name );
> 	}
> 	else {
> 		return &GetCreateNewLink( $id, $name );
> 	}
> }
> 
> sub GetPageOrEditLink {
> 	my ( $id, $name ) = @_;
> 	my ($link, $anchor) = split( /#/, $id, 2);
> 	
> 	return &GetPageOrEditAnchoredLink($link, $anchor, $name);
> }
> 
> sub GetBackLinksSearchLink {
> 	my ($id) = @_;
> 	my $name = $id;
> 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
> 	
> 	if ($FreeLinks) {
> 		$name =~ s/_/ /g;    # Display with spaces
> 		$id   =~ s/_/+/g;    # Search for url-escaped spaces
> 	}
> 	return &ScriptLinkTitle( "back=$id", $name, "Click to see which pages link to this one" );
> }
> 
> sub GetPrefsLink {
> 	return &ScriptLink( "action=editprefs", "Preferences" );
> }
> 
> sub GetRandomLink {
> 	return &ScriptLink( "action=random", "Random Page" );
> }
> 
> sub ScriptLinkDiff {
> 	my ( $diff, $id, $text, $rev ) = @_;
> 	
> 	$rev = "&revision=$rev" if ( $rev ne "" );
> 	$diff = &GetParam( "defaultdiff", 1 ) if ( $diff == 4 );
> 	
> 	return &ScriptLinkTitle( "action=browse&diff=$diff&id=$id$rev", $text, "Click to view last revision" );
> }
> 
> sub GetUploadLink {
> 	return &ScriptLink( 'action=upload', "Upload" );
> }
> 
> sub ScriptLinkTitle {
> 	my ( $action, $text, $title ) = @_;
> 	if ($FreeLinks) {
> 		$action =~ s/ /_/g;
> 	}
> 	return "<a href=\"$ScriptName"
> 	  . &ScriptLinkChar()
> 	  . "$action\" title=\"$title\" class='wikiscriptlinktitle'>$text</a>";
> }
> 
> sub GetAuthorLink {
> 	my ( $host, $userName, $uid ) = @_;
> 	my ( $html, $title, $userNameShow );
> 	$userNameShow = $userName;
> 	
> 	if ($FreeLinks) {
> 		$userName     =~ s/ /_/g;
> 		$userNameShow =~ s/_/ /g;
> 	}
> 	if ( &ValidId($userName) ne "" ) {    # Invalid under current rules
> 		$userName = "";                   # Just pretend it isn't there.
> 	}
> 	if ( ( $uid > 0 ) && ( $userName ne "" ) ) {
> 		$html = &ScriptLinkTitle( "$HomePagePrefix/$userName", $userNameShow, Ts( 'ID %s', $uid ) . ' ' . Ts( 'from %s', $host ) );
> 	}
> 	else {
> 		$html = $host;
> 	}
> 	return $html;
> }
> 
> sub GetHistoryLink {
> 	my ( $id, $text, $title ) = @_;
> 	if ($FreeLinks) {
> 		$id =~ s/ /_/g;
> 	}
> 	return &ScriptLinkTitle( "action=history&id=$id", $text, $title );
> }
> 
> sub GetHeader {
> 	my ( $id, $title, $oldId ) = @_;
> 	my $header    = "";
> 	my $logoImage = "";
> 	my $result    = "";
> 	my $embed     = &GetParam( 'embed', $EmbedWiki );
> 	my $altText   = "[Home]";
> 	my $temp      = "";
> 	
> 	$result = &GetHttpHeader("");
> 	
> 	if ($FreeLinks) {
> 		$title =~ s/_/ /g;    # Display as spaces
> 	}
> 	
> 	$result .= &GetHtmlHeader("$SiteName: $title", $id);
> 	
> 	return $result if ($embed);
> 	$result .= "<div class='wikiheader'>";
> 	
> 	if ( $oldId ne "" ) {
> 		$result .=
> 		  $q->h3( '(' . Ts( 'redirected from %s', &GetEditLink( $oldId, $oldId ) )  . ')' );
> 	}
> 	
> 	if ( ( !$embed ) && ( $LogoUrl ne "" ) ) {
> 		$logoImage = "img class='wikilogo' src=\"$LogoUrl\" alt=\"$altText\" border=0";
> 		
> 		if ( !$LogoLeft ) {
> 			$logoImage .= " align=\"right\"";
> 		}
> 		$header = &ScriptLink( $HomePage, "\n<$logoImage>" );
> 	}
> 	
> 	if ( $id ne "" ) {
> 		my $authtype = &CheckIsAuthUser($id);
> 		if (&PageIsLocked($id, 1) || $authtype eq "1"){
> 			$temp = "<span class='wikilockicon' title='This page is locked.'>&nbsp;</span>";
> 		}
> 		else {	
> 			if ( -f &GetLockedPageFile($id) ) {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='This page locked for others. Click to edit page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 			else {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='Click to edit this page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 		}		
> 		$result .= $q->h1( $header . &GetBackLinksSearchLink($id) . $temp );
> 	}
> 	else {
> 		$result .= $q->h1( $header . $title );
> 	}
> 	
> 
> 	if ( &GetParam( "toplinkbar", 1 ) ) {		
> 		$result .= &GetGotoBar($id);
> 		$result .= $WikiLineHeader;
> 	}
> 	$result .= "</div>";	
> 	return $result;
> }
> 
> sub GetHttpHeader {
> 	my ($type) = @_;
> 	my $cookie;
> 	$type = "text/html" if ( $type eq "" );
> 	if ( defined( $SetCookie{'id'} ) ) {
> 		$cookie =
> 		   "$CookieName=" . "rev&"
> 		  . $SetCookie{'rev'} . "&id&"
> 		  . $SetCookie{'id'}
> 		  . "&randkey&"
> 		  . $SetCookie{'randkey'};
> 		$cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
> 		if ( $HttpCharset ne "" ) {
> 			return $q->header(
> 				-cookie => $cookie,
> 				-type   => "$type; charset=$HttpCharset"
> 			);
> 		}
> 		return $q->header( -cookie => $cookie );
> 	}
> 	if ( $HttpCharset ne "" ) {
> 		return $q->header( -type => "$type; charset=$HttpCharset" );
> 	}
> 	return $q->header( -type => $type );
> }
> 
> sub GetHtmlHeader {
> 	my ($title, $id) = @_;
> 	my ( $dtd, $html, $bodyExtra, $stylesheet );
> 	
> 	$html  = "";
> 	$dtd   = "-//IETF//DTD HTML//EN";
> 	$html  = qq(<!DOCTYPE HTML PUBLIC "$dtd">);
> 	$title = $q->escapeHTML($title);
> 	$html .= "\n<html><head><title>$title</title>";
> 	
> 	if ( $FavIcon ne "" ) {
> 		$html .= "<link rel='SHORTCUT ICON' href='$FavIcon'>";
> 	}
> 	
> 	if ($MetaKeywords) {
> 		my $keywords = $OpenPageName;
> 		$keywords =~ s/([a-z])([A-Z])/$1, $2/g;
> 		$html .= "\n<meta name='keywords' content='$keywords'/>" if $keywords;
> 	}
> 	
> 	if ( $SiteBase ne "" ) {
> 		$html .= qq(<base href="$SiteBase">);
> 	}
> 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
> 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
> 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
> 	
> 	if ( $stylesheet ne "" ) {
> 		$html .= qq(<link rel="stylesheet" href="$stylesheet">);
> 	}
> 
>    my $bots = "";
>    # actions and non-existant page views don't get indexed or followed by robots
>    if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
>    $bots = $bots . 'index,' . $bots . 'follow';
>    $html .= qq(<meta name="robots" content="$bots" />\n);
> 	
> 	$html .= $UserHeader;
> 	$bodyExtra = "";
> 	
> 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
> 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
> 	
> 	$html .= "</head><body$bodyExtra>";
> 	$html .= "\n<div id='wikicontainer'>";
> 	
> 	return $html;
> }
> 
> sub GetLeftNav {
> 	my $id = shift;
> 	my $action = &GetParam( "action", "" );
> 	my $html = "";
> 	
> 	$html .= "\n<div class='wikileftnav'>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'HomePage', 'Home page', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'NobleWiki', 'Wiki Info', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'CategoryCategory', 'Contents', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'FeaturedContent', 'Featured', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'random', 'Random Article', "1");	
> 	
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>	";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'RecentChanges', 'Recent changes', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'ListOfWantedPages', 'Wanted Pages', "");
> 					
> 	if ($id ne ""){
> 		unless ($id eq 'ListOfWantedPages' or $id eq 'RecentChanges'){	
> 			if (&UserCanEdit( $id, 0 )){ $html .= "\n<li><a href='?action=edit&id=$id'>Edit this Page</a></li>";	}
> 			else { $html .= "\n<li class='disabled'>Edit this Page</li>"; }
> 							
> 			if ($action eq 'history'){ $html .= "\n<li class='disabled'>Version History</li>"; }
> 			else { $html .= "\n<li><a href='?action=history&id=$id'>Version History</a></li>"; }
> 		}
> 		else {
> 			$html .= "\n<li class='disabled'>Edit this Page</li>"; 
> 			$html .= "\n<li class='disabled'>Version History</li>"; 
> 		}
> 	}
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'SandBox', 'SandBox', "");
> 	
> 	$html .= "\n	</ul></div>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'editprefs', 'Preferences', "1");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiContacts', 'Contact Us', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiHelp', 'Help', "");
> 		
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>";
> 	$html .= "\n	<div class='wikileftnavsearch' style='text-align:right;'>";
> 	$html .= "\n		<form>";
> 	$html .= "\n			<div class='wikisearchlabel' style='text-align:left;'><b>Search</b></div>";
> 	$html .= "\n			<input type='text' title='Enter ! before search term for exclusion' name='search' id='searchterm' />";
> 	$html .= "\n			<input type='submit' value='Go!' name='dosearch' title='Click to perform your search request.' />";
> 	$html .= "\n		</form></div>";
> 	$html .= "\n</div>";
> 	
> 	return $html;	
> }
> 
> sub GetFooterText {
> 	my ( $id, $rev ) = @_;
> 	my $result;
> 	
> 	if ( &GetParam( 'embed', $EmbedWiki ) ) {
> 		return "";
> 	}
> 	
> 	$result = "<div class='wikifooter'>";
> 	$result .= &GetGotoBar($id);
> 	$result .= "<div class='wikirevision'>";
> 	
> 	if ($id ne ""){
> 		if ( &UserCanEdit( $id, 0 )) {
> 			if ( $rev ne "" ) {
> 				$result .=
> 				  &GetOldPageLink( 'edit', $id, $rev, Ts( 'Edit revision %s of this page', $rev ) );
> 			}
> 			else {
> 				$result .= &GetEditLink( $id, "Edit text of this page" );
> 			}
> 		}
> 		else {
> 			$result .= "This page is read-only";
> 		}
> 	}
> 	
> 	if ($id ne ""){ $result .= " | " . &GetHistoryLink( $id, "View other revisions", "Click to view revision history" ); }	
> 	if ( $rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
> 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?$id' class='wikiusemetalink'>Search MetaWiki</a>"; }
> 	
> 	$result .= "</div>";
> 	
> 	if ($id ne ""){ 
> 		if ( $Section{'revision'} > 0 ) {
> 			$result .= "<div class='wikirevision'>";		
> 			$result .= "Created " . &TimeToText($Page{'tscreate'});
> 			
> 			if ($Page{'authorcreate'}) { $result .= " by " . $Page{'authorcreate'}; } 
> 			
> 			$result .= " | ";	
> 			if ( $rev eq "" ) { $result .= "Last edited"; }
> 			else { $result .= "Edited"; }
> 			
> 			$result .= " " . &TimeToText( $Section{ts} );
> 				
> 			if ($AuthorFooter) { $result .= " by " . &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}); }
> 		}
> 		
> 		if ($UseDiff) { $result .= " " . &ScriptLinkDiff( 4, $id, "(diff)", $rev ); }
> 	}
> 	
> 	$result .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$result .= &GetSearchForm();	
> 	if ( $DataDir =~ m|/tmp/| ) {
> 		$result .= "\n<br><b>";
> 		$result .= "Warning";
> 		$result .= ":</b> ";
> 		$result .= "Database is stored in temporary directory $DataDir";
> 		$result .= "\n<br>";
> 	}
> 	
> 	if ( $ConfigError ne "" ) {
> 		$result .= "\n<br>";
> 		$result .= "\n<b>Config file error:</b>";
> 		$result .= "$ConfigError <br>";
> 	}
> 	
> 	$result .= "</form>";
> 	$result .= &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { $result .= &GetAdminBar($id, ""); }
> 	$result .= "</div>";
> 		
> 	return $result;
> }
> 
> sub getFooterNote {
> 	my $html;
> 	my $userid = &GetParam("username", "");
> 	my $access = "Guest ";
> 	my $username = "Anonymous";
> 
> 	if (UserIsAdmin()){
> 		$access = "Admin ";
> 	}
> 	elsif (UserIsEditor()){
> 		$access = "Editor ";
> 	}
> 	
> 	if ($userid ne ""){
> 		$username = $userid;
> 	}
> 	
> 	if ($FooterNote ne ""){
> 		$html = $FooterNote;
> 		$html =~ s/access/$access/;
> 		$html =~ s/username/$userid/;
> 	}
> 	
> 	return $html;
> }
> 
> sub GetCommonFooter {
> 	my ($html);
> 	my $id = &GetParam( "id",     "" );
> 	
> 	$html = $WikiLineFooter;
> 	$html .= "\n<div class='wikifooter'>";
> 	$html .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$html .= &GetGotoBar("");
> 	$html .= &GetSearchForm();
> 	$html .= "</form>";	
> 	$html .= &getFooterNote();
> 	
> 	if ( $AdminBar && &UserIsAdmin() ) { $html .= &GetAdminBar($id, "class='wikirevision'"); }
> 	$html .= "\n<div>"; ## ??NEEDED ??
> 	
> 	return $html;
> }
> 
> sub GetGotoBar {
> 	my ($id) = @_;
> 	my ( $main, $bartext );
> 	
> 	$bartext = "\n<div class='wikigotobar'>";
> 	$bartext .= &GetPageLink($HomePage);
> 	
> 	if ( $id =~ m|/| ) {
> 		$main = $id;
> 		$main =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		unless ($main eq $HomePage){
> 			$bartext .= " | " . &GetPageLink($main);
> 		}
> 	}
> 	
> 	$bartext .= " | " . &GetPageLink($RCName);
> 	$bartext .= " | " . &GetPrefsLink();
> 	
> 	if ( $UseUpload && &UserCanUpload() ) {
> 		$bartext .= " | " . &GetUploadLink();
> 	}
> 	
> 	$bartext .= " | " . &ScriptLink( "action=listfiles&filter=sample", "List Assets" );
> 	
> 	if ( &GetParam( "linkrandom", 0 ) ) {
> 		$bartext .= " | " . &GetRandomLink();
> 	}
> 	
> 	if ( $UserGotoBar ne "" ) {
> 		$bartext .= " | " . $UserGotoBar;
> 	}
> 	
> 	$bartext .= "</div>";
> 	
> 	return $bartext;
> }
> 
> sub GetSearchForm {
> 	my ($html);
> 	
> 	$html =  "\n<div class='wikisearch'>";
> 	$html .= "\n<div class='wikisearchlabel'>Search:</div>";
> 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";	
> 	if ($SearchButton) {
> 		$html .= " " . $q->submit( 'dosearch', "Go!" );
> 	}
> 	else {
> 		$html .= &GetHiddenValue( "dosearch", 1 );
> 	}
> 	
> 	$html .= "</div>";
> 	return $html;
> }
> 
> sub GetRedirectPage {
> 	my ( $newid, $name, $isEdit ) = @_;
> 	my ( $url, $html );
> 	my ($nameLink);
> 
> 	# Normally get URL from script, but allow override.
> 	$FullUrl  = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$url      = $FullUrl . &ScriptLinkChar() . $newid;
> 	$nameLink = "<a href='$url' class='wikiredirect'>$name</a>";
> 	
> 	if ( $RedirType < 3 ) {
> 		if ( $RedirType == 1 ) {    # Use CGI.pm
> 			 # NOTE: do NOT use -method (does not work with old CGI.pm versions)
> 			 # Thanks to Daniel Neri for fixing this problem.
> 			$html = $q->redirect( -uri => $url );
> 		}
> 		else {    # Minimal header
> 			$html = "Status: 302 Moved\n";
> 			$html .= "Location: $url\n";
> 			$html .= "Content-Type: text/html\n";   # Needed for browser failure
> 		}
> 		$html .= " Your browser should go to the $newid page.";
> 		$html .= " If it does not, click $nameLink to continue.";
> 	}
> 	else {
> 		if ($isEdit) {
> 			$html  = &GetHeader( "", "Thanks for editing...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
>  			$html .= "Thank you for editing $nameLink ";
> 		}
> 		else {
> 			$html = &GetHeader( "", "Link to another page...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
> 		}
> 		
> 		$html .= "Follow the $nameLink link to continue.";
> 		$html .= "</div>";
> 		$html .= "</div></div></body></html>";	
> 	}
> 	
> 	return $html;
> }
> 
> # ==== Common wiki markup ====
> sub RestoreSavedText {
> 	my ($text) = @_;
> 	
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
> }
> 
> sub RemoveFS {
> 	my ($text) = @_;
> 
> 	# Note: must remove all $FS, and $FS may be multi-byte/char separator
> 	$text =~ s/($FS)+(\d)/$2/g;
> 	
> 	return $text;
> }
> 
> sub WikiToHTML {
> 	my ($pageText) = @_;
> 	$TableMode       = 0;
> 	%SaveUrl         = ();
> 	%SaveNumUrl      = ();
> 	$SaveUrlIndex    = 0;
> 	$SaveNumUrlIndex = 0;
> 	$pageText        = &RemoveFS($pageText);
> 	
> 	if ($RawHtml) {
> 		$pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
> 	}
> 	
> 	$pageText = &QuoteHtml($pageText);
> 	$pageText =~ s/\\ *\r?\n/ /g;    # Join lines with backslash at end
> 		
> 	if ($ParseParas) {
> 
> 		# Note: The following 3 rules may span paragraphs, so they are
> 		#       copied from CommonMarkup
> 		$pageText =~ s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 		$pageText =~ s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		$pageText =~ s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		$pageText =~ s/\{{template:(\w+\s*.*?)}}/&StoreTemplate($1)/iges;
> 		$pageText =~ s/\{{flash:\s*(.*?)}}/&StoreRaw(&GetFlash($1))/iges;
> 		$pageText =~ s/\{{gallery:\s*(.*?)}}/&StoreRaw(&GetGallery($1))/iges;
> 		
> 		$pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
> 		$pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
> 		
> 	}
> 	else {
> 		$pageText = &WikiLinesToHtml($pageText);         # Line-oriented markup
> 		$pageText = &CommonMarkup( $pageText, 1, 0 );    # Multi-line markup
> 
> 	}
> 	
> 	while (@HeadingNumbers) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$pageText =~ s/&lt;toc&gt;/<div class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/&lt;toc ((\d)+)?&gt;/<div style='width: $1;' class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/\#SUBPAGES\s+(\w+.*?)/&StoreRaw("\n<h6>" . Ts('Subpages of: %s', &QuoteHtml($1)) . "<\/h6>" . &GetPageList(&GetSubpages($1)))/ige;
> 	$pageText =~ s/\#SUBPAGES/&StoreRaw("\n<h6>" . Ts('Subpages for %s', $MainPage) . "<\/h6>" . &GetPageList(&GetSubpages($MainPage)))/ige;
> 	
> 	if ( $LateRules ne "" ) {
> 		$pageText = &EvalLocalRules( $LateRules, $pageText, 0 );
> 	}
> 	
> 	return &RestoreSavedText($pageText);
> }
> 
> sub CommonMarkup {
> 	my ( $text, $useImage, $doLines ) = @_;
> 	local $_ = $text;
> 	
> 	if ( $doLines < 2 ) {    # 2 = do line-oriented only
> 		
> 		while ( m!\#INCLUDE\s*((\w+\.?\w*|/)+)!gi and $AllowInclusion ) {		
> 			my $FileName = $1;
> 			
> 			open FILE, "$InclusionDir/$FileName"
> 			or &ReportError(T("Cannot open $FileName: $!"));
> 			
> 			local $/;			
> 			my $FileContent = <FILE>;
> 			
> 			close FILE
> 			or &ReportError(T("Cannot close $FileName: $!"));
> 			s!\#INCLUDE\s*$FileName!$FileContent!i unless $FileName !~ /(html?|txt)$/i;
> 		}
>   
> 		# The <nowiki> tag stores text with no markup (except quoting HTML)
> 		s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 
> 		# The <pre> tag wraps the stored text with the HTML <pre> tag
> 		s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		
> 		if ( $EarlyRules ne "" ) {
> 			$_ = &EvalLocalRules( $EarlyRules, $_, !$useImage );
> 		}
> 		
> 		s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
> 		
> 		if ($HtmlTags) {
> 			my ($t);
> 			foreach $t (@HtmlPairs) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
> 			}
> 			foreach $t (@HtmlSingle) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
> 			}
> 		}
> 		else {
> 
> 			# Note that these tags are restricted to a single line
> 			s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
> 			s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
> 			s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
> 			s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
> 		}
> 
> 		# Auto signature if use ~~~~ ; useful for quick comments
> 	    my $id = &GetParam("username", "");
> 		my $idLink = "$HomePagePrefix/$id";
> 		my $timestamp = &TimeToText($Now);
> 		my $finalText = "";
> 		
> 		$id =~ s/ /_/g;
> 
> 		if ($id){
> 			$finalText = &StorePageOrEditLink($idLink, $id);
> 			s/\~\~\~\~/<i>\[$finalText]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$finalText at $timestamp]<\/i>/gi;
> 		}
> 		else {
> 			$id = "Guest";			
> 			s/\~\~\~\~/<i>\[$id at $timestamp]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$id at $timestamp]<\/i>/gi;
> 		}
> 		
> 		s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;    # <tt> (MeatBall)
> 		s/\&lt;br\&gt;/<br>/gi;    # Allow simple line break anywhere
> 		
> 		if ($HtmlLinks) {
> 			s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
> 		}
> 		
> 		if ($FreeLinks) {
> 
> 			# Consider: should local free-link descriptions be conditional?
> 			# Also, consider that one could write [[Bad Page|Good Page]]?
> 			s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
> 			s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
> 		}
> 		
> 		if ($BracketText) {        
> 			# Links like [URL text of link]
> 			s/\[$UrlPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketUrl($1, $2, $useImage, $3)/geos;
> 			s/\[$InterLinkPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketInterPage($1, $2, $useImage, $3)/geos;
> 			
> 			if ( $WikiLinks && $BracketWiki ) {    # Local bracket-links
> 				s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
> 				s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1, $2, $3)/geos if $NamedAnchors;
> 			}
> 		}
> 		
> 		s/\[$UrlPattern(\|(.*))?\]/&StoreBracketUrl($1, "", 0, "")/geo;
> 		s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0, "")/geo;
> 		s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
> 		s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
> 		
> 		if ($WikiLinks) {
> 			s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1, $2, ""))/geo if $NamedAnchors;
> 
> 			# CAA: Putting \b in front of $LinkPattern breaks /SubPage links
> 			#      (subpage links without the main page)
> 			s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
> 		}
> 		s/\b$RFCPattern/&StoreRFC($1)/geo;
> 		s/\b$ISBNPattern/&StoreISBN($1)/geo;
> 		
> 		if ($UseUpload) {
> 			s/$UploadPattern/&StoreUpload($1)/geo;
> 		}
> 		
> 		if ($ThinLine) {
> 			if ($OldThinLine) {   
> 				# Backwards compatible, conflicts with headers
> 				s/====+/$WikiLine2/g;
> 			}
> 			else {                
> 				# New behavior--no conflict
> 				s/------+/$WikiLine2/g;
> 			}
> 			s/----+/$WikiLine1/g;
> 		}
> 		else {
> 			s/----+/$WikiLine/g;
> 		}
> 		
> 		if ($AutoMailto) {
> 			s/([A-z0-9-_]+(?:\.[A-z0-9-_]+)*)\@([A-z0-9-_]+(?:\.[A-z0-9-_]+)*(?:\.[A-z]{2,})+)/<a href="mailto:$1\@$2">$1\@$2<\/a>/g;
> 		}
> 	}
> 	
> 	if ($doLines) {    
> 			# 0 = no line-oriented, 1 or 2 = do line-oriented
> 		    # The quote markup patterns avoid overlapping tags (with 5 quotes)
> 		    # by matching the inner quotes for the strong pattern.
> 		s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g; #'REMARK
> 		s/''(.*?)''/<em>$1<\/em>/g;
> 		
> 		if ($UseHeadings) {
> 		 ## s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
> 			s/(^|\n)\s*(\=+)\s*(#)?\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $4, $3)/geo;
> 		}
> 		
> 		if ($TableMode == 1) {
> 			my @cells = split(/\|\|/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\|\|)+([^\|<]+)/) {	
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\|\|)+)/"<\/td><td $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;
> 			} 
> 			s/(\|\w*=\w*)+([^\|<]+)//g;   
> 		}
> 		elsif  ($TableMode == 2) {
> 			my @cells = split(/\!\!/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\!\!)+([^\!<]+)/) {			
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\!\!)+)/"<\/th><th $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;				
> 			}
> 			s/(\|\w*=\w*)+([^\!<]+)//g;
> 		}
> 	}
> 	
> 	return $_;
> }
> 
> sub GetTableCellModifiers {
> 	my ($given, $initialCell, $cellIndex) = @_;	
> 	my ($options) = $given;
> 
> 	/^(\s*(\w+)\s*)\|/;
> 	my $align = $2;
> 	if ($initialCell ne ""){ $align = $initialCell; }
> 		
> 	$align = $align =~ /^  / ? ($align =~ /  $/ ? 'center' : 'right') : 'left';
> 	$align = "align='$align'";
> 	
> 	my ($options) = $options =~ /(\|\S*=\S*)+/g;
> 	my %options = &GetOptions($options);
> 
> 	my $class;
> 	my $style;
> 	my $width;	
> 	my $rowclass;
> 	my $rowstyle;
> 	my $rowalign;
> 	my $tablewidth;
> 	my $tableclass;
> 	my $tablestyle;
> 		
> 	if ($TableCellDefaults{"rowclass"} =~ /clear/){ $TableCellDefaults{"rowclass"} = ""; }
> 	if ($TableCellDefaults{"rowstyle"} =~ /clear/){ $TableCellDefaults{"rowstyle"} = ""; }
> 	if ($TableCellDefaults{"rowalign"} =~ /clear/){ $TableCellDefaults{"rowalign"} = ""; }
> 				
> 	if ($TableCellDefaults{"rowclass"}){ $rowclass = $TableCellDefaults{"rowclass"}; }
> 	if ($TableCellDefaults{"rowstyle"}){ $rowstyle = $TableCellDefaults{"rowstyle"}; }
> 	if ($TableCellDefaults{"rowalign"}){ $rowalign = $TableCellDefaults{"rowalign"}; }
> 		
> 	if ($options{'rowclass'}){ $rowclass = "class='" . $options{'rowclass'} . "'"; $TableCellDefaults{"rowclass"} = $rowclass; }
> 	if ($options{'rowstyle'}){ $rowstyle = "style='" . $options{'rowstyle'} . "'"; $TableCellDefaults{"rowstyle"} = $rowstyle; }
> 	if ($options{'rowalign'}){ $rowalign = "align='" . $options{'rowalign'} . "'"; $TableCellDefaults{"rowalign"} = $rowalign; }
> 	
> 	if ($rowclass){ $class = $rowclass; }
> 	if ($rowstyle){ $style = $rowstyle; }
> 	if ($rowalign){ $align = $rowalign; }
> 
> 	if ($TableCellDefaults{"class$cellIndex"} =~ /clear/){ $TableCellDefaults{"class$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"style$cellIndex"} =~ /clear/){ $TableCellDefaults{"style$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"align$cellIndex"} =~ /clear/){ $TableCellDefaults{"align$cellIndex"} = ""; }
> 			
> 	if ($TableCellDefaults{"class$cellIndex"}){ $class = $TableCellDefaults{"class$cellIndex"}; }
> 	if ($TableCellDefaults{"style$cellIndex"}){ $style = $TableCellDefaults{"style$cellIndex"}; }
> 	if ($TableCellDefaults{"align$cellIndex"}){ $align = $TableCellDefaults{"align$cellIndex"}; }
> 
> 	if ($options{'class'}){ $class = "class='" . $options{'class'} . "'"; $TableCellDefaults{"class$cellIndex"} = $class; }
> 	if ($options{'style'}){ $style = "style='" . $options{'style'} . "'"; $TableCellDefaults{"style$cellIndex"} = $style; }
> 	if ($options{'align'}){ $align = "align='" . $options{'align'} . "'"; $TableCellDefaults{"align$cellIndex"} = $align; }
> 	if ($options{'width'}){ $width = "width='" . $options{'width'} . "'"; }
> 	if ($options{'tablewidth'}){ $tablewidth = "width='" . $options{'tablewidth'} . "'"; }
> 	if ($options{'tablestyle'}){ $tablestyle = "style='" . $options{'tablestyle'} . "'"; }
> 	if ($options{'tableclass'}){ $tableclass = "class='" . $options{'tableclass'} . "'"; } else { $tableclass = "class='wikilargelist'"; }
> 					
> 	return ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass);				
> }
> 
> sub WikiLinesToHtml {
> 	my ($pageText) = @_;
> 	my ( $pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode );
> 	
> 	@htmlStack = ();
> 	$depth     = 0;
> 	$pageHtml  = "";
> 	
> 	foreach ( split( /\r?\n/, $pageText ) ) {    # Process lines one-at-a-time
> 		$code           = "";
> 		$codeAttributes = "";
> 		$TableMode      = 0;
> 		$_ .= "\n";
> 		
> 		if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\:+)/<dt><dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\*+)/<li>/) {
> 			$code  = "ul";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\#+)/<li>/) {
> 			$code  = "ol";
> 			$depth = length $1;
> 		}
> 		elsif ($TableSyntax && /^(\!\!)+.*\!\!\s*$/) {
> 			/^(\!\!)+([^\!]+)/;
> 			
> 			%TableCellDefaults = {};
> 			
> 			my $switches = $2;
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, "", 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/th><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 2;
> 			$depth = 1;
> 		}
> 		elsif ($TableSyntax && /^(\|\|)+.*\|\|\s*$/) {
> 			/^((\|\|)+)(.*?)\|\|/;	
> 	
> 			my ($alignInitial) = $3;
> 			my $switches = $3;
> 			($alignInitial) = $alignInitial =~ /(.*)\|/;	
> 
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, $alignInitial, 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/td><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 1;
> 			$depth = 1;
> 		}
> 		elsif (/^[ \t].*\S/) {
> 			$code  = "pre";
> 			$depth = 1;
> 		}
> 		else {
> 			$depth = 0;
> 		}
> 		
> 		while ( @htmlStack > $depth ) {    
> 			# Close tags as needed
> 			$pageHtml .= "</" . pop(@htmlStack) . ">";
> 		}
> 		
> 		if ( $depth > 0 ) {
> 			$depth = $IndentLimit if ( $depth > $IndentLimit );
> 			if (@htmlStack) {              
> 				# Non-empty stack
> 				$oldCode = pop(@htmlStack);
> 				
> 				if ( $oldCode ne $code ) {
> 					$pageHtml .= "</$oldCode><$code>";
> 				}
> 				push( @htmlStack, $code );
> 			}
> 			
> 			while ( @htmlStack < $depth ) {
> 				push( @htmlStack, $code );
> 				$pageHtml .= "\n<$code $codeAttributes>";
> 			}
> 		}
> 		
> 		if ( !$ParseParas ) {
> 			s/^\s*$/<p>\n/;    # Blank lines become <p> tags
> 		}
> 		$pageHtml .= &CommonMarkup( $_, 1, 2 );    # Line-oriented common markup
> 	}
> 	
> 	while ( @htmlStack > 0 ) {                     
> 		# Clear stack
> 		$pageHtml .= "</" . pop(@htmlStack) . ">";
> 	}
> 	
> 	return $pageHtml;
> }
> 
> sub EvalLocalRules {
> 	my ( $rules, $origText, $isDiff ) = @_;
> 	my ( $text, $reportError, $errorText );
> 	
> 	$text        = $origText;
> 	$reportError = 1;
> 
> 	# Basic idea: the $rules should change $text, possibly with different
> 	# behavior if $isDiff is true (no images or color changes?)
> 	# Note: for fun, the $rules could also change $reportError and $origText
> 	if ( !eval $rules ) {
> 		$errorText = $@;
> 		
> 		if ( $errorText eq "" ) {
> 
> 		  # Search for "Unknown Error" for the reason the next line is commented
> 		  #     $errorText = "Unknown Error (no error text)";
> 		}
> 		if ( $errorText ne "" ) {
> 			$text = $origText;    # Consider: should partial results be kept?
> 			
> 			if ($reportError) {
> 				$text .= "\n<hr>";
> 				$text .= "<b>";
> 				$text .= "Local rule error:";
> 				$text .= "</b><br>";
> 				$text .= &QuoteHtml($errorText);
> 			}
> 		}
> 	}
> 	
> 	return $text;
> }
> 
> sub QuoteHtml {
> 	my ($html) = @_;
> 	
> 	$html =~ s/&/&amp;/g;
> 	$html =~ s/</&lt;/g;
> 	$html =~ s/>/&gt;/g;
> 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
> 	
> 	return $html;
> }
> 
> sub ParseParagraph {
> 	my ($text) = @_;
> 	
> 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
> 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
> 	
> 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
> 	return "\n<p>$text</p>";
> }
> 
> sub StoreInterPage {
> 	my ( $id, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &InterPageLink( $id, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
> }
> 
> sub InterPageLink {
> 	my ( $id, $useImage ) = @_;
> 	my ( $name, $site, $remotePage, $url, $punct );
> 	
> 	( $id, $punct ) = &SplitUrlPunct($id);
> 	$name = $id;
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$url = &GetSiteUrl($site);
> 	
> 	return ( "", $id . $punct ) if ( $url eq "" );
> 	
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url .= $remotePage;
> 	
> 	return ( &UrlLinkOrImage( $url, $name, $useImage ), $punct );
> }
> 
> sub StoreBracketInterPage {
> 	my ( $id, $text, $useImage, $options ) = @_;
> 	my ( $site, $remotePage, $url, $index );
> 	
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url = &GetSiteUrl($site);
> 	
> 	if ( $text ne "" ) {
> 		return "[$id $text]" if ( $url eq "" );
> 	}
> 	else {
> 		return "[$id]" if ( $url eq "" );
> 		$text = &GetBracketUrlIndex($id);
> 	}
> 	
> 	$url .= $remotePage;
> 	
> 	$text = StoreBracketUrl( $url, $text, $useImage, $options);
> 	
> 	return $text;
> }
> 
> sub GetBracketUrlIndex {
> 	my ($id) = @_;
> 	my ( $index, $key );
> 
> 	# Consider plain array?
> 	if ( $SaveNumUrl{$id} > 0 ) {
> 		return $SaveNumUrl{$id};
> 	}
> 	
> 	$SaveNumUrlIndex++;    # Start with 1
> 	$SaveNumUrl{$id} = $SaveNumUrlIndex;
> 	
> 	return $SaveNumUrlIndex;
> }
> 
> sub GetSiteUrl {
> 	my ($site) = @_;
> 	my ( $data, $status );
> 	
> 	if ( !$InterSiteInit ) {
> 		( $status, $data ) = &ReadFile($InterFile);
> 		
> 		if ($status) {
> 			%InterSite = split( /\s+/, $data );    # Consider defensive code
> 		}
> 
> 		# Check for definitions to allow file to override automatic settings
> 		if ( !defined( $InterSite{'LocalWiki'} ) ) {
> 			$InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		if ( !defined( $InterSite{'Local'} ) ) {
> 			$InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		$InterSiteInit = 1;                        # Init only once per request
> 	}
> 	
> 	return $InterSite{$site} if ( defined( $InterSite{$site} ) );
> 	return "";
> }
> 
> sub StoreRaw {
> 	my ($html) = @_;
> 	
> 	$SaveUrl{$SaveUrlIndex} = $html;
> 	
> 	return $FS . $SaveUrlIndex++ . $FS;
> }
> 
> sub StorePre {
> 	my ( $html, $tag ) = @_;
> 	
> 	return &StoreRaw( "<$tag>" . $html . "</$tag>" );
> }
> 
> sub ReadWikiFile {
> 	my ($fileName) = @_;
> 	my ($fileData, %tempPage, %tempSection, %tempText);
> 	
> 	return unless -f $fileName;
> 	
> 	$fileData = &ReadFileOrDie($fileName);
> 	%tempPage = split(/$FS1/, $fileData, -1);
> 	%tempSection = split(/$FS2/, $tempPage{'text_default'}, -1);
> 	%tempText = split(/$FS3/, $tempSection{'data'}, -1);
> 	
> 	return $tempText{'text'};
> }
> 
> sub WikiFileToHTML {
> 	my ($text) = @_;
> 	my ($output);
> 	my ($mySaveUrlIndex, $mySaveNumUrlIndex, $myTableMode, %mySaveUrl, %mySaveNumUrl);
> 	
> 	return unless $text;
> 	
> 	# Global variables do not help this code. Nasty, but easiest solution.
> 	%mySaveUrl= %SaveUrl;
> 	%mySaveNumUrl= %SaveNumUrl;
> 	$mySaveUrlIndex= $SaveUrlIndex;
> 	$mySaveNumUrlIndex = $SaveNumUrlIndex;
> 	$myTableMode= $TableMode;
> 	
> 	$output = &WikiToHTML($text);
> 	
> 	%SaveUrl = %mySaveUrl;
> 	%SaveNumUrl = %mySaveNumUrl;
> 	$SaveUrlIndex = $mySaveUrlIndex;
> 	$SaveNumUrlIndex = $mySaveNumUrlIndex;
> 	$TableMode = $myTableMode;
> 	
> 	return $output;
> }
> 
> sub StoreTemplate {
> 	my ($params) = @_;
> 	my ($templateId, $templateFile, $templateText, $output, %substitutes);
> 	
> 	$params =~ s/^\s*(\S+)\s*/$templateId=$1,''/e;
> 	return &StoreRaw(T('No template name')) unless $templateId;
> 	
> 	$templateFile = &GetPageFile($templateId);
> 	return &StoreRaw(Ts('Template %s not found', $templateId)) unless -f $templateFile;
> 	
> 	while ($params =~ /^(\S+)\s*=(.*)$/gm) {
> 		$substitutes{$1} = $2;
> 	}
> 	
> 	$templateText = &ReadWikiFile($templateFile);
> 	$templateText =~ s/\$(\S+)\$/$substitutes{$1}/gi;
> 	$templateText =~ s/{{//g; # Avoid nesting.
> 	$output = &WikiFileToHTML($templateText);
> 	
> 	return &StoreRaw($output);
> }
> 
> sub StoreHref {
> 	my ( $anchor, $text ) = @_;
> 	
> 	return "<a" . &StoreRaw($anchor) . ">$text</a>";
> }
> 
> sub StoreUrl {
> 	my ( $name, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &UrlLink( $name, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
> }
> 
> sub UrlLink {
> 	my ( $rawname, $useImage ) = @_;
> 	my ( $name, $punct );
> 	
> 	( $name, $punct ) = &SplitUrlPunct($rawname);
> 	
> 	if ( $LimitFileUrl && ( $NetworkFile && $name =~ m|^file:| ) ) {
> 
> 		# Only do remote file:// links. No file:///c|/windows.
> 		if ( $name =~ m|^file://[^/]| ) {
> 			return ( "<a href='$name' class='wikiurllink'>$name</a>", $punct );
> 		}
> 		
> 		return ( $rawname, "" );
> 	}
> 	
> 	return ( &UrlLinkOrImage( $name, $name, $useImage ), $punct );
> }
> 
> sub UrlLinkOrImage {
> 	my ( $url, $name, $useImage ) = @_;
> 	
> 	# Restricted image URLs so that mailto:foo@bar.gif is not an image
> 	if ( $useImage && &ImageAllowed($url) ) {
> 		return "<a href='$url' class='wikiurlorimage' target='_blank'><img class='wikiurlorimage' src='$url'></a>";
> 	}
> 	
> 	return "<a href='$url' class='wikiurlorimage'>$name</a>";
> }
> 
> sub ImageAllowed {
> 	my ($url) = @_;
> 	my ( $site, $imagePrefixes );
> 	
> 	$imagePrefixes = 'http:|https:|ftp:|upload:';
> 	$imagePrefixes .= '|file:' if ( !$LimitFileUrl );
> 	
> 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
> 	return 0 if ( $url =~ /"/ );    #" No HTML-breaking quotes allowed
> 	return 1 if ( @ImageSites < 1 );    # Most common case: () means all allowed
> 	return 0 if ( $ImageSites[0] eq 'none' );    # Special case: none allowed
> 
> 	foreach $site (@ImageSites) {
> 		return 1
> 		  if ( $site eq substr( $url, 0, length($site) ) );    # Match prefix
> 	}
> 	
> 	return 0;
> }
> 
> sub ExtensionAllowed {
> 	my ($file) = @_;
> 	
> 	return 1 if ( $file =~ m/\.(jpg|bmp|pdf|gif|psd|ai|xls|ppt|js|css|doc|txt)$/ );
> 	
> 	return 0;	
> }
> 
> sub GetUploadUrl {
> 	my ($url) = @_;
> 	
> 	&StoreRaw($url);
> }
> 
> sub GetOptions {
> 	my ($text) = @_;
> 	my %options;
> 	
> 	foreach my $pair (split(/\|/, $text)){
> 		my @keyvalues = split (/=/, $pair);
> 		$options{$keyvalues[0]} = $keyvalues[1];
> 	}
> 	
> 	return %options;	
> }
> 
> sub ComputeImageRatio {
> 	my ($imageName, $desiredWidth, $desiredHeight, $okayLarger) = @_;
> 	my $filepath = "$UploadDir/$imageName";
> 	my ($imageWidth, $imageHeight) = Image::Size::imgsize($filepath);
> 	
> 	my $ratioWidth = 1;
> 	my $ratioHeight = 1;
> 	my $ratioFinal = 1;
> 	
> 	if ($desiredWidth){ $ratioWidth = $desiredWidth/$imageWidth; }
> 	if ($desiredHeight){ $ratioHeight = $desiredHeight/$imageHeight; }
> 	
> 	if ($okayLarger){
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioWidth; }
> 		else { $ratioFinal = $ratioHeight; }
> 	}
> 	else {
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioHeight; }
> 		else { $ratioFinal = $ratioWidth; }
> 	
> 	}
> 	
> 	my $finalWidth = int($ratioFinal * $imageWidth);
> 	my $finalHeight = int($ratioFinal * $imageHeight);
> 	
> 	return ($finalWidth, $finalHeight);
> }
> 
> sub StoreBracketUrl {
> 	my ( $url, $text, $useImage, $options ) = @_;
> 	my %options = &GetOptions($options);
> 	my $imageFloat;
> 	my $imageClear = "\n<br class='clear$options{clear}'/>";
> 	my $boxFloat = " float" . $options{'boxfloat'};
> 	my $boxClear = "\n<br class='clear$options{boxclear}'/>";
> 	my $width;
> 	my $height;
> 	my $title;
> 	my $caption;
> 	my $description;
> 	my $imageLink;
> 	my $boxWidth = "style='width: 300px !important;'";
> 
> 	if ( $text eq "" ) { $text = &GetBracketUrlIndex($url); }
> 
> 	if ($options{'float'}){ $imageFloat = "float" . $options{'float'}; }
> 	if ($options{'clear'}){ $imageClear = "\n<br class='clear$options{clear}'/>"; }
> 	if ($options{'title'}){ $title = $options{title}; } else { $title = $text; }
> 	if ($options{'width'}){ $width = $options{'width'}; }
> 	if ($options{'height'}){ $height = $options{'height'}; }
> 			
> 	if ($options{'boxfloat'}){ $boxFloat = "float" . $options{'boxfloat'}; }
> 	if ($options{'boxclear'}){ $boxClear = "\n<br class='clear$options{boxclear}'/>"; }
> 	if ($options{'boxwidth'}){ $boxWidth = "style='width: $options{boxwidth} !important;'"; }
> 	if ($options{'caption'}){ 
> 		if ($options{'description'}){ $description = $options{description}; } 
> 		else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 		
> 		$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div><div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 	}
> 	
> 	if ($url =~ /$UploadPattern/){ $url = "$UploadUrl/$1"; }	
> 	if ( $BracketImg && $useImage && &ImageAllowed($text) ) {		
> 		if ($text =~ /$UploadPattern/){
> 			my $imageName = $1;
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($imageName, $width, $height, "");
> 			my $imageStyle = "style='width: $imageWidth; height: $imageHeight;'";
> 			
> 			$imageLink = "$UploadUrl/" . &GetUploadUrl($1);			
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' $imageStyle src='$imageLink'></a>";
> 		}
> 		else {
> 			$imageLink = $text;
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' src='$imageLink'></a>";
> 		}
> 		my $expandlink =  "<a target='_blank' class='wikiexpandimageicon' href='$imageLink' title='View source image'>&nbsp;</a>";
> 		
> 		if ($options{'caption'}){ 
> 			if ($options{'description'}){ $description = $options{description}; } 
> 			else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 			
> 			$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div>$expandlink<div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 		}
> 			
> 		if ($imageClear){ $text .= $imageClear; }		
> 					
> 		if ($caption){
> 			$text = "\n<div title='$title' class='wikibracketbox $boxFloat' $boxWidth>$text$caption</div>";		
> 		}
> 		else {
> 			$text = "\n<div title='$title' class='$boxFloat'>$text</div>";	
> 		}
> 		
> 		if ($boxClear){ $text .= $boxClear; }
> 	}
> 	else {
> 		$text = "<a href='$url' title='$title' class='wikibracketurl'>[$text]</a>";
> 	}
> 	
> 	return &StoreRaw($text);
> }
> 
> sub StoreBracketLink {
> 	my ( $name, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( $name, "[$text]" ) );
> }
> 
> sub StoreBracketAnchoredLink {
> 	my ( $name, $anchor, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( "$name#$anchor", "[$text]" ) );
> }
> 
> sub StorePageOrEditLink {
> 	my ( $page, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$page =~ s/^\s+//;        # Trim extra spaces
> 		$page =~ s/\s+$//;
> 		$page =~ s|\s*/\s*|/|;    # ...also before/after subpages
> 	}
> 	$name =~ s/^\s+//;
> 	$name =~ s/\s+$//;
> 	
> 	return &StoreRaw( &GetPageOrEditLink( $page, $name ) );
> }
> 
> sub StoreRFC {
> 	my ($num) = @_;
> 	return &StoreRaw( &RFCLink($num) );
> }
> 
> sub RFCLink {
> 	my ($num) = @_;
> 	return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\" class='wikirfclink'>RFC $num</a>";
> }
> 
> sub StoreUpload {
> 	my ($url) = @_;
> 	return &StoreRaw( &UploadLink($url) );
> }
> 
> sub UploadLink {
> 	my ($filename) = @_;
> 	my ( $html, $url );
> 	
> 	return $filename if ( $UploadUrl eq "" );    # No bad links if misconfigured
> 	
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$url  = $UploadUrl . $filename;
> 	$html = "<a href='$url' class='wikiuploadlink' target='_blank'>";
> 	
> 	if ( &ImageAllowed($url) ) {
> 		$html .= "<img class='wikiuploadlink' src='$url' alt='upload:$filename'>";
> 	}
> 	else {
> 		$html .= "upload:$filename";
> 	}
> 	$html .= "</a>";
> 	
> 	return $html;
> }
> 
> sub StoreISBN {
> 	my ($num) = @_;
> 	
> 	return &StoreRaw( &ISBNLink($num) );
> }
> 
> sub ISBNALink {
> 	my ( $num, $pre, $post, $text ) = @_;
> 	
> 	return "<a href='$pre$num$post' class='wikiisbnalink'>$text</a>";
> }
> 
> sub ISBNLink {
> 	my ($rawnum) = @_;
> 	my ( $rawprint, $html, $num, $numSites, $i );
> 	
> 	$num      = $rawnum;
> 	$rawprint = $rawnum;
> 	$rawprint =~ s/ +$//;
> 	$num      =~ s/[- ]//g;
> 	$numSites = scalar @IsbnNames;    # Number of entries
> 	
> 	if ( ( length($num) != 10 ) || ( $numSites < 1 ) ) {
> 		return "ISBN $rawnum";
> 	}
> 	
> 	$html = &ISBNALink( $num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint );
> 	
> 	if ( $numSites > 1 ) {
> 		$html .= " (";
> 		$i = 1;
> 		while ( $i < $numSites ) {
> 			$html .=
> 			  &ISBNALink( $num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i] );
> 			if ( $i < ( $numSites - 1 ) ) {    # Not the last site
> 				$html .= ", ";
> 			}
> 			$i++;
> 		}
> 		$html .= ")";
> 	}
> 	
> 	$html .= " " if ( $rawnum =~ / $/ );    # Add space if old ISBN had space.
> 	
> 	return $html;
> }
> 
> sub SplitUrlPunct {
> 	my ($url) = @_;
> 	my ($punct);
> 	
> 	if ( $url =~ s/\"\"$// ) {  #"REMARK
> 		return ( $url, "" );    # Delete double-quote delimiters here
> 	}
> 	
> 	$punct = "";
> 	if ($NewFS) {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	else {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	
> 	return ( $url, $punct );
> }
> 
> sub StripUrlPunct {
> 	my ($url) = @_;
> 	my ($junk);
> 	
> 	( $url, $junk ) = &SplitUrlPunct($url);
> 	
> 	return $url;
> }
> 
> sub WikiHeadingNumber {
> 	my ( $depth, $text, $useNumber) = @_;
> 	#my ( $depth, $text ) = @_;
> 	my ( $anchor, $number );
> 	
> 	return "" unless --$depth > 0;    # Don't number H1s because it looks stupid
> 		
> 	while ( scalar @HeadingNumbers < ( $depth - 1 ) ) {
> 		push @HeadingNumbers, 1;
> 		$TableOfContents .= "<dl><dt></dt><dd>";
> 	}
> 	
> 	if ( scalar @HeadingNumbers < $depth ) {
> 		push @HeadingNumbers, 0;
> 		$TableOfContents .= "<dl><dt></dt><dd>";
> 	}
> 	
> 	while ( scalar @HeadingNumbers > $depth ) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$HeadingNumbers[$#HeadingNumbers]++;
> 	$number = ( join '.', @HeadingNumbers ) . '. ';
> 
> 	# Remove embedded links. THIS IS FRAGILE!
> 	$text = &RestoreSavedText($text);
> 	$text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si;        # No such page syntax
> 	$text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
> 
> 	# Cook anchor by canonicalizing $text.
> 	$anchor = $text;
> 	$anchor =~ s/\<.*?\>//g;
> 	$anchor =~ s/\W/_/g;
> 	$anchor =~ s/__+/_/g;
> 	$anchor =~ s/^_//;
> 	$anchor =~ s/_$//;
> 
> 	# Last ditch effort
> 	$anchor = "_" . ( join '_', @HeadingNumbers ) unless $anchor;
> 	$TableOfContents .= ('&nbsp;' x (2 * $depth)) . $number;
> 	$TableOfContents .= &ScriptLink( "$OpenPageName#$anchor", $text );
> 	$TableOfContents .= "</dd><dt>";
> 	$TableOfContents .= "</dt><dd>";
> 	  
> 	## return &StoreHref(" name='$anchor'") . $number;
> 	if ($useNumber) {
> 		return &StoreHref(" name='$anchor'") . $number;
> 	} else {
> 		return &StoreHref(" name='$anchor'");
> 	}
> }
> 
> sub WikiHeading {
> 	## my ( $pre, $depth, $text ) = @_;
> 	my ($pre, $depth, $text, $useNumber) = @_;
> 	$depth = length($depth);
> 	$depth = 6 if ( $depth > 6 );
> 	##$text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e;    # $' == $POSTMATCH
> 	if ($useNumber) {
> 		$text = &WikiHeadingNumber($depth,$text, 1) . $text;
> 	} else {
> 		$text = &WikiHeadingNumber($depth,$text, 0) . $text;
> 	}	
> 	return $pre . "<H$depth>$text</H$depth>";
> }
> 
> # ==== Difference markup and HTML ====
> sub GetDiffHTML {
> 	my ( $diffType, $id, $revOld, $revNew, $newText ) = @_;
> 	my ( $html, $diffText, $diffTextTwo, $priorName, $links, $usecomma );
> 	my ( $major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName );
> 	
> 	$links     = " (";
> 	$usecomma  = 0;
> 	$major     = &ScriptLinkDiff( 1, $id, "major diff", "" );
> 	$minor     = &ScriptLinkDiff( 2, $id, "minor diff", "" );
> 	$author    = &ScriptLinkDiff( 3, $id, "author diff", "" );
> 	$useMajor  = 1;
> 	$useMinor  = 1;
> 	$useAuthor = 1;
> 	$diffType  = &GetParam( "defaultdiff", 1 ) if ( $diffType == 4 );
> 	
> 	if ( $diffType == 1 ) {
> 		$priorName = "major";
> 		$cacheName = "major";
> 		$useMajor  = 0;
> 	}
> 	elsif ( $diffType == 2 ) {
> 		$priorName = "minor";
> 		$cacheName = "minor";
> 		$useMinor  = 0;
> 	}
> 	elsif ( $diffType == 3 ) {
> 		$priorName = "author";
> 		$cacheName = "author";
> 		$useAuthor = 0;
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 
> 		# Note: OpenKeptRevisions must have been done by caller.
> 		# Eventually optimize if same as cached revision
> 		$diffText = &GetKeptDiff( $newText, $revOld, 1 );    # 1 = get lock
> 		if ( $diffText eq "" ) {
> 			$diffText = "(The revisions are identical or unavailable.)";
> 		}
> 	}
> 	else {
> 		$diffText = &GetCacheDiff($cacheName);
> 	}
> 	
> 	$useMajor = 0 if ( $useMajor && ( $diffText eq &GetCacheDiff("major") ) );
> 	$useMinor = 0 if ( $useMinor && ( $diffText eq &GetCacheDiff("minor") ) );
> 	$useAuthor = 0 if ( $useAuthor && ( $diffText eq &GetCacheDiff("author") ) );
> 	$useMajor = 0 if ( ( !defined( &GetPageCache('oldmajor') ) ) || ( &GetPageCache("oldmajor") < 1 ) );
> 	$useAuthor = 0 if ( ( !defined( &GetPageCache('oldauthor') ) ) || ( &GetPageCache("oldauthor") < 1 ) );
> 	
> 	if ($useMajor) {
> 		$links .= $major;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useMinor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $minor;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useAuthor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $author;
> 	}
> 	
> 	if ( !( $useMajor || $useMinor || $useAuthor ) ) {
> 		$links .= "no other diffs";
> 	}
> 	$links .= ")";
> 	
> 	if ( ( !defined($diffText) ) || ( $diffText eq "" ) ) {
> 		$diffText = "No diff available.";
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 		my $currentRevision = "current revision";
> 		
> 		$currentRevision = "revision $revNew " if $revNew;
> 		$html .= "<h4>Difference (from revision $revOld to $currentRevision)</h4>";
> 		$html .= "$links<br><br>";
> 		$html .= &DiffToHTML($diffText);
> 	}
> 	else {
> 		if (
> 			( $diffType != 2 )
> 			&& (   ( !defined( &GetPageCache("old$cacheName") ) )
> 				|| ( &GetPageCache("old$cacheName") < 1 ) )
> 		  )
> 		{
> 			$html .= "<h4>No diff available -- this is the first $priorName revision.</h4>";
> 			$html .= "$links<br><br>";
> 		}
> 		else {
> 			$html .= "<h4>Difference from prior $priorName revision</h4>";
> 			$html .= "$links<br><br>";
> 			$html .= &DiffToHTML($diffText);
> 		}
> 	}
> 	@HeadingNumbers  = ();
> 	$TableOfContents = "";
> 		
> 	return $html;
> }
> 
> sub GetCacheDiff {
> 	my ($type) = @_;
> 	my ($diffText);
> 	$diffText = &GetPageCache("diff_default_$type");
> 	$diffText = &GetCacheDiff('minor') if ( $diffText eq "1" );
> 	$diffText = &GetCacheDiff('major') if ( $diffText eq "2" );
> 	return $diffText;
> }
> 
> # Must be done after minor diff is set and OpenKeptRevisions called
> sub GetKeptDiff {
> 	my ( $newText, $oldRevision, $lock ) = @_;
> 	my ( %sect, %data, $oldText );
> 	$oldText = "";
> 	if ( defined( $KeptRevisions{$oldRevision} ) ) {
> 		%sect = split( /$FS2/, $KeptRevisions{$oldRevision}, -1 );
> 		%data = split( /$FS3/, $sect{'data'}, -1 );
> 		$oldText = $data{'text'};
> 	}
> 	return "" if ( $oldText eq "" );    # Old revision not found
> 	return &GetDiff( $oldText, $newText, $lock );
> }
> 
> sub GetDiff {
>   my $textOld = shift;
>   my $textNew = shift;
> 
>   my %format = (
>     paraIdent     => '<tr valign=top><td class="diff-para-ident">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident">%text%</td></tr>',
>     paraAdded     => '<tr valign=top><td class="diff-para-ident"></td><td class="diff-vertical"></td><td class="diff-para-added">%text%</td></tr>',
>     paraDeleted   => '<tr valign=top><td class="diff-para-deleted">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident"></td></tr>',
>     paraChanged   => '<tr valign=top><td class="diff-para-changed-old">%text%</td><td class="diff-vertical"></td><td class="diff-para-changed-new">%text%</td></tr>',
>     paraReplaced  => '<tr valign=top><td class="diff-para-deleted">%textDeleted%</td><td class="diff-vertical"></td><td class="diff-para-added">%textAdded%</td></tr>',
>   
>     changeContext => 1,
>     changeHeader  => '<tr valign=top><td class="diff-header">Paragraph %oldFrom%</td><td class="diff-vertical">&nbsp;</td><td class="diff-header">Paragraph %newFrom%</td></tr>',
>   
>     spanIdent     => '<span class="diff-span-ident">%text%</span>',
>     spanAdded     => '<span class="diff-span-added">%text%</span>',
>     spanDeleted   => '<span class="diff-span-deleted">%text%</span>',
> 
>     processText => sub {
> 
>       my $text = shift;
> 
>       $text =~ s[&]               [&amp;]g;
>       $text =~ s[<]               [&lt;]g;
>       $text =~ s[>]               [&gt;]g;
>       $text =~ s[\n]              [<br>\n]g;
>       $text =~ s[\r]              []g;
>       $text =~ s[([\t ]+)([\t ])] [('&nbsp;' x length($1)) . $2]ge;
>       $text =~ s[^[\t ]]          [&nbsp;];
> 
>       return $text;
>     }
>   );
> 
>   my $diff = Diff::diffText($textOld, $textNew, %format);
>   
>   if ($diff ne "") {
>     $diff =~ s[<td class="diff-para-changed-old">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-added">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>     
>     $diff =~ s[<td class="diff-para-changed-new">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-deleted">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>   
>     $diff = qq[<div id=wikidiffdiv><table id=wikidifftable>$diff</table></div>];
>   }
> 
>   return $diff;
> }
> 
> sub DiffToHTML { shift }
> 
> 
> 
> # ==== Database (Page, Section, Text, Kept, User) functions ====
> sub OpenNewPage {
> 	my ($id) = @_;
> 	%Page             = ();
> 	$Page{'version'}  = 3;       # Data format version
> 	$Page{'revision'} = 0;       # Number of edited times
> 	$Page{'tscreate'} = $Now;    # Set once at creation
> 	$Page{'ts'}       = $Now;    # Updated every edit
> 	$Page{'authorcreate'} = GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
> }
> 
> sub OpenNewSection {
> 	my ( $name, $data ) = @_;
> 	%Section             = ();
> 	$Section{'name'}     = $name;
> 	$Section{'version'}  = 1;                   # Data format version
> 	$Section{'revision'} = 0;                   # Number of edited times
> 	$Section{'tscreate'} = $Now;                # Set once at creation
> 	$Section{'ts'}       = $Now;                # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'host'} 	 = "";        # Updated only for real edits (can be slow)
> 	$Section{'id'}   	 = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} 		 = join( $FS2, %Section );    # Replace with save?
> 	$Page{'authorcreate'}= GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
> }
> 
> sub OpenNewText {
> 	my ($name) = @_;                          # Name of text (usually "default")
> 	%Text = ();
> 	
> 	if ( $NewText ne "" ) {
> 		$Text{'text'} = $NewText;
> 	}
> 	else {
> 		$Text{'text'} = "Describe the new page here.";
> 	}
> 	
> 	$Text{'text'} .= "\n" if ( substr( $Text{'text'}, -1, 1 ) ne "\n" );
> 	$Text{'minor'}     = 0;                   # Default as major edit
> 	$Text{'newauthor'} = 1;                   # Default as new author
> 	$Text{'summary'}   = "";
> 	
> 	&OpenNewSection( "text_$name", join( $FS3, %Text ) );
> }
> 
> sub GetPageFile {
> 	my ($id) = @_;
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
> }
> 
> sub OpenPage {
> 	my ($id) = @_;
> 	my ( $fname, $data );
> 	
> 	if (!CheckIsAuthUser($id)) { $id = "AuthError"; } #auth patch
> 	if ( $OpenPageName eq $id ) { return; }
> 	
> 	%Section = ();
> 	%Text    = ();
> 	$fname   = &GetPageFile($id);
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		%Page = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	}
> 	else {
> 		&OpenNewPage($id);
> 	}
> 	
> 	if ( $Page{'version'} != 3 ) {
> 		&UpdatePageVersion();
> 	}
> 	
> 	$OpenPageName = $id;
> }
> 
> sub OpenSection {
> 	my ($name) = @_;
> 	if ( !defined( $Page{$name} ) ) {
> 		&OpenNewSection( $name, "" );
> 	}
> 	else {
> 		%Section = split( /$FS2/, $Page{$name}, -1 );
> 	}
> }
> 
> sub OpenText {
> 	my ($name) = @_;
> 	if ( !defined( $Page{"text_$name"} ) ) {
> 		&OpenNewText($name);
> 	}
> 	else {
> 		&OpenSection("text_$name");
> 		%Text = split( /$FS3/, $Section{'data'}, -1 );
> 	}
> }
> 
> sub OpenDefaultText {
> 	&OpenText('default');
> }
> 
> # Called after OpenKeptRevisions
> sub OpenKeptRevision {
> 	my ($revision) = @_;
> 	%Section = split( /$FS2/, $KeptRevisions{$revision}, -1 );
> 	%Text = split( /$FS3/, $Section{'data'}, -1 );
> }
> 
> sub GetPageCache {
> 	my ($name) = @_;
> 	return $Page{"cache_$name"};
> }
> 
> # Always call SavePage within a lock.
> sub SavePage {
> 	my $file = &GetPageFile($OpenPageName);
> 	$Page{'revision'} += 1;    # Number of edited times
> 	$Page{'ts'} = $Now;        # Updated every edit
> 	&CreatePageDir( $PageDir, $OpenPageName );
> 	&WriteStringToFile( $file, join( $FS1, %Page ) );
> }
> 
> sub SaveSection {
> 	my ( $name, $data ) = @_;
> 	$Section{'revision'} += 1;    # Number of edited times
> 	$Section{'ts'}       = $Now;                          # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'id'}       = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} = join( $FS2, %Section );
> }
> 
> sub SaveText {
> 	my ($name) = @_;
> 	&SaveSection( "text_$name", join( $FS3, %Text ) );
> }
> 
> sub SaveDefaultText {
> 	&SaveText('default');
> }
> 
> sub SetPageCache {
> 	my ( $name, $data ) = @_;
> 	$Page{"cache_$name"} = $data;
> }
> 
> sub UpdatePageVersion {
> 	&ReportError( "Bad page version (or corrupt page)." );
> }
> 
> sub KeepFileName {
> 	return $KeepDir . "/"
> 	  . &GetPageDirectory($OpenPageName)
> 	  . "/$OpenPageName.kp";
> }
> 
> sub SaveKeepSection {
> 	my $file = &KeepFileName();
> 	my $data;
> 	return if ( $Section{'revision'} < 1 );    # Don't keep "empty" revision
> 	$Section{'keepts'} = $Now;
> 	$data = $FS1 . join( $FS2, %Section );
> 	&CreatePageDir( $KeepDir, $OpenPageName );
> 	&AppendStringToFileLimited( $file, $data, $KeepSize );
> }
> 
> sub ExpireKeepFile {
> 	my ( $fname, $data, @kplist, %tempSection, $expirets );
> 	my ( $anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev );
> 	my ( $oldMajor, $oldAuthor );
> 	$fname = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );    # Also empty
> 	
> 	shift(@kplist) if ( $kplist[0] eq "" );    # First can be empty
> 	return if ( length(@kplist) < 1 );         # Also empty
> 	
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;                                # Bad keep file
> 	}
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	return if ( $tempSection{'keepts'} >= $expirets );    # Nothing old enough
> 	
> 	$anyExpire = 0;
> 	$anyKeep   = 0;
> 	%keepFlag  = ();
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	foreach ( reverse @kplist ) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		$expire      = 0;
> 		
> 		if ( $sectName eq "text_default" ) {
> 			if (   ( $KeepMajor && ( $sectRev == $oldMajor ) )
> 				|| ( $KeepAuthor && ( $sectRev == $oldAuthor ) ) )
> 			{
> 				$expire = 0;
> 			}
> 			elsif ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		else {
> 			if ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		if ( !$expire ) {
> 			$keepFlag{ $sectRev . "," . $sectName } = 1;
> 			$anyKeep = 1;
> 		}
> 		else {
> 			$anyExpire = 1;
> 		}
> 	}
> 	if ( !$anyKeep ) {    # Empty, so remove file
> 		unlink($fname);
> 		return;
> 	}
> 	return if ( !$anyExpire );    # No sections expired
> 	
> 	open( OUT, ">$fname" ) or die( Ts( 'cant write %s', $fname ) . ": $!" );
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		
> 		if ( $keepFlag{ $sectRev . "," . $sectName } ) {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
> }
> 
> sub OpenKeptList {
> 	my ( $fname, $data );
> 	@KeptList = ();
> 	$fname    = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@KeptList = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> }
> 
> sub OpenKeptRevisions {
> 	my ($name) = @_;    # Name of section
> 	my ( $fname, $data, %tempSection );
> 	
> 	%KeptRevisions = ();
> 	&OpenKeptList();
> 	
> 	foreach (@KeptList) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		next if ( $tempSection{'name'} ne $name );
> 		$KeptRevisions{ $tempSection{'revision'} } = $_;
> 	}
> }
> 
> sub LoadUserData {
> 	my ( $data, $status );
> 	%UserData = ();
> 	( $status, $data ) = &ReadFile( &UserDataFilename($UserID) );
> 	
> 	if ( !$status ) {
> 		$UserID = 112;    # Could not open file.  Consider warning message?
> 		return;
> 	}
> 	%UserData = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> }
> 
> sub UserDataFilename {
> 	my ($id) = @_;
> 	if ($id =~ /(\d+)/){
> 		$id = $1;
> 	}
> 	else { die "The userid must be a positive integer"; }
> 	
> 	return "" if ( $id < 1 );
> 	return $UserDir . "/" . ( $id % 10 ) . "/$id.db";
> }
> 
> # ==== Misc. functions ====
> sub ReportError {
> 	my ($errmsg) = @_;
> 	
> 	print &GetHeader( "", "ERROR!", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>$errmsg</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub ValidId {
> 	my ($id) = @_;
> 	if ( length($id) > 120 ) {
> 		return Ts( 'Page name is too long: %s', $id );
> 	}
> 	
> 	if ( $id =~ m| | ) {
> 		return Ts( 'Page name may not contain space characters: %s', $id );
> 	}
> 	
> 	if ($UseSubpage) {
> 		if ( $id =~ m|.*/.*/| ) {
> 			return Ts( 'Too many / characters in page %s', $id );
> 		}
> 		if ( $id =~ /^\// ) {
> 			return Ts( 'Invalid Page %s (subpage without main page)', $id );
> 		}
> 		if ( $id =~ /\/$/ ) {
> 			return Ts( 'Invalid Page %s (missing subpage name)', $id );
> 		}
> 	}
> 	
> 	if ($FreeLinks) {
> 		$id =~ s/ /_/g;
> 		if ( !$UseSubpage ) {
> 			if ( $id =~ /\// ) {
> 				return Ts( 'Invalid Page %s (/ not allowed)', $id );
> 			}
> 		}
> 		if ( !( $id =~ m|^$FreeLinkPattern$| ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 		if ( $id =~ m|\.db$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .db)', $id );
> 		}
> 		if ( $id =~ m|\.lck$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .lck)', $id );
> 		}
> 		return "";
> 	}
> 	else {
> 		if ( !( $id =~ /^$LinkPattern$/ ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 	}
> 	
> 	return "";
> }
> 
> sub ValidIdOrDie {
> 	my ($id) = @_;
> 	my $error;
> 	
> 	$error = &ValidId($id);
> 	
> 	if ( $error ne "" ) {
> 		&ReportError($error);
> 		return 0;
> 	}
> 	return 1;
> }
> 
> sub UserCanEdit {
> 	my ( $id, $deepCheck ) = @_;
> 	my $authtype = &CheckIsAuthUser($id);
> 	
> 	# Optimized for the "everyone can edit" case (don't check passwords)
> 	if ( ( $id ne "" ) && ( -f &GetLockedPageFile($id) ) ) {
> 		return 1 if ( &UserIsAdmin() );    # Requires more privledges
> 		     # Consider option for editor-level to edit these pages?
> 		return 0;
> 	}
> 	if ( !$EditAllowed ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ( -f "$DataDir/noedit" ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ($deepCheck) {    # Deeper but slower checks (not every page)
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0 if ( &UserIsBanned() );
> 	}
> 	return 1;
> }
> 
> sub UserIsBanned {
> 	my ( $host, $ip, $data, $status );
> 	( $status, $data ) = &ReadFile("$DataDir/banlist");
> 	return 0 if ( !$status );    # No file exists, so no ban
> 	$data =~ s/\r//g;
> 	$ip   = $ENV{'REMOTE_ADDR'};
> 	$host = &GetRemoteHost(0);
> 	
> 	foreach ( split( /\n/, $data ) ) {
> 		next if ( (/^\s*$/) || (/^#/) );    # Skip empty, spaces, or comments
> 		return 1 if ( $ip   =~ /$_/i );
> 		return 1 if ( $host =~ /$_/i );
> 	}
> 	return 0;
> }
> 
> sub UserIsAdmin {
> 	my ( @pwlist, $userPassword );
> 	
> 	return 0 if ( $AdminPass eq "" );
> 	$userPassword = &GetParam( "adminpw", "" );
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $AdminPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
> }
> 
> sub UserIsEditor {
> 	my ( @pwlist, $userPassword );
> 	
> 	return 1 if ( &UserIsAdmin() );    # Admin includes editor
> 	return 0 if ( $EditPass eq "" );
> 	$userPassword = &GetParam( "password", "" );    # Used for both
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $EditPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
> }
> 
> sub UserIsEditorOrAdmin {
> 	return (UserIsEditor || UserIsAdmin);	
> }
> 
> sub UserCanUpload {
> 	return 1 if ( &UserIsEditor() );
> 	return $AllUpload;
> }
> 
> sub GetLockedPageFile {
> 	my ($id) = @_;
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
> }
> 
> sub RequestLockDir {
> 	my ( $name, $tries, $wait, $errorDie ) = @_;
> 	my ( $lockName, $n );
> 	&CreateDir($TempDir);
> 	$lockName = $LockDir . $name;
> 	$n        = 0;
> 	while ( mkdir( $lockName, 0555 ) == 0 ) {
> 		if ( $! != 17 ) {
> 			die( Ts( 'can not make %s', $LockDir ) . ": $!\n" ) if $errorDie;
> 			return 0;
> 		}
> 		return 0 if ( $n++ >= $tries );
> 		sleep($wait);
> 	}
> 	return 1;
> }
> 
> sub ReleaseLockDir {
> 	my ($name) = @_;
> 	rmdir( $LockDir . $name );
> }
> 
> sub RequestLock {
> 
> 	# 10 tries, 3 second wait, possibly die on error
> 	return &RequestLockDir( "main", 10, 3, $LockCrash );
> }
> 
> sub ReleaseLock {
> 	&ReleaseLockDir('main');
> }
> 
> sub ForceReleaseLock {
> 	my ($name) = @_;
> 	my $forced;
> 
> 	# First try to obtain lock (in case of normal edit lock)
> 	# 5 tries, 3 second wait, do not die on error
> 	$forced = !&RequestLockDir( $name, 5, 3, 0 );
> 	&ReleaseLockDir($name);    # Release the lock, even if we didn't get it.
> 	return $forced;
> }
> 
> sub RequestCacheLock {
> 
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'cache', 4, 2, 0 );
> }
> 
> sub ReleaseCacheLock {
> 	&ReleaseLockDir('cache');
> }
> 
> sub RequestDiffLock {
> 
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'diff', 4, 2, 0 );
> }
> 
> sub ReleaseDiffLock {
> 	&ReleaseLockDir('diff');
> }
> 
> # Index lock is not very important--just return error if not available
> sub RequestIndexLock {
> 
> 	# 1 try, 2 second wait, do not die on error
> 	return &RequestLockDir( 'index', 1, 2, 0 );
> }
> 
> sub ReleaseIndexLock {
> 	&ReleaseLockDir('index');
> }
> 
> sub ReadFile {
> 	my ($fileName) = @_;
> 	my ($data);
> 	local $/ = undef;    # Read complete files
> 	if ( open( IN, "<$fileName" ) ) {
> 		$data = <IN>;
> 		close IN;
> 		return ( 1, $data );
> 	}
> 	return ( 0, "" );
> }
> 
> sub ReadFileOrDie {
> 	my ($fileName) = @_;
> 	my ( $status, $data );
> 	( $status, $data ) = &ReadFile($fileName);
> 	if ( !$status ) {
> 		die( Ts( 'Can not open %s', $fileName ) . ": $!" );
> 	}
> 	return $data;
> }
> 
> sub WriteStringToFile {
> 	my ( $file, $string ) = @_;
> 	open( OUT, ">$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
> }
> 
> sub AppendStringToFile {
> 	my ( $file, $string ) = @_;
> 	open( OUT, ">>$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
> }
> 
> sub AppendStringToFileLimited {
> 	my ( $file, $string, $limit ) = @_;
> 	if ( ( $limit < 1 ) || ( ( ( -s $file ) + length($string) ) <= $limit ) ) {
> 		&AppendStringToFile( $file, $string );
> 	}
> }
> 
> sub CreateDir {
> 	my ($newdir) = @_;
> 	mkdir( $newdir, 0775 ) if ( !( -d $newdir ) );
> }
> 
> sub CreatePageDir {
> 	my ( $dir, $id ) = @_;
> 	my $subdir;
> 	&CreateDir($dir);    # Make sure main page exists
> 	$subdir = $dir . "/" . &GetPageDirectory($id);
> 	&CreateDir($subdir);
> 	if ( $id =~ m|([^/]+)/| ) {
> 		$subdir = $subdir . "/" . $1;
> 		&CreateDir($subdir);
> 	}
> }
> 
> sub UpdateHtmlCache {
> 	my ( $id, $html ) = @_;
> 	my $idFile;
> 	$idFile = &GetHtmlCacheFile($id);
> 	&CreatePageDir( $HtmlDir, $id );
> 	if ( &RequestCacheLock() ) {
> 		&WriteStringToFile( $idFile, $html );
> 		&ReleaseCacheLock();
> 	}
> }
> 
> sub GenerateAllPagesList {
> 	my ( @pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId );
> 	@pages = ();
> 	if ($FastGlob) {
> 
> 		# The following was inspired by the FastGlob code by Marc W. Mengel.
> 		# Thanks to Bob Showalter for pointing out the improvement.
> 		opendir( PAGELIST, $PageDir );
> 		@dirs = readdir(PAGELIST);
> 		closedir(PAGELIST);
> 		@dirs = sort(@dirs);
> 		foreach $dir (@dirs) {
> 			next
> 			  if ( substr( $dir, 0, 1 ) eq '.' );  # No ., .., or .dirs or files
> 			opendir( PAGELIST, "$PageDir/$dir" );
> 			@pageFiles = readdir(PAGELIST);
> 			closedir(PAGELIST);
> 			foreach $id (@pageFiles) {
> 				next if ( ( $id eq '.' ) || ( $id eq '..' ) );
> 				if ( substr( $id, -3 ) eq '.db' ) {
> 					push( @pages, substr( $id, 0, -3 ) );
> 				}
> 				elsif ( substr( $id, -4 ) ne '.lck' ) {
> 					opendir( PAGELIST, "$PageDir/$dir/$id" );
> 					@subpageFiles = readdir(PAGELIST);
> 					closedir(PAGELIST);
> 					foreach $subId (@subpageFiles) {
> 						if ( substr( $subId, -3 ) eq '.db' ) {
> 							push( @pages, "$id/" . substr( $subId, 0, -3 ) );
> 						}
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		# Old slow/compatible method.
> 		@dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
> 		
> 		foreach $dir (@dirs) {
> 			if ( -e "$PageDir/$dir" ) {    # Thanks to Tim Holt
> 				while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
> 					s|^$PageDir/||;
> 					m|^[^/]+/(\S*).db|;
> 					$id = $1;
> 					push( @pages, $id );
> 				}
> 			}
> 		}
> 	}
> 	
> 	return sort(@pages);
> }
> 
> sub AllPagesList {
> 	my ( $rawIndex, $refresh, $status );
> 	
> 	if ( !$UseIndex ) {
> 		return &GenerateAllPagesList();
> 	}
> 	
> 	$refresh = &GetParam( "refresh", 0 );
> 	if ( $IndexInit && !$refresh ) {
> 
> 		# Note for mod_perl: $IndexInit is reset for each query
> 		# Eventually consider some timestamp-solution to keep cache?
> 		return @IndexList;
> 	}
> 	
> 	if ( ( !$refresh ) && ( -f $IndexFile ) ) {
> 		( $status, $rawIndex ) = &ReadFile($IndexFile);
> 		
> 		if ($status) {
> 			%IndexHash = split( /\s+/, $rawIndex );
> 			@IndexList = sort( keys %IndexHash );
> 			$IndexInit = 1;
> 			
> 			return @IndexList;
> 		}
> 
> 		# If open fails just refresh the index
> 	}
> 	@IndexList = ();
> 	%IndexHash = ();
> 	@IndexList = &GenerateAllPagesList();
> 	
> 	foreach (@IndexList) {
> 		$IndexHash{$_} = 1;
> 	}
> 	$IndexInit = 1;    # Initialized for this run of the script
> 	                   # Try to write out the list for future runs
> 	&RequestIndexLock() or return @IndexList;
> 	&WriteStringToFile( $IndexFile, join( " ", %IndexHash ) );
> 	&ReleaseIndexLock();
> 	
> 	return @IndexList;
> }
> 
> sub AllSubPagesList {
> 	my $GivenPage = shift;
> 	my @PageList = &AllPagesList();
> 	my @Results;
> 	
> 	foreach (@PageList){
> 		if (/^$GivenPage\//i){
> 			push @Results, $_;	
> 		}
> 	}
> 	
> 	return @Results;
> }
> 
> sub CalcDay {
> 	my ($ts) = @_;
> 	
> 	$ts += $TimeZoneOffset;
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	
> 	if ($NumberDates) {
> 		$year = $year + 1900;
> 		$mon = $mon + 1;
> 		if ($mon < 10){ $mon = "0$mon"; }
> 		if ($mday < 10){ $mday = "0$mday"; }
> 		
> 		return "$year$NumberDatesDelim$mon$NumberDatesDelim$mday";
> 	}
> 	
> 	return (
> 		"January",   "February", "March",    "April",
> 		"May",       "June",     "July",     "August",
> 		"September", "October",  "November", "December"
> 	  )[$mon]
> 	  . " "
> 	  . $mday . ", "
> 	  . ( $year + 1900 );
> }
> 
> sub CalcTime {
> 	my ($ts) = @_;
> 	my ( $ampm, $mytz );
> 	
> 	$ts += $TimeZoneOffset;
> 	
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	$mytz = "";
> 	
> 	if ( ( $TimeZoneOffset == 0 ) && ( $ScriptTZ ne "" ) ) {
> 		$mytz = " " . $ScriptTZ;
> 	}
> 	$ampm = "";
> 	
> 	if ($UseAmPm) {
> 		$ampm = " am";
> 		if ( $hour > 11 ) {
> 			$ampm = " pm";
> 			$hour = $hour - 12;
> 		}
> 		$hour = 12 if ( $hour == 0 );
> 	}
> 	
> 	$min = "0" . $min if ( $min < 10 );
> 	
> 	return $hour . ":" . $min . $ampm . $mytz;
> }
> 
> sub TimeToText {
> 	my ($t) = @_;
> 	
> 	return &CalcDay($t) . " " . &CalcTime($t);
> }
> 
> sub GetParam {
> 	my ( $name, $default ) = @_;
> 	my $result;
> 	
> 	$result = $q->param($name);
> 	
> 	if ( !defined($result) ) {
> 		if ( defined( $UserData{$name} ) ) {
> 			$result = $UserData{$name};
> 		}
> 		else {
> 			$result = $default;
> 		}
> 	}
> 	
> 	return $result;
> }
> 
> sub GetHiddenValue {
> 	my ( $name, $value ) = @_;
> 	
> 	$q->param( $name, $value );
> 	
> 	return $q->hidden($name);
> }
> 
> sub GetRemoteHost {
> 	my ($doMask) = @_;
> 	my ( $rhost, $iaddr );
> 	
> 	$rhost = $ENV{REMOTE_HOST};
> 	
> 	if ( $UseLookup && ( $rhost eq "" ) ) {
> 
> 		# Catch errors (including bad input) without aborting the script
> 		eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
> 		  . '$rhost = gethostbyaddr($iaddr, AF_INET)';
> 	}
> 	
> 	if ( $rhost eq "" ) {
> 		$rhost = $ENV{REMOTE_ADDR};
> 	}
> 	
> 	$rhost = &GetMaskedHost($rhost) if ($doMask);
> 	
> 	return $rhost;
> }
> 
> sub FreeToNormal {
> 	my ($id) = @_;
> 	
> 	$id =~ s/ /_/g;
> 	$id = ucfirst($id) if ( $UpperFirst || $FreeUpper );
> 	
> 	if ( index( $id, '_' ) > -1 ) {    # Quick check for any space/underscores
> 		$id =~ s/__+/_/g;
> 		$id =~ s/^_//;
> 		$id =~ s/_$//;
> 		
> 		if ($UseSubpage) {
> 			$id =~ s|_/|/|g;
> 			$id =~ s|/_|/|g;
> 		}
> 	}
> 	
> 	if ($FreeUpper) {
> 
> 		# Note that letters after ' are *not* capitalized
> 		if ( $id =~ m|[-_.,\(\)/][a-z]| ) { # Quick check for non-canonical case
> 			$id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
> 		}
> 	}
> 	
> 	return $id;
> }
> 
> #END_OF_BROWSE_CODE
> # == Page-editing and other special-action code ========================
> $OtherCode = "";    # Comment next line to always compile (slower)
> 
> #$OtherCode = <<'#END_OF_OTHER_CODE';
> sub DoOtherRequest {
> 	my ( $id, $action, $filter, $text, $search );
> 	
> 	$action = &GetParam( "action", "" );
> 	$id     = &GetParam( "id",     "" );
> 	$filter = &GetParam( "filter", "" );
> 	
> 	if ( $action ne "" ) {
> 		$action = lc($action);
> 		
> 		if ( $action eq "edit" ) {
> 			&DoEdit( $id, 0, 0, "", 0 ) if &ValidIdOrDie($id);
> 		}
> 		elsif ( $action eq "unlock" ) {
> 			&DoUnlock();
> 		}
> 		elsif ( $action eq "index" ) {
> 			&DoIndex();
> 		}
> 		elsif ( $action eq "links" ) {
> 			&DoLinks();
> 		}
> 		elsif ( $action eq "maintain" ) {
> 			&DoMaintain();
> 		}
> 		elsif ( $action eq "pagelock" ) {
> 			&DoPageLock();
> 		}
> 		elsif ( $action eq "editlock" ) {
> 			&DoEditLock();
> 		}
> 		elsif ( $action eq "editprefs" ) {
> 			&DoEditPrefs();
> 		}
> 		elsif ( $action eq "editbanned" ) {
> 			&DoEditBanned();
> 		}
> 		elsif ( $action eq "editlinks" ) {
> 			&DoEditLinks();
> 		}
> 		elsif ( $action eq "login" ) {
> 			&DoEnterLogin();
> 		}
> 		elsif ( $action eq "newlogin" ) {
> 			$UserID = 0;
> 			&DoEditPrefs();    # Also creates new ID
> 		}
> 		elsif ( $action eq "version" ) {
> 			&DoShowVersion();
> 		}
> 		elsif ( $action eq "rss" ) {
> 			&DoRss();
> 		}
> 		elsif ( $action eq "delete" ) {
> 			&DoDeletePage($id);
> 		}
> 		elsif ( $UseUpload && ( $action eq "upload" ) ) {
> 			&DoUpload();
> 		}
> 		elsif ( $action eq "maintainrc" ) {
> 			&DoMaintainRc();
> 		}
> 		elsif ( $action eq "convert" ) {
> 			&DoConvert();
> 		}
> 		elsif ( $action eq "trimusers" ) {
> 			&DoTrimUsers();
> 		}
> 		elsif ( $action eq "listfiles" ) {
> 			&DoListFiles($id, $filter, 0);	
> 		}
> 		elsif ( $action eq "listdisabled" ) {
> 			&DoListFiles($id, $filter, 1);	
> 		}
> 		else {
> 			&ReportError( Ts( 'Invalid action parameter %s', $action ) );
> 		}
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_prefs", 0 ) ) {
> 		&DoUpdatePrefs();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_ban", 0 ) ) {
> 		&DoUpdateBanned();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "enter_login", 0 ) ) {
> 		&DoLogin();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_links", 0 ) ) {
> 		&DoUpdateLinks();
> 		return;
> 	}
> 	
> 	if ( $UseUpload && ( &GetParam( "upload", 0 ) ) ) {
> 		&SaveUpload();
> 		return;
> 	}
> 	
> 	$search = &GetParam( "search", "" );
> 	
> 	if ( ( $search ne "" ) || ( &GetParam( "dosearch", "" ) ne "" ) ) {
> 		&DoSearch($search, $filter);
> 		return;
> 	}
> 	else {
> 		$search = &GetParam( "back", "" );
> 		if ( $search ne "" ) {
> 			&DoBackLinks($search, $filter);
> 			
> 			return;
> 		}
> 	}
> 
> 	# Handle posted pages
> 	if ( &GetParam( "oldtime", "" ) ne "" ) {
> 		$id = &GetParam( "title", "" );
> 		&DoPost() if &ValidIdOrDie($id);
> 		
> 		return;
> 	}
> 	
> 	&ReportError( "Invalid URL." );
> }
> 
> sub PageIsLocked {
> 	my ($id, $deepedit) = @_;
> 	my ($result) = 0;
> 	
> 	if ( !&UserCanEdit( $id, $deepedit ) ) {
> 			$result = 1;
> 		if ( &UserIsBanned() ) {
> 			$result = 2;
> 		}
> 		else {
> 			$result = 3;
> 		}
> 	}
> 	
> 	return $result;
> }
> 
> sub DoEdit {
> 	my ( $id, $isConflict, $oldTime, $newText, $preview ) = @_;
> 	my ( $header, $editRows, $editCols, $userName, $revision, $oldText );
> 	my ( $summary, $isEdit, $pageTime, $isLocked );
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 	if (!$authtype) { $id = "AuthError"; } #auth patch	
> 	if ($FreeLinks) { $id = &FreeToNormal($id); }   # Take care of users like Markus Lude :-)	
> 	
> 	$isLocked = &PageIsLocked( $id, 1 );
> 	
> 	if ( $isLocked > 0 or $authtype eq "" || $authtype eq "1") {
> 		print &GetHeader( "", "Editing Denied", "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		
> 		if ( $isLocked == 2 ) {
> 			print "\n<h2>Editing not allowed: user, ip, or network is blocked.</h2>";
> 			print "\nContact the wiki administrator for more information.";
> 		}
> 		else {
> 			print "\n<h2>Editing not allowed: $id is read-only.</h2>";
> 		}
> 		
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";
> 			
> 		return;
> 	}
> 
> 	# Consider sending a new user-ID cookie if user does not have one
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$pageTime = $Section{'ts'};
> 	$header   = Ts( 'Editing %s', $id );
> 
> 	# Old revision handling
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$revision = "";
> 
> 			# Consider better solution like error message?
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 			$header = Ts( 'Editing revision %s of ', $revision ) . $id;
> 		}
> 	}
> 	
> 	$oldText = $Text{'text'};
> 	
> 	if ( $preview && !$isConflict ) {
> 		$oldText = $newText;
> 	}
> 	
> 	$editRows = &GetParam( "editrows", 20 );
> 	$editCols = &GetParam( "editcols", 65 );
> 	print &GetHeader( "", &QuoteHtml($header), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $revision ne "" ) {
> 		print "\n<b>Editing old revision $revision. Saving this page will replace the latest revision with this text.</b><br>";
> 	}
> 	
> 	if ($isConflict) {
> 		$editRows -= 10 if ( $editRows > 19 );
> 		print "\n<H1>Edit Conflict!</H1>";
> 		
> 		if ( $isConflict > 1 ) {
> 
> 			# The main purpose of a new warning is to display more text
> 			# and move the save button down from its old location.
> 			print "\n<h2>(This is a new conflict)</h2>";
> 		}
> 		
> 		print "\n<p><strong>";
> 		print "\nSomeone saved this page after you started editing. ";
> 		print "\nThe top textbox contains the saved text. ";
> 		print "\nOnly the text in the top textbox will be saved.";
> 		print "\n</strong></p><br>";
> 		print "\nScroll down to see your edited text.";
> 		print "\n<br>";
> 		print "\nLast save time: ";
> 		print &TimeToText($oldTime);
> 		print "\n(Current time is: ";
> 		print &TimeToText($Now);
> 		print "\n)<br>";
> 	}
> 	print "\n<div id='wikieditbar'>";
> 	print "<a href='$ScriptName?WikiStyleGuide'>WikiStyleGuide</a> | ";
> 	print "<a href='$ScriptName?WikiHeadings'>WikiHeadings</a> | ";
> 	print "<a href='$ScriptName?WikiGallery'>WikiGallery</a>| ";
> 	print "<a href='$ScriptName?WikiFlash'>WikiFlash</a>| ";
> 	print "<a href='$ScriptName?WikiTOCs'>WikiTOCs</a> | ";
> 	print "<a href='$ScriptName?WikiURLs'>WikiURLs</a> | ";
> 	print "<a href='$ScriptName?WikiImages'>WikiImages</a> | ";
> 	print "<a href='$ScriptName?WikiTables'>WikiTables</a> | ";
> 	print "<a href='$ScriptName?WikiLists'>WikiLists</a> | ";
> 	print "<a href='$ScriptName?WikiMarkup'>WikiMarkup</a>";
> 	print "\n</div>";
> 	
> 	print "\n<br>";
> 	print "\n<form id='wikiform' action='$ScriptName#preview-anchor' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "title",   $id );
> 	print &GetHiddenValue( "oldtime",     $pageTime );
> 	print &GetHiddenValue( "oldconflict", $isConflict );
> 	  
> 	if ( $revision ne "" ) {
> 		print &GetHiddenValue( "revision", $revision );
> 	}
> 	
> 	print &GetTextArea( 'text', $oldText, $editRows, $editCols );
> 	$summary = &GetParam( "summary", "*" );
> 	
> 	print "\n<br><br><div id='wikisaveedit'>Summary:";
> 	print
> 	  $q->textfield(
> 		-name      => 'summary',
> 		-id		   => 'summarytext',
> 		-default   => $summary,
> 		-override  => 1,
> 		-size      => 60,
> 		-maxlength => 200
> 	  );
> 	  
> 	if ( &GetParam("recent_edit") eq "on" ) {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name    => 'recent_edit',
> 			-checked => 1,
> 			-label   => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	else {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name  => 'recent_edit',
> 			-checked => 0,
> 			-label => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n&nbsp;&nbsp;&nbsp;"
> 		  . $q->checkbox(
> 			-name  => 'do_email_notify',
> 			-label =>
> 			  Ts( 'Send email notification that %s has been changed.', $id )
> 		  );
> 	}
> 	
> 	print "\n<br>";
> 	
> 	if ( $EditNote ne "" ) {
> 		print $EditNote . '<br>';
> 	}
> 	$userName = &GetParam( "username", "" );
> 	print $q->submit( -name => 'Preview', -value => 'Preview' );
> 	print $q->button( -name => 'Cancel', -value => 'Cancel', -onclick => 'window.location="' . $ScriptName . '?' . $id . '";' );
> 	print $q->submit( -name => 'Save', -value => "Save" );	
> 	
> 	if ( $userName ne "" ) {
> 		print "\n (Your user name is ";
> 		print &GetPageLinkText($HomePagePrefix . '/' . $userName, $userName);
> 		print "\n )";
> 	}
> 	else {
> 		print ' (', Ts( 'Visit %s to set your user name.', &GetPrefsLink() ), ') ';
> 	}
> 
> 	if ($isConflict) {
> 		print "\n<br><hr><p><strong>";
> 		print "\nThis is the text you submitted:";
> 		print  "</strong><p>";
> 		print &GetTextArea( 'newtext', $newText, $editRows, $editCols );
> 	}
> 	
> 	print "\n</div>";
> 	print "\n</form>";
> 	print "<a name='preview-anchor'></a>";
> 	print "\n</div>";			
> 	print "\n$WikiLineFooter";
> 	
> 	if ($preview) {
> 		
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print $WikiLineHeaderPreview;
> 		print "\n<div id='wikipreview' class='wikipreview'>";				
> 		if ($isConflict) {
> 			print "\n<b>NOTE: This preview shows the revision of the other author.</b><hr>";
> 		}
> 		
> 		$MainPage = $id;
> 		$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		print &WikiToHTML($oldText);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter";
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print "\n<div id='wikibar'>&nbsp</div>";
> 	}
> 
> 	print "\n<div class='wikifooter'>";	
> 	print "<div class='wikirevision'>";
> 	print &GetHistoryLink( $id, "View other revisions<br>", "Click to view revision history");
> 	print "</div>";
> 	print &GetGotoBar($id);
> 	print &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }		
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetTextArea {
> 	my ( $name, $text, $rows, $cols ) = @_;
> 	my ( $html );
> 	
> 	$html = "\n<div style='width: 100%;'>";
> 	if ( &GetParam( "editwide", 1 ) ) {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-style    => 'width:100%',
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	else {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	
> 	$html .= "</div>";
> 	
> 	return $html;
> }
> 
> sub DoEditPrefs {
> 	my ( $check, $recentName, %labels );
> 	
> 	$recentName = $RCName;
> 	$recentName =~ s/_/ /g;
> 	
> 	&DoNewLogin() if ( $UserID < 400 );
> 	
> 	print &GetHeader( "", "Editing Preferences", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikidiff'>";
> 	print "\n<h2>Access Controls</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "edit_prefs", 1 );
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th colspan='2'><b>User Information </b></th></tr>";
> 	print "\n<tr><td>Your User ID number </td><td>$UserID</td></tr>";
> 	print "\n<tr><td>UserName</td>";
> 	print "\n<td>" . &GetFormText( 'username', "", 30, 50 );
> 	print "\n<br>(blank to remove, or valid page name)</td></tr>";
> 	print "\n<tr><td>Set Password </td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => '*',
> 		-size      => 30,
> 		-maxlength => 50
> 	  );
> 	 print "\n<br>(blank to remove password)";
> 	 print "\n<br>Passwords allow sharing preferences between multiple systems. Passwords are completely optional. ";
> 	 print "\n</td></tr>";
> 
> 
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		print "\n<tr><td>Administrator Password </td>";
> 		print "\n<td>";
> 		print
> 		  $q->password_field(
> 			-name      => 'p_adminpw',
> 			-value     => '*',
> 			-size      => 30,
> 			-maxlength => 50
> 		  );
> 		print "\n<br>(blank to remove password)";
> 		print "\n<br>(Administrator passwords are used for special maintenance.)";
> 		print "\n</td></tr>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n<tr><td>Email Address</td>";
> 		print "\n<td>" . &GetFormText( 'email', "", 30, 60 );
> 		print "\n<br>" . &GetFormCheck( 'notify', 1, "Include this address in the site email list." );
> 		print "\n<br>(Uncheck the box to remove the address.) ";
> 		
> 		print "\n</td></tr>";
> 	}
> 	
> 	print "\n</table>";
> 	
> 	print "\n$WikiLinePref<b>$recentName:</b>";
> 	print "\n<br>Default days to display: ";
> 	print &GetFormText( 'rcdays', $RcDefault, 4, 9 );
> 	print "\n<br>", &GetFormCheck( 'rcnewtop', $RecentTop, "Most recent changes on top" );
> 	print "\n<br>", &GetFormCheck( 'rcall', 0, "Show all changes (not just most recent)" );
> 	
> 	%labels = (
> 		0 => "Hide minor edits",
> 		1 => "Show minor edits",
> 		2 => "Show only minor edits"
> 	);
> 	
> 	print "\n<br>Minor edit display: ";
> 	print $q->popup_menu(
> 		-name   => 'p_rcshowedit',
> 		-values => [ 0, 1, 2 ],
> 		-labels => \%labels,
> 		-default => &GetParam( "rcshowedit", $ShowEdits )
> 	);
> 	
> 	print "\n<br>", &GetFormCheck( 'rcchangehist', 1, "Use 'changes' as link to history" );
> 
> 	if ($UseDiff) {
> 		print "\n$WikiLinePref<b>Differences:</b>";
> 		print "\n<br>", &GetFormCheck( 'diffrclink', 1, "Show (diff) links on $recentName " );
> 		print "\n<br>", &GetFormCheck( 'alldiff', 0, "Show differences on all pages" );
> 		print "\n  (", &GetFormCheck( 'norcdiff', 1, "No differences on $recentName " ), ")";
> 		%labels = ( 1 => "Major", 2 => "Minor", 3 => "Author" );
> 		print "\n<br>Default difference type: ";
> 		print $q->popup_menu(
> 			-name   => 'p_defaultdiff',
> 			-values => [ 1, 2, 3 ],
> 			-labels => \%labels,
> 			-default => &GetParam( "defaultdiff", 1 )
> 		);
> 	}
> 	
> 	print "\n$WikiLinePref<b>Misc:</b>";
> 
> 	# Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
> 	print "\n<br>";
> 	print "\nServer time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print &GetFormText( 'tzoffset', 0, 4, 9 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'editwide', 1, "Use 100% wide edit area (if supported)" );
> 	print "\n<br>";
> 	print "\nEdit area rows: ";
> 	print &GetFormText( 'editrows', 20, 4, 4 );
> 	print "\n columns: ";
> 	print &GetFormText( 'editcols', 65, 4, 4 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'toplinkbar', 1, "Show link bar on top" );
> 	print "\n<br>";
> 	print &GetFormCheck( 'linkrandom', 0, "Add 'Random Page' link to link bar" );
> 	print "\n<br>";
> 	print "\nStyleSheet URL: ";
> 	print &GetFormText( 'stylesheet', "", 30, 150 );
> 	print "\n<br><br>";
> 	print "\n<input type='button' name='Cancel' value='Cancel' onclick='history.go(-1);' style='margin-right: 20px;'>";
> 	print "\n<input type='reset' name='Reset'> ";
> 	print $q->submit( -name => 'Save', -value => "Save" );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print "\n$WikiLineFooter";
> 	print "\n<div class='wikifooter'>";
> 	print &GetGotoBar("");
> 
> 	print &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetFormText {
> 	my ( $name, $default, $size, $max ) = @_;
> 	my $text = &GetParam( $name, $default );
> 	
> 	return $q->textfield(
> 		-name      => "p_$name",
> 		-default   => $text,
> 		-override  => 1,
> 		-size      => $size,
> 		-maxlength => $max
> 	);
> }
> 
> sub GetFormCheck {
> 	my ( $name, $default, $label ) = @_;
> 	my $checked = ( &GetParam( $name, $default ) > 0 );
> 	
> 	return $q->checkbox(
> 		-name     => "p_$name",
> 		-override => 1,
> 		-checked  => $checked,
> 		-label    => $label
> 	);
> }
> 
> sub DoUpdatePrefs {
> 	my ( $username, $password, $stylesheet );
> 
> 	# All link bar settings should be updated before printing the header
> 	&UpdatePrefCheckbox("toplinkbar");
> 	&UpdatePrefCheckbox("linkrandom");
> 	
> 	print &GetHeader( "", "Saving Preferences" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $UserID < 1001 ) {
> 		print "\n<h2>Invalid UserID $UserID, preferences not saved.</h2>";
> 		
> 		if ( $UserID == 111 ) {
> 			print "\n<br>(Preferences require cookies, but no cookie was sent.)";
> 		}
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$username = &GetParam( "p_username", "" );
> 	
> 	if ($FreeLinks) {
> 		$username =~ s/^\[\[(.+)\]\]/$1/;    # Remove [[ and ]] if added
> 		$username = &FreeToNormal($username);
> 		$username =~ s/_/ /g;
> 	}
> 	
> 	if ( $username eq "" ) {
> 		print "\n<h2>UserName removed.</h2>";
> 		undef $UserData{'username'};
> 	}
> 	elsif ( ( !$FreeLinks ) && ( !( $username =~ /^$LinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( $FreeLinks && ( !( $username =~ /^$FreeLinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( length($username) > 50 ) {    # Too long
> 		print "\n<h2>UserName must be 50 characters or less. (not saved)</h2>";
> 	}
> 	else {
> 		print "\n<h2>UserName $username saved.</h2>";
> 		$UserData{'username'} = $username;
> 	}
> 	
> 	$password = &GetParam( "p_password", "" );
> 	
> 	if ( $password eq "" ) {
> 		print "\nPassword removed.<br>";
> 		undef $UserData{'password'};
> 	}
> 	elsif ( $password ne "*" ) {
> 		print "\nPassword changed.<br>";
> 		$UserData{'password'} = $password;
> 	}
> 	
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		$password = &GetParam( "p_adminpw", "" );
> 		if ( $password eq "" ) {
> 			print "\nAdministrator password removed.<br>";
> 			undef $UserData{'adminpw'};
> 		}
> 		elsif ( $password ne "*" ) {
> 			print "\nAdministrator password changed.<br>";
> 			$UserData{'adminpw'} = $password;
> 			
> 			if ( &UserIsAdmin() ) {
> 				print "\nUser has administrative abilities.<br>";
> 			}
> 			elsif ( &UserIsEditor() ) {
> 				print "\nUser has editor abilities.<br>";
> 			}
> 			else {
> 				print "\nUser does not have administrative abilities. (Password does not match administrative password(s).) <br>";
> 			}
> 		}
> 	}
> 	if ($EmailNotify) {
> 		&UpdatePrefCheckbox("notify");
> 		&UpdateEmailList();
> 	}
> 	
> 	&UpdatePrefNumber( "rcdays", 0, 0, 999999 );
> 	&UpdatePrefCheckbox("rcnewtop");
> 	&UpdatePrefCheckbox("rcall");
> 	&UpdatePrefCheckbox("rcchangehist");
> 	&UpdatePrefCheckbox("editwide");
> 	
> 	if ($UseDiff) {
> 		&UpdatePrefCheckbox("norcdiff");
> 		&UpdatePrefCheckbox("diffrclink");
> 		&UpdatePrefCheckbox("alldiff");
> 		&UpdatePrefNumber( "defaultdiff", 1, 1, 3 );
> 	}
> 	
> 	&UpdatePrefNumber( "rcshowedit", 1, 0,    2 );
> 	&UpdatePrefNumber( "tzoffset",   0, -999, 999 );
> 	&UpdatePrefNumber( "editrows",   1, 1,    999 );
> 	&UpdatePrefNumber( "editcols",   1, 1,    999 );
> 	
> 	print "\n<br>Server time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print "\n<br>";
> 	$TimeZoneOffset = &GetParam( "tzoffset", 0 ) * ( 60 * 60 );
> 	
> 	print"Local time: ";
> 	print &TimeToText($Now);
> 	print "\n<br>";
> 	$stylesheet = &GetParam( 'p_stylesheet', "" );
> 
> 	if ( $stylesheet eq "" ) {
> 		if ( &GetParam( 'stylesheet', "" ) ne "" ) {
> 			print "\nStyleSheet URL removed.<br>";
> 		}
> 		undef $UserData{'stylesheet'};
> 	}
> 	else {
> 		$stylesheet =~ s/[">]//g;  # Remove characters that would cause problems"
> 		$UserData{'stylesheet'} = $stylesheet;
> 		print "\nStyleSheet setting saved.<br>";
> 	}
> 	
> 	&SaveUserData();
> 	
> 	print "\n<br><b>Preferences saved.</b>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # add or remove email address from preferences to $EmailFile
> sub UpdateEmailList {
> 	my (@old_emails);
> 	local $/ = "\n";               # don't slurp whole files in this sub.
> 	
> 	if ( my $new_email = $UserData{'email'} = &GetParam( "p_email", "" ) ) {
> 		my $notify = $UserData{'notify'};
> 		if ( -f $EmailFile ) {
> 			open( NOTIFY, $EmailFile ) or die( Ts( 'Could not read from %s:', $EmailFile ) . " $!\n" );
> 			@old_emails = <NOTIFY>;
> 			close(NOTIFY);
> 		}
> 		else {
> 			@old_emails = ();
> 		}
> 		
> 		my $already_in_list = grep /$new_email/, @old_emails;
> 		
> 		if ( $notify and ( not $already_in_list ) ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">>$EmailFile" ) ) {
> 				&ReleaseLock();    # Don't leave hangling locks
> 				die( "Could not append to $EmailFile : $!\n" );
> 			}
> 			
> 			print NOTIFY $new_email, "\n";
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 		elsif ( ( not $notify ) and $already_in_list ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">$EmailFile" ) ) {
> 				&ReleaseLock();
> 				die( "Could not overwrite $EmailFile : $!\n" );
> 			}
> 			foreach (@old_emails) {
> 				print NOTIFY "$_" unless /$new_email/;
> 			}
> 			
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 	}
> }
> 
> sub UpdatePrefCheckbox {
> 	my ($param) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	$UserData{$param} = 1 if ( $temp eq "on" );
> 	$UserData{$param} = 0 if ( $temp eq "*" );
> 
> 	# It is possible to skip updating by using another value, like "2"
> }
> 
> sub UpdatePrefNumber {
> 	my ( $param, $integer, $min, $max ) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	return if ( $temp eq "*" );
> 	
> 	$temp =~ s/[^-\d\.]//g;
> 	$temp =~ s/\..*// if ($integer);
> 	
> 	return if ( $temp eq "" );
> 	return if ( ( $temp < $min ) || ( $temp > $max ) );
> 	
> 	$UserData{$param} = $temp;
> }
> 
> sub DoIndex {
> 	print &GetHeader( "", "Index of all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( "", &AllPagesList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Create a new user file/cookie pair
> sub DoNewLogin {
> 
> 	# Consider warning if cookie already exists
> 	# (maybe use "replace=1" parameter)
> 	&CreateUserDir();
> 	$SetCookie{'id'}      = &GetNewUserId();
> 	$SetCookie{'randkey'} = int( rand(1000000000) );
> 	$SetCookie{'rev'}     = 1;
> 	%UserCookie           = %SetCookie;
> 	$UserID               = $SetCookie{'id'};
> 
> 	# The cookie will be transmitted in the next header
> 	%UserData               = %UserCookie;
> 	$UserData{'createtime'} = $Now;
> 	$UserData{'createip'}   = $ENV{REMOTE_ADDR};
> 	&SaveUserData();
> }
> 
> sub DoEnterLogin {
> 	print &GetHeader( "", "Login", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>Enter UserID</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( 'enter_login', 1 );
> 	print "\n<table><tr>";
> 	print "\n<td>User ID number &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->textfield(
> 		-name      => 'p_userid',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n<tr>";
> 	print "\n<td>Password  &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n</tr></table><br>";
> 	print $q->submit( -name => 'Login', -value => 'Login' );
> 	print "\n<br></form></div>";
> 	print &GetCommonFooter();
> 	print "\n</div></body></html>";	
> }
> 
> sub DoLogin {
> 	my ( $uid, $password, $success );
> 	
> 	$success = 0;
> 	$uid = &GetParam( "p_userid", "" );
> 	$uid =~ s/\D//g;
> 	$password = &GetParam( "p_password", "" );
> 	
> 	print &GetHeader( "", "Login Results", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( ( $uid > 199 ) && ( $password ne "" ) && ( $password ne "*" ) ) {
> 		$UserID = $uid;
> 		&LoadUserData();
> 		if ( $UserID > 199 ) {
> 			if ( defined( $UserData{'password'} ) && ( $UserData{'password'} eq $password ) ) {
> 				$SetCookie{'id'}      = $uid;
> 				$SetCookie{'randkey'} = $UserData{'randkey'};
> 				$SetCookie{'rev'}     = 1;
> 				$success              = 1;
> 			}
> 			else {
> 				print "\nUserID Account Undefined<br>";
> 			}
> 		}
> 		else {
> 			print "\nUserID must be above 199<br>";
> 		}
> 	}
> 	
> 	
> 	if ($success) {
> 		print "\n<h2>Login for user ID $uid complete.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Login for user ID $uid failed.</h2>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter;
> 	print "\n</div></body></html>";	
> }
> 
> sub GetNewUserId {
> 	my ($id);
> 	
> 	$id = $StartUID;
> 	
> 	while ( -f &UserDataFilename( $id + 1000 ) ) {
> 		$id += 1000;
> 	}
> 	
> 	while ( -f &UserDataFilename( $id + 100 ) ) {
> 		$id += 100;
> 	}
> 	
> 	while ( -f &UserDataFilename( $id + 10 ) ) {
> 		$id += 10;
> 	}
> 	
> 	&RequestLock() or die( "Could not get user-ID lock" );
> 	while ( -f &UserDataFilename($id) ) {
> 		$id++;
> 	}
> 	
> 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
> 	&ReleaseLock();
> 	
> 	return $id;
> }
> 
> # Consider user-level lock?
> sub SaveUserData {
> 	my ( $userFile, $data );
> 	
> 	&CreateUserDir();
> 	$userFile = &UserDataFilename($UserID);
> 	$data = join( $FS1, %UserData );
> 	&WriteStringToFile( $userFile, $data );
> }
> 
> sub CreateUserDir {
> 	my ( $n, $subdir );
> 	
> 	if ( !( -d "$UserDir/0" ) ) {
> 		&CreateDir($UserDir);
> 		foreach $n ( 0 .. 9 ) {
> 			$subdir = "$UserDir/$n";
> 			&CreateDir($subdir);
> 		}
> 	}
> }
> 
> sub DoSearch {
> 	my ($string, $filter) = @_;
> 	my ( $title );
> 	if ( $string eq "" ) {
> 		&DoIndex();
> 		return;
> 	}
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( "Search for: $title %s", $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( $filter, &SearchTitleAndBody($string, $filter) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='search' value='$string'>";
> 	print "\n<input type='hidden' name='dosearch' value='1'>";	
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoBackLinks {
> 	my ($string, $filter) = @_;
> 	my ($title);
> 	
> 	$title = $string;
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( 'Backlinks for: %s', $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	# At this time the backlinks are mostly a renamed search.
> 	# An initial attempt to match links only failed on subpages and free links.
> 	# Escape some possibly problematic characters:
> 	
> 	$string =~ s/([_ ])/( |_)/g;
> 	$string =~ s/([-'(),])/\\$1/g; #'REMARK
> 	$string =~ m,/, ? "\\b$string\\b" : "$string\\b";
> 	
> 	print PrintPageList( grep($_ !~ $title, $filter, &SearchTitleAndBody($string, $filter, "")) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='back' value='$string'>";
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub PrintPageList {
> 	my ($filter, @results) = @_;
> 	my $term;
>     my $pagename;
>     my $html = "";
>     my $pagecount = scalar(@results);
>     my $currentInitial = "";
>     my $thisInitial;
>     my $lastInitial;
>     my $letterGrouping = ($pagecount > 25);
>     my $currentParent = "";
>     my $linktext = "";
>     my $notFirst;
> 
> 	if ($filter ne ""){ $term = " using filter '<em>$filter</em>'"; }
> 	$html .= "<h2>" . ( scalar(@results) ) . " pages found: $term</h2>";
>     #$html .= "<ol>\n" if ($letterGrouping ne 1); # commented to keep a 'original' usemod look
>     
>     if ($letterGrouping) {
>         $html .= "<h3 class='lettergroup'>";
>         foreach $pagename (@results) {
>             $thisInitial = substr($pagename,0,1);
>             if ($thisInitial ne $lastInitial) {
>                     $html .= "<a href=\"#letter".$thisInitial."\">".$thisInitial."</a> ";
>                     $lastInitial = $thisInitial;
>             }
>         }
>         $html .= "</h3>";
>     }
>     
>     foreach $pagename (@results) {
>         if ($letterGrouping) {
>             $thisInitial = substr($pagename,0,1);
>             if ($currentInitial ne $thisInitial) {
>                 #$html .= "</ol>" if ($currentInitial ne ""); # commented to keep a 'original' usemod look
>                 $html .= "\n<br><br><h3 class='lettergroup'><a name=\"letter$thisInitial\"> $thisInitial </h3>\n$WikiLine\n";
>                 #$html .= "<ol>\n"; # commented to keep a 'original' usemod look
>                 $currentInitial = $thisInitial; 
>                 $notFirst = 0;
>             }
>         }
>         #$html .= "<li>"; # commented to keep a 'original' usemod look
>         $html .= "   ";
>         if (not($pagename =~ m|(.*)/(.*)|)) {
>             $currentParent = $pagename;
>             $linktext = $pagename;
>         } 
>         else {
>             if ($1 eq $currentParent) {
>                 if ($letterGrouping){  $linktext = "$currentParent/$2";}
>                 else { $html .= "... "; $linktext = "/$2";}                
>             } 
>             else {
>                 $linktext = $pagename;
>             }
>         }
>         if ($notFirst){ $notFirst = 1; $linktext = ", $linktext"; }
>         $html .= &GetPageLinkText($pagename,$linktext);
> 
>         if ($letterGrouping){ $html .= ", "; }
>         else { $html .= "\n<br>"; }
>     }
>     #$html .= "</ol>\n"; # commented to keep a 'original' usemod look
>     $html .= "\n<br>";
>     
>     return $html;
> }
> 
> sub DoLinks {	
> 	print &GetHeader( "", &QuoteHtml( "Full Link List" ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<hr><pre>\n\n\n\n";    # Extra lines to get below the logo
> 
> 	print &PrintLinkList(&GetFullLinkList(
> 		&GetParam("unique", 1),
> 		&GetParam("sort", 1),
> 		&GetParam("page", 1),
> 		&GetParam("inter", 0),
> 		&GetParam("url", 0),
> 		&GetParam("exists", 2),
> 		&GetParam("empty", 0),
> 		&GetParam("search", "")
> 	));
> 	
> 	print "\n</pre>";
> 	print "\n</div>";
> 	print "\n</div></div></body></html>";	
> }
> 
> sub PrintLinkList {
> 	my ( $pagelines, $page,  $names, $editlink );
> 	my ( $link, $text, $extra, @links, %pgExists );
> 	
> 	%pgExists = ();
> 	
> 	foreach $page ( &AllPagesList() ) {
> 		$pgExists{$page} = 1;
> 	}
> 	
> 	$names    = &GetParam( "names",    1 );
> 	$editlink = &GetParam( "editlink", 0 );
> 	
> 	foreach $pagelines (@_) {
> 		@links = ();
> 		
> 		foreach $page ( split( ' ', $pagelines ) ) {
> 			if ( $page =~ /\:/ ) {    # URL or InterWiki form
> 				if ( $page =~ /$UrlPattern/ ) {
> 					( $link, $extra ) = &UrlLink( $page, 0 );    # No images
> 				}
> 				else {
> 					( $link, $extra ) = &InterPageLink( $page, 0 );  # No images
> 				}
> 			}
> 			else {
> 				if ( $pgExists{$page} ) {
> 					$link = &GetPageLink($page);
> 				}
> 				else {
> 					$link = $page;
> 					if ($editlink) {
> 						$link .= &GetEditLink( $page, "?" );
> 					}
> 				}
> 			}
> 			
> 			push( @links, $link );
> 		}
> 		if ( !$names ) {
> 			shift(@links);
> 		}
> 		
> 		$text .= join(' ', @links) . "\n";
> 	}
> 	
> 	return $text;
> }
> 
> sub GetFullLinkList {
> 	my ($unique, $sort, $pagelink, $interlink, $urllink, $exists, $empty, $search, $listWantedPages )= @_ ;
> 	my ($name, $link ); # foreach iterators (though why not use $_ ?)
> 	#my ($name, $unique, $sort, $exists, $empty, $link, $search);
> 	#my ($pagelink, $interlink, $urllink);
> 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
> 	
> 	#$unique = &GetParam("unique", 1);
> 	#$sort = &GetParam("sort", 1);
> 	#$pagelink = &GetParam("page", 1);
> 	#$interlink = &GetParam("inter", 0);
> 	#$urllink = &GetParam("url", 0);
> 	#$exists = &GetParam("exists", 2);
> 	#$empty = &GetParam("empty", 0);
> 	#$search = &GetParam("search", "");
> 	
> 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) {
> 		$pagelink = 0;
> 	}
> 	%pgExists = ();
> 	@pglist   = &AllPagesList();
> 	
> 	foreach $name (@pglist) {
> 		$pgExists{$name} = 1;
> 	}
> 	%seen = ();
> 	
> 	foreach $name (@pglist) {
> 		@newlinks = ();
> 		if ( $unique != 2 ) {
> 			%seen = ();
> 		}
> 		
> 		@links = &GetPageLinks($name, $pagelink, $interlink, $urllink, $listWantedPages);
> 	
> 	    foreach $link (@links) {
> 			if ($link =~ m/^\//){
> 				$name =~ m/(.*)\//;
> 				
> 				if ($1){ $link = $1 . $link; }
> 				else { $link = $name . $link; }
> 			}
> 			
> 			$seen{$link}++;
> 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) {
> 				next;
> 			}
> 			push( @newlinks, $link );
> 		}
> 		
> 		@links = @newlinks;
> 		if ($sort) {
> 			@links = sort(@links);
> 		}
> 		unshift( @links, $name );
> 		
> 		if ( $empty || ( $#links > 0 ) ) {    # If only one item, list is empty.
> 			push( @found, join( ' ', @links ) );
> 		}
> 	}
> 	return @found;
> }
> 
> sub GetSubpages {
> 	my ($parentPage) = @_;
> 	my ($dir, @subpageFiles, @pages, $subId);
> 	
> 	return "" unless $parentPage;
> 	$dir = GetPageDirectory($parentPage);
> 	
> 	opendir(PAGELIST, "$PageDir/$dir/$parentPage") or return "";
> 	@subpageFiles = readdir(PAGELIST);
> 	closedir(PAGELIST);
> 	
> 	foreach $subId (@subpageFiles) {
> 		if (substr($subId, -3) eq '.db') {
> 		  push(@pages, "$parentPage/" . substr($subId, 0, -3));
> 		}
> 	}
> 	return @pages;
> }
> 
> sub GetPageList {
> 	my ($pagename, $retval);
> 	my (@list) = @_;
> 
> 	foreach $pagename (@list) {
> 	##	$retval .= ".... " if ($pagename =~ m|/|);
> 		$retval .= "&nbsp;" . &GetPageLink($pagename) . "<br>";
> 	}
> 
> 	return $retval;
> }
> 
> sub GetPageLinks {
> 	my ( $name, $pagelink, $interlink, $urllink, $listWantedPages ) = @_;
> 	my ( $text, @links );
> 	
> 	@links = ();
> 	&OpenPage($name);
> 	&OpenDefaultText();
> 	
> 	$text = $Text{'text'};
> 	$text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
> 	$text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
> 	$text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
> 	$text =~ s/<tt>(.|\n)*?\<\/tt>/ /ig;
> 	
> 	if ($interlink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to inter-site links
> 		$text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$InterLinkPattern/ /g;
> 	}
> 	
> 	if ($urllink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to URLs
> 		$text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$UrlPattern/ /g;
> 	}
> 	
> 	if ($pagelink) {
> 		if ($FreeLinks) {
> 			my $f2 = $FreeLinkPattern;
> 			
> 			$text =~ s/\[\[$f2\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 			$text =~ s/\[\[$f2\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 		}
> 		
> 		if ($listWantedPages){ $text =~ s/\[((.|\n)*?)\]/ /ig; }
> 			
> 		if ($WikiLinks) {
> 			$text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 		}
> 	}
> 	
> 	return @links;
> }
> 
> sub DoPost {
> 	my ( $editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user );
> 	my $string      = &GetParam( "text",        undef );
> 	my $id          = &GetParam( "title",       "" );
> 	my $summary     = &GetParam( "summary",     "" );
> 	my $oldtime     = &GetParam( "oldtime",     "" );
> 	my $oldconflict = &GetParam( "oldconflict", "" );
> 	my $isEdit      = 0;
> 	my $editTime    = $Now;
> 	my $authorAddr  = $ENV{REMOTE_ADDR};
> 	
> 	if ($id =~ /($LinkPattern)/){
> 		$id = $1;
> 	}
> 	else {
> 		die "The page name $id is not valid";
> 	}
> 	
> 	if ($FreeLinks){
> 		$id = &FreeToNormal($id);
> 	}
> 	
> 	if ( !&UserCanEdit( $id, 1 ) ) {
> 		# This is an internal interface--we don't need to explain
> 		&ReportError( Ts( 'Editing not allowed for %s.', $id ) );
> 		return;
> 	}
> 	
> 	if (   ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'Sample_Undefined_Page' )
> 		|| ( $id eq 'Sample_Undefined_Page' ) )
> 	{
> 		&ReportError( " $id cannot be defined." );
> 		return;
> 	}
> 	
> 	$string  = &RemoveFS($string);
> 	$summary = &RemoveFS($summary);
> 	$summary =~ s/[\r\n]//g;
> 	
> 	if ( length($summary) > 300 ) {    # Too long (longer than form allows)
> 		$summary = substr( $summary, 0, 300 );
> 	}
> 
> 	# Add a newline to the end of the string (if it doesn't have one)
> 	$string .= "\n" if ( !( $string =~ /\n$/ ) );
> 
> 
> 	# Lock before getting old page to prevent races
> 	# Consider extracting lock section into sub, and eval-wrap it?
> 	# (A few called routines can die, leaving locks.)
> 	if ($LockCrash) {
> 		&RequestLock() or die( "Could not get editing lock" );
> 	}
> 	else {
> 		if ( !&RequestLock() ) {
> 			&ForceReleaseLock('main');
> 		}
> 
> 		# Clear all other locks.
> 		&ForceReleaseLock('cache');
> 		&ForceReleaseLock('diff');
> 		&ForceReleaseLock('index');
> 	}
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$old     = $Text{'text'};
> 	$oldrev  = $Section{'revision'};
> 	$pgtime  = $Section{'ts'};
> 	$preview = 0;
> 	$preview = 1 if ( &GetParam( "Preview", "" ) ne "" );
> 	
> 	if ( !$preview && ( $old eq $string ) ) {    # No changes (ok for preview)
> 		&ReleaseLock();
> 		&ReBrowsePage( $id, "", 1 );
> 		return;
> 	}
> 	
> 	if ( ( $UserID > 399 ) || ( $Section{'id'} > 399 ) ) {
> 		$newAuthor = ( $UserID ne $Section{'id'} );    # known user(s)
> 	}
> 	else {
> 		$newAuthor = ( $Section{'ip'} ne $authorAddr );    # hostname fallback
> 	}
> 	$newAuthor = 1 if ( $oldrev == 0 );    # New page
> 	$newAuthor = 0 if ( !$newAuthor );     # Standard flag form, not empty
> 	                                       # Detect editing conflicts and resubmit edit
> 	                                       
> 	if ( ( $oldrev > 0 ) && ( $newAuthor && ( $oldtime != $pgtime ) ) ) {
> 		&ReleaseLock();
> 		if ( $oldconflict > 0 ) {    # Conflict again...
> 			&DoEdit( $id, 2, $pgtime, $string, $preview );
> 		}
> 		else {
> 			&DoEdit( $id, 1, $pgtime, $string, $preview );
> 		}
> 		return;
> 	}
> 	
> 	if ($preview) {
> 		&ReleaseLock();
> 		&DoEdit( $id, 0, $pgtime, $string, 1 );
> 		return;
> 	}
> 	
> 	$user = &GetParam( "username", "" );
> 
> 	# If the person doing editing chooses, send out email notification
> 	if ($EmailNotify) {
> 		&EmailNotify( $id, $user )
> 		  if &GetParam( "do_email_notify", "" ) eq 'on';
> 	}
> 	
> 	if ( &GetParam( "recent_edit", "" ) eq 'on' ) {
> 		$isEdit = 1;
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'oldmajor', $Section{'revision'} );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'oldauthor', $Section{'revision'} );
> 	}
> 	
> 	&SaveKeepSection();
> 	&ExpireKeepFile();
> 	
> 	if ($UseDiff) {
> 		&UpdateDiffs( $id, $editTime, $old, $string, $isEdit, $newAuthor );
> 	}
> 	
> 	$Text{'text'}      = $string;
> 	$Text{'minor'}     = $isEdit;
> 	$Text{'newauthor'} = $newAuthor;
> 	$Text{'summary'}   = $summary;
> 	$Section{'host'}   = &GetRemoteHost(1);
> 	
> 	&SaveDefaultText();
> 	&SavePage();
> 	&WriteRcLog( $id, $summary, $isEdit, $editTime, $Section{'revision'}, $user,
> 		$Section{'host'} );
> 
> 	if ($UseCache) {
> 		&UnlinkHtmlCache($id);    # Old cached copy is invalid
> 		if ( $Page{'revision'} < 2 ) {    # If this is a new page...
> 			&NewPageCacheClear($id);      # ...uncache pages linked to this one.
> 		}
> 	}
> 	
> 	if ( $UseIndex && ( $Page{'revision'} == 1 ) ) {
> 		unlink($IndexFile);               # Regenerate index on next request
> 	}
> 	&ReleaseLock();
> 	&ReBrowsePage( $id, "", 1 );
> }
> 
> sub UpdateDiffs {
> 	my ( $id, $editTime, $old, $new, $isEdit, $newAuthor ) = @_;
> 	my ( $editDiff, $oldMajor, $oldAuthor );
> 	
> 	$editDiff  = &GetDiff( $old, $new, 0 );    # 0 = already in lock
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	if ($UseDiffLog) {
>   		my $editDiff = Diff::diffClassic($old, $new);  # add this line
>   		&WriteDiff($id, $editTime, $editDiff);
> 	}
> 	
> 	&SetPageCache( 'diff_default_minor', $editDiff );
> 	if ( $isEdit || !$newAuthor ) {
> 		&OpenKeptRevisions('text_default');
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'diff_default_major', "1" );
> 	}	
> 	else {
> 		&SetPageCache( 'diff_default_major',
> 			&GetKeptDiff( $new, $oldMajor, 0 ) );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'diff_default_author', "1" );
> 	}	
> 	elsif ( $oldMajor == $oldAuthor ) {
> 		&SetPageCache( 'diff_default_author', "2" );
> 	}
> 	else {
> 		&SetPageCache( 'diff_default_author',
> 			&GetKeptDiff( $new, $oldAuthor, 0 ) );
> 	}
> }
> 
> # Translation note: the email messages are still sent in English
> # Send an email message.
> sub SendEmail {
> 	my ( $to, $from, $reply, $subject, $message ) = @_;
> 
> 	# sendmail options:
> 	#    -odq : send mail to queue (i.e. later when convenient)
> 	#    -oi  : do not wait for "." line to exit
> 	#    -t   : headers determine recipient.
> 	open( SENDMAIL, "| $SendMail -oi -t " ) or die "Can't send email: $!\n";
> 	print SENDMAIL "From: $from\n";
> 	print SENDMAIL "To: $to\n";
> 	print SENDMAIL "Reply-to: $reply\n";
> 	print SENDMAIL "Subject: $subject\n";
> 	print SENDMAIL "$message\n";
> 	close(SENDMAIL) or warn "sendmail didn't close nicely";
> }
> ## Email folks who want to know a note that a page has been modified. - JimM.
> sub EmailNotify {
> 	local $/ = "\n";    # don't slurp whole files in this sub.
> 	
> 	if ($EmailNotify) {
> 		my ( $id, $user ) = @_;
> 		
> 		if ($user) {
> 			$user = " by $user";
> 		}
> 		
> 		my $address;
> 		
> 		return if ( !-f $EmailFile );    # No notifications yet
> 		
> 		open( EMAIL, $EmailFile )
> 		  or die "Can't open $EmailFile: $!\n";
> 		$address = join ",", <EMAIL>;
> 		$address =~ s/\n//g;
> 		close(EMAIL);
> 		
> 		my $home_url        = $q->url();
> 		my $page_url        = $home_url . "?$id";
> 		my $editors_summary = $q->param("summary");
> 
> 		if ( ( $editors_summary eq "*" ) or ( $editors_summary eq "" ) ) {
> 			$editors_summary = "";
> 		}
> 		else {
> 			$editors_summary = " Summary: $editors_summary";
> 		}
> 		
> 		my $content = <<"END_MAIL_CONTENT";
> 
>  The $SiteName page $id at
>    $page_url
>  has been changed$user to revision $Page{revision}. $editors_summary
> 
>  (Replying to this notification will
>   send email to the entire mailing list,
>   so only do that if you mean to.
> 
>   To remove yourself from this list, visit
>   ${home_url}?action=editprefs .)
> END_MAIL_CONTENT
> 		my $subject = "The $id page at $SiteName has been changed.";
> 
> 		# I'm setting the "reply-to" field to be the same as the "to:" field
> 		# which seems appropriate for a mailing list, especially since the
> 		# $EmailFrom string needn't be a real email address.
> 		&SendEmail( $address, $EmailFrom, $address, $subject, $content );
> 	}
> }
> 
> sub SearchTitleAndBody {
> 	my ($term, $filter) = @_;
> 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
> 	
> 	#If the search term has a !preceding it, strip it and set the exclusion flag
> 	if ($term =~ m/^\!/){ 
> 		$excludeTerm = 1;
> 		$term = substr($term, 1);	
> 	}
> 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
> 	if ($filter =~ m/^\!/){ 
> 		$excludeFilter = 1;
> 		$filter = substr($filter, 1);	
> 	}
> 
> 	foreach $name ( &AllPagesList() ) {
> 		if ($excludeFilter){
> 			if ($filter) { next if ($name =~ m/$filter/); }
> 		}
> 		else {
> 			if ($filter) { next unless ($name =~ m/$filter/); }
> 
> 		}
> 		
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if (!$excludeTerm){  
> 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( $freeName =~ /$term/i ) {
> 					push( @found, $name );
> 				}
> 			}
> 		}
> 		else { 
> 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( ! ($freeName =~ /$term/i) ) {
> 					push( @found, $name );
> 				}
> 			}			
> 		}
> 	}
> 	
> 	return @found;
> }
> 
> sub SearchBody {
> 	my ($string) = @_;
> 	my ( $name, @found );
> 	
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if ( $Text{'text'} =~ /$string/i ) {
> 			push( @found, $name );
> 		}
> 	}
> 	
> 	return @found;
> }
> 
> sub UnlinkHtmlCache {
> 	my ($id) = @_;
> 	my $idFile;
> 	
> 	$idFile = &GetHtmlCacheFile($id);
> 	
> 	if ( -f $idFile ) {
> 		unlink($idFile);
> 	}
> }
> 
> sub NewPageCacheClear {
> 	my ($id) = @_;
> 	my $name;
> 	
> 	return if ( !$UseCache );
> 	
> 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
> 	                    # The following code used to search the body for the $id
> 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
> 		&UnlinkHtmlCache($name);
> 	}
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub DoUnlock {
> 	my $LockMessage = "Normal Unlock.";
> 	
> 	print &GetHeader( "", "Removing edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>This operation may take several seconds...</h2>\n";
> 	
> 	if ( &ForceReleaseLock('main') ) {
> 		$LockMessage = "Forced Unlock.";
> 	}
> 	
> 	&ForceReleaseLock('cache');
> 	&ForceReleaseLock('diff');
> 	&ForceReleaseLock('index');
> 	
> 	print "\n<br><h2>$LockMessage</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub WriteRcLog {
> 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
> 	my ( $extraTemp, %extra );
> 	
> 	%extra = ();
> 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
> 	$extra{'name'}     = $name     if ( $name ne "" );
> 	$extra{'revision'} = $revision if ( $revision ne "" );
> 	$extraTemp = join( $FS2, %extra );
> 
> 	# The two fields at the end of a line are kind and extension-hash
> 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
> 	
> 	if ( !open( OUT, ">>$RcFile" ) ) {
> 		die( Ts( '%s log error:', $RCName ) . " $!" );
> 	}
> 	
> 	print OUT $rc_line . "\n";
> 	close(OUT);
> }
> 
> sub WriteDiff {
> 	my ( $id, $editTime, $diffString ) = @_;
> 	
> 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
> 	print OUT "------\n" . $id . "|" . $editTime . "\n";
> 	print OUT $diffString;
> 	close(OUT);
> }
> 
> # Actions are vetoable if someone edits the page before
> # the keep expiry time. For example, page deletion. If
> # no one edits the page by the time the keep expiry time
> # elapses, then no one has vetoed the last action, and the
> # action is accepted.
> # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
> sub ProcessVetos {
> 	my ($expirets);
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	
> 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
> 	
> 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
> 		&DeletePage( $OpenPageName, 1, 1 );
> 		return ( 1, "(deleted)" );
> 	}
> 	
> 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
> 		my $fname = $1;
> 
> 		# Only replace an allowed, existing file.
> 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
> 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
> 				my $string = $1;
> 				
> 				$string =~ s/\r\n/\n/gms;
> 				open( OUT, ">$fname" ) or return 0;
> 				print OUT $string;
> 				close OUT;
> 				
> 				return ( 0, "(replaced)" );
> 			}
> 		}
> 	}
> 	return ( 0, "(done)" );
> }
> 
> sub DoMaintain {
> 	my ( $name, $fname, $data, $message, $status );
> 	
> 	print &GetHeader( "", "Maintenance on all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	$fname = "$DataDir/maintain";
> 	
> 	if ( !&UserIsAdmin() ) {
> 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
> 			print "\nMaintenance not done. ";
> 			print "\n(Maintenance can only be done once every 12 hours.)";
> 			print "\nRemove the 'maintain' file or wait.";
> 			print "\n</div>";
> 			print &GetCommonFooter();
> 			print "\n</div></div></body></html>";
> 			
> 			return;
> 		}
> 	}
> 	
> 	&RequestLock() or die( "Could not get maintain-lock" );
> 
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		( $status, $message ) = &ProcessVetos();
> 		&ExpireKeepFile() unless $status;
> 		
> 		print "\n.... " if ( $name =~ m|/| );
> 		print &GetPageLink($name);
> 		print "\n $message<br>";
> 	}
> 
> 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
> 	&ReleaseLock();
> 
> 	# Do any rename/deletion commands
> 	# (Must be outside lock because it will grab its own lock)
> 	$fname = "$DataDir/editlinks";
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		print "\n<hr>Processing rename/delete commands:<br>";
> 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
> 		unlink("$fname.old");
> 		rename( $fname, "$fname.old" );
> 	}
> 	
> 	if ($MaintTrimRc) {
> 		&RequestLock() or die( "Could not get lock for RC maintenance" );
> 		$status = &TrimRc();                # Consider error messages?
> 		&ReleaseLock();
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Must be called within a lock.
> # Thanks to Alex Schroeder for original code
> sub TrimRc {
> 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
> 
> 	# Determine the number of days to go back
> 	$days = 0;
> 	
> 	foreach (@RcDays) {
> 		$days = $_ if $_ > $days;
> 	}
> 	$starttime = $Now - $days * 24 * 60 * 60;
> 	return 1 if ( !-f $RcFile );    # No work if no file exists
> 	( $status, $data ) = &ReadFile($RcFile);
> 	
> 	if ( !$status ) {
> 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
> 		
> 		return 0;
> 	}
> 
> 	# Move the old stuff from rc to temp
> 	@rc = split( /\n/, $data );
> 	
> 	for ( $i = 0 ; $i < @rc ; $i++ ) {
> 		($ts) = split( /$FS3/, $rc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	
> 	return 1 if ( $i < 1 );    # No lines to move from new to old
> 	
> 	@temp = splice( @rc, 0, $i );
> 
> 	# Write new files and backups
> 	if ( !open( OUT, ">>$RcOldFile" ) ) {
> 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
> 		return 0;
> 	}
> 	print OUT join( "\n", @temp ) . "\n";
> 	close(OUT);
> 	
> 	&WriteStringToFile( $RcFile . '.old', $data );
> 	$data = join( "\n", @rc );
> 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
> 	&WriteStringToFile( $RcFile, $data );
> 	
> 	return 1;
> }
> 
> sub DoMaintainRc {
> 	print &GetHeader( "", "Maintaining RC log", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	&RequestLock() or die( "Could not get lock for RC maintenance" );
> 	
> 	if ( &TrimRc() ) {
> 		print "\n<br>RC maintenance done.<br>";
> 	}
> 	else {
> 		print "\n<br>RC maintenance not done.<br>";
> 	}
> 	&ReleaseLock();
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub UserIsEditorOrError {
> 	if ( !&UserIsEditor() ) {
> 		print "\n<h2>This operation is restricted to site editors only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></body></html>";
> 			
> 		return 0;
> 	}
> 	
> 	return 1;
> }
> 
> sub UserIsAdminOrError {
> 	if ( !&UserIsAdmin() ) {
> 		print "\n<h2>This operation is restricted to administrators only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></body></html>";	
> 		return 0;
> 	}
> 	
> 	return 1;
> }
> 
> sub CheckIsAuthUser {
> 	my ($id) = @_;
> 	my $auth = ""; 
> 	my $found = 0;
> 	my $authtype;
> 	my $authname; 
> 	my $aname;
> 	my $afname;
> 	my $linecount = 0;
> 
> 	if (!(&UserIsAdmin())) {
> 		$aname = $id;
> 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
> 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
> 		
> 		if (-r $afname) {			
> 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
> 			
> 			open (AFN,"<$afname");
> 			while (<AFN>) {
> 				if (/$FS1/) { next; }       	# skip header and footer
> 				if (/^>\s[^\w]/) { next; }  	# skip comments	
> 				if (/diff-/){ next; }		
> 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
> 					$authtype = $1;
> 					$authname = $2; 
> 					
> 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
> 					elsif ($authtype eq "r"){ $authtype = "1"; }
> 					else { $authtype = "1"; }
> 					
> 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
> 				}
> 			}
> 			close AFN;
> 			if ($linecount == 0){ $auth = "3"; }
> 			elsif ($found == 0) { $auth = ""; }
> 		}
> 		else {
> 			$auth = "3";
> 		}
> 	}
> 	else {
> 		$auth = "3";
> 	}
> 	return $auth;
> }
> 
> sub DoEditLock {
> 	my ($fname);
> 	
> 	print &GetHeader( "", "Set or Remove global edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	$fname = "$DataDir/noedit";
> 
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 	
> 	if ( -f $fname ) {
> 		print "\n<h2>Edit lock created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Edit lock removed.</h2>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoPageLock {
> 	my ( $fname, $id );
> 	
> 	print &GetHeader( "", "Set or Remove page edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	# Consider allowing page lock/unlock at editor level?
> 	return if ( !&UserIsAdminOrError() );
> 		
> 	$id = &GetParam( "id", "" );
> 	if ( $id eq "" ) {
> 		print "\n<p>Missing page id to lock/unlock...</p>";
> 		
> 		return;
> 	}
> 	
> 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
> 	$fname = &GetLockedPageFile($id);
> 	
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 
> 	if ( -f $fname ) {
> 		print "\n<h2>Lock for '$id' created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Lock for '$id' removed.</h2>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoEditBanned {
> 	my ( $banList, $status );
> 	
> 	print &GetHeader( "", "Editing Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	return if ( !&UserIsAdminOrError() );
> 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
> 	$banList = "" if ( !$status );
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_ban", 1 );
> 	print "\n<h2> Banned IP/network/host list:</h2>";
> 	print "\nEach entry is either a commented line (starting with #), ";
> 	print "\nor a Perl regular expression (matching either an IP address or ";
> 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
> 	print "\ngive up your admin access (remove password in Preferences).";
> 	print "\n<p><br><b>Example:</b><br><br>";
> 	print "\n# blocks hosts ending with .foocorp.com<br>";
> 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
> 	print "\n# blocks exact IP address<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
> 	print "\n# blocks whole 123.21.3.* IP network<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
> 	print &GetTextArea( 'banlist', $banList, 12, 50 );
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Save' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	;
> }
> 
> sub DoUpdateBanned {
> 	my ( $newList, $fname );
> 	
> 	print &GetHeader( "", "Updating Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$fname = "$DataDir/banlist";
> 	$newList = &GetParam( "banlist", "#Empty file" );
> 	
> 	if ( $newList eq "" ) {
> 		print "\n<p>Empty banned list or error.</p>";
> 		print "\n<p>Resubmit with at least one space character to remove.</p>";
> 	}
> 	elsif ( $newList =~ /^\s*$/s ) {
> 		unlink($fname);
> 		print "\n<p>Removed banned list</p>";
> 	}
> 	else {
> 		&WriteStringToFile( $fname, $newList );
> 		print "\n<p>Updated banned list</p>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # ==== Editing/Deleting pages and links ====
> sub DoEditLinks {
> 	print &GetHeader( "", "Editing Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_links", 1 );
> 	print "\n<h2>Editing/Deleting page titles:</h2>";
> 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
> 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
> 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
> 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
> 	print &GetTextArea( 'commandlist', "", 12, 50 );
> 	print "\n<br><br>";
> 	print $q->checkbox(
> 		-name     => "p_changerc",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Edit $RCName"
> 	);
> 	print "\n<br>";
> 	print $q->checkbox(
> 		-name     => "p_changetext",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Substitute text for rename"
> 	);
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Process Command' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub UpdateLinksList {
> 	my ( $commandList, $doRC, $doText ) = @_;
> 	
> 	if ($doText) {
> 		&BuildLinkIndex();
> 	}
> 	&RequestLock() or die "UpdateLinksList could not get main lock";
> 	unlink($IndexFile) if ($UseIndex);
> 	
> 	foreach ( split( /\n/, $commandList ) ) {
> 		s/\s+$//g;
> 		
> 		next if ( !(/^[=!|?]/) );    # Only valid commands.
> 		print "\nProcessing $_<br>\n";
> 		
> 		if (/^\!(.+)/) {
> 			&DeletePage( $1, $doRC, $doText );
> 		}
> 		elsif (/^\?(.+)/){
> 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
> 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
> 			print "\n<br><br>";
> 		}
> 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
>       		my $GivenPage = $1;
>       		my $GivenNewName = $2;
>       
>       		if ($GivenPage =~ s[\/\*][]) {
>        			print "\nRenaming subpages of $GivenPage too...<br>";
>         
>         		foreach (&AllSubPagesList($GivenPage)) {
> 					my $NewSubName = $_;
> 					
> 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
> 					print "\nrenaming $_ to $NewSubName<br>";
> 					&RenamePage($_, $NewSubName, $doRC, $doText);
> 		        }
>       		}
> 		      # rename the page itself
> 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
> 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
> 		}
> 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
> 			&RenameTextLinks( $1, $2 );
> 		}
> 	}
> 	
> 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
> 	unlink($IndexFile) if ($UseIndex);
> 	&ReleaseLock();
> }
> 
> sub BuildLinkIndex {
> 	my ( @pglist, $page, @links, $link, %seen );
> 	
> 	@pglist    = &AllPagesList();
> 	%LinkIndex = ();
> 	
> 	foreach $page (@pglist) {
> 		&BuildLinkIndexPage($page);
> 	}
> }
> 
> sub BuildLinkIndexPage {
> 	my ($page) = @_;
> 	my ( @links, $link, %seen );
> 	
> 	@links = &GetPageLinks( $page, 1, 0, 0 );
> 	%seen = ();
> 	
> 	foreach $link (@links) {
> 		if ( defined( $LinkIndex{$link} ) ) {
> 			if ( !$seen{$link} ) {
> 				$LinkIndex{$link} .= " " . $page;
> 			}
> 		}
> 		else {
> 			$LinkIndex{$link} .= " " . $page;
> 		}
> 		$seen{$link} = 1;
> 	}
> }
> 
> sub DoUpdateLinks {
> 	my ( $commandList, $doRC, $doText );
> 	
> 	print &GetHeader( "", "Updating Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$commandList = &GetParam( "commandlist", "" );
> 	$doRC        = &GetParam( "p_changerc",  "0" );
> 	$doRC = 1 if ( $doRC eq "on" );
> 	$doText = &GetParam( "p_changetext", "0" );
> 	$doText = 1 if ( $doText eq "on" );
> 	
> 	if ( $commandList eq "" ) {
> 		print "\n<p>Empty command list or error.</p>";
> 	}
> 	else {
> 		&UpdateLinksList( $commandList, $doRC, $doText );
> 		print "\n<p>Finished command list.</p>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub EditRecentChanges {
> 	my ( $action, $old, $new ) = @_;
> 	
> 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
> 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
> }
> 
> sub EditRecentChangesFile {
> 	my ( $fname, $action, $old, $new, $printError ) = @_;
> 	my ( $status, $fileData, $errorText, $rcline, @rclist );
> 	my ( $outrc, $ts, $page, $junk );
> 	
> 	( $status, $fileData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
> 		print $errorText if ($printError);
> 		
> 		return;
> 	}
> 	
> 	$outrc = "";
> 	@rclist = split( /\n/, $fileData );
> 	
> 	foreach $rcline (@rclist) {
> 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
> 		if ( $page eq $old ) {
> 			if ( $action == 1 ) {    # Delete
> 				;                    # Do nothing (don't add line to new RC)
> 			}
> 			elsif ( $action == 2 ) {
> 				$junk = $rcline;
> 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
> 				$outrc .= $junk . "\n";
> 			}
> 		}
> 		else {
> 			$outrc .= $rcline . "\n";
> 		}
> 	}
> 	
> 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
> 	&WriteStringToFile( $fname, $outrc );
> }
> 
> # Delete and rename must be done inside locks.
> sub DeletePage {
> 	my ( $page, $doRC, $doText ) = @_;
> 	my ( $fname, $status );
> 	
> 	$page =~ s/ /_/g;
> 	$page =~ s/\[+//;
> 	$page =~ s/\]+//;
> 	$status = &ValidId($page);
> 	
> 	if ( $status ne "" ) {
> 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$fname = &GetPageFile($page);
> 	unlink($fname) if ( -f $fname );
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	unlink($fname)     if ( -f $fname );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
> 	       # Currently don't do anything with page text
> }
> 
> # Given text, returns substituted text
> sub SubstituteTextLinks {
> 	my ( $old, $new, $text ) = @_;
> 
> 	# Much of this is taken from the common markup
> 	%SaveUrl      = ();
> 	$SaveUrlIndex = 0;
> 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
> 	
> 	if ($RawHtml) {
> 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
> 	}
> 	
> 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
> 	
> 	if ($FreeLinks) {
> 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
> 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
> 	}
> 	
> 	if ($BracketText) {         # Links like [URL text of link]
> 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 	}
> 	
> 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
> 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
> 	
> 	if ($WikiLinks) {
> 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
> 	}
> 
> 	# Thanks to David Claughton for the following fix
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
> }
> 
> sub SubFreeLink {
> 	my ( $link, $name, $old, $new ) = @_;
> 	my ($oldlink);
> 	
> 	$oldlink = $link;
> 	$link =~ s/^\s+//;
> 	$link =~ s/\s+$//;
> 	
> 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
> 	{
> 		$link = $new;
> 	}
> 	
> 	else {
> 		$link = $oldlink;    # Preserve spaces if no match
> 	}
> 	
> 	$link = "[[$link";
> 	
> 	if ( $name ne "" ) {
> 		$link .= "|$name";
> 	}
> 	
> 	$link .= "]]";
> 	
> 	return &StoreRaw($link);
> }
> 
> sub SubWikiLink {
> 	my ( $link, $old, $new ) = @_;
> 	my ($newBracket);
> 	
> 	$newBracket = 0;
> 	
> 	if ( $link eq $old ) {
> 		$link = $new;
> 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
> 			$link = "[[$link]]";
> 		}
> 	}
> 	
> 	return &StoreRaw($link);
> }
> 
> # Rename is mostly copied from expire
> sub RenameKeepText {
> 	my ( $page, $old, $new ) = @_;
> 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
> 	my ( $sectName, $newText );
> 	
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	return if ( !( -f $fname ) );
> 	( $status, $data ) = &ReadFile($fname);
> 	return if ( !$status );
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;
> 	}
> 
> 	# First pass: optimize for nothing changed
> 	$changed = 0;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$changed = 1 if ( $Text{'text'} ne $newText );
> 		}
> 	}
> 	
> 	return if ( !$changed );    # No sections changed
> 	open( OUT, ">$fname" ) or return;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$Text{'text'} = $newText;
> 			$tempSection{'data'} = join( $FS3, %Text );
> 			print OUT $FS1, join( $FS2, %tempSection );
> 		}
> 		else {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
> }
> 
> sub RenameTextLinks {
> 	my ( $old, $new ) = @_;
> 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
> 	my ( $oldCanonical, @pageList );
> 	$old =~ s/ /_/g;
> 	$oldCanonical = &FreeToNormal($old);
> 	$new =~ s/ /_/g;
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$old =~ s/_/ /g;
> 	$new =~ s/_/ /g;
> 
> 	# Note: the LinkIndex must be built prior to this routine
> 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
> 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
> 	foreach $page (@pageList) {
> 		$changed = 0;
> 		&OpenPage($page);
> 		foreach $section ( keys %Page ) {
> 			if ( $section =~ /^text_/ ) {
> 				&OpenSection($section);
> 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
> 				$oldText = $Text{'text'};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Text{'text'} = $newText;
> 					$Section{'data'} = join( $FS3, %Text );
> 					$Page{$section} = join( $FS2, %Section );
> 					$changed = 1;
> 				}
> 			}
> 			elsif ( $section =~ /^cache_diff/ ) {
> 				$oldText = $Page{$section};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Page{$section} = $newText;
> 					$changed = 1;
> 				}
> 			}
> 
> 			# Add other text-sections (categories) here
> 		}
> 		if ($changed) {
> 			$file = &GetPageFile($page);
> 			&WriteStringToFile( $file, join( $FS1, %Page ) );
> 		}
> 		&RenameKeepText( $page, $old, $new );
> 	}
> }
> 
> sub RenamePage {
> 	my ( $old, $new, $doRC, $doText ) = @_;
> 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
> 	
> 	$old =~ s/ /_/g;
> 	$new    = &FreeToNormal($new);
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$newfname = &GetPageFile($new);
> 	if ( -f $newfname ) {
> 		print "\nRename: new page $new already exists--not renamed.<br>";
> 		return;
> 	}
> 	$oldfname = &GetPageFile($old);
> 	if ( !( -f $oldfname ) ) {
> 		print "\nRename: old page $old does not exist--nothing done.<br>";
> 		return;
> 	}
> 	
> 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
> 	rename( $oldfname, $newfname );
> 	&CreatePageDir( $KeepDir, $new );
> 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
> 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
> 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
> 	rename( $oldkeep, $newkeep );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
> 
> 	if ($doText) {
> 		&BuildLinkIndexPage($new);          # Keep index up-to-date
> 		&RenameTextLinks( $old, $new );
> 	}
> }
> 
> sub DoShowVersion {
> 	print &GetHeader( "", "Displaying Wiki Version", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>NobleWiki</h2>";
> 	print "\n<p>derived from UseModWiki version 1.0</p>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
> 	my ( $id, $status, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
> }
> sub GetGallery {
> 	my ($params) = @_;
> 	my @lines = split(/\r?\n/, $params);
> 	my $lineNum = 0;
> 	my $imageNum = 0;
> 	my %options;
> 	my $images = "";
> 	my $text = "";
> 	
> 	my $defaultImage = "image1.jpg";
> 	my $defaultThumb = "thumb_image1.jpg";
> 	my $image;
> 	my $thumb;
> 	my $title;
> 	my $header;
> 	my $caption;
> 	my $description;
> 	my $thumbWidth = 100;
> 	
> 	$GLOBAL_galleryCount++;
> 		
> 	foreach my $line (@lines){
> 		%options = &GetOptions($line);
> 		
> 		if ($lineNum == 0){
> 			$lineNum++;
> 			
> 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
> 			if ($options{'description'}){ $description = $options{'description'}; }
> 			if ($options{'header'}){ $header = $options{'header'}; }
> 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
> 			
> 			next;	
> 		}
> 		else {		
> 			if ($options{'image'}){ $image = $options{'image'}; }
> 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
> 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
> 			
> 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
> 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
> 			
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
> 				
> 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
> 		}
> 	}
> 	
> 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
> 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
> 	
> 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
> 	
> 	$text .= "\n	    <ul>";	
> 	$text .= $images;
> 	$text .= "\n	    </ul>";
> 	
> 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
> 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
> 	
> 	$text .= "\n	</div>";		
> 	
> 	return $text;
> }
> 
> sub GetFlash {
> 	my ($options) = @_;
> 	my %options = &GetOptions($options);	
> 	my $fpath = "$UploadUrl/";
> 	my $defaultSWF = 'ufo.swf';
> 	my $maxWidth = 400;
> 	my $maxHeight = 300;
> 	my $ratio = 1;
> 	
> 	my $text = "";
> 	
> 	my $fname;
> 	my $fwidth;
> 	my $fheight;
> 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
> 	my $idFO = "FO_$GLOBAL_flashCount";
> 
> 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
> 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
> 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
> 	
> 	if ($fwidth > $maxWidth){
> 		$ratio = $maxWidth / $fwidth;
> 		$fwidth = $maxWidth;
> 		$fheight = int ($ratio * $fheight);
> 	}
> 	elsif ($fheight > $maxHeight){
> 		$ratio = $maxHeight / $fheight;
> 		$fheight = $maxHeight;
> 		$fwidth = int ($ratio * $fwidth);
> 	}
> 			
> 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
> 	
> 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
> 	$text .= "\n<script type='text/javascript'>";
> 	$text .= "\n			var fpath = '$fpath';";
> 	$text .= "\n			var fname = '$fname';";
> 	$text .= "\n			var fwidth = $fwidth;";
> 	$text .= "\n			var fheight = $fheight;";
> 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
> 	$text .= "\n			\$(window).load(function () {";
> 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
> 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
> 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
> 	$text .= "\n		    });";
> 	$text .= "\n		</script>";		
> 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
> 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
> 	$text .= "\n		<p style='clear: both;'></p>";
> 	$text .= "\n	</div>";
> 
> 	$GLOBAL_flashCount++;
> 	
> 	return $text;		
> }
> sub GetAdminBar {
> 	my ($id, $cssClass) = @_;
> 	my ($result);
> 
> 	$result .= "\n<div $cssClass>";
> 	$result .= "Administration: ";
> 	
> 	my ($notValid) = $id =~ /^\d*$/;
> 	
> 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
> 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
> 	} 
> 		
> 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
> 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
> 	
> 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
> 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
> 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
> 	$result .= " | " . &ScriptLink("action=orphans", "List Orphans" );
> 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
> 			
> 	if ( -f "$DataDir/noedit" ) {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
> 	}
> 	else {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
> 	}
> 	
> 	$result .= "</div>";
> 	
> 	return $result;
> }
> 
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
> 	my ($id) = @_;
> 	
> 	return if ( !&ValidIdOrDie($id) );
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
> 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		print "\n<h2>Delete Page?</h2>";
> 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
> 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";	
> 		
> 		return;
> 	}
> 	
> 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
> 	print &GetLeftNav("");	
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $id eq $HomePage ) {
> 		print Ts( '%s can not be deleted.', $HomePage );
> 	}
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) {
> 			print Ts( '%s can not be deleted because it is locked.', $id );
> 		}
> 		else {
> 
> 			# Must lock because of RC-editing
> 			&RequestLock() or die( "Could not get editing lock" );
> 			DeletePage( $id, 1, 1 );
> 			&ReleaseLock();
> 			print Ts( '%s has been deleted.', $id );
> 		}
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
> 	print &GetHeader( "", "File Upload Page", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<h2>Select File</h2>";
> 	print "\nThe current upload size limit is $MaxPost.<br>";
> 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
> 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
> 	print "\n<input type='hidden' name='upload' value='1' />";
> 	print "\nFile to Upload: ";
> 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
> 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub SaveUpload {
> 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
> 	print &GetHeader( "", "Upload Finished", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$filename = $q->param('file');
> 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
> 	
> 	$uploadFilehandle = $filename;
> 	open UPLOADFILE, ">$UploadDir$filename";
> 	binmode(UPLOADFILE);	
> 	while (<$uploadFilehandle>) { print UPLOADFILE; }
> 	close UPLOADFILE;
> 	
> 
> 	print "\n<h2>Upload Completed</h2>";
> 	print "\nThe wiki link to your file is:<br><br>";
> 	
> 	$printFilename = $filename;
> 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
> 	$fileUrl = $UploadUrl . $printFilename;
> 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
> 
> 	if ( $filename =~ /${ImageExtensions}$/ ) {
> 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub ConvertFsFile {
> 	my ( $oldFS, $newFS, $fname ) = @_;
> 	my ( $oldData, $newData, $status );
> 	
> 	return if ( !-f $fname );           # Convert only existing regular files
> 	( $status, $oldData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
> 		
> 		return;
> 	}
> 	
> 	$newData = $oldData;
> 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
> 	
> 	return if ( $oldData eq $newData );    # Do not write if the same
> 	&WriteStringToFile( $fname, $newData );
> 
> 	# print $fname . '<br>';    # progress report
> }
> 
> # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
> # Note that top level directory (page/keep/user) contains only dirs
> sub ConvertFsDir {
> 	my ( $oldFS, $newFS, $topDir ) = @_;
> 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	@dirs = sort(@dirs);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$topDir/$dir" );             # Top level directories only
> 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
> 		
> 		opendir( DIRLIST, "$topDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
> 			$fname = "$topDir/$dir/$file";
> 			if ( -f $fname ) {
> 				# print $fname . '<br>';   # progress
> 				&ConvertFsFile( $oldFS, $newFS, $fname );
> 			}
> 			elsif ( -d $fname ) {
> 				opendir( DIRLIST, $fname );
> 				@subFiles = readdir(DIRLIST);
> 				closedir(DIRLIST);
> 				
> 				foreach $subFile (@subFiles) {
> 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
> 					$subFname = "$fname/$subFile";
> 					if ( -f $subFname ) {
> 						# print $subFname . '<br>';   # progress
> 						&ConvertFsFile( $oldFS, $newFS, $subFname );
> 					}
> 				}
> 			}
> 		}
> 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
> 	}
> }
> 
> sub ConvertFsCleanup {
> 	my ($topDir) = @_;
> 	my ( @dirs, $dir );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-f "$topDir/$dir" );             # Remove only files...
> 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
> 		unlink "$topDir/$dir";
> 	}
> }
> 
> sub DoConvert {
> 	my $oldFS = "\xb3";
> 	my $newFS = "\x1e\xff\xfe\x1e";
> 	
> 	print &GetHeader( "", "Convert wiki DB", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";	
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $FS ne $newFS ) {
> 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
> 		return;
> 	}
> 	
> 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
> 	print "\nWiki DB locked for conversion.<br>";
> 	print "\nConverting Wiki DB...<br>";
> 	
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
> 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
> 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
> 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
> 	&ConvertFsCleanup($PageDir);
> 	&ConvertFsCleanup($KeepDir);
> 	&ConvertFsCleanup($UserDir);
> 	
> 	print "\nFinished converting wiki DB.<br>";
> 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Remove user-id files if no useful preferences set
> sub DoTrimUsers {
> 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
> 	my ( @dirs, @files, $dir, $file, $item );
> 	
> 	print &GetHeader( "", "Trim wiki users", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$removed = 0;
> 	$maxID   = 1001;
> 	opendir( DIRLIST, $UserDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
> 		
> 		opendir( DIRLIST, "$UserDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
> 				$id    = $1;
> 				$maxID = $id if ( $id > $maxID );
> 				%Data  = ();
> 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
> 				
> 				if ($status) {
> 					%Data =
> 					  split( /$FS1/, $data, -1 )
> 					  ;    # -1 keeps trailing null fields
> 					$keep = 0;
> 					
> 					foreach $item (qw(username password adminpw stylesheet)) {
> 						$keep = 1
> 						  if ( defined( $Data{$item} )
> 							&& ( $Data{$item} ne "" ) );
> 					}
> 					
> 					if ( !$keep ) {
> 						unlink "$UserDir/$dir/$file";
> 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
> 						$removed += 1;
> 					}
> 				}
> 			}
> 		}
> 	}
> 	print Ts( 'Removed %s files.', $removed ) . '<br>';
> 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoAssetsToc {
> 	## Check $DataDir and see if assets-toc exists
> 	## -- if not, then build TOC
> 	## -- if does, but is older than 1 minute, rebuild TOC
> 	## Return TOC	
> }
> sub DoFilterToc {
> 	## Given @filters, pageIndex, pageSize
> 	## Get TOC from DoAssetsTOC
> 	## Apply @filters; sort, apply pageIndex * pageSize as offset
> 	## Return FilteredTOC	
> }
> sub DoListFiles {
> 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
> 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
> 	my ( $id, $filter, $managedisabled ) = @_;
> 
> 	if ($managedisabled){ 
> 		$targetDir = "$DisabledDir";
> 	}
> 	else {
> 		$targetDir = "$UploadDir";
> 	}
> 
> 	# CREATE array of filters
> 	$filter = lc($filter);
> 	$filter =~ s/\s//go;
> 	if ($filter ne ""){ 
> 		if ($filter =~ m/,/){
> 			@filters = split(',', $filter);
> 			
> 		}
> 		else {
> 			push (@filters, $filter);
> 		}
> 		$term = "using '<em>$filter</em>'";
> 	}
> 		
> 	# READ DIRECTORY	
> 	opendir( DIRLIST, $targetDir );
> 	@list = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	# RUN INCLUSIVE FILTERS
> 	foreach $file (@list){		
> 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
> 		
> 		if ($filter eq ""){  push @includes, $file; next; }
> 		
> 		$qualifies = 0;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;
> 			$include = $item;
> 					
> 			if ($item =~ m/^\!/){ next; }
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
> 		}
> 		
> 		if ($qualifies){ push @includes, $file; }
> 	}
> 
> 	# RUN EXCLUSIVE FILTERS
> 
> 	foreach $file (@includes){
> 		if ($filter eq ""){  push @files, $file; next; }
> 				
> 		$qualifies = 1;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;					
> 			unless ($item =~ m/^\!/){ next; }
> 			$include = substr($item, 1);
> 
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
> 		}
> 		
> 		if ($qualifies){ push @files, $file; }
> 	}
> 	
> 	print &GetHeader( "", "Manage Assets", "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikidiff'>";
> 	
> 	#return if ( !&UserIsEditorOrError() );
> 		
> 	if ($managedisabled){
> 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
> 		
> 		# MOVE file to disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $keeppath){
> 				if (-w $UploadDir){
> 					if (rename($keeppath, $uploadpath)){
> 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
> 		
> 		# MOVE file from disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $uploadpath){
> 				if (-w $DisabledDir){
> 					if (rename($uploadpath, $keeppath)){
> 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
> 	
> 	foreach $file (@files) {
> 		$filecount++;
> 		$linkname = "upload:$file";
> 		
> 		@links = SearchTitleAndBody($file, "", "");
> 		$numlinks = scalar(@links);
> 
> 		$title = "";
> 		$action = "";
> 			
> 		if ($managedisabled){			
> 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td>$file</td>";
> 			print "\n<td>$size</td>";			
> 			
> 			if ( &UserIsEditorOrAdmin() ){
> 				$title = "Click to re-enable file.";
> 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
> 			}
> 		}
> 		else {		
> 			$uploadpath = "$UploadUrl/$file";
> 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
> 			print "\n<td>$size</td>";
> 			
> 			if ($numlinks > 0){
> 				$title = "Click to see what pages link to this file.";
> 				$action = "href='$ScriptName?back=$file'";
> 			}
> 			elsif ( &UserIsEditorOrAdmin() ){
> 				$numlinks = "0";
> 				$title = "Click to disable file.";
> 				$action = "href='$ScriptName?action=listfiles&id=$file'";
> 			}		
> 		}
> 
> 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
> 		print "\n</tr>";
> 	}
> 	
> 	if (scalar(@files) == 0){
> 		print "\n<td colspan='4'>No files available</td></tr>";
> 	}
> 	print "\n</table>";
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
> 	print "\n<input type='submit' value='Apply Filter'>";
> 	
> 	
> 	if ($managedisabled){
> 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
> 	}
> 	else {
> 		print "\n<input type='hidden' name='action' value='listfiles'>";
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
> 	}
> 	print "\nUse ! to exclude a term, separate terms with a comma";
> 	print "\n</form>";
> 	print "\n</div>";
> 	print $WikiLineFooter;
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";				
> }
> 
> 
> #END_OF_OTHER_CODE
> &DoWikiRequest() if ( $RunCGI && ( $_ ne 'nocgi' ) );    # Do everything.
> 1;    # In case we are loaded from elsewhere
> 
> # == End of UseModWiki script. ===========================================
------
SandBox|1195622164
100c100
< $StyleSheet = "/css/default.css";   # URL for CSS stylesheet (like "/wiki.css")
---
> $StyleSheet = "/css/wiki.default.css";   # URL for CSS stylesheet (like "/wiki.css")
165c165
< $InclusionDir = "$DataDir/includes-data"; 
---
> $InclusionDir = "$DataDir/includes-data";
299a300
> 	
305a307
> 	
308a311
> 		
318a322
> 	
324,325c328
< 	$LpA =
< 	  $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
---
> 	$LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
339a343
> 	
347a352
> 	
427,429c432,434
< 	if ( $id =~ /^([a-zA-Z])/ ) {
< 		return uc($1);
< 	}
---
> 	
> 	if ( $id =~ /^([a-zA-Z])/ ) { return uc($1); }
> 	
434a440
> 	
437a444
> 	
442a450
> 	
444a453
> 	
449a459
> 	
451a462
> 	
464d474
< 	$CGI::POST_MAX = $MaxPost;
465a476,477
> 	$CGI::POST_MAX = $MaxPost;
> 	
514a527
> 	
535a549
> 	
552a567
> 	
578a594
> 	
586a603
> 	
691a709
> 	
744a763
> 	
759a779
> 	
765a786
> 	
789a811
> 	
808a831
> 	
821a844
> 	
851a875
> 	
858a883
> 	
891a917
> 	
908a935
> 	
977a1005
> 		
978a1007
> 		
993a1023
> 		
1017a1048
> 	
1020a1052
> 	
1025a1058
> 	
1026a1060
> 	
1040a1075
> 	
1056a1092
> 	
1069,1071c1105,1107
< 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) {
< 		$link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  ";
< 	}
---
> 	
> 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) { $link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  "; }
> 	
1075a1112
> 	
1086,1087c1123,1125
< 	my $ChannelAbout =
< 	  &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
---
> 	
> 	my $ChannelAbout = &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
> 	
1147a1186
> 	
1155a1195
> 	
1158a1199
> 	
1159a1201
> 	
1194c1236
< 	@pageList = &AllPagesList();                              # Optimize?
---
> 	@pageList = &AllPagesList();       # Optimize?
1238a1281
> 	
1242c1285
< 	print "\n</div></div></body></html>";	
---
> 	print "\n</div></div></body></html>";
1261a1305
> 	
1266,1271c1310,1313
< 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) {
< 		$host = $sect{'host'};
< 	}
< 	else {
< 		$host = $sect{'ip'};
< 	}
---
> 	
> 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) { $host = $sect{'host'}; }
> 	else { $host = $sect{'ip'};	}
> 	
1281a1324
> 		
1289a1333
> 	
1303a1348
> 	
1313a1359
> 	
1314a1361
> 	
1320,1322c1367,1368
< 	if ($SlashLinks) {
< 		return '/';
< 	}
---
> 	if ($SlashLinks) { return '/'; }
> 	
1333a1380
> 	my $result = "<a href='$ScriptName" . &ScriptLinkChar() . "$action' class='$class' title='$title'>$text</a>";
1335,1337c1382
< 	return "<a href='$ScriptName"
< 	  . &ScriptLinkChar()
< 	  . "$action' class='$class' title='$title'>$text</a>";
---
> 	return $result;
1375c1420
< 	return &ScriptLink("action=orphans", T('Orphans'));
---
> 	return &ScriptLink("action=orphans", 'Orphans');
1379c1424
< 	print &GetHeader("", &QuoteHtml(T('Full Orphan List')), "");
---
> 	print &GetHeader("", &QuoteHtml('Full Orphan List'), "");
1393,1395c1438
< 	foreach my $name (@pglist) {
< 		$seen{$name} = 0;
< 	}
---
> 	foreach my $name (@pglist) { $seen{$name} = 0; }
1412,1414c1455,1456
< 	foreach my $name (sort keys %seen) {
< 		push(@found, $name) if $seen{$name} < 1;
< 	}
---
> 	foreach my $name (sort keys %seen) { push(@found, $name) if $seen{$name} < 1; }
> 	
1442a1485
> 	
1452a1496
> 	
1481a1526
> 	
1486a1532
> 	
1487a1534
> 	
1492a1540
> 	
1493a1542
> 	
1533a1583
> 	
1539,1544c1589,1591
< 	if ($EditNameLink) {
< 		return &GetEditLink( $id, $name );
< 	}
< 	else {
< 		return &GetCreateNewLink( $id, $name );
< 	}
---
> 	
> 	if ($EditNameLink) { return &GetEditLink( $id, $name ); }
> 	else { return &GetCreateNewLink( $id, $name ); }
1557d1603
< 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
1558a1605,1606
> 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
> 	
1588a1637
> 	
1591a1641
> 	
1605a1656
> 	
1608a1660
> 	
1614a1667
> 	
1620,1622c1673,1675
< 	if ($FreeLinks) {
< 		$id =~ s/ /_/g;
< 	}
---
> 	
> 	if ($FreeLinks) { $id =~ s/ /_/g; }
> 	
1684c1737,1739
< 	$result .= "</div>";	
---
> 	
> 	$result .= "</div>";
> 		
1690a1746
> 	
1710a1767
> 	
1827,1829c1884
< 	if ( &GetParam( 'embed', $EmbedWiki ) ) {
< 		return "";
< 	}
---
> 	if ( &GetParam( 'embed', $EmbedWiki ) ) { return ""; }
1962,1964c2017
< 	if ( $UseUpload && &UserCanUpload() ) {
< 		$bartext .= " | " . &GetUploadLink();
< 	}
---
> 	if ( $UseUpload && &UserCanUpload() ) { $bartext .= " | " . &GetUploadLink(); }
1968,1970c2021,2022
< 	if ( &GetParam( "linkrandom", 0 ) ) {
< 		$bartext .= " | " . &GetRandomLink();
< 	}
---
> 	if ( &GetParam( "linkrandom", 0 ) ) { $bartext .= " | " . &GetRandomLink(); }
> 	if ( $UserGotoBar ne "" ) { $bartext .= " | " . $UserGotoBar; }
1972,1974c2024
< 	if ( $UserGotoBar ne "" ) {
< 		$bartext .= " | " . $UserGotoBar;
< 	}
---
> 	$bartext .= "</div>";
1976,1977d2025
< 	$bartext .= "</div>";
< 	
1986,1992c2034,2037
< 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";	
< 	if ($SearchButton) {
< 		$html .= " " . $q->submit( 'dosearch', "Go!" );
< 	}
< 	else {
< 		$html .= &GetHiddenValue( "dosearch", 1 );
< 	}
---
> 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";
> 		
> 	if ($SearchButton) { $html .= " " . $q->submit( 'dosearch', "Go!" ); }
> 	else { $html .= &GetHiddenValue( "dosearch", 1 ); }
1994a2040
> 	
2070,2072c2116
< 	if ($RawHtml) {
< 		$pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
< 	}
---
> 	if ($RawHtml) { $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige; }
2108,2110c2151
< 	if ( $LateRules ne "" ) {
< 		$pageText = &EvalLocalRules( $LateRules, $pageText, 0 );
< 	}
---
> 	if ( $LateRules ne "" ) { $pageText = &EvalLocalRules( $LateRules, $pageText, 0 ); }
2125c2166
< 			or &ReportError(T("Cannot open $FileName: $!"));
---
> 			or &ReportError("Cannot open $FileName: $!");
2131c2172
< 			or &ReportError(T("Cannot close $FileName: $!"));
---
> 			or &ReportError("Cannot close $FileName: $!");
2251,2253c2292,2294
< 			# 0 = no line-oriented, 1 or 2 = do line-oriented
< 		    # The quote markup patterns avoid overlapping tags (with 5 quotes)
< 		    # by matching the inner quotes for the strong pattern.
---
> 		# 0 = no line-oriented, 1 or 2 = do line-oriented
> 	    # The quote markup patterns avoid overlapping tags (with 5 quotes)
> 	    # by matching the inner quotes for the strong pattern.
2258d2298
< 		 ## s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
2511a2552
> 	
2572,2574c2613
< 	if ( $SaveNumUrl{$id} > 0 ) {
< 		return $SaveNumUrl{$id};
< 	}
---
> 	if ( $SaveNumUrl{$id} > 0 ) { return $SaveNumUrl{$id}; }
2667c2706
< 	return &StoreRaw(T('No template name')) unless $templateId;
---
> 	return &StoreRaw('No template name') unless $templateId;
2755c2794
< 	return 1 if ( $file =~ m/\.(jpg|bmp|pdf|gif|psd|ai|xls|ppt|js|css|doc|txt)$/ );
---
> 	return 1 if ( $file =~ m/\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
2907a2947
> 	
2912a2953
> 	
2917a2959
> 	
3021d3062
< 	#my ( $depth, $text ) = @_;
3024c3065
< 	return "" unless --$depth > 0;    # Don't number H1s because it looks stupid
---
> 	return "" unless --$depth > 0;
3074a3116
> 	
3077c3119
< 	##$text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e;    # $' == $POSTMATCH
---
> 		
3082a3125
> 	
3194a3238
> 	
3197a3242
> 	
3204a3250
> 	
3210a3257
> 	
3276a3322
> 	
3286a3333
> 	
3304d3350
< 	%Text = ();
3306,3311c3352
< 	if ( $NewText ne "" ) {
< 		$Text{'text'} = $NewText;
< 	}
< 	else {
< 		$Text{'text'} = "Describe the new page here.";
< 	}
---
> 	%Text = ();
3312a3354,3356
> 	if ( $NewText ne "" ) { $Text{'text'} = $NewText; }
> 	else { $Text{'text'} = "Describe the new page here."; }
> 	
3322a3367
> 	
3332c3377,3378
< 	
---
> 	if ( $id eq ""){ return; }
> 		
3345,3347c3391
< 	if ( $Page{'version'} != 3 ) {
< 		&UpdatePageVersion();
< 	}
---
> 	if ( $Page{'version'} != 3 ) { &UpdatePageVersion(); }
3354,3359c3398,3400
< 	if ( !defined( $Page{$name} ) ) {
< 		&OpenNewSection( $name, "" );
< 	}
< 	else {
< 		%Section = split( /$FS2/, $Page{$name}, -1 );
< 	}
---
> 	
> 	if ( !defined( $Page{$name} ) ) { &OpenNewSection( $name, "" ); }
> 	else { %Section = split( /$FS2/, $Page{$name}, -1 ); }
3363a3405
> 	
3379a3422
> 	
3385a3429
> 	
3391a3436
> 	
3399a3445
> 	
3410a3457
> 	
3419a3467
> 	
3435a3484
> 	
3436a3486
> 	
3446a3497
> 	
3522a3574
> 	
3546a3599
> 	
3553a3607
> 	
3558a3613
> 	
3582a3638
> 	
3639a3696
> 	
3667a3725
> 	
3673a3732
> 	
3683a3743
> 	
3728a3789
> 	
3734a3796
> 	
3737a3800
> 	
3745a3809
> 	
3750a3815
> 	
3771a3836
> 	
3808a3871
> 	
3814a3878
> 	
3820a3885
> 	
3824a3890
> 	
3829a3896
> 	
3836a3904
> 	
3843a3912
> 	
3850a3920
> 	
3856a3927
> 	
3859a3931
> 	
3868a3941
> 	
3878a3952
> 	
3958a4032
> 	
3965a4040
> 	
4334,4336c4409
< 	if ( $preview && !$isConflict ) {
< 		$oldText = $newText;
< 	}
---
> 	if ( $preview && !$isConflict ) { $oldText = $newText; }
4339a4413
> 	
4371a4446
> 	
4391,4393c4466
< 	if ( $revision ne "" ) {
< 		print &GetHiddenValue( "revision", $revision );
< 	}
---
> 	if ( $revision ne "" ) { print &GetHiddenValue( "revision", $revision ); }
4439,4441c4512,4513
< 	if ( $EditNote ne "" ) {
< 		print $EditNote . '<br>';
< 	}
---
> 	if ( $EditNote ne "" ) { print $EditNote . '<br>'; }
> 	
4473c4545,4546
< 		print "\n<div id='wikipreview' class='wikipreview'>";				
---
> 		print "\n<div id='wikipreview' class='wikipreview'>";
> 					
4494c4567,4569
< 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }		
---
> 	
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
> 			
4771a4847
> 	
4992,4997c5067,5069
< 	if ($success) {
< 		print "\n<h2>Login for user ID $uid complete.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Login for user ID $uid failed.</h2>";
< 	}
---
> 	if ($success) { print "\n<h2>Login for user ID $uid complete.</h2>"; }
> 	else { print "\n<h2>Login for user ID $uid failed.</h2>"; }
> 	
5008,5010c5080,5082
< 	while ( -f &UserDataFilename( $id + 1000 ) ) {
< 		$id += 1000;
< 	}
---
> 	while ( -f &UserDataFilename( $id + 1000 ) ) { $id += 1000; }
> 	while ( -f &UserDataFilename( $id + 100 ) ) { $id += 100; }
> 	while ( -f &UserDataFilename( $id + 10 ) ) { $id += 10; }
5012,5014c5084,5086
< 	while ( -f &UserDataFilename( $id + 100 ) ) {
< 		$id += 100;
< 	}
---
> 	&RequestLock() or die( "Could not get user-ID lock" );
> 
> 	while ( -f &UserDataFilename($id) ) { $id++; }
5016,5018c5088,5089
< 	while ( -f &UserDataFilename( $id + 10 ) ) {
< 		$id += 10;
< 	}
---
> 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
> 	&ReleaseLock();
5020,5027d5090
< 	&RequestLock() or die( "Could not get user-ID lock" );
< 	while ( -f &UserDataFilename($id) ) {
< 		$id++;
< 	}
< 	
< 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
< 	&ReleaseLock();
< 	
5055a5119
> 	
5163c5227
<         if ($letterGrouping){ $html .= ", "; }
---
>         if ($letterGrouping){ if ($notFirst){ $html .= ", "; }}
5245a5310,5311
> 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
> 
5247,5249c5313
< 	#my ($pagelink, $interlink, $urllink);
< 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
< 	
---
> 	#my ($pagelink, $interlink, $urllink);	
5314a5379
> 	
5333a5399
> 	
5408c5474
< 	if ($id =~ /($LinkPattern)/){
---
> 	if ($id =~ /()/){
5482a5549
> 	
5551a5619
> 	
6561a6630
> 	
6795c6864
< 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
---
> 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
7273c7340
< 			print "\n<td>$size</td>";			
---
> 			print "\n<td align='right'>$size</td>";			
7287c7354
< 			print "\n<td>$size</td>";
---
> 			print "\n<td align='right'>$size</td>";
7324d7391
< 	print $WikiLineFooter;
------
SandBox|1195622592
1,7401d0
< #!E:/Program Files/perl/bin/perl.exe
< # UseModWiki version 1.0 (September 12, 2003)
< # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
< # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
< # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
< #    <marcus@ira.uka.de>
< # ...which was based on
< #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
< #    and The Original WikiWikiWeb  (C) Ward Cunningham
< #        <ward@c2.com> (code reused with permission)
< # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
< #
< # This program is free software; you can redistribute it and/or modify
< # it under the terms of the GNU General Public License as published by
< # the Free Software Foundation; either version 2 of the License, or
< # (at your option) any later version.
< #
< # This program is distributed in the hope that it will be useful,
< # but WITHOUT ANY WARRANTY; without even the implied warranty of
< # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< # GNU General Public License for more details.
< #
< # You should have received a copy of the GNU General Public License
< # along with this program; if not, write to the
< #    Free Software Foundation, Inc.
< #    59 Temple Place, Suite 330
< #    Boston, MA 02111-1307 USA
< use Diff;
< use MagicContent;
< use Image::Size;
< 
< package UseModWiki;
< use strict;
< local $| = 1;    # Do not buffer output (localized for mod_perl)
< 
< # Configuration/constant variables:
< use vars qw(@RcDays @HtmlPairs @HtmlSingle
<   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
<   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
<   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
<   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
<   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
<   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
<   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
<   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
<   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
<   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
<   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
<   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
<   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
<   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
<   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
<   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
<   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
<   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine
<   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
<   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
<   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton $HomePagePrefix
<   $EditNameLink $UseMetaWiki @ImageSites $BracketImg $DisabledDir
<   $AllowInclusion $InclusionDir $NumberDatesDelim);
<   
< # Note: $NotifyDefault is kept because it was a config variable in 0.90
< # Other global variables:
< use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
<   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
<   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
<   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
<   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
<   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
<   $ConfigError $UploadPattern $WikiLineHeader $WikiLineHeaderPreview $WikiLineFooter $WikiLineDiff
<   $WikiLine $WikiLine1 $WikiLine2 $WikiLinePref $AutoMailto
<   $GLOBAL_imageCount $GLOBAL_flashCount $GLOBAL_galleryCount
<   $WikiLeftNav %TableCellDefaults $DownloadExtensions
<   );
< 
< # == Configuration =====================================================
< $DataDir = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/wiki";    # Main wiki directory
< $UseConfig = 0;    # 1 = use config file,    0 = do not look for config
< $ConfigFile = "$DataDir/config";    # Configuration file
< 
< # Default configuration (used if UseConfig is 0)
< $CookieName = "NobleWiki";          # Name for this wiki (for multi-wiki sites)
< $SiteName   = "Noble Pursuit Games Wiki";          # Name of site (used for titles)
< $HomePage   = "HomePage";           # Home page (change space to _)
< $HomePagePrefix = "HomePage";      # Which page will be linked when a valid $username is clicked in the RC history.
< $RCName     = "RecentChanges";      # Name of changes page (change space to _)
< $LogoUrl    = "";                   # URL for site logo ("" for no logo)
< $ENV{PATH}  = "/usr/bin/";          # Path used to find "diff"
< $ScriptTZ   = "";                   # Local time zone ("" means do not print)
< $RcDefault  = 7;                    # Default number of RecentChanges days
< @RcDays     = qw(1 3 7 30 90 180);  # Days for links on RecentChanges
< $KeepDays   = 14;                   # Days to keep old revisions
< $SiteBase   = "";                   # Full URL for <BASE> header
< 
< 								    # Set if the auto-detected URL is wrong
< $FullUrl    = "http://wiki.kurcina.org/cgi-bin/index.cgi";                                 
< $RedirType  = 1;                    # 1 = CGI.pm, 2 = script, 3 = no redirect
< $AdminPass  = "linhson";            # Set to non-blank to enable password(s)
< $EditPass   = "emerald";            # Like AdminPass, but for editing only
< $StyleSheet = "/css/wiki.default.css";   # URL for CSS stylesheet (like "/wiki.css")
< $NotFoundPg = "PageNotFound";       # Page for not-found links ("" for blank pg)
< $EmailFrom  = "NobleWiki";          # Text for "From: " field of email notes.
< $SendMail   = "/usr/sbin/sendmail"; # Full path to sendmail executable
< $AutoMailto = 1;					# 0 = off; 1 = convert email address automatically to mailTo:<address>
< 									# HTML for bottom of every page
< $FooterNote = "<a href='?action=editprefs'><div id='anylogo' title='access username'>&nbsp;</div></a>";                   
< 
< $EditNote   = "";                   # HTML notice above buttons on edit page
< $MaxPost    = 1024 * 5000;          # Maximum 210K posts (about 200K for pages)
< $NewText    = "";                   # New page text ("" for default message)
< $HttpCharset      = "";           # Charset for pages, like "iso-8859-2"
< 
< $InterWikiMoniker = "NobleWiki";  # InterWiki moniker for this wiki. (for RSS)
< $SiteDescription  = $SiteName;    # Description of this wiki. (for RSS)
< $RssLogoUrl       = "";           # Optional image for RSS feed
< $EarlyRules       = "";           # Local syntax rules for wiki->html (evaled)
< $LateRules        = "";           # Local syntax rules for wiki->html (evaled)
< $KeepSize         = 0;            # If non-zero, maximum size of keep file
< $BGColor          = "";           # Background color ('' to disable)
< $DiffColor1       = "#ffffaf";    # Background color of old/deleted text
< $DiffColor2       = "#cfffcf";    # Background color of new/added text
< $FavIcon          = "";           # URL of bookmark/favorites icon, or ''
< $RssDays          = 7;            # Default number of days in RSS feed
< $UserGotoBar      = "";           # HTML added to end of goto bar
< $UserGotoBar     .= "<a href='$ScriptName?WikiHelp'>Help</a>";
< 
< $UserHeader       = "";           # Optional HTML header additional content
< $UserHeader		 .= "\n<link rel='stylesheet' type='text/css' media='screen' href='/css/jquery.lightbox-0.4.css'/>";
< $UserHeader      .= "\n<script src='/js/jquery-1.2.1.js'></script>";
< $UserHeader      .= "\n<script src='/js/ufo.js'></script>";
< $UserHeader		 .= "\n<script src='/js/jquery.lightbox-0.4.js'></script>";
< 
< $UserBody         = "";           # Optional <BODY> tag additional content
< $StartUID         = 1001;         # Starting number for user IDs
< 								  # Full path (like /foo/www/uploads) for files
< $UploadDir        = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/docs/attachments";
< 								  # Full URL (like http://foo.com/uploads)
< $UploadUrl        = "http://wiki.kurcina.org/attachments";
< $DisabledDir      = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/disabled";
<       
< @ImageSites       = qw();         # Url prefixes of good image sites: ()=all
< 
< # Major options:
< $UseSubpage  = 1;             # 1 = use subpages,       0 = do not use subpages
< $UseCache    = 0;             # 1 = cache HTML pages,   0 = generate every page
< $EditAllowed = 1;             # 1 = editing allowed,    0 = read-only
< $RawHtml     = 0;             # 1 = allow <HTML> tag,   0 = no raw HTML in pages
< $HtmlTags    = 1;             # 1 = "unsafe" HTML tags, 0 = only minimal tags
< $UseDiff     = 1;             # 1 = use diff features,  0 = do not use diff
< $FreeLinks   = 1;             # 1 = use [[word]] links, 0 = LinkPattern only
< $WikiLinks   = 1;             # 1 = use LinkPattern,    0 = use [[word]] only
< $AdminDelete = 1;             # 1 = Admin only deletes, 0 = Editor can delete
< $RunCGI      = 1;             # 1 = Run script as CGI,  0 = Load but do not run
< $EmailNotify = 0;             # 1 = use email notices,  0 = no email on changes
< $EmbedWiki   = 0;             # 1 = no headers/footers, 0 = normal wiki pages
< $DeletedPage = "DeletedPage"; # 0 = disable, 'PageName' = tag to delete page
< $ReplaceFile = "ReplaceFile"; # 0 = disable, 'PageName' = indicator tag
< @ReplaceableFiles = ();       # List of allowed server files to replace
< $TableSyntax      = 1;        # 1 = wiki syntax tables, 0 = no table syntax
< $NewFS            = 1;        # 1 = new multibyte $FS,  0 = old $FS
< $UseUpload        = 1;        # 1 = allow uploads,      0 = no uploads
< $AllowInclusion = 1;          # 1 = files (*.txt,*.html) may be included by include:file.html,
< 	                          # 0 = files will not be included
< 	                          # from where shall the files be included?
< $InclusionDir = "$DataDir/includes-data";
<   
< # Minor options:
< $LogoLeft     = 1;    # 1 = logo on left,       0 = logo on right
< $RecentTop    = 1;    # 1 = recent on top,      0 = recent on bottom
< $UseDiffLog   = 1;    # 1 = save diffs to log,  0 = do not save diffs
< $KeepMajor    = 1;    # 1 = keep major rev,     0 = expire all revisions
< $KeepAuthor   = 1;    # 1 = keep author rev,    0 = expire all revisions
< $ShowEdits    = 0;    # 1 = show minor edits,   0 = hide edits by default
< $HtmlLinks    = 1;    # 1 = allow A HREF links, 0 = no raw HTML links
< $SimpleLinks  = 0;    # 1 = only letters,       0 = allow _ and numbers
< $NonEnglish   = 0;    # 1 = extra link chars,   0 = only A-Za-z chars
< $ThinLine     = 0;    # 1 = fancy <hr> tags,    0 = classic wiki <hr>
< $BracketText  = 1;    # 1 = allow [URL text],   0 = no link descriptions
< $UseAmPm      = 0;    # 1 = use am/pm in times, 0 = use 24-hour times
< $UseIndex     = 0;    # 1 = use index file,     0 = slow/reliable method
< $UseHeadings  = 1;    # 1 = allow = h1 text =,  0 = no header formatting
< $NetworkFile  = 1;    # 1 = allow remote file:, 0 = no file:// links
< $BracketWiki  = 1;    # 1 = [WikiLnk txt] link, 0 = no local descriptions
< $UseLookup    = 1;    # 1 = lookup host names,  0 = skip lookup (IP only)
< $FreeUpper    = 1;    # 1 = force upper case,   0 = do not force case
< $FastGlob     = 1;    # 1 = new faster code,    0 = old compatible code
< $MetaKeywords = 1;    # 1 = Google-friendly,    0 = search-engine averse
< $NamedAnchors = 1;    # 0 = no anchors, 1 = enable anchors,
<                       # 2 = enable but suppress display
< $SlashLinks   = 0;    # 1 = use script/action links, 0 = script?action
< $UpperFirst   = 1;    # 1 = free links start uppercase, 0 = no ucfirst
< $AdminBar     = 1;    # 1 = admins see admin links, 0 = no admin bar
< $RepInterMap  = 0;    # 1 = intermap is replacable, 0 = not replacable
< $ConfirmDel   = 1;    # 1 = delete link confirm page, 0 = immediate delete
< $MaskHosts    = 0;    # 1 = mask hosts/IPs,      0 = no masking
< $LockCrash    = 0;    # 1 = crash if lock stuck, 0 = auto clear locks
< $HistoryEdit  = 0;    # 1 = edit links on history page, 0 = no edit links
< $OldThinLine  = 0;    # 1 = old ==== thick line, 0 = ------ for thick line
< $NumberDates  = 1;    # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
< $NumberDatesDelim = "-"; # If $NumberDates is 1, this character separate the year, month, day
< $ParseParas   = 1;    # 1 = new paragraph markup, 0 = old markup
< $AuthorFooter = 1;    # 1 = show last author in footer, 0 = do not show
< $AllUpload    = 0;    # 1 = anyone can upload,   0 = only editor/admins
< $LimitFileUrl = 1;    # 1 = limited use of file: URLs, 0 = no limits
< $MaintTrimRc  = 1;    # 1 = maintain action trims RC, 0 = only maintainrc
< $SearchButton = 1;    # 1 = search button on page, 0 = old behavior
< $EditNameLink = 0;    # 1 = edit links use name (CSS), 0 = '?' links
< $UseMetaWiki  = 0;    # 1 = add MetaWiki search links, 0 = no MW links
< $BracketImg   = 1;    # 1 = [url url.gif] becomes image link, 0 = no img
< 
< $WikiLineHeader = "\n<div class='wikilineheader'></div>";
< $WikiLineHeaderPreview = "\n<div class='wikilineheaderpreview'></div>";
< $WikiLineFooter = "\n<div class='wikilinefooter'></div>";
< $WikiLineDiff   = "\n<div class='wikilinediff'></div>";
< $WikiLinePref   = "\n<div class='wikilinepref'></div>";
< $WikiLine       = "\n<div class='wikiline'></div>";
< $WikiLine1      = "\n<div class='wikiline1'></div>";
< $WikiLine2      = "\n<div class='wikiline2'></div>";
< 
< # Names of sites.  (The first entry is used for the number link.)
< @IsbnNames = ( 'bn.com', 'amazon.com', 'search' );
< 
< # Full URL of each site before the ISBN
< @IsbnPre = (
< 	"http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=",
< 	"http://www.amazon.com/exec/obidos/ISBN=",
< 	"http://www.pricescan.com/books/BookDetail.asp?isbn="
< );
< 
< # Rest of URL of each site after the ISBN (usually '')
< @IsbnPost = ( "", "", "" );
< 
< # HTML tag lists, enabled if $HtmlTags is set.
< # Scripting is currently possible with these tags,
< # so they are *not* particularly "safe".
< # Tags that must be in <tag> ... </tag> pairs:
< @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
<   em s strike strong tt var div center blockquote ol ul dl caption);
< 
< # Single tags (that do not require a closing /tag)
< @HtmlSingle = qw(br p hr li dt dd tr td th);
< @HtmlPairs  = ( @HtmlPairs, @HtmlSingle );     # All singles can also be pairs
< 
< # == You should not have to change anything below this line. =============
< $IndentLimit = 20;                             # Maximum depth of nested lists
< $PageDir     = "$DataDir/page-data";           # Stores page data
< $HtmlDir     = "$DataDir/html-version";        # Stores HTML versions
< $UserDir     = "$DataDir/user-data";           # Stores user data
< $KeepDir     = "$DataDir/keep-data";           # Stores kept (old) page data
< $TempDir     = "$DataDir/temp-files";          # Temporary files and locks
< $LockDir     = "$TempDir/lock-dir";            # DB is locked if this exists
< $InterFile   = "$DataDir/intermap";            # Interwiki site->url map
< $RcFile      = "$DataDir/recent-log";          # New RecentChanges logfile
< $RcOldFile   = "$DataDir/oldrecent-log";       # Old RecentChanges logfile
< $IndexFile   = "$DataDir/page-index";          # List of all pages
< $EmailFile   = "$DataDir/email-list";          # Email notification lists
< if ($RepInterMap) {
< 	push @ReplaceableFiles, $InterFile;
< }
< 
< # The "main" program, called at the end of this script file.
< sub DoWikiRequest {
< 	if ( $UseConfig && ( -f $ConfigFile ) ) {
< 		$ConfigError = "";
< 		if ( !do $ConfigFile ) {               # Some error occurred
< 			$ConfigError = $@;
< 			if ( $ConfigError eq "" ) {
< 
< 			  # Unfortunately, if the last expr returns 0, one will get a false
< 			  # error above.  To remain compatible with existing installs the
< 			  # wiki must not report an error unless there is error text in $@.
< 			  # (Errors in "use strict" may not have error text.)
< 			  # Uncomment the line below if you want to catch use strict errors.
< 			  #       $ConfigError = "Unknown Error (no error text)";
< 			}
< 		}
< 	}
< 	&InitLinkPatterns();
< 	if ( !&DoCacheBrowse() ) {
< 		eval $BrowseCode;
< 		&InitRequest() or return;
< 		if ( !&DoBrowseRequest() ) {
< 			eval $OtherCode;
< 			&DoOtherRequest();
< 		}
< 	}
< }
< 
< # == Common and cache-browsing code ====================================
< sub InitLinkPatterns {
< 	my ( $UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim );
< 
< 	# Field separators are used in the URL-style patterns below.
< 	if ($NewFS) {
< 		$FS = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
< 	}
< 	else {
< 		$FS = "\xb3";                # The FS character is a superscript "3"
< 	}
< 	
< 	$FS1         = $FS . "1";  # The FS values are used to separate fields
< 	$FS2         = $FS . "2";  # in stored hashtables and other data structures.
< 	$FS3         = $FS . "3";  # The FS character is not allowed in user data.
< 	$UpperLetter = "[A-Z";
< 	$LowerLetter = "[a-z";
< 	$AnyLetter   = "[A-Za-z";
< 	
< 	if ($NonEnglish) {
< 		$UpperLetter .= "\xc0-\xde";
< 		$LowerLetter .= "\xdf-\xff";
< 		
< 		if ($NewFS) {
< 			$AnyLetter .= "\x80-\xff";
< 		}
< 		else {
< 			$AnyLetter .= "\xc0-\xff";
< 		}
< 	}
< 	if ( !$SimpleLinks ) {
< 		$AnyLetter .= "_0-9";
< 	}
< 	
< 	$UpperLetter .= "]";
< 	$LowerLetter .= "]";
< 	$AnyLetter   .= "]";
< 
< 	# Main link pattern: lowercase between uppercase, then anything
< 	$LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
< 
< 	# Optional subpage link pattern: uppercase, lowercase, then anything
< 	$LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
< 	if ($UseSubpage) {
< 
< 		# Loose pattern: If subpage is used, subpage may be simple name
< 		$LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
< 
< 		# Strict pattern: both sides must be the main LinkPattern
< 		# $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
< 	}
< 	else {
< 		$LinkPattern = "($LpA)";
< 	}
< 	
< 	$QDelim = '(?:"")?';    # Optional quote delimiter (not in output)
< 	$AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
< 	$LinkPattern .= $QDelim;
< 
< 	# Inter-site convention: sites must start with uppercase letter
< 	# (Uppercase letter avoids confusion with URLs)
< 	$InterSitePattern = $UpperLetter . $AnyLetter . "+";
< 	$InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
< 	
< 	if ($FreeLinks) {
< 
< 		# Note: the - character must be first in $AnyLetter definition
< 		if ($NonEnglish) {
< 			if ($NewFS) {
< 				$AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
< 			}
< 			else {
< 				$AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
< 			}
< 		}
< 		else {
< 			$AnyLetter = "[-,.()' _0-9A-Za-z]";
< 		}
< 	}
< 	$FreeLinkPattern = "($AnyLetter+";
< 	if ($UseSubpage) {
< 		$FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+";
< 	}
< 	
< 	if ($NamedAnchors){
< 		$FreeLinkPattern .= "(?:#(?:\\w+))?)";
< 	}
< 	else {
< 		$FreeLinkPattern .= ")";
< 	}
< 	
< 	$FreeLinkPattern .= $QDelim;
< 
< 	# Url-style links are delimited by one of:
< 	#   1.  Whitespace                           (kept in output)
< 	#   2.  Left or right angle-bracket (< or >) (kept in output)
< 	#   3.  Right square-bracket (])             (kept in output)
< 	#   4.  A single double-quote (")            (kept in output)
< 	#   5.  A $FS (field separator) character    (kept in output)
< 	#   6.  A double double-quote ("")           (removed from output)
< 	$UrlProtocols    = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|prospero|telnet|gopher";
< 	$UrlProtocols   .= '|file' if ( $NetworkFile || !$LimitFileUrl );
< 	
< 	$UrlPattern      = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
< 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
< 	$DownloadExtensions = "(pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)";
< 	$RFCPattern      = "RFC\\s?(\\d+)";
< 	$ISBNPattern     = "ISBN:?([0-9- xX]{10,})";
< 	$UploadPattern   = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
< }
< 
< # Simple HTML cache
< sub DoCacheBrowse {
< 	my ( $query, $idFile, $text );
< 	return 0 if ( !$UseCache );
< 	$query = $ENV{'QUERY_STRING'};
< 	if ( ( $query eq "" ) && ( $ENV{'REQUEST_METHOD'} eq "GET" ) ) {
< 		$query = $HomePage;    # Allow caching of home page.
< 	}
< 	if ( !( $query =~ /^$LinkPattern$/ ) ) {
< 		if ( !( $FreeLinks && ( $query =~ /^$FreeLinkPattern$/ ) ) ) {
< 			return 0;          # Only use cache for simple links
< 		}
< 	}
< 	$idFile = &GetHtmlCacheFile($query);
< 	if ( -f $idFile ) {
< 		local $/ = undef;      # Read complete files
< 		open( INFILE, "<$idFile" ) or return 0;
< 		$text = <INFILE>;
< 		close INFILE;
< 		print $text;
< 		return 1;
< 	}
< 	return 0;
< }
< 
< sub GetHtmlCacheFile {
< 	my ($id) = @_;
< 	return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
< }
< 
< sub GetPageDirectory {
< 	my ($id) = @_;
< 	
< 	if ( $id =~ /^([a-zA-Z])/ ) { return uc($1); }
< 	
< 	return "other";
< }
< 
< sub T {
< 	my ($text) = @_;
< 	
< 	if ( defined( $Translate{$text} ) && ( $Translate{$text} ne "" ) ) {
< 		return $Translate{$text};
< 	}
< 	
< 	return $text;
< }
< 
< sub Ts {
< 	my ( $text, $string ) = @_;
< 	
< 	$text = T($text);
< 	$text =~ s/\%s/$string/;
< 	
< 	return $text;
< }
< 
< sub Tss {
< 	my $text = @_[0];
< 	
< 	$text = T($text);
< 	$text =~ s/\%([1-9])/$_[$1]/ge;
< 	
< 	return $text;
< }
< 
< # == Normal page-browsing and RecentChanges code =======================
< $BrowseCode = "";    # Comment next line to always compile (slower)
< 
< #$BrowseCode = <<'#END_OF_BROWSE_CODE';
< use CGI;
< use CGI::Carp qw(fatalsToBrowser);
< 
< sub InitRequest {
< 	my @ScriptPath = split( '/', "$ENV{SCRIPT_NAME}" );
< 	
< 	$CGI::POST_MAX = $MaxPost;
< 	
< 	if ($UseUpload) {
< 		$CGI::DISABLE_UPLOADS = 0;    # allow uploads
< 	}
< 	else {
< 		$CGI::DISABLE_UPLOADS = 1;    # no uploads
< 	}
< 	
< 	if ($SlashLinks && length($ENV{'PATH_INFO'}>1)){
< 		$ENV{'QUERY_STRING'} .= '&' if($ENV{'QUERY_STRING'});
< 		$ENV{'QUERY_STRING'} .= substr($ENV{'PATH_INFO'},1);
< 	}
< 	
< 	$q = new CGI();
< 	
< 	if ($SlashLinks){
< 		my $numberOfSlashes = ($ENV{'PATH_INFO'} = tr[/][/]);
< 		$ScriptName = ('../' x $numberOfSlashes) . $ScriptName;
< 	}
< 
< 	# Fix some issues with editing UTF8 pages (if charset specified)
< 	if ( $HttpCharset ne "" ) {
< 		$q->charset($HttpCharset);
< 	}
< 	$Now           = time;                # Reset in case script is persistent
< 	$ScriptName    = pop(@ScriptPath);    # Name used in links
< 		
< 	$IndexInit     = 0;                   # Must be reset for each request
< 	$InterSiteInit = 0;
< 	%InterSite     = ();
< 	$MainPage     = ".";    # For subpages only, the name of the top-level page
< 	$OpenPageName = "";     # Currently open page
< 	&CreateDir($DataDir);   # Create directory if it doesn't exist
< 
< 	if ( !-d $DataDir ) {
< 		&ReportError( "Could not create $DataDir : $!" );
< 		return 0;
< 	}
< 	&InitCookie();          # Reads in user data
< 	return 1;
< }
< 
< sub InitCookie {
< 	%SetCookie      = ();
< 	$TimeZoneOffset = 0;
< 	undef $q->{'.cookies'};    # Clear cache if it exists (for SpeedyCGI)
< 	%UserData   = ();                        # Fix for persistent environments.
< 	%UserCookie = $q->cookie($CookieName);
< 	$UserID     = $UserCookie{'id'};
< 	$UserID =~ s/\D//g;                      # Numeric only
< 	
< 	if ( $UserID < 200 ) {
< 		$UserID = 111;
< 	}
< 	else {
< 		&LoadUserData($UserID);
< 	}
< 	if ( $UserID > 199 ) {
< 		if (   ( $UserData{'id'} != $UserCookie{'id'} )
< 			|| ( $UserData{'randkey'} != $UserCookie{'randkey'} ) )
< 		{
< 			$UserID   = 113;
< 			%UserData = ();    # Invalid.  Consider warning message.
< 		}
< 	}
< 	if ( $UserData{'tzoffset'} != 0 ) {
< 		$TimeZoneOffset = $UserData{'tzoffset'} * ( 60 * 60 );
< 	}
< }
< 
< sub DoBrowseRequest {
< 	my ( $id, $action, $text );
< 	
< 	if ( !$q->param ) {        # No parameter
< 		&BrowsePage($HomePage);
< 		return 1;
< 	}
< 	$id = &GetParam( 'keywords', "" );
< 	if ($id) {                 # Just script?PageName
< 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
< 			$id = &FreeToNormal($id);
< 		}
< 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
< 			$id = $NotFoundPg;
< 		}
< 		&BrowsePage($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	$action = lc( &GetParam( 'action', "" ) );
< 	$id = &GetParam( 'id', "" );
< 	
< 	if ( $action eq 'browse' ) {
< 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
< 			$id = &FreeToNormal($id);
< 		}
< 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
< 			$id = $NotFoundPg;
< 		}
< 		&BrowsePage($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	elsif ( $action eq 'rc' ) {
< 		&BrowsePage($RCName);
< 		return 1;
< 	}
< 	elsif ( $action eq 'random' ) {
< 		&DoRandom();
< 		return 1;
< 	}
< 	elsif ($action eq 'orphans') {
< 		&DoOrphanList();
< 		return 1;
< 	} 
< 	elsif ($action eq 'history') {
< 		&DoHistory($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	
< 	return 0;    # Request not handled
< }
< 
< sub BrowsePage {
< 	my ($id) = @_;
< 	my ( $fullHtml, $oldId, $allDiff, $showDiff, $openKept );
< 	my ( $revision, $goodRevision, $diffRevision, $newText );
< 	my ( $fragHtml );
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$openKept = 0;
< 	$revision = &GetParam( 'revision', "" );
< 	$revision =~ s/\D//g;    # Remove non-numeric chars
< 	$goodRevision = $revision;    # Non-blank only if exists
< 
< 	if ( $revision ne "" ) {
< 		&OpenKeptRevisions('text_default');
< 		$openKept = 1;
< 		if ( !defined( $KeptRevisions{$revision} ) ) {
< 			$goodRevision = "";
< 		}
< 		else {
< 			&OpenKeptRevision($revision);
< 		}
< 	}
< 
< 	# Raw mode: just untranslated wiki text
< 	if ( &GetParam( 'raw', 0 ) ) {
< 		print &GetHttpHeader('text/plain');
< 		print $Text{'text'};
< 		return;
< 	}
< 	$newText = $Text{'text'};              # For differences
< 	                                       # Handle a single-level redirect
< 	$oldId   = &GetParam( 'oldid', "" );
< 	if (   ( $oldId eq "" )
< 		&& ( substr( $Text{'text'}, 0, 10 ) eq '#REDIRECT ' ) )
< 	{
< 		$oldId = $id;
< 		if ( ($FreeLinks) && ( $Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/ ) ) {
< 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/ );
< 			$id = &FreeToNormal($id);
< 		}
< 		else {
< 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+(\S+)/ );
< 		}
< 		if ( &ValidId($id) eq "" ) {
< 
< 			# Consider revision in rebrowse?
< 			&ReBrowsePage( $id, $oldId, 0 );
< 			return;
< 		}
< 		else {    # Not a valid target, so continue as normal page
< 			$id    = $oldId;
< 			$oldId = "";
< 		}
< 	}
< 	$MainPage = $id;
< 	$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
< 	$fullHtml = &GetHeader( $id, &QuoteHtml($id), $oldId );
< 
< 	unless( $id eq $RCName ){ $fullHtml .= &GetLeftNav($id); }
< 	if ( $UseDiff && $showDiff ) {
< 		$fullHtml .= "\n<div class='wikiadmin'>";
< 	}
< 	else {
< 		unless ($id eq $RCName){ $fullHtml .= "\n<div class='wikitext'>"; }
< 		else { $fullHtml .= "\n<div class='wikiadmin'>"; }
< 	}
< 	
< 		if ( $revision ne "" ) {
< 		if ( ( $revision eq $Page{'revision'} ) || ( $goodRevision ne "" ) ) {
< 			$fragHtml = "\n<div class='wikidifftexttitle'>Showing revision $revision.</div>";
< 		}
< 		else {
< 			$fragHtml = "\n<div class='wikidifftexttitle'>Revision $revision not available, showing current revision instead.</div>";
< 		}
< 	}
< 	
< 	$fullHtml .= $fragHtml;
< 	
< 	$allDiff = &GetParam( 'alldiff', 0 );
< 	if ( $allDiff != 0 ) {
< 		$allDiff = &GetParam( 'defaultdiff', 1 );
< 	}
< 	
< 	if (
< 		(
< 			( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName )
< 		)
< 		&& &GetParam( 'norcdiff', 1 )
< 	  )
< 	{
< 		$allDiff = 0;    # Only show if specifically requested
< 	}
< 	
< 	$showDiff = &GetParam( 'diff', $allDiff );
< 	
< 	if ( $UseDiff && $showDiff ) {
< 		$diffRevision = $goodRevision;
< 		$diffRevision = &GetParam( 'diffrevision', $diffRevision );
< 
< 		# Eventually try to avoid the following keep-loading if possible?
< 		&OpenKeptRevisions('text_default') if ( !$openKept );
< 		$fullHtml .= &GetDiffHTML( $showDiff, $id, $diffRevision, $revision, $newText );
< 		$fullHtml .= $fragHtml;
< 
< 	}
< 
< 	# magiccontent patch - tarquin
< 	# Refactored and added position functionality --DavidClaughton.
< 	my ($magiccommand, $magicpos, $magicparams);
< 	my ($magicHTML, $magicDiv, $wikiHTML) = ("", "", "");
< 	
< 	if ( ($magicpos, $magiccommand, $magicparams) = $Text{'text'} =~ m[^\#MAGIC\s*(?:\@(top|bottom))?\s*(\w*)\s*(.*)\n] ){
< 		$Text{'text'} =~ s/^\#MAGIC.*\n//; # kill the magic command line in source
< 		$wikiHTML = &WikiToHTML($Text{'text'});
< 		
< 		#$magicDiv = "\n<hr>\n"; # Remove if using CSS.
< 		
< 		# call: MakeSection( current page, magic module, line of parameters)
< 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
< 		
< 		if (lc $magicpos eq "top"){
< 			$fullHtml .= $magicHTML . $magicDiv . $wikiHTML;
< 		}
< 		else {
< 			$fullHtml .= $wikiHTML . $magicDiv . $magicHTML;
< 		}
< 	}
< 	else {
< 		$fullHtml .= &WikiToHTML($Text{'text'});
< 	}
< 	
< 	if ( !&GetParam( 'embed', $EmbedWiki ) ) {
< 		$fullHtml .= "</div>";
< 		$fullHtml .= $WikiLineFooter;
< 	}
< 
< 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) )
< 	{
< 		print $fullHtml;
< 		print $WikiLineDiff;
< 		print &GetLeftNav($id);
< 		print "\n<div class='wikidiff'>";
< 		&DoRc(1);
< 		print "\n</div>";
< 		print "\n$WikiLineFooter" if ( !&GetParam( 'embed', $EmbedWiki ) );
< 
< 		print &GetFooterText( $id, $goodRevision );
< 		print "\n</div></div></body></html>";
< 		
< 		return;
< 	}
< 	
< 	$fullHtml .= &GetFooterText( $id, $goodRevision );
< 	$fullHtml .= "</div></div></body></html>";
< 	print $fullHtml;
< 	
< 	return
< 	
< 	if ( $showDiff || ( $revision ne "" ) );    # Don't cache special version
< 	&UpdateHtmlCache( $id, $fullHtml ) if ( $UseCache && ( $oldId eq "" ) );
< }
< 
< sub ReBrowsePage {
< 	my ( $id, $oldId, $isEdit ) = @_;
< 	
< 	if ( $oldId ne "" ) {    
< 		# Target of #REDIRECT (loop breaking)
< 		print &GetRedirectPage( "action=browse&id=$id&oldid=$oldId", $id, $isEdit );
< 	}
< 	else {
< 		print &GetRedirectPage( $id, $id, $isEdit );
< 	}
< }
< 
< sub DoRc {
< 	my ($rcType) = @_;       # 0 = RSS, 1 = HTML
< 	my ( $fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly );
< 	my ( @fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML );
< 	my $starttime = 0;
< 	my $showbar   = 0;
< 	
< 	if ( 0 == $rcType ) {
< 		$showHTML = 0;
< 	}
< 	else {
< 		$showHTML = 1;
< 	}
< 	
< 	if ( &GetParam( "from", 0 ) ) {
< 		$starttime = &GetParam( "from", 0 );
< 		if ($showHTML) {
< 			print "\n<h2>";
< 			print "\nUpdates since " . &TimeToText($starttime);
< 			print "\n</h2>";
< 		}
< 	}
< 	else {
< 		$daysago = &GetParam( "days", 0 );
< 		$daysago = &GetParam( "rcdays", 0 ) if ( $daysago == 0 );
< 		if ($daysago) {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $daysago );
< 			if ($showHTML) {
< 				print "\n<h2>";
< 				print Ts( 'Updates in the last %s day' . ( ( $daysago != 1 ) ? "s" : "" ), $daysago );
< 				print "\n</h2>";
< 			}
< 
< 			# Note: must have two translations (for "day" and "days")
< 			# Following comment line is for translation helper script
< 			# Ts('Updates in the last %s days', '');
< 		}
< 	}
< 	
< 	if ( $starttime == 0 ) {
< 		if ( 0 == $rcType ) {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RssDays );
< 		}
< 		else {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RcDefault );
< 		}
< 		if ($showHTML) {
< 			print "\n<h2>";
< 			print Ts('Updates in the last %s day'. ( ( $RcDefault != 1 ) ? "s" : "" ),$RcDefault );
< 			print "\n</h2>";
< 		}
< 
< 		# Translation of above line is identical to previous version
< 	}
< 
< 	# Read rclog data (and oldrclog data if needed)
< 	( $status, $fileData ) = &ReadFile($RcFile);
< 	$errorText = "";
< 	
< 	if ( !$status ) {
< 		# Save error text if needed.
< 		$errorText = "\n<p><strong>";
< 		$errorText .= "Could not open $RCName log file";
< 		$errorText .= ":</strong> $RcFile</p>";
< 		$errorText .= "Error was ";
< 		$errorText .= ":<pre>$!</pre><p>";
< 		$errorText .= "Note: This error is normal if no changes have been made.";
< 
< 	}
< 	@fullrc = split( /\n/, $fileData );
< 	$firstTs = 0;
< 	
< 	if ( @fullrc > 0 ) {    # Only false if no lines in file
< 		($firstTs) = split( /$FS3/, $fullrc[0] );
< 	}
< 	if ( ( $firstTs == 0 ) || ( $starttime <= $firstTs ) ) {
< 		( $status, $oldFileData ) = &ReadFile($RcOldFile);
< 		if ($status) {
< 			@fullrc = split( /\n/, $oldFileData . $fileData );
< 		}
< 		else {
< 			if ( $errorText ne "" ) {    
< 			
< 				# could not open either rclog file
< 				print $errorText;
< 				print "\n<p><strong>";
< 				print "\nCould not open old $RCName log file";
< 				print "\n:</strong> $RcOldFile</p>";
< 				print "\nError was";
< 				print "\n:<pre>$!</pre>";
< 				
< 				return;
< 			}
< 		}
< 	}
< 	$lastTs = 0;
< 	if ( @fullrc > 0 ) {                 
< 		# Only false if no lines in file
< 		($lastTs) = split( /$FS3/, $fullrc[$#fullrc] );
< 	}
< 	$lastTs++ if ( ( $Now - $lastTs ) > 5 );    # Skip last unless very recent
< 	$idOnly = &GetParam( "rcidonly", "" );
< 	
< 	if ( $idOnly && $showHTML ) {
< 		print "\n<b>(";
< 		print "\nfor ";
< 		print &ScriptLink( $idOnly, $idOnly );
< 		print "\n only";
< 		print "\n)</b><br>";
< 	}
< 	
< 	if ($showHTML) {
< 		foreach $i (@RcDays) {
< 			print "\n | " if $showbar;
< 			$showbar = 1;
< 			print &ScriptLink( "action=rc&days=$i",
< 				Ts( '%s day' . ( ( $i != 1 ) ? 's' : '' ), $i ) );
< 
< 			# Note: must have two translations (for "day" and "days")
< 			# Following comment line is for translation helper script
< 			# Ts('%s days', '');
< 		}
< 		print "\n<br><br>";
< 		print &ScriptLink( "action=rc&from=$lastTs", "List new changes starting from" );
< 		print "\n " . &TimeToText($lastTs);
< 		print "\n<br><br>";
< 	}
< 	
< 	$i = 0;
< 	while ( $i < @fullrc ) {    
< 		# Optimization: skip old entries quickly
< 		($ts) = split( /\W/, $fullrc[$i] );
< 		if ( $ts >= $starttime ) {
< 			$i -= 1000 if ( $i > 0 );
< 			last;
< 		}
< 		$i += 1000;
< 	}
< 	
< 	$i -= 1000 if ( ( $i > 0 ) && ( $i >= @fullrc ) );
< 	for ( ; $i < @fullrc ; $i++ ) {
< 		($ts) = split( /\W/, $fullrc[$i] );
< 		last if ( $ts >= $starttime );
< 	}
< 	
< 	if ( $i == @fullrc && $showHTML ) {
< 		print "\n<br><strong>";
< 		print "\nNo updates since ";
< 		print &TimeToText($starttime);
< 		print "\n</strong><br>";
< 	}
< 	else {
< 		splice( @fullrc, 0, $i );    # Remove items before index $i
< 		
< 		# Consider an end-time limit (items older than X)
< 		if ( 0 == $rcType ) {
< 			print &GetRcRss(@fullrc);
< 		}
< 		else {
< 			print &GetRcHtml(@fullrc);
< 		}
< 	}
< 	
< 	if ($showHTML) {
< 		print "\nPage generated ";
< 		print &TimeToText($Now);
< 		print "\n<br>";
< 	}
< }
< 
< sub GetRc {
< 	my $rcType = shift;
< 	my @outrc  = @_;
< 	my ( $rcline,   $date, $newtop, $author, $inlist,   $result );
< 	my ( $showedit, $link, $all,    $idOnly, $headItem, $item );
< 	my ( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp );
< 	my ( $rcchangehist, $tEdit, $tChanges, $tDiff );
< 	my ( $headList, $historyPrefix, $diffPrefix );
< 	my %extra      = ();
< 	my %changetime = ();
< 	my %pagecount  = ();
< 
< 	# Slice minor edits
< 	$showedit = &GetParam( "rcshowedit", $ShowEdits );
< 	$showedit = &GetParam( "showedit",   $showedit );
< 	if ( $showedit != 1 ) {
< 		my @temprc = ();
< 		foreach $rcline (@outrc) {
< 			( $ts, $pagename, $summary, $isEdit, $host ) =
< 			  split( /$FS3/, $rcline );
< 			if ( $showedit == 0 ) {    # 0 = No edits
< 				push( @temprc, $rcline ) if ( !$isEdit );
< 			}
< 			else {                     # 2 = Only edits
< 				push( @temprc, $rcline ) if ($isEdit);
< 			}
< 		}
< 		@outrc = @temprc;
< 	}
< 
< 	# Optimize param fetches out of main loop
< 	$rcchangehist = &GetParam( "rcchangehist", 1 );
< 
< 	# Optimize translations out of main loop
< 	$tEdit         = "(edit)";
< 	$tDiff         = "(diff)";
< 	$tChanges      = "changes";
< 	$diffPrefix    = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
< 	$historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
< 	
< 	foreach $rcline (@outrc) {
< 		( $ts, $pagename ) = split( /$FS3/, $rcline );
< 		$pagecount{$pagename}++;
< 		$changetime{$pagename} = $ts;
< 	}
< 	
< 	$date     = "";
< 	$all      = &GetParam( "rcall", 0 );
< 	$all      = &GetParam( "all", $all );
< 	$newtop   = &GetParam( "rcnewtop", $RecentTop );
< 	$newtop   = &GetParam( "newtop", $newtop );
< 	$idOnly   = &GetParam( "rcidonly", "" );
< 	$inlist   = 0;
< 	$headList = "";
< 	$result   = "";
< 	@outrc    = reverse @outrc if ($newtop);
< 
< 	foreach $rcline (@outrc) {
< 		( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp ) =
< 		  split( /$FS3/, $rcline );
< 		next if ( ( !$all ) && ( $ts < $changetime{$pagename} ) );
< 		next if ( ( $idOnly ne "" ) && ( $idOnly ne $pagename ) );
< 		
< 		%extra = split( /$FS2/, $extraTemp, -1 );
< 		
< 		if ( $date ne &CalcDay($ts) ) {
< 			$date = &CalcDay($ts);
< 			if ( 1 == $rcType ) {    # HTML
< 				                     # add date, properly closing lists first
< 				if ($inlist) {
< 					$result .= "</ul>";
< 					$inlist = 0;
< 				}
< 				$result .= "\n<p><strong>" . $date . "</strong></p>";
< 				if ( !$inlist ) {
< 					$result .= "\n<ul>";
< 					$inlist = 1;
< 				}
< 			}
< 		}
< 		
< 		if ( 0 == $rcType ) {        # RSS
< 			( $headItem, $item ) = &GetRssRcLine(
< 				$pagename,          $ts,
< 				$host,              $extra{'name'},
< 				$extra{'id'},       $summary,
< 				$isEdit,            $pagecount{$pagename},
< 				$extra{'revision'}, $diffPrefix,
< 				$historyPrefix
< 			);
< 			$headList .= $headItem;
< 			$result   .= $item;
< 		}
< 		else {                       # HTML
< 			$result .= &GetHtmlRcLine(
< 				$pagename,          $ts,
< 				$host,              $extra{'name'},
< 				$extra{'id'},       $summary,
< 				$isEdit,            $pagecount{$pagename},
< 				$extra{'revision'}, $tEdit,
< 				$tDiff,             $tChanges,
< 				$all,               $rcchangehist
< 			);
< 		}
< 	}
< 	
< 	if ( 1 == $rcType ) {
< 		$result .= "</ul>" if ($inlist);    # Close final tag
< 	}
< 	
< 	return ( $headList, $result );            # Just ignore headList for HTML
< }
< 
< sub GetRcHtml {
< 	my ( $html, $extra );
< 	
< 	( $extra, $html ) = &GetRc( 1, @_ );
< 	
< 	return $html;
< }
< 
< sub GetHtmlRcLine {
< 	my (
< 		$pagename, $timestamp, $host,      $userName, $userID,
< 		$summary,  $isEdit,    $pagecount, $revision, $tEdit,
< 		$tDiff,    $tChanges,  $all,       $rcchangehist
< 	  )
< 	  = @_;
< 	my ( $author, $sum, $edit, $count, $link, $html );
< 	
< 	$html = "";
< 	$host = &QuoteHtml($host);
< 	
< 	if ( defined($userName) && defined($userID) ) {
< 		$author = &GetAuthorLink( $host, $userName, $userID );
< 	}
< 	else {
< 		$author = &GetAuthorLink( $host, "", 0 );
< 	}
< 	
< 	$sum = "";
< 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$summary = &QuoteHtml($summary);
< 		$sum     = "<strong>[$summary]</strong> ";
< 	}
< 	
< 	$edit  = "";
< 	$edit  = "<em>$tEdit</em> " if ($isEdit);
< 	$count = "";	
< 	
< 	if ( ( !$all ) && ( $pagecount > 1 ) ) {
< 		$count = "($pagecount ";
< 		if ($rcchangehist) {
< 			$count .= &GetHistoryLink( $pagename, $tChanges, "Click to view revision history" );
< 		}
< 		else {
< 			$count .= $tChanges;
< 		}
< 		$count .= ") ";
< 	}
< 	
< 	$link = "";
< 	
< 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) { $link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  "; }
< 	
< 	$link .= &GetPageLink($pagename);
< 	$html .= "\n<li>$link ";
< 	$html .= &CalcTime($timestamp) . " : $count$edit" . " $sum";
< 	$html .= ". . . . . $author";
< 	
< 	return $html;
< }
< 
< sub GetRcRss {
< 	my ( $rssHeader, $headList, $items );
< 
< 	# Normally get URL from script, but allow override
< 	$FullUrl         = $q->url( -full => 1 ) if ( $FullUrl eq "" );
< 	$QuotedFullUrl   = &QuoteHtml($FullUrl);
< 	$SiteDescription = &QuoteHtml($SiteDescription);
< 	
< 	my $ChannelAbout = &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
< 	
< 	$rssHeader = <<RSS ;
< <?xml version="1.0" encoding="ISO-8859-1"?>
< <rdf:RDF
<     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
<     xmlns="http://purl.org/rss/1.0/"
<     xmlns:dc="http://purl.org/dc/elements/1.1/"
<     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
< >
<     <channel rdf:about="$ChannelAbout">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
<         <description>${\(&QuoteHtml($SiteDescription))}</description>
<         <wiki:interwiki>
<             <rdf:Description link="$QuotedFullUrl">
<                 <rdf:value>$InterWikiMoniker</rdf:value>
<             </rdf:Description>
<         </wiki:interwiki>
<         <items>
<             <rdf:Seq>
< RSS
< 	( $headList, $items ) = &GetRc( 0, @_ );
< 	$rssHeader .= $headList;
< 	return <<RSS ;
< $rssHeader
<             </rdf:Seq>
<         </items>
<     </channel>
<     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <url>$RssLogoUrl</url>
<         <link>$QuotedFullUrl</link>
<     </image>
< $items
< </rdf:RDF>
< RSS
< }
< 
< sub GetRssRcLine {
< 	my (
< 		$pagename, $timestamp,  $host,   $userName,
< 		$userID,   $summary,    $isEdit, $pagecount,
< 		$revision, $diffPrefix, $historyPrefix
< 	  )
< 	  = @_;
< 	my (
< 		$itemID,     $description, $authorLink, $author, $status,
< 		$importance, $date,        $item,       $headItem
< 	);
< 
< 	# Add to list of items in the <channel/>
< 	$itemID = $FullUrl
< 	  . &ScriptLinkChar()
< 	  . &GetOldPageParameters( 'browse', $pagename, $revision );
< 	$itemID   = &QuoteHtml($itemID);
< 	$headItem = "                <rdf:li rdf:resource=\"$itemID\"/>";
< 
< 	# Add to list of items proper.
< 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$description = &QuoteHtml($summary);
< 	}
< 	
< 	$host = &QuoteHtml($host);
< 	if ($userName) {
< 		$author     = &QuoteHtml($userName);
< 		$authorLink = "link=\"$QuotedFullUrl?$author\"";
< 	}
< 	else {
< 		$author = $host;
< 	}
< 	
< 	$status     = ( 1 == $revision ) ? 'new'   : 'updated';
< 	$importance = $isEdit            ? 'minor' : 'major';
< 	$timestamp += $TimeZoneOffset;
< 	
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($timestamp);
< 	
< 	$year += 1900;
< 	$date = sprintf( "%4d-%02d-%02dT%02d:%02d:%02d+%02d:00", $year, $mon + 1, $mday, $hour, $min, $sec, $TimeZoneOffset / ( 60 * 60 ) );
< 	$pagename = &QuoteHtml($pagename);
< 
< 	# Write it out longhand
< 	$item = <<RSS ;
<     <item rdf:about="$itemID">
<         <title>$pagename</title>
<         <link>$QuotedFullUrl?$pagename</link>
<         <description>$description</description>
<         <dc:date>$date</dc:date>
<         <dc:contributor>
<             <rdf:Description wiki:host="$host" $authorLink>
<                 <rdf:value>$author</rdf:value>
<             </rdf:Description>
<         </dc:contributor>
<         <wiki:status>$status</wiki:status>
<         <wiki:importance>$importance</wiki:importance>
<         <wiki:diff>$diffPrefix$pagename</wiki:diff>
<         <wiki:version>$revision</wiki:version>
<         <wiki:history>$historyPrefix$pagename</wiki:history>
<     </item>
< RSS
< 	return ( $headItem, $item );
< }
< 
< sub DoRss {
< 	print "\nContent-type: text/xml\n\n";
< 	&DoRc(0);
< }
< 
< sub DoRandom {
< 	my ( $id, @pageList );
< 	
< 	@pageList = &AllPagesList();       # Optimize?
< 	$id       = $pageList[ int( rand( $#pageList + 1 ) ) ];
< 	
< 	&ReBrowsePage( $id, "", 0 );
< }
<    
< sub DoHistory {
< 	my ($id) = @_;
< 	my ( $html, $canEdit, $row, $newText );
< 
< 	print &GetHeader( "", Ts( 'History of %s', $id ), "" );
< 	print &GetLeftNav($id);
< 	print "\n<div class='wikiadmin'>";
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$newText = $Text{'text'};
< 	$canEdit = 0;
< 	$canEdit = &UserCanEdit($id) if ($HistoryEdit);
< 		
< 	if ($UseDiff) {
<       print "\n<form id='wikiform' action='$ScriptName' method='get'>";
<       print "\n<input type='hidden' name='action' value='browse'/>";
<       print "\n<input type='hidden' name='diff' value='1'/>";
<       print "\n<input type='hidden' name='id' value=\"$id\"/>";
<       print "\n<table class='wikihistory' border='0' width='90%'>";
< 	}
< 	
< 	$html = &GetHistoryLine( $id, $Page{'text_default'}, $canEdit, $row++ );
< 	&OpenKeptRevisions('text_default');
< 	
< 	foreach ( reverse sort { $a <=> $b } keys %KeptRevisions ) {
< 		next if ( $_ eq "" );    # (needed?)
< 		$html .= &GetHistoryLine( $id, $KeptRevisions{$_}, $canEdit, $row++ );
< 	}
< 	
< 	print $html;
< 	
< 	if ($UseDiff) {
< 		my $label = "Compare";
< 		
< 		print "\n<tr><td align='center'><br>";
< 		print "\n<input type='submit' value='$label'/>&nbsp;&nbsp;</td></tr></table></form>";
< 		print &GetDiffHTML( &GetParam( 'defaultdiff', 1 ), $id, "", "", $newText );
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 
< 	print "\n</div></div></body></html>";
< }
< 
< sub GetMaskedHost {
< 	my ($text) = @_;
< 	my ($logText);
< 	if ( !$MaskHosts ) {
< 		return $text;
< 	}
< 	$logText = "(logged)";
< 	if ( !( $text =~ s/\d+$/$logText/ ) ) { # IP address (ending numbers masked)
< 		$text =~ s/^[^\.\(]+/$logText/;     # Host name: mask until first .
< 	}
< 	return $text;
< }
< 
< sub GetHistoryLine {
< 	my ( $id, $section, $canEdit, $row ) = @_;
< 	my ( $html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor );
< 	my ( %sect, %revtext );
< 	
< 	%sect = split( /$FS2/, $section, -1 );
< 	%revtext = split( /$FS3/, $sect{'data'} );
< 	$rev     = $sect{'revision'};
< 	$summary = $revtext{'summary'};
< 	
< 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) { $host = $sect{'host'}; }
< 	else { $host = $sect{'ip'};	}
< 	
< 	$host     = &GetMaskedHost($host);
< 	$user     = $sect{'username'};
< 	$uid      = $sect{'id'};
< 	$ts       = $sect{'ts'};
< 	$minor    = "";
< 	$minor    = "<i>(edited) </i>" if ( $revtext{'minor'} );
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 
< 	if ($UseDiff) {
< 		my ( $c1, $c2 );
< 		
< 		$c1 = "checked='checked'" if 1 == $row;
< 		$c2 = "checked='checked'" if 0 == $row;
< 		$html .= "\n<tr>";
< 		$html .= "\n<td align='center'>";
< 		$html .= "\n<input type='radio' name='diffrevision' value='$rev' $c1/>";
< 		$html .= "\n<input type='radio' name='revision' value='$rev' $c2/>";
< 		$html .= "</td><td>";
< 	}
< 	
< 	if ( 0 == $row ) {    
< 		# current revision
< 		$html .= &GetPageLinkText( $id, Ts( 'RevisionB %s', $rev ) ) . ' ';
< 		
< 		if ($canEdit) {
< 			$html .= &GetEditLink( $id, "Edit" ) . ' ';
< 		}
< 	}
< 	else {
< 		$html .= &GetOldPageLink( 'browse', $id, $rev, Ts( 'RevisionA %s', $rev ) ) . ' ';
< 		if ($canEdit) {
< 			$html .= &GetOldPageLink( 'edit', $id, $rev, "Edit" ) . ' ';
< 		}
< 	}
< 	
< 	$html .= "\n<td>" . &TimeToText($ts) . "</td>";
< 	$html .= "\n<td> by " . &GetAuthorLink( $host, $user, $uid ) . " $minor</td>";
< 	
< 	if ( defined($summary) && ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$summary = &QuoteHtml($summary);    # Thanks Sunir! :-)
< 		$html .= "\n<td>[$summary]</td>";
< 	}
< 	else {
< 		$html .= "\n<td>&nbsp;</td>";
< 	}
< 	
< 	$html .= $UseDiff ? "</tr>" : "\n<br>";
< 	
< 	return $html;
< }
< 
< # ==== HTML and page-oriented functions ====
< sub ScriptLinkChar {
< 	if ($SlashLinks) { return '/'; }
< 	
< 	return '?';
< }
< 
< sub ScriptLink {
< 	my ( $action, $text ) = @_;
< 	
< 	return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\" class='wikiscriptlink' title='Click to visit page'>$text</a>";
< }
< 
< sub ScriptLinkClass {
< 	my ( $action, $text, $class, $title ) = @_;
< 	my $result = "<a href='$ScriptName" . &ScriptLinkChar() . "$action' class='$class' title='$title'>$text</a>";
< 	
< 	return $result;
< }
< 
< sub ScriptLinkLeftNav {
< 	my ($id, $action, $target, $label, $type) = @_;
< 	my $html;
< 	my $title;
< 	my $class;	
< 	
< 	if ($type eq "1"){
< 		if ($action eq $target){ $html .= "\n<li class='disabled'>$label</li>"; }
< 		else { $html .= "\n<li><a class='wikipagelink' title='Click to visit this page.' href='\?action=$target'>$label</a></li>"; }	
< 		
< 	}
< 	else {
< 		my $authtype = &CheckIsAuthUser($target);
< 		
< 		if ($authtype eq ""){
< 			$title = "This page is private.";
< 			$class = "wikipagelink private";
< 			$label .= "!";
< 		}
< 		elsif ( $authtype eq "1"){
< 			$title = "Click to visit this locked page.";
< 			$class = "wikipagelink locked";
< 			$label .= "&not;";
< 		}
< 		else {
< 			$title = "Click to visit this page.";
< 			$class = "wikipagelink";		
< 		}
< 		
< 		if ($id eq $target){ $html .= "\n<li class='selected'>$label</li>"; }
< 		else { $html .= "\n<li><a class='$class' title='$title' href='\?$target'>$label</a></li>"; }		
< 	}
< }
< 
< sub GetOrphanLink {
< 	return &ScriptLink("action=orphans", 'Orphans');
< }
< 
< sub DoOrphanList {
< 	print &GetHeader("", &QuoteHtml('Full Orphan List'), "");
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print &PrintPageList( "", &GetOrphanList() );
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub GetOrphanList {
< 	my @found;	
< 	my %seen = ();
< 	my @pglist = &AllPagesList();
< 	
< 	foreach my $name (@pglist) { $seen{$name} = 0; }
< 	
< 	# pages linked from menu bar aren't orphans
< 	$seen{$HomePage} = 1;
< 	$seen{$RCName} = 1;
< 	
< 	foreach my $name (@pglist) {
< 		my @links = &GetPageLinks($name, 1, 0, 0, 0);
< 		
< 		foreach my $link (@links) {
< 			#don't include self links
< 			unless ($link eq $name) {
< 				$seen{$link}++ if exists $seen{$link};
< 			}
< 		}
< 	}
< 	
< 	foreach my $name (sort keys %seen) { push(@found, $name) if $seen{$name} < 1; }
< 	
< 	return @found;
< }
< 
< 
< sub GetPageLinkText {
< 	my ( $id, $name ) = @_;
< 	$id =~ s|^/|$MainPage/|;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	my $authtype = &CheckIsAuthUser($id);
< 
< 	if ($authtype eq ""){
< 		return &ScriptLinkClass( $id, "$name!", 'wikipagelink private', 'This page is private.' );
< 	}
< 		
< 	if ( -f &GetLockedPageFile($id) || $authtype eq "1"){
< 		return &ScriptLinkClass( $id, "$name&not;", 'wikipagelink locked', 'Click to visit this locked page' );
< 	}
< 	
< 	return &ScriptLinkClass( $id, $name, 'wikipagelink', 'Click to visit page' );
< }
< 
< sub GetPageLink {
< 	my ($id) = @_;
< 	
< 	return &GetPageLinkText( $id, $id );
< }
< 
< sub GetEditLink {
< 	my ( $id, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	return &ScriptLinkClass( "action=edit&id=$id", $name, 'wikipageedit', 'Click to edit page' );
< }
< 
< sub GetCreateNewLink {
< 	my ( $id, $name ) = @_;
< 	my ( $html );
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	$html  = "<a href='$ScriptName";
< 	$html .= &ScriptLinkChar();
< 	$html .= "action=edit&id=$id' class='wikicreatepagelink' title='Create this entry'>";
< 	$html .= $name;
< 	$html .= "<span class='wikilinkicon'>&nbsp;</span>";
< 	$html .= "</a>";
< 	
< 	return $html;
< }
< 
< sub GetDeleteLink {
< 	my ( $id, $name, $confirm ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	return &ScriptLink( "action=delete&id=$id&confirm=$confirm", $name );
< }
< 
< sub GetOldPageParameters {
< 	my ( $kind, $id, $revision ) = @_;
< 	
< 	$id = &FreeToNormal($id) if $FreeLinks;
< 	
< 	return "action=$kind&id=$id&revision=$revision";
< }
< 
< sub GetOldPageLink {
< 	my ( $kind, $id, $revision, $name ) = @_;
< 	
< 	$name =~ s/_/ /g if $FreeLinks;
< 	
< 	return &ScriptLink( &GetOldPageParameters( $kind, $id, $revision ), $name );
< }
< 
< sub GetPageOrEditAnchoredLink {
< 	my ( $id, $anchor, $name ) = @_;
< 	my ( @temp, $exists );
< 	my $NamedFreeLink = 0;
< 	
< 	if ( $name eq "" ) {
< 		$name = $id;
< 		if ($FreeLinks) {
< 			$name =~ s/_/ /g;
< 		}
< 	}
< 	else {
< 		$NamedFreeLink = 1;
< 	}
< 	
< 	$id =~ s|^/|$MainPage/|;
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 	}
< 	$exists = 0;
< 	
< 	if ($UseIndex) {
< 		if ( !$IndexInit ) {
< 			@temp = &AllPagesList();    # Also initializes hash
< 		}
< 		$exists = 1 if ( $IndexHash{$id} );
< 	}
< 	elsif ( -f &GetPageFile($id) ) {    # Page file exists
< 		$exists = 1;
< 	}
< 	
< 	if ($exists) {
< 		$id = "$id#$anchor" if $anchor;
< 		$name = "$name#$anchor"  if $anchor && $NamedAnchors != 2 && !$NamedFreeLink;
< 		
< 		return &GetPageLinkText( $id, $name );
< 	}
< 	
< 	if ( $FreeLinks && !$EditNameLink ) {
< 		if ( $name =~ m| | ) {          # Not a single word
< 			$name = "[$name]";          # Add brackets so boundaries are obvious
< 		}
< 	}
< 	
< 	if ($EditNameLink) { return &GetEditLink( $id, $name ); }
< 	else { return &GetCreateNewLink( $id, $name ); }
< }
< 
< sub GetPageOrEditLink {
< 	my ( $id, $name ) = @_;
< 	my ($link, $anchor) = split( /#/, $id, 2);
< 	
< 	return &GetPageOrEditAnchoredLink($link, $anchor, $name);
< }
< 
< sub GetBackLinksSearchLink {
< 	my ($id) = @_;
< 	my $name = $id;
< 	
< 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
< 	
< 	if ($FreeLinks) {
< 		$name =~ s/_/ /g;    # Display with spaces
< 		$id   =~ s/_/+/g;    # Search for url-escaped spaces
< 	}
< 	return &ScriptLinkTitle( "back=$id", $name, "Click to see which pages link to this one" );
< }
< 
< sub GetPrefsLink {
< 	return &ScriptLink( "action=editprefs", "Preferences" );
< }
< 
< sub GetRandomLink {
< 	return &ScriptLink( "action=random", "Random Page" );
< }
< 
< sub ScriptLinkDiff {
< 	my ( $diff, $id, $text, $rev ) = @_;
< 	
< 	$rev = "&revision=$rev" if ( $rev ne "" );
< 	$diff = &GetParam( "defaultdiff", 1 ) if ( $diff == 4 );
< 	
< 	return &ScriptLinkTitle( "action=browse&diff=$diff&id=$id$rev", $text, "Click to view last revision" );
< }
< 
< sub GetUploadLink {
< 	return &ScriptLink( 'action=upload', "Upload" );
< }
< 
< sub ScriptLinkTitle {
< 	my ( $action, $text, $title ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$action =~ s/ /_/g;
< 	}
< 	
< 	return "<a href=\"$ScriptName"
< 	  . &ScriptLinkChar()
< 	  . "$action\" title=\"$title\" class='wikiscriptlinktitle'>$text</a>";
< }
< 
< sub GetAuthorLink {
< 	my ( $host, $userName, $uid ) = @_;
< 	my ( $html, $title, $userNameShow );
< 	$userNameShow = $userName;
< 	
< 	if ($FreeLinks) {
< 		$userName     =~ s/ /_/g;
< 		$userNameShow =~ s/_/ /g;
< 	}
< 	
< 	if ( &ValidId($userName) ne "" ) {    # Invalid under current rules
< 		$userName = "";                   # Just pretend it isn't there.
< 	}
< 	
< 	if ( ( $uid > 0 ) && ( $userName ne "" ) ) {
< 		$html = &ScriptLinkTitle( "$HomePagePrefix/$userName", $userNameShow, Ts( 'ID %s', $uid ) . ' ' . Ts( 'from %s', $host ) );
< 	}
< 	else {
< 		$html = $host;
< 	}
< 	
< 	return $html;
< }
< 
< sub GetHistoryLink {
< 	my ( $id, $text, $title ) = @_;
< 	
< 	if ($FreeLinks) { $id =~ s/ /_/g; }
< 	
< 	return &ScriptLinkTitle( "action=history&id=$id", $text, $title );
< }
< 
< sub GetHeader {
< 	my ( $id, $title, $oldId ) = @_;
< 	my $header    = "";
< 	my $logoImage = "";
< 	my $result    = "";
< 	my $embed     = &GetParam( 'embed', $EmbedWiki );
< 	my $altText   = "[Home]";
< 	my $temp      = "";
< 	
< 	$result = &GetHttpHeader("");
< 	
< 	if ($FreeLinks) {
< 		$title =~ s/_/ /g;    # Display as spaces
< 	}
< 	
< 	$result .= &GetHtmlHeader("$SiteName: $title", $id);
< 	
< 	return $result if ($embed);
< 	$result .= "<div class='wikiheader'>";
< 	
< 	if ( $oldId ne "" ) {
< 		$result .=
< 		  $q->h3( '(' . Ts( 'redirected from %s', &GetEditLink( $oldId, $oldId ) )  . ')' );
< 	}
< 	
< 	if ( ( !$embed ) && ( $LogoUrl ne "" ) ) {
< 		$logoImage = "img class='wikilogo' src=\"$LogoUrl\" alt=\"$altText\" border=0";
< 		
< 		if ( !$LogoLeft ) {
< 			$logoImage .= " align=\"right\"";
< 		}
< 		$header = &ScriptLink( $HomePage, "\n<$logoImage>" );
< 	}
< 	
< 	if ( $id ne "" ) {
< 		my $authtype = &CheckIsAuthUser($id);
< 		if (&PageIsLocked($id, 1) || $authtype eq "1"){
< 			$temp = "<span class='wikilockicon' title='This page is locked.'>&nbsp;</span>";
< 		}
< 		else {	
< 			if ( -f &GetLockedPageFile($id) ) {
< 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='This page locked for others. Click to edit page'><span class='wikiediticon'>&nbsp;</span></a>";
< 			}
< 			else {
< 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='Click to edit this page'><span class='wikiediticon'>&nbsp;</span></a>";
< 			}
< 		}		
< 		$result .= $q->h1( $header . &GetBackLinksSearchLink($id) . $temp );
< 	}
< 	else {
< 		$result .= $q->h1( $header . $title );
< 	}
< 	
< 
< 	if ( &GetParam( "toplinkbar", 1 ) ) {		
< 		$result .= &GetGotoBar($id);
< 		$result .= $WikiLineHeader;
< 	}
< 	
< 	$result .= "</div>";
< 		
< 	return $result;
< }
< 
< sub GetHttpHeader {
< 	my ($type) = @_;
< 	my $cookie;
< 	
< 	$type = "text/html" if ( $type eq "" );
< 	if ( defined( $SetCookie{'id'} ) ) {
< 		$cookie =
< 		   "$CookieName=" . "rev&"
< 		  . $SetCookie{'rev'} . "&id&"
< 		  . $SetCookie{'id'}
< 		  . "&randkey&"
< 		  . $SetCookie{'randkey'};
< 		$cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
< 		if ( $HttpCharset ne "" ) {
< 			return $q->header(
< 				-cookie => $cookie,
< 				-type   => "$type; charset=$HttpCharset"
< 			);
< 		}
< 		return $q->header( -cookie => $cookie );
< 	}
< 	if ( $HttpCharset ne "" ) {
< 		return $q->header( -type => "$type; charset=$HttpCharset" );
< 	}
< 	
< 	return $q->header( -type => $type );
< }
< 
< sub GetHtmlHeader {
< 	my ($title, $id) = @_;
< 	my ( $dtd, $html, $bodyExtra, $stylesheet );
< 	
< 	$html  = "";
< 	$dtd   = "-//IETF//DTD HTML//EN";
< 	$html  = qq(<!DOCTYPE HTML PUBLIC "$dtd">);
< 	$title = $q->escapeHTML($title);
< 	$html .= "\n<html><head><title>$title</title>";
< 	
< 	if ( $FavIcon ne "" ) {
< 		$html .= "<link rel='SHORTCUT ICON' href='$FavIcon'>";
< 	}
< 	
< 	if ($MetaKeywords) {
< 		my $keywords = $OpenPageName;
< 		$keywords =~ s/([a-z])([A-Z])/$1, $2/g;
< 		$html .= "\n<meta name='keywords' content='$keywords'/>" if $keywords;
< 	}
< 	
< 	if ( $SiteBase ne "" ) {
< 		$html .= qq(<base href="$SiteBase">);
< 	}
< 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
< 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
< 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
< 	
< 	if ( $stylesheet ne "" ) {
< 		$html .= qq(<link rel="stylesheet" href="$stylesheet">);
< 	}
< 
<    my $bots = "";
<    # actions and non-existant page views don't get indexed or followed by robots
<    if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
<    $bots = $bots . 'index,' . $bots . 'follow';
<    $html .= qq(<meta name="robots" content="$bots" />\n);
< 	
< 	$html .= $UserHeader;
< 	$bodyExtra = "";
< 	
< 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
< 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
< 	
< 	$html .= "</head><body$bodyExtra>";
< 	$html .= "\n<div id='wikicontainer'>";
< 	
< 	return $html;
< }
< 
< sub GetLeftNav {
< 	my $id = shift;
< 	my $action = &GetParam( "action", "" );
< 	my $html = "";
< 	
< 	$html .= "\n<div class='wikileftnav'>";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'HomePage', 'Home page', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'NobleWiki', 'Wiki Info', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'CategoryCategory', 'Contents', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'FeaturedContent', 'Featured', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'random', 'Random Article', "1");	
< 	
< 	$html .= "\n		</ul>";
< 	$html .= "\n	</div>	";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'RecentChanges', 'Recent changes', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'ListOfWantedPages', 'Wanted Pages', "");
< 					
< 	if ($id ne ""){
< 		unless ($id eq 'ListOfWantedPages' or $id eq 'RecentChanges'){	
< 			if (&UserCanEdit( $id, 0 )){ $html .= "\n<li><a href='?action=edit&id=$id'>Edit this Page</a></li>";	}
< 			else { $html .= "\n<li class='disabled'>Edit this Page</li>"; }
< 							
< 			if ($action eq 'history'){ $html .= "\n<li class='disabled'>Version History</li>"; }
< 			else { $html .= "\n<li><a href='?action=history&id=$id'>Version History</a></li>"; }
< 		}
< 		else {
< 			$html .= "\n<li class='disabled'>Edit this Page</li>"; 
< 			$html .= "\n<li class='disabled'>Version History</li>"; 
< 		}
< 	}
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'SandBox', 'SandBox', "");
< 	
< 	$html .= "\n	</ul></div>";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'editprefs', 'Preferences', "1");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiContacts', 'Contact Us', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiHelp', 'Help', "");
< 		
< 	$html .= "\n		</ul>";
< 	$html .= "\n	</div>";
< 	$html .= "\n	<div class='wikileftnavsearch' style='text-align:right;'>";
< 	$html .= "\n		<form>";
< 	$html .= "\n			<div class='wikisearchlabel' style='text-align:left;'><b>Search</b></div>";
< 	$html .= "\n			<input type='text' title='Enter ! before search term for exclusion' name='search' id='searchterm' />";
< 	$html .= "\n			<input type='submit' value='Go!' name='dosearch' title='Click to perform your search request.' />";
< 	$html .= "\n		</form></div>";
< 	$html .= "\n</div>";
< 	
< 	return $html;	
< }
< 
< sub GetFooterText {
< 	my ( $id, $rev ) = @_;
< 	my $result;
< 	
< 	if ( &GetParam( 'embed', $EmbedWiki ) ) { return ""; }
< 	
< 	$result = "<div class='wikifooter'>";
< 	$result .= &GetGotoBar($id);
< 	$result .= "<div class='wikirevision'>";
< 	
< 	if ($id ne ""){
< 		if ( &UserCanEdit( $id, 0 )) {
< 			if ( $rev ne "" ) {
< 				$result .=
< 				  &GetOldPageLink( 'edit', $id, $rev, Ts( 'Edit revision %s of this page', $rev ) );
< 			}
< 			else {
< 				$result .= &GetEditLink( $id, "Edit text of this page" );
< 			}
< 		}
< 		else {
< 			$result .= "This page is read-only";
< 		}
< 	}
< 	
< 	if ($id ne ""){ $result .= " | " . &GetHistoryLink( $id, "View other revisions", "Click to view revision history" ); }	
< 	if ( $rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
< 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?$id' class='wikiusemetalink'>Search MetaWiki</a>"; }
< 	
< 	$result .= "</div>";
< 	
< 	if ($id ne ""){ 
< 		if ( $Section{'revision'} > 0 ) {
< 			$result .= "<div class='wikirevision'>";		
< 			$result .= "Created " . &TimeToText($Page{'tscreate'});
< 			
< 			if ($Page{'authorcreate'}) { $result .= " by " . $Page{'authorcreate'}; } 
< 			
< 			$result .= " | ";	
< 			if ( $rev eq "" ) { $result .= "Last edited"; }
< 			else { $result .= "Edited"; }
< 			
< 			$result .= " " . &TimeToText( $Section{ts} );
< 				
< 			if ($AuthorFooter) { $result .= " by " . &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}); }
< 		}
< 		
< 		if ($UseDiff) { $result .= " " . &ScriptLinkDiff( 4, $id, "(diff)", $rev ); }
< 	}
< 	
< 	$result .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	$result .= &GetSearchForm();	
< 	if ( $DataDir =~ m|/tmp/| ) {
< 		$result .= "\n<br><b>";
< 		$result .= "Warning";
< 		$result .= ":</b> ";
< 		$result .= "Database is stored in temporary directory $DataDir";
< 		$result .= "\n<br>";
< 	}
< 	
< 	if ( $ConfigError ne "" ) {
< 		$result .= "\n<br>";
< 		$result .= "\n<b>Config file error:</b>";
< 		$result .= "$ConfigError <br>";
< 	}
< 	
< 	$result .= "</form>";
< 	$result .= &getFooterNote();
< 	if ( $AdminBar && &UserIsAdmin() ) { $result .= &GetAdminBar($id, ""); }
< 	$result .= "</div>";
< 		
< 	return $result;
< }
< 
< sub getFooterNote {
< 	my $html;
< 	my $userid = &GetParam("username", "");
< 	my $access = "Guest ";
< 	my $username = "Anonymous";
< 
< 	if (UserIsAdmin()){
< 		$access = "Admin ";
< 	}
< 	elsif (UserIsEditor()){
< 		$access = "Editor ";
< 	}
< 	
< 	if ($userid ne ""){
< 		$username = $userid;
< 	}
< 	
< 	if ($FooterNote ne ""){
< 		$html = $FooterNote;
< 		$html =~ s/access/$access/;
< 		$html =~ s/username/$userid/;
< 	}
< 	
< 	return $html;
< }
< 
< sub GetCommonFooter {
< 	my ($html);
< 	my $id = &GetParam( "id",     "" );
< 	
< 	$html = $WikiLineFooter;
< 	$html .= "\n<div class='wikifooter'>";
< 	$html .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	$html .= &GetGotoBar("");
< 	$html .= &GetSearchForm();
< 	$html .= "</form>";	
< 	$html .= &getFooterNote();
< 	
< 	if ( $AdminBar && &UserIsAdmin() ) { $html .= &GetAdminBar($id, "class='wikirevision'"); }
< 	$html .= "\n<div>"; ## ??NEEDED ??
< 	
< 	return $html;
< }
< 
< sub GetGotoBar {
< 	my ($id) = @_;
< 	my ( $main, $bartext );
< 	
< 	$bartext = "\n<div class='wikigotobar'>";
< 	$bartext .= &GetPageLink($HomePage);
< 	
< 	if ( $id =~ m|/| ) {
< 		$main = $id;
< 		$main =~ s|/.*||;    # Only the main page name (remove subpage)
< 		
< 		unless ($main eq $HomePage){
< 			$bartext .= " | " . &GetPageLink($main);
< 		}
< 	}
< 	
< 	$bartext .= " | " . &GetPageLink($RCName);
< 	$bartext .= " | " . &GetPrefsLink();
< 	
< 	if ( $UseUpload && &UserCanUpload() ) { $bartext .= " | " . &GetUploadLink(); }
< 	
< 	$bartext .= " | " . &ScriptLink( "action=listfiles&filter=sample", "List Assets" );
< 	
< 	if ( &GetParam( "linkrandom", 0 ) ) { $bartext .= " | " . &GetRandomLink(); }
< 	if ( $UserGotoBar ne "" ) { $bartext .= " | " . $UserGotoBar; }
< 	
< 	$bartext .= "</div>";
< 	
< 	return $bartext;
< }
< 
< sub GetSearchForm {
< 	my ($html);
< 	
< 	$html =  "\n<div class='wikisearch'>";
< 	$html .= "\n<div class='wikisearchlabel'>Search:</div>";
< 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";
< 		
< 	if ($SearchButton) { $html .= " " . $q->submit( 'dosearch', "Go!" ); }
< 	else { $html .= &GetHiddenValue( "dosearch", 1 ); }
< 	
< 	$html .= "</div>";
< 	
< 	return $html;
< }
< 
< sub GetRedirectPage {
< 	my ( $newid, $name, $isEdit ) = @_;
< 	my ( $url, $html );
< 	my ($nameLink);
< 
< 	# Normally get URL from script, but allow override.
< 	$FullUrl  = $q->url( -full => 1 ) if ( $FullUrl eq "" );
< 	$url      = $FullUrl . &ScriptLinkChar() . $newid;
< 	$nameLink = "<a href='$url' class='wikiredirect'>$name</a>";
< 	
< 	if ( $RedirType < 3 ) {
< 		if ( $RedirType == 1 ) {    # Use CGI.pm
< 			 # NOTE: do NOT use -method (does not work with old CGI.pm versions)
< 			 # Thanks to Daniel Neri for fixing this problem.
< 			$html = $q->redirect( -uri => $url );
< 		}
< 		else {    # Minimal header
< 			$html = "Status: 302 Moved\n";
< 			$html .= "Location: $url\n";
< 			$html .= "Content-Type: text/html\n";   # Needed for browser failure
< 		}
< 		$html .= " Your browser should go to the $newid page.";
< 		$html .= " If it does not, click $nameLink to continue.";
< 	}
< 	else {
< 		if ($isEdit) {
< 			$html  = &GetHeader( "", "Thanks for editing...", "" );
< 			$html .= &GetLeftNav("");
< 			$html .= "\n<div class='wikiadmin'>";
<  			$html .= "Thank you for editing $nameLink ";
< 		}
< 		else {
< 			$html = &GetHeader( "", "Link to another page...", "" );
< 			$html .= &GetLeftNav("");
< 			$html .= "\n<div class='wikiadmin'>";
< 		}
< 		
< 		$html .= "Follow the $nameLink link to continue.";
< 		$html .= "</div>";
< 		$html .= "</div></div></body></html>";	
< 	}
< 	
< 	return $html;
< }
< 
< # ==== Common wiki markup ====
< sub RestoreSavedText {
< 	my ($text) = @_;
< 	
< 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
< 	
< 	return $text;
< }
< 
< sub RemoveFS {
< 	my ($text) = @_;
< 
< 	# Note: must remove all $FS, and $FS may be multi-byte/char separator
< 	$text =~ s/($FS)+(\d)/$2/g;
< 	
< 	return $text;
< }
< 
< sub WikiToHTML {
< 	my ($pageText) = @_;
< 	$TableMode       = 0;
< 	%SaveUrl         = ();
< 	%SaveNumUrl      = ();
< 	$SaveUrlIndex    = 0;
< 	$SaveNumUrlIndex = 0;
< 	$pageText        = &RemoveFS($pageText);
< 	
< 	if ($RawHtml) { $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige; }
< 	
< 	$pageText = &QuoteHtml($pageText);
< 	$pageText =~ s/\\ *\r?\n/ /g;    # Join lines with backslash at end
< 		
< 	if ($ParseParas) {
< 
< 		# Note: The following 3 rules may span paragraphs, so they are
< 		#       copied from CommonMarkup
< 		$pageText =~ s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
< 		$pageText =~ s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
< 		$pageText =~ s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
< 		$pageText =~ s/\{{template:(\w+\s*.*?)}}/&StoreTemplate($1)/iges;
< 		$pageText =~ s/\{{flash:\s*(.*?)}}/&StoreRaw(&GetFlash($1))/iges;
< 		$pageText =~ s/\{{gallery:\s*(.*?)}}/&StoreRaw(&GetGallery($1))/iges;
< 		
< 		$pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
< 		$pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
< 		
< 	}
< 	else {
< 		$pageText = &WikiLinesToHtml($pageText);         # Line-oriented markup
< 		$pageText = &CommonMarkup( $pageText, 1, 0 );    # Multi-line markup
< 	}
< 	
< 	while (@HeadingNumbers) {
< 		pop @HeadingNumbers;
< 		$TableOfContents .= "</dd></dl>";
< 	}
< 	
< 	$pageText =~ s/&lt;toc&gt;/<div class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
< 	$pageText =~ s/&lt;toc ((\d)+)?&gt;/<div style='width: $1;' class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
< 	$pageText =~ s/\#SUBPAGES\s+(\w+.*?)/&StoreRaw("\n<h6>" . Ts('Subpages of: %s', &QuoteHtml($1)) . "<\/h6>" . &GetPageList(&GetSubpages($1)))/ige;
< 	$pageText =~ s/\#SUBPAGES/&StoreRaw("\n<h6>" . Ts('Subpages for %s', $MainPage) . "<\/h6>" . &GetPageList(&GetSubpages($MainPage)))/ige;
< 	
< 	if ( $LateRules ne "" ) { $pageText = &EvalLocalRules( $LateRules, $pageText, 0 ); }
< 	
< 	return &RestoreSavedText($pageText);
< }
< 
< sub CommonMarkup {
< 	my ( $text, $useImage, $doLines ) = @_;
< 	local $_ = $text;
< 	
< 	if ( $doLines < 2 ) {    # 2 = do line-oriented only
< 		
< 		while ( m!\#INCLUDE\s*((\w+\.?\w*|/)+)!gi and $AllowInclusion ) {		
< 			my $FileName = $1;
< 			
< 			open FILE, "$InclusionDir/$FileName"
< 			or &ReportError("Cannot open $FileName: $!");
< 			
< 			local $/;			
< 			my $FileContent = <FILE>;
< 			
< 			close FILE
< 			or &ReportError("Cannot close $FileName: $!");
< 			s!\#INCLUDE\s*$FileName!$FileContent!i unless $FileName !~ /(html?|txt)$/i;
< 		}
<   
< 		# The <nowiki> tag stores text with no markup (except quoting HTML)
< 		s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
< 
< 		# The <pre> tag wraps the stored text with the HTML <pre> tag
< 		s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
< 		s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
< 		
< 		if ( $EarlyRules ne "" ) {
< 			$_ = &EvalLocalRules( $EarlyRules, $_, !$useImage );
< 		}
< 		
< 		s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
< 		
< 		if ($HtmlTags) {
< 			my ($t);
< 			foreach $t (@HtmlPairs) {
< 				s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
< 			}
< 			foreach $t (@HtmlSingle) {
< 				s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
< 			}
< 		}
< 		else {
< 
< 			# Note that these tags are restricted to a single line
< 			s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
< 			s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
< 			s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
< 			s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
< 		}
< 
< 		# Auto signature if use ~~~~ ; useful for quick comments
< 	    my $id = &GetParam("username", "");
< 		my $idLink = "$HomePagePrefix/$id";
< 		my $timestamp = &TimeToText($Now);
< 		my $finalText = "";
< 		
< 		$id =~ s/ /_/g;
< 
< 		if ($id){
< 			$finalText = &StorePageOrEditLink($idLink, $id);
< 			s/\~\~\~\~/<i>\[$finalText]<\/i>/gi;
< 			s/\$\$\$\$/<i>\[$finalText at $timestamp]<\/i>/gi;
< 		}
< 		else {
< 			$id = "Guest";			
< 			s/\~\~\~\~/<i>\[$id at $timestamp]<\/i>/gi;
< 			s/\$\$\$\$/<i>\[$id at $timestamp]<\/i>/gi;
< 		}
< 		
< 		s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;    # <tt> (MeatBall)
< 		s/\&lt;br\&gt;/<br>/gi;    # Allow simple line break anywhere
< 		
< 		if ($HtmlLinks) {
< 			s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
< 		}
< 		
< 		if ($FreeLinks) {
< 
< 			# Consider: should local free-link descriptions be conditional?
< 			# Also, consider that one could write [[Bad Page|Good Page]]?
< 			s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
< 			s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
< 		}
< 		
< 		if ($BracketText) {        
< 			# Links like [URL text of link]
< 			s/\[$UrlPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketUrl($1, $2, $useImage, $3)/geos;
< 			s/\[$InterLinkPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketInterPage($1, $2, $useImage, $3)/geos;
< 			
< 			if ( $WikiLinks && $BracketWiki ) {    # Local bracket-links
< 				s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
< 				s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1, $2, $3)/geos if $NamedAnchors;
< 			}
< 		}
< 		
< 		s/\[$UrlPattern(\|(.*))?\]/&StoreBracketUrl($1, "", 0, "")/geo;
< 		s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0, "")/geo;
< 		s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
< 		s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
< 		
< 		if ($WikiLinks) {
< 			s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1, $2, ""))/geo if $NamedAnchors;
< 
< 			# CAA: Putting \b in front of $LinkPattern breaks /SubPage links
< 			#      (subpage links without the main page)
< 			s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
< 		}
< 		s/\b$RFCPattern/&StoreRFC($1)/geo;
< 		s/\b$ISBNPattern/&StoreISBN($1)/geo;
< 		
< 		if ($UseUpload) {
< 			s/$UploadPattern/&StoreUpload($1)/geo;
< 		}
< 		
< 		if ($ThinLine) {
< 			if ($OldThinLine) {   
< 				# Backwards compatible, conflicts with headers
< 				s/====+/$WikiLine2/g;
< 			}
< 			else {                
< 				# New behavior--no conflict
< 				s/------+/$WikiLine2/g;
< 			}
< 			s/----+/$WikiLine1/g;
< 		}
< 		else {
< 			s/----+/$WikiLine/g;
< 		}
< 		
< 		if ($AutoMailto) {
< 			s/([A-z0-9-_]+(?:\.[A-z0-9-_]+)*)\@([A-z0-9-_]+(?:\.[A-z0-9-_]+)*(?:\.[A-z]{2,})+)/<a href="mailto:$1\@$2">$1\@$2<\/a>/g;
< 		}
< 	}
< 	
< 	if ($doLines) {    
< 		# 0 = no line-oriented, 1 or 2 = do line-oriented
< 	    # The quote markup patterns avoid overlapping tags (with 5 quotes)
< 	    # by matching the inner quotes for the strong pattern.
< 		s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g; #'REMARK
< 		s/''(.*?)''/<em>$1<\/em>/g;
< 		
< 		if ($UseHeadings) {
< 			s/(^|\n)\s*(\=+)\s*(#)?\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $4, $3)/geo;
< 		}
< 		
< 		if ($TableMode == 1) {
< 			my @cells = split(/\|\|/);
< 			my $cellIndex = 0;
< 			
< 			while (/(\|\|)+([^\|<]+)/) {	
< 				my $switches = @cells->[++$cellIndex];
< 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
< 				my $cellOptions = "$class $style $width $align";
< 				
< 				s/((\|\|)+)/"<\/td><td $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;
< 			} 
< 			s/(\|\w*=\w*)+([^\|<]+)//g;   
< 		}
< 		elsif  ($TableMode == 2) {
< 			my @cells = split(/\!\!/);
< 			my $cellIndex = 0;
< 			
< 			while (/(\!\!)+([^\!<]+)/) {			
< 				my $switches = @cells->[++$cellIndex];
< 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
< 				my $cellOptions = "$class $style $width $align";
< 				
< 				s/((\!\!)+)/"<\/th><th $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;				
< 			}
< 			s/(\|\w*=\w*)+([^\!<]+)//g;
< 		}
< 	}
< 	
< 	return $_;
< }
< 
< sub GetTableCellModifiers {
< 	my ($given, $initialCell, $cellIndex) = @_;	
< 	my ($options) = $given;
< 
< 	/^(\s*(\w+)\s*)\|/;
< 	my $align = $2;
< 	if ($initialCell ne ""){ $align = $initialCell; }
< 		
< 	$align = $align =~ /^  / ? ($align =~ /  $/ ? 'center' : 'right') : 'left';
< 	$align = "align='$align'";
< 	
< 	my ($options) = $options =~ /(\|\S*=\S*)+/g;
< 	my %options = &GetOptions($options);
< 
< 	my $class;
< 	my $style;
< 	my $width;	
< 	my $rowclass;
< 	my $rowstyle;
< 	my $rowalign;
< 	my $tablewidth;
< 	my $tableclass;
< 	my $tablestyle;
< 		
< 	if ($TableCellDefaults{"rowclass"} =~ /clear/){ $TableCellDefaults{"rowclass"} = ""; }
< 	if ($TableCellDefaults{"rowstyle"} =~ /clear/){ $TableCellDefaults{"rowstyle"} = ""; }
< 	if ($TableCellDefaults{"rowalign"} =~ /clear/){ $TableCellDefaults{"rowalign"} = ""; }
< 				
< 	if ($TableCellDefaults{"rowclass"}){ $rowclass = $TableCellDefaults{"rowclass"}; }
< 	if ($TableCellDefaults{"rowstyle"}){ $rowstyle = $TableCellDefaults{"rowstyle"}; }
< 	if ($TableCellDefaults{"rowalign"}){ $rowalign = $TableCellDefaults{"rowalign"}; }
< 		
< 	if ($options{'rowclass'}){ $rowclass = "class='" . $options{'rowclass'} . "'"; $TableCellDefaults{"rowclass"} = $rowclass; }
< 	if ($options{'rowstyle'}){ $rowstyle = "style='" . $options{'rowstyle'} . "'"; $TableCellDefaults{"rowstyle"} = $rowstyle; }
< 	if ($options{'rowalign'}){ $rowalign = "align='" . $options{'rowalign'} . "'"; $TableCellDefaults{"rowalign"} = $rowalign; }
< 	
< 	if ($rowclass){ $class = $rowclass; }
< 	if ($rowstyle){ $style = $rowstyle; }
< 	if ($rowalign){ $align = $rowalign; }
< 
< 	if ($TableCellDefaults{"class$cellIndex"} =~ /clear/){ $TableCellDefaults{"class$cellIndex"} = ""; }
< 	if ($TableCellDefaults{"style$cellIndex"} =~ /clear/){ $TableCellDefaults{"style$cellIndex"} = ""; }
< 	if ($TableCellDefaults{"align$cellIndex"} =~ /clear/){ $TableCellDefaults{"align$cellIndex"} = ""; }
< 			
< 	if ($TableCellDefaults{"class$cellIndex"}){ $class = $TableCellDefaults{"class$cellIndex"}; }
< 	if ($TableCellDefaults{"style$cellIndex"}){ $style = $TableCellDefaults{"style$cellIndex"}; }
< 	if ($TableCellDefaults{"align$cellIndex"}){ $align = $TableCellDefaults{"align$cellIndex"}; }
< 
< 	if ($options{'class'}){ $class = "class='" . $options{'class'} . "'"; $TableCellDefaults{"class$cellIndex"} = $class; }
< 	if ($options{'style'}){ $style = "style='" . $options{'style'} . "'"; $TableCellDefaults{"style$cellIndex"} = $style; }
< 	if ($options{'align'}){ $align = "align='" . $options{'align'} . "'"; $TableCellDefaults{"align$cellIndex"} = $align; }
< 	if ($options{'width'}){ $width = "width='" . $options{'width'} . "'"; }
< 	if ($options{'tablewidth'}){ $tablewidth = "width='" . $options{'tablewidth'} . "'"; }
< 	if ($options{'tablestyle'}){ $tablestyle = "style='" . $options{'tablestyle'} . "'"; }
< 	if ($options{'tableclass'}){ $tableclass = "class='" . $options{'tableclass'} . "'"; } else { $tableclass = "class='wikilargelist'"; }
< 					
< 	return ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass);				
< }
< 
< sub WikiLinesToHtml {
< 	my ($pageText) = @_;
< 	my ( $pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode );
< 	
< 	@htmlStack = ();
< 	$depth     = 0;
< 	$pageHtml  = "";
< 	
< 	foreach ( split( /\r?\n/, $pageText ) ) {    # Process lines one-at-a-time
< 		$code           = "";
< 		$codeAttributes = "";
< 		$TableMode      = 0;
< 		$_ .= "\n";
< 		
< 		if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
< 			$code  = "dl";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\:+)/<dt><dd>/) {
< 			$code  = "dl";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\*+)/<li>/) {
< 			$code  = "ul";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\#+)/<li>/) {
< 			$code  = "ol";
< 			$depth = length $1;
< 		}
< 		elsif ($TableSyntax && /^(\!\!)+.*\!\!\s*$/) {
< 			/^(\!\!)+([^\!]+)/;
< 			
< 			%TableCellDefaults = {};
< 			
< 			my $switches = $2;
< 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, "", 0);
< 			my $cellOptions = "$class $style $width $align";
< 			
< 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/th><\/tr>\n"/e;
< 			
< 			$code = "table";
< 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
< 			$TableMode = 2;
< 			$depth = 1;
< 		}
< 		elsif ($TableSyntax && /^(\|\|)+.*\|\|\s*$/) {
< 			/^((\|\|)+)(.*?)\|\|/;	
< 	
< 			my ($alignInitial) = $3;
< 			my $switches = $3;
< 			($alignInitial) = $alignInitial =~ /(.*)\|/;	
< 
< 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, $alignInitial, 0);
< 			my $cellOptions = "$class $style $width $align";
< 			
< 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/td><\/tr>\n"/e;
< 			
< 			$code = "table";
< 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
< 			$TableMode = 1;
< 			$depth = 1;
< 		}
< 		elsif (/^[ \t].*\S/) {
< 			$code  = "pre";
< 			$depth = 1;
< 		}
< 		else {
< 			$depth = 0;
< 		}
< 		
< 		while ( @htmlStack > $depth ) {    
< 			# Close tags as needed
< 			$pageHtml .= "</" . pop(@htmlStack) . ">";
< 		}
< 		
< 		if ( $depth > 0 ) {
< 			$depth = $IndentLimit if ( $depth > $IndentLimit );
< 			if (@htmlStack) {              
< 				# Non-empty stack
< 				$oldCode = pop(@htmlStack);
< 				
< 				if ( $oldCode ne $code ) {
< 					$pageHtml .= "</$oldCode><$code>";
< 				}
< 				push( @htmlStack, $code );
< 			}
< 			
< 			while ( @htmlStack < $depth ) {
< 				push( @htmlStack, $code );
< 				$pageHtml .= "\n<$code $codeAttributes>";
< 			}
< 		}
< 		
< 		if ( !$ParseParas ) {
< 			s/^\s*$/<p>\n/;    # Blank lines become <p> tags
< 		}
< 		$pageHtml .= &CommonMarkup( $_, 1, 2 );    # Line-oriented common markup
< 	}
< 	
< 	while ( @htmlStack > 0 ) {                     
< 		# Clear stack
< 		$pageHtml .= "</" . pop(@htmlStack) . ">";
< 	}
< 	
< 	return $pageHtml;
< }
< 
< sub EvalLocalRules {
< 	my ( $rules, $origText, $isDiff ) = @_;
< 	my ( $text, $reportError, $errorText );
< 	
< 	$text        = $origText;
< 	$reportError = 1;
< 
< 	# Basic idea: the $rules should change $text, possibly with different
< 	# behavior if $isDiff is true (no images or color changes?)
< 	# Note: for fun, the $rules could also change $reportError and $origText
< 	if ( !eval $rules ) {
< 		$errorText = $@;
< 		
< 		if ( $errorText eq "" ) {
< 
< 		  # Search for "Unknown Error" for the reason the next line is commented
< 		  #     $errorText = "Unknown Error (no error text)";
< 		}
< 		if ( $errorText ne "" ) {
< 			$text = $origText;    # Consider: should partial results be kept?
< 			
< 			if ($reportError) {
< 				$text .= "\n<hr>";
< 				$text .= "<b>";
< 				$text .= "Local rule error:";
< 				$text .= "</b><br>";
< 				$text .= &QuoteHtml($errorText);
< 			}
< 		}
< 	}
< 	
< 	return $text;
< }
< 
< sub QuoteHtml {
< 	my ($html) = @_;
< 	
< 	$html =~ s/&/&amp;/g;
< 	$html =~ s/</&lt;/g;
< 	$html =~ s/>/&gt;/g;
< 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
< 	
< 	return $html;
< }
< 
< sub ParseParagraph {
< 	my ($text) = @_;
< 	
< 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
< 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
< 	
< 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
< 	
< 	return "\n<p>$text</p>";
< }
< 
< sub StoreInterPage {
< 	my ( $id, $useImage ) = @_;
< 	my ( $link, $extra );
< 	
< 	( $link, $extra ) = &InterPageLink( $id, $useImage );
< 
< 	# Next line ensures no empty links are stored
< 	$link = &StoreRaw($link) if ( $link ne "" );
< 	
< 	return $link . $extra;
< }
< 
< sub InterPageLink {
< 	my ( $id, $useImage ) = @_;
< 	my ( $name, $site, $remotePage, $url, $punct );
< 	
< 	( $id, $punct ) = &SplitUrlPunct($id);
< 	$name = $id;
< 	( $site, $remotePage ) = split( /:/, $id, 2 );
< 	$url = &GetSiteUrl($site);
< 	
< 	return ( "", $id . $punct ) if ( $url eq "" );
< 	
< 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
< 	$url .= $remotePage;
< 	
< 	return ( &UrlLinkOrImage( $url, $name, $useImage ), $punct );
< }
< 
< sub StoreBracketInterPage {
< 	my ( $id, $text, $useImage, $options ) = @_;
< 	my ( $site, $remotePage, $url, $index );
< 	
< 	( $site, $remotePage ) = split( /:/, $id, 2 );
< 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
< 	$url = &GetSiteUrl($site);
< 	
< 	if ( $text ne "" ) {
< 		return "[$id $text]" if ( $url eq "" );
< 	}
< 	else {
< 		return "[$id]" if ( $url eq "" );
< 		$text = &GetBracketUrlIndex($id);
< 	}
< 	
< 	$url .= $remotePage;
< 	
< 	$text = StoreBracketUrl( $url, $text, $useImage, $options);
< 	
< 	return $text;
< }
< 
< sub GetBracketUrlIndex {
< 	my ($id) = @_;
< 	my ( $index, $key );
< 
< 	# Consider plain array?
< 	if ( $SaveNumUrl{$id} > 0 ) { return $SaveNumUrl{$id}; }
< 	
< 	$SaveNumUrlIndex++;    # Start with 1
< 	$SaveNumUrl{$id} = $SaveNumUrlIndex;
< 	
< 	return $SaveNumUrlIndex;
< }
< 
< sub GetSiteUrl {
< 	my ($site) = @_;
< 	my ( $data, $status );
< 	
< 	if ( !$InterSiteInit ) {
< 		( $status, $data ) = &ReadFile($InterFile);
< 		
< 		if ($status) {
< 			%InterSite = split( /\s+/, $data );    # Consider defensive code
< 		}
< 
< 		# Check for definitions to allow file to override automatic settings
< 		if ( !defined( $InterSite{'LocalWiki'} ) ) {
< 			$InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
< 		}
< 		
< 		if ( !defined( $InterSite{'Local'} ) ) {
< 			$InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
< 		}
< 		
< 		$InterSiteInit = 1;                        # Init only once per request
< 	}
< 	
< 	return $InterSite{$site} if ( defined( $InterSite{$site} ) );
< 	return "";
< }
< 
< sub StoreRaw {
< 	my ($html) = @_;
< 	
< 	$SaveUrl{$SaveUrlIndex} = $html;
< 	
< 	return $FS . $SaveUrlIndex++ . $FS;
< }
< 
< sub StorePre {
< 	my ( $html, $tag ) = @_;
< 	
< 	return &StoreRaw( "<$tag>" . $html . "</$tag>" );
< }
< 
< sub ReadWikiFile {
< 	my ($fileName) = @_;
< 	my ($fileData, %tempPage, %tempSection, %tempText);
< 	
< 	return unless -f $fileName;
< 	
< 	$fileData = &ReadFileOrDie($fileName);
< 	%tempPage = split(/$FS1/, $fileData, -1);
< 	%tempSection = split(/$FS2/, $tempPage{'text_default'}, -1);
< 	%tempText = split(/$FS3/, $tempSection{'data'}, -1);
< 	
< 	return $tempText{'text'};
< }
< 
< sub WikiFileToHTML {
< 	my ($text) = @_;
< 	my ($output);
< 	my ($mySaveUrlIndex, $mySaveNumUrlIndex, $myTableMode, %mySaveUrl, %mySaveNumUrl);
< 	
< 	return unless $text;
< 	
< 	# Global variables do not help this code. Nasty, but easiest solution.
< 	%mySaveUrl= %SaveUrl;
< 	%mySaveNumUrl= %SaveNumUrl;
< 	$mySaveUrlIndex= $SaveUrlIndex;
< 	$mySaveNumUrlIndex = $SaveNumUrlIndex;
< 	$myTableMode= $TableMode;
< 	
< 	$output = &WikiToHTML($text);
< 	
< 	%SaveUrl = %mySaveUrl;
< 	%SaveNumUrl = %mySaveNumUrl;
< 	$SaveUrlIndex = $mySaveUrlIndex;
< 	$SaveNumUrlIndex = $mySaveNumUrlIndex;
< 	$TableMode = $myTableMode;
< 	
< 	return $output;
< }
< 
< sub StoreTemplate {
< 	my ($params) = @_;
< 	my ($templateId, $templateFile, $templateText, $output, %substitutes);
< 	
< 	$params =~ s/^\s*(\S+)\s*/$templateId=$1,''/e;
< 	return &StoreRaw('No template name') unless $templateId;
< 	
< 	$templateFile = &GetPageFile($templateId);
< 	return &StoreRaw(Ts('Template %s not found', $templateId)) unless -f $templateFile;
< 	
< 	while ($params =~ /^(\S+)\s*=(.*)$/gm) {
< 		$substitutes{$1} = $2;
< 	}
< 	
< 	$templateText = &ReadWikiFile($templateFile);
< 	$templateText =~ s/\$(\S+)\$/$substitutes{$1}/gi;
< 	$templateText =~ s/{{//g; # Avoid nesting.
< 	$output = &WikiFileToHTML($templateText);
< 	
< 	return &StoreRaw($output);
< }
< 
< sub StoreHref {
< 	my ( $anchor, $text ) = @_;
< 	
< 	return "<a" . &StoreRaw($anchor) . ">$text</a>";
< }
< 
< sub StoreUrl {
< 	my ( $name, $useImage ) = @_;
< 	my ( $link, $extra );
< 	
< 	( $link, $extra ) = &UrlLink( $name, $useImage );
< 
< 	# Next line ensures no empty links are stored
< 	$link = &StoreRaw($link) if ( $link ne "" );
< 	
< 	return $link . $extra;
< }
< 
< sub UrlLink {
< 	my ( $rawname, $useImage ) = @_;
< 	my ( $name, $punct );
< 	
< 	( $name, $punct ) = &SplitUrlPunct($rawname);
< 	
< 	if ( $LimitFileUrl && ( $NetworkFile && $name =~ m|^file:| ) ) {
< 
< 		# Only do remote file:// links. No file:///c|/windows.
< 		if ( $name =~ m|^file://[^/]| ) {
< 			return ( "<a href='$name' class='wikiurllink'>$name</a>", $punct );
< 		}
< 		
< 		return ( $rawname, "" );
< 	}
< 	
< 	return ( &UrlLinkOrImage( $name, $name, $useImage ), $punct );
< }
< 
< sub UrlLinkOrImage {
< 	my ( $url, $name, $useImage ) = @_;
< 	
< 	# Restricted image URLs so that mailto:foo@bar.gif is not an image
< 	if ( $useImage && &ImageAllowed($url) ) {
< 		return "<a href='$url' class='wikiurlorimage' target='_blank'><img class='wikiurlorimage' src='$url'></a>";
< 	}
< 	
< 	return "<a href='$url' class='wikiurlorimage'>$name</a>";
< }
< 
< sub ImageAllowed {
< 	my ($url) = @_;
< 	my ( $site, $imagePrefixes );
< 	
< 	$imagePrefixes = 'http:|https:|ftp:|upload:';
< 	$imagePrefixes .= '|file:' if ( !$LimitFileUrl );
< 	
< 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
< 	return 0 if ( $url =~ /"/ );    #" No HTML-breaking quotes allowed
< 	return 1 if ( @ImageSites < 1 );    # Most common case: () means all allowed
< 	return 0 if ( $ImageSites[0] eq 'none' );    # Special case: none allowed
< 
< 	foreach $site (@ImageSites) {
< 		return 1
< 		  if ( $site eq substr( $url, 0, length($site) ) );    # Match prefix
< 	}
< 	
< 	return 0;
< }
< 
< sub ExtensionAllowed {
< 	my ($file) = @_;
< 	
< 	return 1 if ( $file =~ m/\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
< 	
< 	return 0;	
< }
< 
< sub GetUploadUrl {
< 	my ($url) = @_;
< 	
< 	&StoreRaw($url);
< }
< 
< sub GetOptions {
< 	my ($text) = @_;
< 	my %options;
< 	
< 	foreach my $pair (split(/\|/, $text)){
< 		my @keyvalues = split (/=/, $pair);
< 		$options{$keyvalues[0]} = $keyvalues[1];
< 	}
< 	
< 	return %options;	
< }
< 
< sub ComputeImageRatio {
< 	my ($imageName, $desiredWidth, $desiredHeight, $okayLarger) = @_;
< 	my $filepath = "$UploadDir/$imageName";
< 	my ($imageWidth, $imageHeight) = Image::Size::imgsize($filepath);
< 	
< 	my $ratioWidth = 1;
< 	my $ratioHeight = 1;
< 	my $ratioFinal = 1;
< 	
< 	if ($desiredWidth){ $ratioWidth = $desiredWidth/$imageWidth; }
< 	if ($desiredHeight){ $ratioHeight = $desiredHeight/$imageHeight; }
< 	
< 	if ($okayLarger){
< 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioWidth; }
< 		else { $ratioFinal = $ratioHeight; }
< 	}
< 	else {
< 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioHeight; }
< 		else { $ratioFinal = $ratioWidth; }
< 	
< 	}
< 	
< 	my $finalWidth = int($ratioFinal * $imageWidth);
< 	my $finalHeight = int($ratioFinal * $imageHeight);
< 	
< 	return ($finalWidth, $finalHeight);
< }
< 
< sub StoreBracketUrl {
< 	my ( $url, $text, $useImage, $options ) = @_;
< 	my %options = &GetOptions($options);
< 	my $imageFloat;
< 	my $imageClear = "\n<br class='clear$options{clear}'/>";
< 	my $boxFloat = " float" . $options{'boxfloat'};
< 	my $boxClear = "\n<br class='clear$options{boxclear}'/>";
< 	my $width;
< 	my $height;
< 	my $title;
< 	my $caption;
< 	my $description;
< 	my $imageLink;
< 	my $boxWidth = "style='width: 300px !important;'";
< 
< 	if ( $text eq "" ) { $text = &GetBracketUrlIndex($url); }
< 
< 	if ($options{'float'}){ $imageFloat = "float" . $options{'float'}; }
< 	if ($options{'clear'}){ $imageClear = "\n<br class='clear$options{clear}'/>"; }
< 	if ($options{'title'}){ $title = $options{title}; } else { $title = $text; }
< 	if ($options{'width'}){ $width = $options{'width'}; }
< 	if ($options{'height'}){ $height = $options{'height'}; }
< 			
< 	if ($options{'boxfloat'}){ $boxFloat = "float" . $options{'boxfloat'}; }
< 	if ($options{'boxclear'}){ $boxClear = "\n<br class='clear$options{boxclear}'/>"; }
< 	if ($options{'boxwidth'}){ $boxWidth = "style='width: $options{boxwidth} !important;'"; }
< 	if ($options{'caption'}){ 
< 		if ($options{'description'}){ $description = $options{description}; } 
< 		else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
< 		
< 		$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div><div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
< 	}
< 	
< 	if ($url =~ /$UploadPattern/){ $url = "$UploadUrl/$1"; }	
< 	if ( $BracketImg && $useImage && &ImageAllowed($text) ) {		
< 		if ($text =~ /$UploadPattern/){
< 			my $imageName = $1;
< 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($imageName, $width, $height, "");
< 			my $imageStyle = "style='width: $imageWidth; height: $imageHeight;'";
< 			
< 			$imageLink = "$UploadUrl/" . &GetUploadUrl($1);			
< 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' $imageStyle src='$imageLink'></a>";
< 		}
< 		else {
< 			$imageLink = $text;
< 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' src='$imageLink'></a>";
< 		}
< 		my $expandlink =  "<a target='_blank' class='wikiexpandimageicon' href='$imageLink' title='View source image'>&nbsp;</a>";
< 		
< 		if ($options{'caption'}){ 
< 			if ($options{'description'}){ $description = $options{description}; } 
< 			else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
< 			
< 			$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div>$expandlink<div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
< 		}
< 			
< 		if ($imageClear){ $text .= $imageClear; }		
< 					
< 		if ($caption){
< 			$text = "\n<div title='$title' class='wikibracketbox $boxFloat' $boxWidth>$text$caption</div>";		
< 		}
< 		else {
< 			$text = "\n<div title='$title' class='$boxFloat'>$text</div>";	
< 		}
< 		
< 		if ($boxClear){ $text .= $boxClear; }
< 	}
< 	else {
< 		$text = "<a href='$url' title='$title' class='wikibracketurl'>[$text]</a>";
< 	}
< 	
< 	return &StoreRaw($text);
< }
< 
< sub StoreBracketLink {
< 	my ( $name, $text ) = @_;
< 	
< 	return &StoreRaw( &GetPageLinkText( $name, "[$text]" ) );
< }
< 
< sub StoreBracketAnchoredLink {
< 	my ( $name, $anchor, $text ) = @_;
< 	
< 	return &StoreRaw( &GetPageLinkText( "$name#$anchor", "[$text]" ) );
< }
< 
< sub StorePageOrEditLink {
< 	my ( $page, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$page =~ s/^\s+//;        # Trim extra spaces
< 		$page =~ s/\s+$//;
< 		$page =~ s|\s*/\s*|/|;    # ...also before/after subpages
< 	}
< 	$name =~ s/^\s+//;
< 	$name =~ s/\s+$//;
< 	
< 	return &StoreRaw( &GetPageOrEditLink( $page, $name ) );
< }
< 
< sub StoreRFC {
< 	my ($num) = @_;
< 	
< 	return &StoreRaw( &RFCLink($num) );
< }
< 
< sub RFCLink {
< 	my ($num) = @_;
< 	
< 	return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\" class='wikirfclink'>RFC $num</a>";
< }
< 
< sub StoreUpload {
< 	my ($url) = @_;
< 	
< 	return &StoreRaw( &UploadLink($url) );
< }
< 
< sub UploadLink {
< 	my ($filename) = @_;
< 	my ( $html, $url );
< 	
< 	return $filename if ( $UploadUrl eq "" );    # No bad links if misconfigured
< 	
< 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
< 	$url  = $UploadUrl . $filename;
< 	$html = "<a href='$url' class='wikiuploadlink' target='_blank'>";
< 	
< 	if ( &ImageAllowed($url) ) {
< 		$html .= "<img class='wikiuploadlink' src='$url' alt='upload:$filename'>";
< 	}
< 	else {
< 		$html .= "upload:$filename";
< 	}
< 	$html .= "</a>";
< 	
< 	return $html;
< }
< 
< sub StoreISBN {
< 	my ($num) = @_;
< 	
< 	return &StoreRaw( &ISBNLink($num) );
< }
< 
< sub ISBNALink {
< 	my ( $num, $pre, $post, $text ) = @_;
< 	
< 	return "<a href='$pre$num$post' class='wikiisbnalink'>$text</a>";
< }
< 
< sub ISBNLink {
< 	my ($rawnum) = @_;
< 	my ( $rawprint, $html, $num, $numSites, $i );
< 	
< 	$num      = $rawnum;
< 	$rawprint = $rawnum;
< 	$rawprint =~ s/ +$//;
< 	$num      =~ s/[- ]//g;
< 	$numSites = scalar @IsbnNames;    # Number of entries
< 	
< 	if ( ( length($num) != 10 ) || ( $numSites < 1 ) ) {
< 		return "ISBN $rawnum";
< 	}
< 	
< 	$html = &ISBNALink( $num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint );
< 	
< 	if ( $numSites > 1 ) {
< 		$html .= " (";
< 		$i = 1;
< 		while ( $i < $numSites ) {
< 			$html .=
< 			  &ISBNALink( $num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i] );
< 			if ( $i < ( $numSites - 1 ) ) {    # Not the last site
< 				$html .= ", ";
< 			}
< 			$i++;
< 		}
< 		$html .= ")";
< 	}
< 	
< 	$html .= " " if ( $rawnum =~ / $/ );    # Add space if old ISBN had space.
< 	
< 	return $html;
< }
< 
< sub SplitUrlPunct {
< 	my ($url) = @_;
< 	my ($punct);
< 	
< 	if ( $url =~ s/\"\"$// ) {  #"REMARK
< 		return ( $url, "" );    # Delete double-quote delimiters here
< 	}
< 	
< 	$punct = "";
< 	if ($NewFS) {
< 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/ );
< 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
< 	}
< 	else {
< 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/ );
< 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
< 	}
< 	
< 	return ( $url, $punct );
< }
< 
< sub StripUrlPunct {
< 	my ($url) = @_;
< 	my ($junk);
< 	
< 	( $url, $junk ) = &SplitUrlPunct($url);
< 	
< 	return $url;
< }
< 
< sub WikiHeadingNumber {
< 	my ( $depth, $text, $useNumber) = @_;
< 	my ( $anchor, $number );
< 	
< 	return "" unless --$depth > 0;
< 		
< 	while ( scalar @HeadingNumbers < ( $depth - 1 ) ) {
< 		push @HeadingNumbers, 1;
< 		$TableOfContents .= "<dl><dt></dt><dd>";
< 	}
< 	
< 	if ( scalar @HeadingNumbers < $depth ) {
< 		push @HeadingNumbers, 0;
< 		$TableOfContents .= "<dl><dt></dt><dd>";
< 	}
< 	
< 	while ( scalar @HeadingNumbers > $depth ) {
< 		pop @HeadingNumbers;
< 		$TableOfContents .= "</dd></dl>";
< 	}
< 	
< 	$HeadingNumbers[$#HeadingNumbers]++;
< 	$number = ( join '.', @HeadingNumbers ) . '. ';
< 
< 	# Remove embedded links. THIS IS FRAGILE!
< 	$text = &RestoreSavedText($text);
< 	$text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si;        # No such page syntax
< 	$text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
< 
< 	# Cook anchor by canonicalizing $text.
< 	$anchor = $text;
< 	$anchor =~ s/\<.*?\>//g;
< 	$anchor =~ s/\W/_/g;
< 	$anchor =~ s/__+/_/g;
< 	$anchor =~ s/^_//;
< 	$anchor =~ s/_$//;
< 
< 	# Last ditch effort
< 	$anchor = "_" . ( join '_', @HeadingNumbers ) unless $anchor;
< 	$TableOfContents .= ('&nbsp;' x (2 * $depth)) . $number;
< 	$TableOfContents .= &ScriptLink( "$OpenPageName#$anchor", $text );
< 	$TableOfContents .= "</dd><dt>";
< 	$TableOfContents .= "</dt><dd>";
< 	  
< 	## return &StoreHref(" name='$anchor'") . $number;
< 	if ($useNumber) {
< 		return &StoreHref(" name='$anchor'") . $number;
< 	} else {
< 		return &StoreHref(" name='$anchor'");
< 	}
< }
< 
< sub WikiHeading {
< 	## my ( $pre, $depth, $text ) = @_;
< 	my ($pre, $depth, $text, $useNumber) = @_;
< 	
< 	$depth = length($depth);
< 	$depth = 6 if ( $depth > 6 );
< 		
< 	if ($useNumber) {
< 		$text = &WikiHeadingNumber($depth,$text, 1) . $text;
< 	} else {
< 		$text = &WikiHeadingNumber($depth,$text, 0) . $text;
< 	}	
< 	
< 	return $pre . "<H$depth>$text</H$depth>";
< }
< 
< # ==== Difference markup and HTML ====
< sub GetDiffHTML {
< 	my ( $diffType, $id, $revOld, $revNew, $newText ) = @_;
< 	my ( $html, $diffText, $diffTextTwo, $priorName, $links, $usecomma );
< 	my ( $major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName );
< 	
< 	$links     = " (";
< 	$usecomma  = 0;
< 	$major     = &ScriptLinkDiff( 1, $id, "major diff", "" );
< 	$minor     = &ScriptLinkDiff( 2, $id, "minor diff", "" );
< 	$author    = &ScriptLinkDiff( 3, $id, "author diff", "" );
< 	$useMajor  = 1;
< 	$useMinor  = 1;
< 	$useAuthor = 1;
< 	$diffType  = &GetParam( "defaultdiff", 1 ) if ( $diffType == 4 );
< 	
< 	if ( $diffType == 1 ) {
< 		$priorName = "major";
< 		$cacheName = "major";
< 		$useMajor  = 0;
< 	}
< 	elsif ( $diffType == 2 ) {
< 		$priorName = "minor";
< 		$cacheName = "minor";
< 		$useMinor  = 0;
< 	}
< 	elsif ( $diffType == 3 ) {
< 		$priorName = "author";
< 		$cacheName = "author";
< 		$useAuthor = 0;
< 	}
< 	
< 	if ( $revOld ne "" ) {
< 
< 		# Note: OpenKeptRevisions must have been done by caller.
< 		# Eventually optimize if same as cached revision
< 		$diffText = &GetKeptDiff( $newText, $revOld, 1 );    # 1 = get lock
< 		if ( $diffText eq "" ) {
< 			$diffText = "(The revisions are identical or unavailable.)";
< 		}
< 	}
< 	else {
< 		$diffText = &GetCacheDiff($cacheName);
< 	}
< 	
< 	$useMajor = 0 if ( $useMajor && ( $diffText eq &GetCacheDiff("major") ) );
< 	$useMinor = 0 if ( $useMinor && ( $diffText eq &GetCacheDiff("minor") ) );
< 	$useAuthor = 0 if ( $useAuthor && ( $diffText eq &GetCacheDiff("author") ) );
< 	$useMajor = 0 if ( ( !defined( &GetPageCache('oldmajor') ) ) || ( &GetPageCache("oldmajor") < 1 ) );
< 	$useAuthor = 0 if ( ( !defined( &GetPageCache('oldauthor') ) ) || ( &GetPageCache("oldauthor") < 1 ) );
< 	
< 	if ($useMajor) {
< 		$links .= $major;
< 		$usecomma = 1;
< 	}
< 	
< 	if ($useMinor) {
< 		$links .= ", " if ($usecomma);
< 		$links .= $minor;
< 		$usecomma = 1;
< 	}
< 	
< 	if ($useAuthor) {
< 		$links .= ", " if ($usecomma);
< 		$links .= $author;
< 	}
< 	
< 	if ( !( $useMajor || $useMinor || $useAuthor ) ) {
< 		$links .= "no other diffs";
< 	}
< 	$links .= ")";
< 	
< 	if ( ( !defined($diffText) ) || ( $diffText eq "" ) ) {
< 		$diffText = "No diff available.";
< 	}
< 	
< 	if ( $revOld ne "" ) {
< 		my $currentRevision = "current revision";
< 		
< 		$currentRevision = "revision $revNew " if $revNew;
< 		$html .= "<h4>Difference (from revision $revOld to $currentRevision)</h4>";
< 		$html .= "$links<br><br>";
< 		$html .= &DiffToHTML($diffText);
< 	}
< 	else {
< 		if (
< 			( $diffType != 2 )
< 			&& (   ( !defined( &GetPageCache("old$cacheName") ) )
< 				|| ( &GetPageCache("old$cacheName") < 1 ) )
< 		  )
< 		{
< 			$html .= "<h4>No diff available -- this is the first $priorName revision.</h4>";
< 			$html .= "$links<br><br>";
< 		}
< 		else {
< 			$html .= "<h4>Difference from prior $priorName revision</h4>";
< 			$html .= "$links<br><br>";
< 			$html .= &DiffToHTML($diffText);
< 		}
< 	}
< 	@HeadingNumbers  = ();
< 	$TableOfContents = "";
< 		
< 	return $html;
< }
< 
< sub GetCacheDiff {
< 	my ($type) = @_;
< 	my ($diffText);
< 	
< 	$diffText = &GetPageCache("diff_default_$type");
< 	$diffText = &GetCacheDiff('minor') if ( $diffText eq "1" );
< 	$diffText = &GetCacheDiff('major') if ( $diffText eq "2" );
< 	
< 	return $diffText;
< }
< 
< # Must be done after minor diff is set and OpenKeptRevisions called
< sub GetKeptDiff {
< 	my ( $newText, $oldRevision, $lock ) = @_;
< 	my ( %sect, %data, $oldText );
< 	
< 	$oldText = "";
< 	if ( defined( $KeptRevisions{$oldRevision} ) ) {
< 		%sect = split( /$FS2/, $KeptRevisions{$oldRevision}, -1 );
< 		%data = split( /$FS3/, $sect{'data'}, -1 );
< 		$oldText = $data{'text'};
< 	}
< 	
< 	return "" if ( $oldText eq "" );    # Old revision not found
< 	return &GetDiff( $oldText, $newText, $lock );
< }
< 
< sub GetDiff {
<   my $textOld = shift;
<   my $textNew = shift;
< 
<   my %format = (
<     paraIdent     => '<tr valign=top><td class="diff-para-ident">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident">%text%</td></tr>',
<     paraAdded     => '<tr valign=top><td class="diff-para-ident"></td><td class="diff-vertical"></td><td class="diff-para-added">%text%</td></tr>',
<     paraDeleted   => '<tr valign=top><td class="diff-para-deleted">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident"></td></tr>',
<     paraChanged   => '<tr valign=top><td class="diff-para-changed-old">%text%</td><td class="diff-vertical"></td><td class="diff-para-changed-new">%text%</td></tr>',
<     paraReplaced  => '<tr valign=top><td class="diff-para-deleted">%textDeleted%</td><td class="diff-vertical"></td><td class="diff-para-added">%textAdded%</td></tr>',
<   
<     changeContext => 1,
<     changeHeader  => '<tr valign=top><td class="diff-header">Paragraph %oldFrom%</td><td class="diff-vertical">&nbsp;</td><td class="diff-header">Paragraph %newFrom%</td></tr>',
<   
<     spanIdent     => '<span class="diff-span-ident">%text%</span>',
<     spanAdded     => '<span class="diff-span-added">%text%</span>',
<     spanDeleted   => '<span class="diff-span-deleted">%text%</span>',
< 
<     processText => sub {
< 
<       my $text = shift;
< 
<       $text =~ s[&]               [&amp;]g;
<       $text =~ s[<]               [&lt;]g;
<       $text =~ s[>]               [&gt;]g;
<       $text =~ s[\n]              [<br>\n]g;
<       $text =~ s[\r]              []g;
<       $text =~ s[([\t ]+)([\t ])] [('&nbsp;' x length($1)) . $2]ge;
<       $text =~ s[^[\t ]]          [&nbsp;];
< 
<       return $text;
<     }
<   );
< 
<   my $diff = Diff::diffText($textOld, $textNew, %format);
<   
<   if ($diff ne "") {
<     $diff =~ s[<td class="diff-para-changed-old">(.*?)</td>] [
<       my $textChanged = $1;
<       $textChanged =~ s[<span class="diff-span-added">.*?</span>] []gs;
<       qq[<td class="diff-para-changed">$textChanged</td>];
<     ]ges;
<     
<     $diff =~ s[<td class="diff-para-changed-new">(.*?)</td>] [
<       my $textChanged = $1;
<       $textChanged =~ s[<span class="diff-span-deleted">.*?</span>] []gs;
<       qq[<td class="diff-para-changed">$textChanged</td>];
<     ]ges;
<   
<     $diff = qq[<div id=wikidiffdiv><table id=wikidifftable>$diff</table></div>];
<   }
< 
<   return $diff;
< }
< 
< sub DiffToHTML { shift }
< 
< # ==== Database (Page, Section, Text, Kept, User) functions ====
< sub OpenNewPage {
< 	my ($id) = @_;
< 	
< 	%Page             = ();
< 	$Page{'version'}  = 3;       # Data format version
< 	$Page{'revision'} = 0;       # Number of edited times
< 	$Page{'tscreate'} = $Now;    # Set once at creation
< 	$Page{'ts'}       = $Now;    # Updated every edit
< 	$Page{'authorcreate'} = GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
< }
< 
< sub OpenNewSection {
< 	my ( $name, $data ) = @_;
< 	
< 	%Section             = ();
< 	$Section{'name'}     = $name;
< 	$Section{'version'}  = 1;                   # Data format version
< 	$Section{'revision'} = 0;                   # Number of edited times
< 	$Section{'tscreate'} = $Now;                # Set once at creation
< 	$Section{'ts'}       = $Now;                # Updated every edit
< 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
< 	$Section{'host'} 	 = "";        # Updated only for real edits (can be slow)
< 	$Section{'id'}   	 = $UserID;
< 	$Section{'username'} = &GetParam( "username", "" );
< 	$Section{'data'}     = $data;
< 	$Page{$name} 		 = join( $FS2, %Section );    # Replace with save?
< 	$Page{'authorcreate'}= GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
< }
< 
< sub OpenNewText {
< 	my ($name) = @_;                          # Name of text (usually "default")
< 	
< 	%Text = ();
< 	
< 	if ( $NewText ne "" ) { $Text{'text'} = $NewText; }
< 	else { $Text{'text'} = "Describe the new page here."; }
< 	
< 	$Text{'text'} .= "\n" if ( substr( $Text{'text'}, -1, 1 ) ne "\n" );
< 	$Text{'minor'}     = 0;                   # Default as major edit
< 	$Text{'newauthor'} = 1;                   # Default as new author
< 	$Text{'summary'}   = "";
< 	
< 	&OpenNewSection( "text_$name", join( $FS3, %Text ) );
< }
< 
< sub GetPageFile {
< 	my ($id) = @_;
< 	
< 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
< }
< 
< sub OpenPage {
< 	my ($id) = @_;
< 	my ( $fname, $data );
< 	
< 	if (!CheckIsAuthUser($id)) { $id = "AuthError"; } #auth patch
< 	if ( $OpenPageName eq $id ) { return; }
< 	if ( $id eq ""){ return; }
< 		
< 	%Section = ();
< 	%Text    = ();
< 	$fname   = &GetPageFile($id);
< 	
< 	if ( -f $fname ) {
< 		$data = &ReadFileOrDie($fname);
< 		%Page = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	}
< 	else {
< 		&OpenNewPage($id);
< 	}
< 	
< 	if ( $Page{'version'} != 3 ) { &UpdatePageVersion(); }
< 	
< 	$OpenPageName = $id;
< }
< 
< sub OpenSection {
< 	my ($name) = @_;
< 	
< 	if ( !defined( $Page{$name} ) ) { &OpenNewSection( $name, "" ); }
< 	else { %Section = split( /$FS2/, $Page{$name}, -1 ); }
< }
< 
< sub OpenText {
< 	my ($name) = @_;
< 	
< 	if ( !defined( $Page{"text_$name"} ) ) {
< 		&OpenNewText($name);
< 	}
< 	else {
< 		&OpenSection("text_$name");
< 		%Text = split( /$FS3/, $Section{'data'}, -1 );
< 	}
< }
< 
< sub OpenDefaultText {
< 	&OpenText('default');
< }
< 
< # Called after OpenKeptRevisions
< sub OpenKeptRevision {
< 	my ($revision) = @_;
< 	
< 	%Section = split( /$FS2/, $KeptRevisions{$revision}, -1 );
< 	%Text = split( /$FS3/, $Section{'data'}, -1 );
< }
< 
< sub GetPageCache {
< 	my ($name) = @_;
< 	
< 	return $Page{"cache_$name"};
< }
< 
< # Always call SavePage within a lock.
< sub SavePage {
< 	my $file = &GetPageFile($OpenPageName);
< 	
< 	$Page{'revision'} += 1;    # Number of edited times
< 	$Page{'ts'} = $Now;        # Updated every edit
< 	&CreatePageDir( $PageDir, $OpenPageName );
< 	&WriteStringToFile( $file, join( $FS1, %Page ) );
< }
< 
< sub SaveSection {
< 	my ( $name, $data ) = @_;
< 	
< 	$Section{'revision'} += 1;    # Number of edited times
< 	$Section{'ts'}       = $Now;                          # Updated every edit
< 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
< 	$Section{'id'}       = $UserID;
< 	$Section{'username'} = &GetParam( "username", "" );
< 	$Section{'data'}     = $data;
< 	$Page{$name} = join( $FS2, %Section );
< }
< 
< sub SaveText {
< 	my ($name) = @_;
< 	
< 	&SaveSection( "text_$name", join( $FS3, %Text ) );
< }
< 
< sub SaveDefaultText {
< 	&SaveText('default');
< }
< 
< sub SetPageCache {
< 	my ( $name, $data ) = @_;
< 	
< 	$Page{"cache_$name"} = $data;
< }
< 
< sub UpdatePageVersion {
< 	&ReportError( "Bad page version (or corrupt page)." );
< }
< 
< sub KeepFileName {
< 	return $KeepDir . "/"
< 	  . &GetPageDirectory($OpenPageName)
< 	  . "/$OpenPageName.kp";
< }
< 
< sub SaveKeepSection {
< 	my $file = &KeepFileName();
< 	my $data;
< 	
< 	return if ( $Section{'revision'} < 1 );    # Don't keep "empty" revision
< 	
< 	$Section{'keepts'} = $Now;
< 	$data = $FS1 . join( $FS2, %Section );
< 	&CreatePageDir( $KeepDir, $OpenPageName );
< 	&AppendStringToFileLimited( $file, $data, $KeepSize );
< }
< 
< sub ExpireKeepFile {
< 	my ( $fname, $data, @kplist, %tempSection, $expirets );
< 	my ( $anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev );
< 	my ( $oldMajor, $oldAuthor );
< 	
< 	$fname = &KeepFileName();
< 	return if ( !( -f $fname ) );
< 	
< 	$data = &ReadFileOrDie($fname);
< 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	return if ( length(@kplist) < 1 );    # Also empty
< 	
< 	shift(@kplist) if ( $kplist[0] eq "" );    # First can be empty
< 	return if ( length(@kplist) < 1 );         # Also empty
< 	
< 	%tempSection = split( /$FS2/, $kplist[0], -1 );
< 
< 	if ( !defined( $tempSection{'keepts'} ) ) {
< 		return;                                # Bad keep file
< 	}
< 	
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 	return if ( $tempSection{'keepts'} >= $expirets );    # Nothing old enough
< 	
< 	$anyExpire = 0;
< 	$anyKeep   = 0;
< 	%keepFlag  = ();
< 	$oldMajor  = &GetPageCache('oldmajor');
< 	$oldAuthor = &GetPageCache('oldauthor');
< 	
< 	foreach ( reverse @kplist ) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName    = $tempSection{'name'};
< 		$sectRev     = $tempSection{'revision'};
< 		$expire      = 0;
< 		
< 		if ( $sectName eq "text_default" ) {
< 			if (   ( $KeepMajor && ( $sectRev == $oldMajor ) )
< 				|| ( $KeepAuthor && ( $sectRev == $oldAuthor ) ) )
< 			{
< 				$expire = 0;
< 			}
< 			elsif ( $tempSection{'keepts'} < $expirets ) {
< 				$expire = 1;
< 			}
< 		}
< 		else {
< 			if ( $tempSection{'keepts'} < $expirets ) {
< 				$expire = 1;
< 			}
< 		}
< 		if ( !$expire ) {
< 			$keepFlag{ $sectRev . "," . $sectName } = 1;
< 			$anyKeep = 1;
< 		}
< 		else {
< 			$anyExpire = 1;
< 		}
< 	}
< 	if ( !$anyKeep ) {    # Empty, so remove file
< 		unlink($fname);
< 		return;
< 	}
< 	return if ( !$anyExpire );    # No sections expired
< 	
< 	open( OUT, ">$fname" ) or die( Ts( 'cant write %s', $fname ) . ": $!" );
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName    = $tempSection{'name'};
< 		$sectRev     = $tempSection{'revision'};
< 		
< 		if ( $keepFlag{ $sectRev . "," . $sectName } ) {
< 			print OUT $FS1, $_;
< 		}
< 	}
< 	close(OUT);
< }
< 
< sub OpenKeptList {
< 	my ( $fname, $data );
< 	
< 	@KeptList = ();
< 	$fname    = &KeepFileName();
< 	return if ( !( -f $fname ) );
< 	
< 	$data = &ReadFileOrDie($fname);
< 	@KeptList = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< }
< 
< sub OpenKeptRevisions {
< 	my ($name) = @_;    # Name of section
< 	my ( $fname, $data, %tempSection );
< 	
< 	%KeptRevisions = ();
< 	&OpenKeptList();
< 	
< 	foreach (@KeptList) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		next if ( $tempSection{'name'} ne $name );
< 		$KeptRevisions{ $tempSection{'revision'} } = $_;
< 	}
< }
< 
< sub LoadUserData {
< 	my ( $data, $status );
< 	
< 	%UserData = ();
< 	( $status, $data ) = &ReadFile( &UserDataFilename($UserID) );
< 	
< 	if ( !$status ) {
< 		$UserID = 112;    # Could not open file.  Consider warning message?
< 		return;
< 	}
< 	
< 	%UserData = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< }
< 
< sub UserDataFilename {
< 	my ($id) = @_;
< 	
< 	if ($id =~ /(\d+)/){
< 		$id = $1;
< 	}
< 	else { die "The userid must be a positive integer"; }
< 	
< 	return "" if ( $id < 1 );
< 	return $UserDir . "/" . ( $id % 10 ) . "/$id.db";
< }
< 
< # ==== Misc. functions ====
< sub ReportError {
< 	my ($errmsg) = @_;
< 	
< 	print &GetHeader( "", "ERROR!", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>$errmsg</h2>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub ValidId {
< 	my ($id) = @_;
< 	
< 	if ( length($id) > 120 ) {
< 		return Ts( 'Page name is too long: %s', $id );
< 	}
< 	
< 	if ( $id =~ m| | ) {
< 		return Ts( 'Page name may not contain space characters: %s', $id );
< 	}
< 	
< 	if ($UseSubpage) {
< 		if ( $id =~ m|.*/.*/| ) {
< 			return Ts( 'Too many / characters in page %s', $id );
< 		}
< 		if ( $id =~ /^\// ) {
< 			return Ts( 'Invalid Page %s (subpage without main page)', $id );
< 		}
< 		if ( $id =~ /\/$/ ) {
< 			return Ts( 'Invalid Page %s (missing subpage name)', $id );
< 		}
< 	}
< 	
< 	if ($FreeLinks) {
< 		$id =~ s/ /_/g;
< 		if ( !$UseSubpage ) {
< 			if ( $id =~ /\// ) {
< 				return Ts( 'Invalid Page %s (/ not allowed)', $id );
< 			}
< 		}
< 		if ( !( $id =~ m|^$FreeLinkPattern$| ) ) {
< 			return Ts( 'Invalid Page %s', $id );
< 		}
< 		if ( $id =~ m|\.db$| ) {
< 			return Ts( 'Invalid Page %s (must not end with .db)', $id );
< 		}
< 		if ( $id =~ m|\.lck$| ) {
< 			return Ts( 'Invalid Page %s (must not end with .lck)', $id );
< 		}
< 		return "";
< 	}
< 	else {
< 		if ( !( $id =~ /^$LinkPattern$/ ) ) {
< 			return Ts( 'Invalid Page %s', $id );
< 		}
< 	}
< 	
< 	return "";
< }
< 
< sub ValidIdOrDie {
< 	my ($id) = @_;
< 	my $error;
< 	
< 	$error = &ValidId($id);
< 	
< 	if ( $error ne "" ) {
< 		&ReportError($error);
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub UserCanEdit {
< 	my ( $id, $deepCheck ) = @_;
< 	my $authtype = &CheckIsAuthUser($id);
< 	
< 	# Optimized for the "everyone can edit" case (don't check passwords)
< 	if ( ( $id ne "" ) && ( -f &GetLockedPageFile($id) ) ) {
< 		return 1 if ( &UserIsAdmin() );    # Requires more privledges
< 		     # Consider option for editor-level to edit these pages?
< 		return 0;
< 	}
< 	if ( !$EditAllowed ) {
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0;
< 	}
< 	if ( -f "$DataDir/noedit" ) {
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0;
< 	}
< 	if ($deepCheck) {    # Deeper but slower checks (not every page)
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0 if ( &UserIsBanned() );
< 	}
< 	
< 	return 1;
< }
< 
< sub UserIsBanned {
< 	my ( $host, $ip, $data, $status );
< 	( $status, $data ) = &ReadFile("$DataDir/banlist");
< 	
< 	return 0 if ( !$status );    # No file exists, so no ban
< 	$data =~ s/\r//g;
< 	$ip   = $ENV{'REMOTE_ADDR'};
< 	$host = &GetRemoteHost(0);
< 	
< 	foreach ( split( /\n/, $data ) ) {
< 		next if ( (/^\s*$/) || (/^#/) );    # Skip empty, spaces, or comments
< 		return 1 if ( $ip   =~ /$_/i );
< 		return 1 if ( $host =~ /$_/i );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsAdmin {
< 	my ( @pwlist, $userPassword );
< 	
< 	return 0 if ( $AdminPass eq "" );
< 	$userPassword = &GetParam( "adminpw", "" );
< 	return 0 if ( $userPassword eq "" );
< 	
< 	foreach ( split( /\s+/, $AdminPass ) ) {
< 		next     if ( $_            eq "" );
< 		return 1 if ( $userPassword eq $_ );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsEditor {
< 	my ( @pwlist, $userPassword );
< 	
< 	return 1 if ( &UserIsAdmin() );    # Admin includes editor
< 	return 0 if ( $EditPass eq "" );
< 	$userPassword = &GetParam( "password", "" );    # Used for both
< 	return 0 if ( $userPassword eq "" );
< 	
< 	foreach ( split( /\s+/, $EditPass ) ) {
< 		next     if ( $_            eq "" );
< 		return 1 if ( $userPassword eq $_ );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsEditorOrAdmin {
< 	return (UserIsEditor || UserIsAdmin);	
< }
< 
< sub UserCanUpload {
< 	return 1 if ( &UserIsEditor() );
< 	return $AllUpload;
< }
< 
< sub GetLockedPageFile {
< 	my ($id) = @_;
< 	
< 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
< }
< 
< sub RequestLockDir {
< 	my ( $name, $tries, $wait, $errorDie ) = @_;
< 	my ( $lockName, $n );
< 	
< 	&CreateDir($TempDir);
< 	$lockName = $LockDir . $name;
< 	$n        = 0;
< 	
< 	while ( mkdir( $lockName, 0555 ) == 0 ) {
< 		if ( $! != 17 ) {
< 			die( Ts( 'can not make %s', $LockDir ) . ": $!\n" ) if $errorDie;
< 			return 0;
< 		}
< 		return 0 if ( $n++ >= $tries );
< 		sleep($wait);
< 	}
< 	
< 	return 1;
< }
< 
< sub ReleaseLockDir {
< 	my ($name) = @_;
< 	
< 	rmdir( $LockDir . $name );
< }
< 
< sub RequestLock {
< 	# 10 tries, 3 second wait, possibly die on error
< 	return &RequestLockDir( "main", 10, 3, $LockCrash );
< }
< 
< sub ReleaseLock {
< 	&ReleaseLockDir('main');
< }
< 
< sub ForceReleaseLock {
< 	my ($name) = @_;
< 	my $forced;
< 
< 	# First try to obtain lock (in case of normal edit lock)
< 	# 5 tries, 3 second wait, do not die on error
< 	$forced = !&RequestLockDir( $name, 5, 3, 0 );
< 	&ReleaseLockDir($name);    # Release the lock, even if we didn't get it.
< 	
< 	return $forced;
< }
< 
< sub RequestCacheLock {
< 	# 4 tries, 2 second wait, do not die on error
< 	return &RequestLockDir( 'cache', 4, 2, 0 );
< }
< 
< sub ReleaseCacheLock {
< 	&ReleaseLockDir('cache');
< }
< 
< sub RequestDiffLock {
< 	# 4 tries, 2 second wait, do not die on error
< 	return &RequestLockDir( 'diff', 4, 2, 0 );
< }
< 
< sub ReleaseDiffLock {
< 	&ReleaseLockDir('diff');
< }
< 
< # Index lock is not very important--just return error if not available
< sub RequestIndexLock {
< 	# 1 try, 2 second wait, do not die on error
< 	return &RequestLockDir( 'index', 1, 2, 0 );
< }
< 
< sub ReleaseIndexLock {
< 	&ReleaseLockDir('index');
< }
< 
< sub ReadFile {
< 	my ($fileName) = @_;
< 	my ($data);
< 	
< 	local $/ = undef;    # Read complete files
< 	if ( open( IN, "<$fileName" ) ) {
< 		$data = <IN>;
< 		close IN;
< 		return ( 1, $data );
< 	}
< 	
< 	return ( 0, "" );
< }
< 
< sub ReadFileOrDie {
< 	my ($fileName) = @_;
< 	my ( $status, $data );
< 	
< 	( $status, $data ) = &ReadFile($fileName);
< 	if ( !$status ) {
< 		die( Ts( 'Can not open %s', $fileName ) . ": $!" );
< 	}
< 	
< 	return $data;
< }
< 
< sub WriteStringToFile {
< 	my ( $file, $string ) = @_;
< 	
< 	open( OUT, ">$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
< 	print OUT $string;
< 	close(OUT);
< }
< 
< sub AppendStringToFile {
< 	my ( $file, $string ) = @_;
< 	
< 	open( OUT, ">>$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
< 	print OUT $string;
< 	close(OUT);
< }
< 
< sub AppendStringToFileLimited {
< 	my ( $file, $string, $limit ) = @_;
< 	
< 	if ( ( $limit < 1 ) || ( ( ( -s $file ) + length($string) ) <= $limit ) ) {
< 		&AppendStringToFile( $file, $string );
< 	}
< }
< 
< sub CreateDir {
< 	my ($newdir) = @_;
< 	
< 	mkdir( $newdir, 0775 ) if ( !( -d $newdir ) );
< }
< 
< sub CreatePageDir {
< 	my ( $dir, $id ) = @_;
< 	my $subdir;
< 	
< 	&CreateDir($dir);    # Make sure main page exists
< 	$subdir = $dir . "/" . &GetPageDirectory($id);
< 	&CreateDir($subdir);
< 	
< 	if ( $id =~ m|([^/]+)/| ) {
< 		$subdir = $subdir . "/" . $1;
< 		&CreateDir($subdir);
< 	}
< }
< 
< sub UpdateHtmlCache {
< 	my ( $id, $html ) = @_;
< 	my $idFile;
< 	
< 	$idFile = &GetHtmlCacheFile($id);
< 	&CreatePageDir( $HtmlDir, $id );
< 	if ( &RequestCacheLock() ) {
< 		&WriteStringToFile( $idFile, $html );
< 		&ReleaseCacheLock();
< 	}
< }
< 
< sub GenerateAllPagesList {
< 	my ( @pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId );
< 	
< 	@pages = ();
< 	if ($FastGlob) {
< 		# The following was inspired by the FastGlob code by Marc W. Mengel.
< 		# Thanks to Bob Showalter for pointing out the improvement.
< 		opendir( PAGELIST, $PageDir );
< 		@dirs = readdir(PAGELIST);
< 		closedir(PAGELIST);
< 		@dirs = sort(@dirs);
< 		foreach $dir (@dirs) {
< 			next
< 			  if ( substr( $dir, 0, 1 ) eq '.' );  # No ., .., or .dirs or files
< 			opendir( PAGELIST, "$PageDir/$dir" );
< 			@pageFiles = readdir(PAGELIST);
< 			closedir(PAGELIST);
< 			foreach $id (@pageFiles) {
< 				next if ( ( $id eq '.' ) || ( $id eq '..' ) );
< 				if ( substr( $id, -3 ) eq '.db' ) {
< 					push( @pages, substr( $id, 0, -3 ) );
< 				}
< 				elsif ( substr( $id, -4 ) ne '.lck' ) {
< 					opendir( PAGELIST, "$PageDir/$dir/$id" );
< 					@subpageFiles = readdir(PAGELIST);
< 					closedir(PAGELIST);
< 					foreach $subId (@subpageFiles) {
< 						if ( substr( $subId, -3 ) eq '.db' ) {
< 							push( @pages, "$id/" . substr( $subId, 0, -3 ) );
< 						}
< 					}
< 				}
< 			}
< 		}
< 	}
< 	else {
< 		# Old slow/compatible method.
< 		@dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
< 		
< 		foreach $dir (@dirs) {
< 			if ( -e "$PageDir/$dir" ) {    # Thanks to Tim Holt
< 				while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
< 					s|^$PageDir/||;
< 					m|^[^/]+/(\S*).db|;
< 					$id = $1;
< 					push( @pages, $id );
< 				}
< 			}
< 		}
< 	}
< 	
< 	return sort(@pages);
< }
< 
< sub AllPagesList {
< 	my ( $rawIndex, $refresh, $status );
< 	
< 	if ( !$UseIndex ) {
< 		return &GenerateAllPagesList();
< 	}
< 	
< 	$refresh = &GetParam( "refresh", 0 );
< 	if ( $IndexInit && !$refresh ) {
< 
< 		# Note for mod_perl: $IndexInit is reset for each query
< 		# Eventually consider some timestamp-solution to keep cache?
< 		return @IndexList;
< 	}
< 	
< 	if ( ( !$refresh ) && ( -f $IndexFile ) ) {
< 		( $status, $rawIndex ) = &ReadFile($IndexFile);
< 		
< 		if ($status) {
< 			%IndexHash = split( /\s+/, $rawIndex );
< 			@IndexList = sort( keys %IndexHash );
< 			$IndexInit = 1;
< 			
< 			return @IndexList;
< 		}
< 
< 		# If open fails just refresh the index
< 	}
< 	
< 	@IndexList = ();
< 	%IndexHash = ();
< 	@IndexList = &GenerateAllPagesList();
< 	
< 	foreach (@IndexList) {
< 		$IndexHash{$_} = 1;
< 	}
< 	
< 	$IndexInit = 1;    # Initialized for this run of the script
< 	                   # Try to write out the list for future runs
< 	&RequestIndexLock() or return @IndexList;
< 	&WriteStringToFile( $IndexFile, join( " ", %IndexHash ) );
< 	&ReleaseIndexLock();
< 	
< 	return @IndexList;
< }
< 
< sub AllSubPagesList {
< 	my $GivenPage = shift;
< 	my @PageList = &AllPagesList();
< 	my @Results;
< 	
< 	foreach (@PageList){
< 		if (/^$GivenPage\//i){
< 			push @Results, $_;	
< 		}
< 	}
< 	
< 	return @Results;
< }
< 
< sub CalcDay {
< 	my ($ts) = @_;
< 	
< 	$ts += $TimeZoneOffset;
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
< 	
< 	if ($NumberDates) {
< 		$year = $year + 1900;
< 		$mon = $mon + 1;
< 		if ($mon < 10){ $mon = "0$mon"; }
< 		if ($mday < 10){ $mday = "0$mday"; }
< 		
< 		return "$year$NumberDatesDelim$mon$NumberDatesDelim$mday";
< 	}
< 	
< 	return (
< 		"January",   "February", "March",    "April",
< 		"May",       "June",     "July",     "August",
< 		"September", "October",  "November", "December"
< 	  )[$mon]
< 	  . " "
< 	  . $mday . ", "
< 	  . ( $year + 1900 );
< }
< 
< sub CalcTime {
< 	my ($ts) = @_;
< 	my ( $ampm, $mytz );
< 	
< 	$ts += $TimeZoneOffset;
< 	
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
< 	$mytz = "";
< 	
< 	if ( ( $TimeZoneOffset == 0 ) && ( $ScriptTZ ne "" ) ) {
< 		$mytz = " " . $ScriptTZ;
< 	}
< 	$ampm = "";
< 	
< 	if ($UseAmPm) {
< 		$ampm = " am";
< 		if ( $hour > 11 ) {
< 			$ampm = " pm";
< 			$hour = $hour - 12;
< 		}
< 		$hour = 12 if ( $hour == 0 );
< 	}
< 	
< 	$min = "0" . $min if ( $min < 10 );
< 	
< 	return $hour . ":" . $min . $ampm . $mytz;
< }
< 
< sub TimeToText {
< 	my ($t) = @_;
< 	
< 	return &CalcDay($t) . " " . &CalcTime($t);
< }
< 
< sub GetParam {
< 	my ( $name, $default ) = @_;
< 	my $result;
< 	
< 	$result = $q->param($name);
< 	
< 	if ( !defined($result) ) {
< 		if ( defined( $UserData{$name} ) ) {
< 			$result = $UserData{$name};
< 		}
< 		else {
< 			$result = $default;
< 		}
< 	}
< 	
< 	return $result;
< }
< 
< sub GetHiddenValue {
< 	my ( $name, $value ) = @_;
< 	
< 	$q->param( $name, $value );
< 	
< 	return $q->hidden($name);
< }
< 
< sub GetRemoteHost {
< 	my ($doMask) = @_;
< 	my ( $rhost, $iaddr );
< 	
< 	$rhost = $ENV{REMOTE_HOST};
< 	
< 	if ( $UseLookup && ( $rhost eq "" ) ) {
< 
< 		# Catch errors (including bad input) without aborting the script
< 		eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
< 		  . '$rhost = gethostbyaddr($iaddr, AF_INET)';
< 	}
< 	
< 	if ( $rhost eq "" ) {
< 		$rhost = $ENV{REMOTE_ADDR};
< 	}
< 	
< 	$rhost = &GetMaskedHost($rhost) if ($doMask);
< 	
< 	return $rhost;
< }
< 
< sub FreeToNormal {
< 	my ($id) = @_;
< 	
< 	$id =~ s/ /_/g;
< 	$id = ucfirst($id) if ( $UpperFirst || $FreeUpper );
< 	
< 	if ( index( $id, '_' ) > -1 ) {    # Quick check for any space/underscores
< 		$id =~ s/__+/_/g;
< 		$id =~ s/^_//;
< 		$id =~ s/_$//;
< 		
< 		if ($UseSubpage) {
< 			$id =~ s|_/|/|g;
< 			$id =~ s|/_|/|g;
< 		}
< 	}
< 	
< 	if ($FreeUpper) {
< 
< 		# Note that letters after ' are *not* capitalized
< 		if ( $id =~ m|[-_.,\(\)/][a-z]| ) { # Quick check for non-canonical case
< 			$id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
< 		}
< 	}
< 	
< 	return $id;
< }
< 
< #END_OF_BROWSE_CODE
< # == Page-editing and other special-action code ========================
< $OtherCode = "";    # Comment next line to always compile (slower)
< 
< #$OtherCode = <<'#END_OF_OTHER_CODE';
< sub DoOtherRequest {
< 	my ( $id, $action, $filter, $text, $search );
< 	
< 	$action = &GetParam( "action", "" );
< 	$id     = &GetParam( "id",     "" );
< 	$filter = &GetParam( "filter", "" );
< 	
< 	if ( $action ne "" ) {
< 		$action = lc($action);
< 		
< 		if ( $action eq "edit" ) {
< 			&DoEdit( $id, 0, 0, "", 0 ) if &ValidIdOrDie($id);
< 		}
< 		elsif ( $action eq "unlock" ) {
< 			&DoUnlock();
< 		}
< 		elsif ( $action eq "index" ) {
< 			&DoIndex();
< 		}
< 		elsif ( $action eq "links" ) {
< 			&DoLinks();
< 		}
< 		elsif ( $action eq "maintain" ) {
< 			&DoMaintain();
< 		}
< 		elsif ( $action eq "pagelock" ) {
< 			&DoPageLock();
< 		}
< 		elsif ( $action eq "editlock" ) {
< 			&DoEditLock();
< 		}
< 		elsif ( $action eq "editprefs" ) {
< 			&DoEditPrefs();
< 		}
< 		elsif ( $action eq "editbanned" ) {
< 			&DoEditBanned();
< 		}
< 		elsif ( $action eq "editlinks" ) {
< 			&DoEditLinks();
< 		}
< 		elsif ( $action eq "login" ) {
< 			&DoEnterLogin();
< 		}
< 		elsif ( $action eq "newlogin" ) {
< 			$UserID = 0;
< 			&DoEditPrefs();    # Also creates new ID
< 		}
< 		elsif ( $action eq "version" ) {
< 			&DoShowVersion();
< 		}
< 		elsif ( $action eq "rss" ) {
< 			&DoRss();
< 		}
< 		elsif ( $action eq "delete" ) {
< 			&DoDeletePage($id);
< 		}
< 		elsif ( $UseUpload && ( $action eq "upload" ) ) {
< 			&DoUpload();
< 		}
< 		elsif ( $action eq "maintainrc" ) {
< 			&DoMaintainRc();
< 		}
< 		elsif ( $action eq "convert" ) {
< 			&DoConvert();
< 		}
< 		elsif ( $action eq "trimusers" ) {
< 			&DoTrimUsers();
< 		}
< 		elsif ( $action eq "listfiles" ) {
< 			&DoListFiles($id, $filter, 0);	
< 		}
< 		elsif ( $action eq "listdisabled" ) {
< 			&DoListFiles($id, $filter, 1);	
< 		}
< 		else {
< 			&ReportError( Ts( 'Invalid action parameter %s', $action ) );
< 		}
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_prefs", 0 ) ) {
< 		&DoUpdatePrefs();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_ban", 0 ) ) {
< 		&DoUpdateBanned();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "enter_login", 0 ) ) {
< 		&DoLogin();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_links", 0 ) ) {
< 		&DoUpdateLinks();
< 		return;
< 	}
< 	
< 	if ( $UseUpload && ( &GetParam( "upload", 0 ) ) ) {
< 		&SaveUpload();
< 		return;
< 	}
< 	
< 	$search = &GetParam( "search", "" );
< 	
< 	if ( ( $search ne "" ) || ( &GetParam( "dosearch", "" ) ne "" ) ) {
< 		&DoSearch($search, $filter);
< 		return;
< 	}
< 	else {
< 		$search = &GetParam( "back", "" );
< 		if ( $search ne "" ) {
< 			&DoBackLinks($search, $filter);
< 			
< 			return;
< 		}
< 	}
< 
< 	# Handle posted pages
< 	if ( &GetParam( "oldtime", "" ) ne "" ) {
< 		$id = &GetParam( "title", "" );
< 		&DoPost() if &ValidIdOrDie($id);
< 		
< 		return;
< 	}
< 	
< 	&ReportError( "Invalid URL." );
< }
< 
< sub PageIsLocked {
< 	my ($id, $deepedit) = @_;
< 	my ($result) = 0;
< 	
< 	if ( !&UserCanEdit( $id, $deepedit ) ) {
< 			$result = 1;
< 		if ( &UserIsBanned() ) {
< 			$result = 2;
< 		}
< 		else {
< 			$result = 3;
< 		}
< 	}
< 	
< 	return $result;
< }
< 
< sub DoEdit {
< 	my ( $id, $isConflict, $oldTime, $newText, $preview ) = @_;
< 	my ( $header, $editRows, $editCols, $userName, $revision, $oldText );
< 	my ( $summary, $isEdit, $pageTime, $isLocked );
< 	
< 	my $authtype = &CheckIsAuthUser($id);
< 	if (!$authtype) { $id = "AuthError"; } #auth patch	
< 	if ($FreeLinks) { $id = &FreeToNormal($id); }   # Take care of users like Markus Lude :-)	
< 	
< 	$isLocked = &PageIsLocked( $id, 1 );
< 	
< 	if ( $isLocked > 0 or $authtype eq "" || $authtype eq "1") {
< 		print &GetHeader( "", "Editing Denied", "" );
< 		print &GetLeftNav("");
< 		print "\n<div class='wikiadmin'>";
< 		
< 		if ( $isLocked == 2 ) {
< 			print "\n<h2>Editing not allowed: user, ip, or network is blocked.</h2>";
< 			print "\nContact the wiki administrator for more information.";
< 		}
< 		else {
< 			print "\n<h2>Editing not allowed: $id is read-only.</h2>";
< 		}
< 		
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></body></html>";
< 			
< 		return;
< 	}
< 
< 	# Consider sending a new user-ID cookie if user does not have one
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$pageTime = $Section{'ts'};
< 	$header   = Ts( 'Editing %s', $id );
< 
< 	# Old revision handling
< 	$revision = &GetParam( 'revision', "" );
< 	$revision =~ s/\D//g;    # Remove non-numeric chars
< 	
< 	if ( $revision ne "" ) {
< 		&OpenKeptRevisions('text_default');
< 		
< 		if ( !defined( $KeptRevisions{$revision} ) ) {
< 			$revision = "";
< 
< 			# Consider better solution like error message?
< 		}
< 		else {
< 			&OpenKeptRevision($revision);
< 			$header = Ts( 'Editing revision %s of ', $revision ) . $id;
< 		}
< 	}
< 	
< 	$oldText = $Text{'text'};
< 	
< 	if ( $preview && !$isConflict ) { $oldText = $newText; }
< 	
< 	$editRows = &GetParam( "editrows", 20 );
< 	$editCols = &GetParam( "editcols", 65 );
< 	
< 	print &GetHeader( "", &QuoteHtml($header), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $revision ne "" ) {
< 		print "\n<b>Editing old revision $revision. Saving this page will replace the latest revision with this text.</b><br>";
< 	}
< 	
< 	if ($isConflict) {
< 		$editRows -= 10 if ( $editRows > 19 );
< 		print "\n<H1>Edit Conflict!</H1>";
< 		
< 		if ( $isConflict > 1 ) {
< 
< 			# The main purpose of a new warning is to display more text
< 			# and move the save button down from its old location.
< 			print "\n<h2>(This is a new conflict)</h2>";
< 		}
< 		
< 		print "\n<p><strong>";
< 		print "\nSomeone saved this page after you started editing. ";
< 		print "\nThe top textbox contains the saved text. ";
< 		print "\nOnly the text in the top textbox will be saved.";
< 		print "\n</strong></p><br>";
< 		print "\nScroll down to see your edited text.";
< 		print "\n<br>";
< 		print "\nLast save time: ";
< 		print &TimeToText($oldTime);
< 		print "\n(Current time is: ";
< 		print &TimeToText($Now);
< 		print "\n)<br>";
< 	}
< 	
< 	print "\n<div id='wikieditbar'>";
< 	print "<a href='$ScriptName?WikiStyleGuide'>WikiStyleGuide</a> | ";
< 	print "<a href='$ScriptName?WikiHeadings'>WikiHeadings</a> | ";
< 	print "<a href='$ScriptName?WikiGallery'>WikiGallery</a>| ";
< 	print "<a href='$ScriptName?WikiFlash'>WikiFlash</a>| ";
< 	print "<a href='$ScriptName?WikiTOCs'>WikiTOCs</a> | ";
< 	print "<a href='$ScriptName?WikiURLs'>WikiURLs</a> | ";
< 	print "<a href='$ScriptName?WikiImages'>WikiImages</a> | ";
< 	print "<a href='$ScriptName?WikiTables'>WikiTables</a> | ";
< 	print "<a href='$ScriptName?WikiLists'>WikiLists</a> | ";
< 	print "<a href='$ScriptName?WikiMarkup'>WikiMarkup</a>";
< 	print "\n</div>";
< 	
< 	print "\n<br>";
< 	print "\n<form id='wikiform' action='$ScriptName#preview-anchor' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( "title",   $id );
< 	print &GetHiddenValue( "oldtime",     $pageTime );
< 	print &GetHiddenValue( "oldconflict", $isConflict );
< 	  
< 	if ( $revision ne "" ) { print &GetHiddenValue( "revision", $revision ); }
< 	
< 	print &GetTextArea( 'text', $oldText, $editRows, $editCols );
< 	$summary = &GetParam( "summary", "*" );
< 	
< 	print "\n<br><br><div id='wikisaveedit'>Summary:";
< 	print
< 	  $q->textfield(
< 		-name      => 'summary',
< 		-id		   => 'summarytext',
< 		-default   => $summary,
< 		-override  => 1,
< 		-size      => 60,
< 		-maxlength => 200
< 	  );
< 	  
< 	if ( &GetParam("recent_edit") eq "on" ) {
< 		print "\n<br>",
< 		  $q->checkbox(
< 			-name    => 'recent_edit',
< 			-checked => 1,
< 			-label   => "This change is a minor edit."
< 		  );
< 		print "\n<br>";
< 	}
< 	else {
< 		print "\n<br>",
< 		  $q->checkbox(
< 			-name  => 'recent_edit',
< 			-checked => 0,
< 			-label => "This change is a minor edit."
< 		  );
< 		print "\n<br>";
< 	}
< 	
< 	if ($EmailNotify) {
< 		print "\n&nbsp;&nbsp;&nbsp;"
< 		  . $q->checkbox(
< 			-name  => 'do_email_notify',
< 			-label =>
< 			  Ts( 'Send email notification that %s has been changed.', $id )
< 		  );
< 	}
< 	
< 	print "\n<br>";
< 	
< 	if ( $EditNote ne "" ) { print $EditNote . '<br>'; }
< 	
< 	$userName = &GetParam( "username", "" );
< 	print $q->submit( -name => 'Preview', -value => 'Preview' );
< 	print $q->button( -name => 'Cancel', -value => 'Cancel', -onclick => 'window.location="' . $ScriptName . '?' . $id . '";' );
< 	print $q->submit( -name => 'Save', -value => "Save" );	
< 	
< 	if ( $userName ne "" ) {
< 		print "\n (Your user name is ";
< 		print &GetPageLinkText($HomePagePrefix . '/' . $userName, $userName);
< 		print "\n )";
< 	}
< 	else {
< 		print ' (', Ts( 'Visit %s to set your user name.', &GetPrefsLink() ), ') ';
< 	}
< 
< 	if ($isConflict) {
< 		print "\n<br><hr><p><strong>";
< 		print "\nThis is the text you submitted:";
< 		print  "</strong><p>";
< 		print &GetTextArea( 'newtext', $newText, $editRows, $editCols );
< 	}
< 	
< 	print "\n</div>";
< 	print "\n</form>";
< 	print "<a name='preview-anchor'></a>";
< 	print "\n</div>";			
< 	print "\n$WikiLineFooter";
< 	
< 	if ($preview) {
< 		
< 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
< 		print $WikiLineHeaderPreview;
< 		print "\n<div id='wikipreview' class='wikipreview'>";
< 					
< 		if ($isConflict) {
< 			print "\n<b>NOTE: This preview shows the revision of the other author.</b><hr>";
< 		}
< 		
< 		$MainPage = $id;
< 		$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
< 		
< 		print &WikiToHTML($oldText);
< 		print "\n</div>";
< 		print "\n$WikiLineFooter";
< 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
< 		print "\n<div id='wikibar'>&nbsp</div>";
< 	}
< 
< 	print "\n<div class='wikifooter'>";	
< 	print "<div class='wikirevision'>";
< 	print &GetHistoryLink( $id, "View other revisions<br>", "Click to view revision history");
< 	print "</div>";
< 	print &GetGotoBar($id);
< 	print &getFooterNote();
< 	
< 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
< 			
< 	print "\n</div></div></body></html>";	
< }
< 
< sub GetTextArea {
< 	my ( $name, $text, $rows, $cols ) = @_;
< 	my ( $html );
< 	
< 	$html = "\n<div style='width: 100%;'>";
< 	if ( &GetParam( "editwide", 1 ) ) {
< 		$html .= $q->textarea(
< 			-name     => $name,
< 			-default  => $text,
< 			-id       => 'wikitextarea' . $name,
< 			-rows     => $rows,
< 			-columns  => $cols,
< 			-override => 1,
< 			-style    => 'width:100%',
< 			-wrap     => 'virtual'
< 		);
< 	}
< 	else {
< 		$html .= $q->textarea(
< 			-name     => $name,
< 			-default  => $text,
< 			-id       => 'wikitextarea' . $name,
< 			-rows     => $rows,
< 			-columns  => $cols,
< 			-override => 1,
< 			-wrap     => 'virtual'
< 		);
< 	}
< 	
< 	$html .= "</div>";
< 	
< 	return $html;
< }
< 
< sub DoEditPrefs {
< 	my ( $check, $recentName, %labels );
< 	
< 	$recentName = $RCName;
< 	$recentName =~ s/_/ /g;
< 	
< 	&DoNewLogin() if ( $UserID < 400 );
< 	
< 	print &GetHeader( "", "Editing Preferences", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikidiff'>";
< 	print "\n<h2>Access Controls</h2>";
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( "edit_prefs", 1 );
< 	print "\n<table class='wikilargelist'>";
< 	print "\n<tr><th colspan='2'><b>User Information </b></th></tr>";
< 	print "\n<tr><td>Your User ID number </td><td>$UserID</td></tr>";
< 	print "\n<tr><td>UserName</td>";
< 	print "\n<td>" . &GetFormText( 'username', "", 30, 50 );
< 	print "\n<br>(blank to remove, or valid page name)</td></tr>";
< 	print "\n<tr><td>Set Password </td>";
< 	print "\n<td>";
< 	print
< 	  $q->password_field(
< 		-name      => 'p_password',
< 		-value     => '*',
< 		-size      => 30,
< 		-maxlength => 50
< 	  );
< 	 print "\n<br>(blank to remove password)";
< 	 print "\n<br>Passwords allow sharing preferences between multiple systems. Passwords are completely optional. ";
< 	 print "\n</td></tr>";
< 
< 
< 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
< 		print "\n<tr><td>Administrator Password </td>";
< 		print "\n<td>";
< 		print
< 		  $q->password_field(
< 			-name      => 'p_adminpw',
< 			-value     => '*',
< 			-size      => 30,
< 			-maxlength => 50
< 		  );
< 		print "\n<br>(blank to remove password)";
< 		print "\n<br>(Administrator passwords are used for special maintenance.)";
< 		print "\n</td></tr>";
< 	}
< 	
< 	if ($EmailNotify) {
< 		print "\n<tr><td>Email Address</td>";
< 		print "\n<td>" . &GetFormText( 'email', "", 30, 60 );
< 		print "\n<br>" . &GetFormCheck( 'notify', 1, "Include this address in the site email list." );
< 		print "\n<br>(Uncheck the box to remove the address.) ";
< 		
< 		print "\n</td></tr>";
< 	}
< 	
< 	print "\n</table>";
< 	
< 	print "\n$WikiLinePref<b>$recentName:</b>";
< 	print "\n<br>Default days to display: ";
< 	print &GetFormText( 'rcdays', $RcDefault, 4, 9 );
< 	print "\n<br>", &GetFormCheck( 'rcnewtop', $RecentTop, "Most recent changes on top" );
< 	print "\n<br>", &GetFormCheck( 'rcall', 0, "Show all changes (not just most recent)" );
< 	
< 	%labels = (
< 		0 => "Hide minor edits",
< 		1 => "Show minor edits",
< 		2 => "Show only minor edits"
< 	);
< 	
< 	print "\n<br>Minor edit display: ";
< 	print $q->popup_menu(
< 		-name   => 'p_rcshowedit',
< 		-values => [ 0, 1, 2 ],
< 		-labels => \%labels,
< 		-default => &GetParam( "rcshowedit", $ShowEdits )
< 	);
< 	
< 	print "\n<br>", &GetFormCheck( 'rcchangehist', 1, "Use 'changes' as link to history" );
< 
< 	if ($UseDiff) {
< 		print "\n$WikiLinePref<b>Differences:</b>";
< 		print "\n<br>", &GetFormCheck( 'diffrclink', 1, "Show (diff) links on $recentName " );
< 		print "\n<br>", &GetFormCheck( 'alldiff', 0, "Show differences on all pages" );
< 		print "\n  (", &GetFormCheck( 'norcdiff', 1, "No differences on $recentName " ), ")";
< 		%labels = ( 1 => "Major", 2 => "Minor", 3 => "Author" );
< 		print "\n<br>Default difference type: ";
< 		print $q->popup_menu(
< 			-name   => 'p_defaultdiff',
< 			-values => [ 1, 2, 3 ],
< 			-labels => \%labels,
< 			-default => &GetParam( "defaultdiff", 1 )
< 		);
< 	}
< 	
< 	print "\n$WikiLinePref<b>Misc:</b>";
< 
< 	# Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
< 	print "\n<br>";
< 	print "\nServer time: ";
< 	print &TimeToText( $Now - $TimeZoneOffset );
< 	print &GetFormText( 'tzoffset', 0, 4, 9 );
< 	print "\n<br>";
< 	print &GetFormCheck( 'editwide', 1, "Use 100% wide edit area (if supported)" );
< 	print "\n<br>";
< 	print "\nEdit area rows: ";
< 	print &GetFormText( 'editrows', 20, 4, 4 );
< 	print "\n columns: ";
< 	print &GetFormText( 'editcols', 65, 4, 4 );
< 	print "\n<br>";
< 	print &GetFormCheck( 'toplinkbar', 1, "Show link bar on top" );
< 	print "\n<br>";
< 	print &GetFormCheck( 'linkrandom', 0, "Add 'Random Page' link to link bar" );
< 	print "\n<br>";
< 	print "\nStyleSheet URL: ";
< 	print &GetFormText( 'stylesheet', "", 30, 150 );
< 	print "\n<br><br>";
< 	print "\n<input type='button' name='Cancel' value='Cancel' onclick='history.go(-1);' style='margin-right: 20px;'>";
< 	print "\n<input type='reset' name='Reset'> ";
< 	print $q->submit( -name => 'Save', -value => "Save" );
< 	print "\n</form>";
< 	print "\n</div>";
< 	print "\n$WikiLineFooter";
< 	print "\n<div class='wikifooter'>";
< 	print &GetGotoBar("");
< 
< 	print &getFooterNote();
< 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
< 	print "\n</div></div></body></html>";	
< }
< 
< sub GetFormText {
< 	my ( $name, $default, $size, $max ) = @_;
< 	my $text = &GetParam( $name, $default );
< 	
< 	return $q->textfield(
< 		-name      => "p_$name",
< 		-default   => $text,
< 		-override  => 1,
< 		-size      => $size,
< 		-maxlength => $max
< 	);
< }
< 
< sub GetFormCheck {
< 	my ( $name, $default, $label ) = @_;
< 	my $checked = ( &GetParam( $name, $default ) > 0 );
< 	
< 	return $q->checkbox(
< 		-name     => "p_$name",
< 		-override => 1,
< 		-checked  => $checked,
< 		-label    => $label
< 	);
< }
< 
< sub DoUpdatePrefs {
< 	my ( $username, $password, $stylesheet );
< 
< 	# All link bar settings should be updated before printing the header
< 	&UpdatePrefCheckbox("toplinkbar");
< 	&UpdatePrefCheckbox("linkrandom");
< 	
< 	print &GetHeader( "", "Saving Preferences" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $UserID < 1001 ) {
< 		print "\n<h2>Invalid UserID $UserID, preferences not saved.</h2>";
< 		
< 		if ( $UserID == 111 ) {
< 			print "\n<br>(Preferences require cookies, but no cookie was sent.)";
< 		}
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></body></html>";
< 		
< 		return;
< 	}
< 	
< 	$username = &GetParam( "p_username", "" );
< 	
< 	if ($FreeLinks) {
< 		$username =~ s/^\[\[(.+)\]\]/$1/;    # Remove [[ and ]] if added
< 		$username = &FreeToNormal($username);
< 		$username =~ s/_/ /g;
< 	}
< 	
< 	if ( $username eq "" ) {
< 		print "\n<h2>UserName removed.</h2>";
< 		undef $UserData{'username'};
< 	}
< 	elsif ( ( !$FreeLinks ) && ( !( $username =~ /^$LinkPattern$/ ) ) ) {
< 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
< 	}
< 	elsif ( $FreeLinks && ( !( $username =~ /^$FreeLinkPattern$/ ) ) ) {
< 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
< 	}
< 	elsif ( length($username) > 50 ) {    # Too long
< 		print "\n<h2>UserName must be 50 characters or less. (not saved)</h2>";
< 	}
< 	else {
< 		print "\n<h2>UserName $username saved.</h2>";
< 		$UserData{'username'} = $username;
< 	}
< 	
< 	$password = &GetParam( "p_password", "" );
< 	
< 	if ( $password eq "" ) {
< 		print "\nPassword removed.<br>";
< 		undef $UserData{'password'};
< 	}
< 	elsif ( $password ne "*" ) {
< 		print "\nPassword changed.<br>";
< 		$UserData{'password'} = $password;
< 	}
< 	
< 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
< 		$password = &GetParam( "p_adminpw", "" );
< 		if ( $password eq "" ) {
< 			print "\nAdministrator password removed.<br>";
< 			undef $UserData{'adminpw'};
< 		}
< 		elsif ( $password ne "*" ) {
< 			print "\nAdministrator password changed.<br>";
< 			$UserData{'adminpw'} = $password;
< 			
< 			if ( &UserIsAdmin() ) {
< 				print "\nUser has administrative abilities.<br>";
< 			}
< 			elsif ( &UserIsEditor() ) {
< 				print "\nUser has editor abilities.<br>";
< 			}
< 			else {
< 				print "\nUser does not have administrative abilities. (Password does not match administrative password(s).) <br>";
< 			}
< 		}
< 	}
< 	
< 	if ($EmailNotify) {
< 		&UpdatePrefCheckbox("notify");
< 		&UpdateEmailList();
< 	}
< 	
< 	&UpdatePrefNumber( "rcdays", 0, 0, 999999 );
< 	&UpdatePrefCheckbox("rcnewtop");
< 	&UpdatePrefCheckbox("rcall");
< 	&UpdatePrefCheckbox("rcchangehist");
< 	&UpdatePrefCheckbox("editwide");
< 	
< 	if ($UseDiff) {
< 		&UpdatePrefCheckbox("norcdiff");
< 		&UpdatePrefCheckbox("diffrclink");
< 		&UpdatePrefCheckbox("alldiff");
< 		&UpdatePrefNumber( "defaultdiff", 1, 1, 3 );
< 	}
< 	
< 	&UpdatePrefNumber( "rcshowedit", 1, 0,    2 );
< 	&UpdatePrefNumber( "tzoffset",   0, -999, 999 );
< 	&UpdatePrefNumber( "editrows",   1, 1,    999 );
< 	&UpdatePrefNumber( "editcols",   1, 1,    999 );
< 	
< 	print "\n<br>Server time: ";
< 	print &TimeToText( $Now - $TimeZoneOffset );
< 	print "\n<br>";
< 	$TimeZoneOffset = &GetParam( "tzoffset", 0 ) * ( 60 * 60 );
< 	
< 	print"Local time: ";
< 	print &TimeToText($Now);
< 	print "\n<br>";
< 	$stylesheet = &GetParam( 'p_stylesheet', "" );
< 
< 	if ( $stylesheet eq "" ) {
< 		if ( &GetParam( 'stylesheet', "" ) ne "" ) {
< 			print "\nStyleSheet URL removed.<br>";
< 		}
< 		undef $UserData{'stylesheet'};
< 	}
< 	else {
< 		$stylesheet =~ s/[">]//g;  # Remove characters that would cause problems"
< 		$UserData{'stylesheet'} = $stylesheet;
< 		print "\nStyleSheet setting saved.<br>";
< 	}
< 	
< 	&SaveUserData();
< 	
< 	print "\n<br><b>Preferences saved.</b>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # add or remove email address from preferences to $EmailFile
< sub UpdateEmailList {
< 	my (@old_emails);
< 	local $/ = "\n";               # don't slurp whole files in this sub.
< 	
< 	if ( my $new_email = $UserData{'email'} = &GetParam( "p_email", "" ) ) {
< 		my $notify = $UserData{'notify'};
< 		if ( -f $EmailFile ) {
< 			open( NOTIFY, $EmailFile ) or die( Ts( 'Could not read from %s:', $EmailFile ) . " $!\n" );
< 			@old_emails = <NOTIFY>;
< 			close(NOTIFY);
< 		}
< 		else {
< 			@old_emails = ();
< 		}
< 		
< 		my $already_in_list = grep /$new_email/, @old_emails;
< 		
< 		if ( $notify and ( not $already_in_list ) ) {
< 			&RequestLock() or die( "Could not get mail lock" );
< 			if ( !open( NOTIFY, ">>$EmailFile" ) ) {
< 				&ReleaseLock();    # Don't leave hangling locks
< 				die( "Could not append to $EmailFile : $!\n" );
< 			}
< 			
< 			print NOTIFY $new_email, "\n";
< 			close(NOTIFY);
< 			&ReleaseLock();
< 		}
< 		elsif ( ( not $notify ) and $already_in_list ) {
< 			&RequestLock() or die( "Could not get mail lock" );
< 			if ( !open( NOTIFY, ">$EmailFile" ) ) {
< 				&ReleaseLock();
< 				die( "Could not overwrite $EmailFile : $!\n" );
< 			}
< 			foreach (@old_emails) {
< 				print NOTIFY "$_" unless /$new_email/;
< 			}
< 			
< 			close(NOTIFY);
< 			&ReleaseLock();
< 		}
< 	}
< }
< 
< sub UpdatePrefCheckbox {
< 	my ($param) = @_;
< 	my $temp = &GetParam( "p_$param", "*" );
< 	
< 	$UserData{$param} = 1 if ( $temp eq "on" );
< 	$UserData{$param} = 0 if ( $temp eq "*" );
< 
< 	# It is possible to skip updating by using another value, like "2"
< }
< 
< sub UpdatePrefNumber {
< 	my ( $param, $integer, $min, $max ) = @_;
< 	my $temp = &GetParam( "p_$param", "*" );
< 	
< 	return if ( $temp eq "*" );
< 	
< 	$temp =~ s/[^-\d\.]//g;
< 	$temp =~ s/\..*// if ($integer);
< 	
< 	return if ( $temp eq "" );
< 	return if ( ( $temp < $min ) || ( $temp > $max ) );
< 	
< 	$UserData{$param} = $temp;
< }
< 
< sub DoIndex {
< 	print &GetHeader( "", "Index of all pages", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print PrintPageList( "", &AllPagesList() );
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Create a new user file/cookie pair
< sub DoNewLogin {
< 	# Consider warning if cookie already exists
< 	# (maybe use "replace=1" parameter)
< 	&CreateUserDir();
< 	$SetCookie{'id'}      = &GetNewUserId();
< 	$SetCookie{'randkey'} = int( rand(1000000000) );
< 	$SetCookie{'rev'}     = 1;
< 	%UserCookie           = %SetCookie;
< 	$UserID               = $SetCookie{'id'};
< 
< 	# The cookie will be transmitted in the next header
< 	%UserData               = %UserCookie;
< 	$UserData{'createtime'} = $Now;
< 	$UserData{'createip'}   = $ENV{REMOTE_ADDR};
< 	&SaveUserData();
< }
< 
< sub DoEnterLogin {
< 	print &GetHeader( "", "Login", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>Enter UserID</h2>";
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( 'enter_login', 1 );
< 	print "\n<table><tr>";
< 	print "\n<td>User ID number &nbsp;</td>";
< 	print "\n<td>";
< 	print
< 	  $q->textfield(
< 		-name      => 'p_userid',
< 		-value     => "",
< 		-size      => 15,
< 		-maxlength => 50
< 	  );
< 	print "\n</td>";
< 	print "\n<tr>";
< 	print "\n<td>Password  &nbsp;</td>";
< 	print "\n<td>";
< 	print
< 	  $q->password_field(
< 		-name      => 'p_password',
< 		-value     => "",
< 		-size      => 15,
< 		-maxlength => 50
< 	  );
< 	print "\n</td>";
< 	print "\n</tr></table><br>";
< 	print $q->submit( -name => 'Login', -value => 'Login' );
< 	print "\n<br></form></div>";
< 	print &GetCommonFooter();
< 	print "\n</div></body></html>";	
< }
< 
< sub DoLogin {
< 	my ( $uid, $password, $success );
< 	
< 	$success = 0;
< 	$uid = &GetParam( "p_userid", "" );
< 	$uid =~ s/\D//g;
< 	$password = &GetParam( "p_password", "" );
< 	
< 	print &GetHeader( "", "Login Results", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( ( $uid > 199 ) && ( $password ne "" ) && ( $password ne "*" ) ) {
< 		$UserID = $uid;
< 		&LoadUserData();
< 		if ( $UserID > 199 ) {
< 			if ( defined( $UserData{'password'} ) && ( $UserData{'password'} eq $password ) ) {
< 				$SetCookie{'id'}      = $uid;
< 				$SetCookie{'randkey'} = $UserData{'randkey'};
< 				$SetCookie{'rev'}     = 1;
< 				$success              = 1;
< 			}
< 			else {
< 				print "\nUserID Account Undefined<br>";
< 			}
< 		}
< 		else {
< 			print "\nUserID must be above 199<br>";
< 		}
< 	}
< 	
< 	
< 	if ($success) { print "\n<h2>Login for user ID $uid complete.</h2>"; }
< 	else { print "\n<h2>Login for user ID $uid failed.</h2>"; }
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter;
< 	print "\n</div></body></html>";	
< }
< 
< sub GetNewUserId {
< 	my ($id);
< 	
< 	$id = $StartUID;
< 	
< 	while ( -f &UserDataFilename( $id + 1000 ) ) { $id += 1000; }
< 	while ( -f &UserDataFilename( $id + 100 ) ) { $id += 100; }
< 	while ( -f &UserDataFilename( $id + 10 ) ) { $id += 10; }
< 	
< 	&RequestLock() or die( "Could not get user-ID lock" );
< 
< 	while ( -f &UserDataFilename($id) ) { $id++; }
< 	
< 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
< 	&ReleaseLock();
< 	
< 	return $id;
< }
< 
< # Consider user-level lock?
< sub SaveUserData {
< 	my ( $userFile, $data );
< 	
< 	&CreateUserDir();
< 	$userFile = &UserDataFilename($UserID);
< 	$data = join( $FS1, %UserData );
< 	&WriteStringToFile( $userFile, $data );
< }
< 
< sub CreateUserDir {
< 	my ( $n, $subdir );
< 	
< 	if ( !( -d "$UserDir/0" ) ) {
< 		&CreateDir($UserDir);
< 		foreach $n ( 0 .. 9 ) {
< 			$subdir = "$UserDir/$n";
< 			&CreateDir($subdir);
< 		}
< 	}
< }
< 
< sub DoSearch {
< 	my ($string, $filter) = @_;
< 	my ( $title );
< 	
< 	if ( $string eq "" ) {
< 		&DoIndex();
< 		return;
< 	}
< 	
< 	print &GetHeader( "", &QuoteHtml( Ts( "Search for: $title %s", $string ) ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print PrintPageList( $filter, &SearchTitleAndBody($string, $filter) );
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
< 	print "\n<input type='hidden' name='search' value='$string'>";
< 	print "\n<input type='hidden' name='dosearch' value='1'>";	
< 	print "\n<input type='submit' value='Apply Filter'>";	
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoBackLinks {
< 	my ($string, $filter) = @_;
< 	my ($title);
< 	
< 	$title = $string;
< 	
< 	print &GetHeader( "", &QuoteHtml( Ts( 'Backlinks for: %s', $string ) ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	# At this time the backlinks are mostly a renamed search.
< 	# An initial attempt to match links only failed on subpages and free links.
< 	# Escape some possibly problematic characters:
< 	
< 	$string =~ s/([_ ])/( |_)/g;
< 	$string =~ s/([-'(),])/\\$1/g; #'REMARK
< 	$string =~ m,/, ? "\\b$string\\b" : "$string\\b";
< 	
< 	print PrintPageList( grep($_ !~ $title, $filter, &SearchTitleAndBody($string, $filter, "")) );
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
< 	print "\n<input type='hidden' name='back' value='$string'>";
< 	print "\n<input type='submit' value='Apply Filter'>";	
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub PrintPageList {
< 	my ($filter, @results) = @_;
< 	my $term;
<     my $pagename;
<     my $html = "";
<     my $pagecount = scalar(@results);
<     my $currentInitial = "";
<     my $thisInitial;
<     my $lastInitial;
<     my $letterGrouping = ($pagecount > 25);
<     my $currentParent = "";
<     my $linktext = "";
<     my $notFirst;
< 
< 	if ($filter ne ""){ $term = " using filter '<em>$filter</em>'"; }
< 	$html .= "<h2>" . ( scalar(@results) ) . " pages found: $term</h2>";
<     #$html .= "<ol>\n" if ($letterGrouping ne 1); # commented to keep a 'original' usemod look
<     
<     if ($letterGrouping) {
<         $html .= "<h3 class='lettergroup'>";
<         foreach $pagename (@results) {
<             $thisInitial = substr($pagename,0,1);
<             if ($thisInitial ne $lastInitial) {
<                     $html .= "<a href=\"#letter".$thisInitial."\">".$thisInitial."</a> ";
<                     $lastInitial = $thisInitial;
<             }
<         }
<         $html .= "</h3>";
<     }
<     
<     foreach $pagename (@results) {
<         if ($letterGrouping) {
<             $thisInitial = substr($pagename,0,1);
<             if ($currentInitial ne $thisInitial) {
<                 #$html .= "</ol>" if ($currentInitial ne ""); # commented to keep a 'original' usemod look
<                 $html .= "\n<br><br><h3 class='lettergroup'><a name=\"letter$thisInitial\"> $thisInitial </h3>\n$WikiLine\n";
<                 #$html .= "<ol>\n"; # commented to keep a 'original' usemod look
<                 $currentInitial = $thisInitial; 
<                 $notFirst = 0;
<             }
<         }
<         #$html .= "<li>"; # commented to keep a 'original' usemod look
<         $html .= "   ";
<         if (not($pagename =~ m|(.*)/(.*)|)) {
<             $currentParent = $pagename;
<             $linktext = $pagename;
<         } 
<         else {
<             if ($1 eq $currentParent) {
<                 if ($letterGrouping){  $linktext = "$currentParent/$2";}
<                 else { $html .= "... "; $linktext = "/$2";}                
<             } 
<             else {
<                 $linktext = $pagename;
<             }
<         }
<         if ($notFirst){ $notFirst = 1; $linktext = ", $linktext"; }
<         $html .= &GetPageLinkText($pagename,$linktext);
< 
<         if ($letterGrouping){ if ($notFirst){ $html .= ", "; }}
<         else { $html .= "\n<br>"; }
<     }
<     #$html .= "</ol>\n"; # commented to keep a 'original' usemod look
<     $html .= "\n<br>";
<     
<     return $html;
< }
< 
< sub DoLinks {	
< 	print &GetHeader( "", &QuoteHtml( "Full Link List" ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<hr><pre>\n\n\n\n";    # Extra lines to get below the logo
< 
< 	print &PrintLinkList(&GetFullLinkList(
< 		&GetParam("unique", 1),
< 		&GetParam("sort", 1),
< 		&GetParam("page", 1),
< 		&GetParam("inter", 0),
< 		&GetParam("url", 0),
< 		&GetParam("exists", 2),
< 		&GetParam("empty", 0),
< 		&GetParam("search", "")
< 	));
< 	
< 	print "\n</pre>";
< 	print "\n</div>";
< 	print "\n</div></div></body></html>";	
< }
< 
< sub PrintLinkList {
< 	my ( $pagelines, $page,  $names, $editlink );
< 	my ( $link, $text, $extra, @links, %pgExists );
< 	
< 	%pgExists = ();
< 	
< 	foreach $page ( &AllPagesList() ) {
< 		$pgExists{$page} = 1;
< 	}
< 	
< 	$names    = &GetParam( "names",    1 );
< 	$editlink = &GetParam( "editlink", 0 );
< 	
< 	foreach $pagelines (@_) {
< 		@links = ();
< 		
< 		foreach $page ( split( ' ', $pagelines ) ) {
< 			if ( $page =~ /\:/ ) {    # URL or InterWiki form
< 				if ( $page =~ /$UrlPattern/ ) {
< 					( $link, $extra ) = &UrlLink( $page, 0 );    # No images
< 				}
< 				else {
< 					( $link, $extra ) = &InterPageLink( $page, 0 );  # No images
< 				}
< 			}
< 			else {
< 				if ( $pgExists{$page} ) {
< 					$link = &GetPageLink($page);
< 				}
< 				else {
< 					$link = $page;
< 					if ($editlink) {
< 						$link .= &GetEditLink( $page, "?" );
< 					}
< 				}
< 			}
< 			
< 			push( @links, $link );
< 		}
< 		if ( !$names ) {
< 			shift(@links);
< 		}
< 		
< 		$text .= join(' ', @links) . "\n";
< 	}
< 	
< 	return $text;
< }
< 
< sub GetFullLinkList {
< 	my ($unique, $sort, $pagelink, $interlink, $urllink, $exists, $empty, $search, $listWantedPages )= @_ ;
< 	my ($name, $link ); # foreach iterators (though why not use $_ ?)
< 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
< 
< 	#my ($name, $unique, $sort, $exists, $empty, $link, $search);
< 	#my ($pagelink, $interlink, $urllink);	
< 	#$unique = &GetParam("unique", 1);
< 	#$sort = &GetParam("sort", 1);
< 	#$pagelink = &GetParam("page", 1);
< 	#$interlink = &GetParam("inter", 0);
< 	#$urllink = &GetParam("url", 0);
< 	#$exists = &GetParam("exists", 2);
< 	#$empty = &GetParam("empty", 0);
< 	#$search = &GetParam("search", "");
< 	
< 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) {
< 		$pagelink = 0;
< 	}
< 	%pgExists = ();
< 	@pglist   = &AllPagesList();
< 	
< 	foreach $name (@pglist) {
< 		$pgExists{$name} = 1;
< 	}
< 	%seen = ();
< 	
< 	foreach $name (@pglist) {
< 		@newlinks = ();
< 		if ( $unique != 2 ) {
< 			%seen = ();
< 		}
< 		
< 		@links = &GetPageLinks($name, $pagelink, $interlink, $urllink, $listWantedPages);
< 	
< 	    foreach $link (@links) {
< 			if ($link =~ m/^\//){
< 				$name =~ m/(.*)\//;
< 				
< 				if ($1){ $link = $1 . $link; }
< 				else { $link = $name . $link; }
< 			}
< 			
< 			$seen{$link}++;
< 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) {
< 				next;
< 			}
< 			
< 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) {
< 				next;
< 			}
< 			
< 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) {
< 				next;
< 			}
< 			
< 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) {
< 				next;
< 			}
< 			push( @newlinks, $link );
< 		}
< 		
< 		@links = @newlinks;
< 		if ($sort) {
< 			@links = sort(@links);
< 		}
< 		unshift( @links, $name );
< 		
< 		if ( $empty || ( $#links > 0 ) ) {    # If only one item, list is empty.
< 			push( @found, join( ' ', @links ) );
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub GetSubpages {
< 	my ($parentPage) = @_;
< 	my ($dir, @subpageFiles, @pages, $subId);
< 	
< 	return "" unless $parentPage;
< 	$dir = GetPageDirectory($parentPage);
< 	
< 	opendir(PAGELIST, "$PageDir/$dir/$parentPage") or return "";
< 	@subpageFiles = readdir(PAGELIST);
< 	closedir(PAGELIST);
< 	
< 	foreach $subId (@subpageFiles) {
< 		if (substr($subId, -3) eq '.db') {
< 		  push(@pages, "$parentPage/" . substr($subId, 0, -3));
< 		}
< 	}
< 	
< 	return @pages;
< }
< 
< sub GetPageList {
< 	my ($pagename, $retval);
< 	my (@list) = @_;
< 
< 	foreach $pagename (@list) {
< 	##	$retval .= ".... " if ($pagename =~ m|/|);
< 		$retval .= "&nbsp;" . &GetPageLink($pagename) . "<br>";
< 	}
< 
< 	return $retval;
< }
< 
< sub GetPageLinks {
< 	my ( $name, $pagelink, $interlink, $urllink, $listWantedPages ) = @_;
< 	my ( $text, @links );
< 	
< 	@links = ();
< 	&OpenPage($name);
< 	&OpenDefaultText();
< 	
< 	$text = $Text{'text'};
< 	$text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
< 	$text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
< 	$text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
< 	$text =~ s/<tt>(.|\n)*?\<\/tt>/ /ig;
< 	
< 	if ($interlink) {
< 		$text =~ s/''+/ /g;    # Quotes can adjacent to inter-site links
< 		$text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 	}
< 	else {
< 		$text =~ s/$InterLinkPattern/ /g;
< 	}
< 	
< 	if ($urllink) {
< 		$text =~ s/''+/ /g;    # Quotes can adjacent to URLs
< 		$text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 	}
< 	else {
< 		$text =~ s/$UrlPattern/ /g;
< 	}
< 	
< 	if ($pagelink) {
< 		if ($FreeLinks) {
< 			my $f2 = $FreeLinkPattern;
< 			
< 			$text =~ s/\[\[$f2\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
< 			$text =~ s/\[\[$f2\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
< 		}
< 		
< 		if ($listWantedPages){ $text =~ s/\[((.|\n)*?)\]/ /ig; }
< 			
< 		if ($WikiLinks) {
< 			$text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 		}
< 	}
< 	
< 	return @links;
< }
< 
< sub DoPost {
< 	my ( $editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user );
< 	my $string      = &GetParam( "text",        undef );
< 	my $id          = &GetParam( "title",       "" );
< 	my $summary     = &GetParam( "summary",     "" );
< 	my $oldtime     = &GetParam( "oldtime",     "" );
< 	my $oldconflict = &GetParam( "oldconflict", "" );
< 	my $isEdit      = 0;
< 	my $editTime    = $Now;
< 	my $authorAddr  = $ENV{REMOTE_ADDR};
< 	
< 	if ($id =~ /()/){
< 		$id = $1;
< 	}
< 	else {
< 		die "The page name $id is not valid";
< 	}
< 	
< 	if ($FreeLinks){
< 		$id = &FreeToNormal($id);
< 	}
< 	
< 	if ( !&UserCanEdit( $id, 1 ) ) {
< 		# This is an internal interface--we don't need to explain
< 		&ReportError( Ts( 'Editing not allowed for %s.', $id ) );
< 		return;
< 	}
< 	
< 	if (   ( $id eq 'SampleUndefinedPage' )
< 		|| ( $id eq 'SampleUndefinedPage' )
< 		|| ( $id eq 'Sample_Undefined_Page' )
< 		|| ( $id eq 'Sample_Undefined_Page' ) )
< 	{
< 		&ReportError( " $id cannot be defined." );
< 		return;
< 	}
< 	
< 	$string  = &RemoveFS($string);
< 	$summary = &RemoveFS($summary);
< 	$summary =~ s/[\r\n]//g;
< 	
< 	if ( length($summary) > 300 ) {    # Too long (longer than form allows)
< 		$summary = substr( $summary, 0, 300 );
< 	}
< 
< 	# Add a newline to the end of the string (if it doesn't have one)
< 	$string .= "\n" if ( !( $string =~ /\n$/ ) );
< 
< 
< 	# Lock before getting old page to prevent races
< 	# Consider extracting lock section into sub, and eval-wrap it?
< 	# (A few called routines can die, leaving locks.)
< 	if ($LockCrash) {
< 		&RequestLock() or die( "Could not get editing lock" );
< 	}
< 	else {
< 		if ( !&RequestLock() ) {
< 			&ForceReleaseLock('main');
< 		}
< 
< 		# Clear all other locks.
< 		&ForceReleaseLock('cache');
< 		&ForceReleaseLock('diff');
< 		&ForceReleaseLock('index');
< 	}
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$old     = $Text{'text'};
< 	$oldrev  = $Section{'revision'};
< 	$pgtime  = $Section{'ts'};
< 	$preview = 0;
< 	$preview = 1 if ( &GetParam( "Preview", "" ) ne "" );
< 	
< 	if ( !$preview && ( $old eq $string ) ) {    # No changes (ok for preview)
< 		&ReleaseLock();
< 		&ReBrowsePage( $id, "", 1 );
< 		return;
< 	}
< 	
< 	if ( ( $UserID > 399 ) || ( $Section{'id'} > 399 ) ) {
< 		$newAuthor = ( $UserID ne $Section{'id'} );    # known user(s)
< 	}
< 	else {
< 		$newAuthor = ( $Section{'ip'} ne $authorAddr );    # hostname fallback
< 	}
< 	
< 	$newAuthor = 1 if ( $oldrev == 0 );    # New page
< 	$newAuthor = 0 if ( !$newAuthor );     # Standard flag form, not empty
< 	                                       # Detect editing conflicts and resubmit edit
< 	                                       
< 	if ( ( $oldrev > 0 ) && ( $newAuthor && ( $oldtime != $pgtime ) ) ) {
< 		&ReleaseLock();
< 		if ( $oldconflict > 0 ) {    # Conflict again...
< 			&DoEdit( $id, 2, $pgtime, $string, $preview );
< 		}
< 		else {
< 			&DoEdit( $id, 1, $pgtime, $string, $preview );
< 		}
< 		return;
< 	}
< 	
< 	if ($preview) {
< 		&ReleaseLock();
< 		&DoEdit( $id, 0, $pgtime, $string, 1 );
< 		return;
< 	}
< 	
< 	$user = &GetParam( "username", "" );
< 
< 	# If the person doing editing chooses, send out email notification
< 	if ($EmailNotify) {
< 		&EmailNotify( $id, $user )
< 		  if &GetParam( "do_email_notify", "" ) eq 'on';
< 	}
< 	
< 	if ( &GetParam( "recent_edit", "" ) eq 'on' ) {
< 		$isEdit = 1;
< 	}
< 	
< 	if ( !$isEdit ) {
< 		&SetPageCache( 'oldmajor', $Section{'revision'} );
< 	}
< 	
< 	if ($newAuthor) {
< 		&SetPageCache( 'oldauthor', $Section{'revision'} );
< 	}
< 	
< 	&SaveKeepSection();
< 	&ExpireKeepFile();
< 	
< 	if ($UseDiff) {
< 		&UpdateDiffs( $id, $editTime, $old, $string, $isEdit, $newAuthor );
< 	}
< 	
< 	$Text{'text'}      = $string;
< 	$Text{'minor'}     = $isEdit;
< 	$Text{'newauthor'} = $newAuthor;
< 	$Text{'summary'}   = $summary;
< 	$Section{'host'}   = &GetRemoteHost(1);
< 	
< 	&SaveDefaultText();
< 	&SavePage();
< 	&WriteRcLog( $id, $summary, $isEdit, $editTime, $Section{'revision'}, $user,
< 		$Section{'host'} );
< 
< 	if ($UseCache) {
< 		&UnlinkHtmlCache($id);    # Old cached copy is invalid
< 		if ( $Page{'revision'} < 2 ) {    # If this is a new page...
< 			&NewPageCacheClear($id);      # ...uncache pages linked to this one.
< 		}
< 	}
< 	
< 	if ( $UseIndex && ( $Page{'revision'} == 1 ) ) {
< 		unlink($IndexFile);               # Regenerate index on next request
< 	}
< 	
< 	&ReleaseLock();
< 	&ReBrowsePage( $id, "", 1 );
< }
< 
< sub UpdateDiffs {
< 	my ( $id, $editTime, $old, $new, $isEdit, $newAuthor ) = @_;
< 	my ( $editDiff, $oldMajor, $oldAuthor );
< 	
< 	$editDiff  = &GetDiff( $old, $new, 0 );    # 0 = already in lock
< 	$oldMajor  = &GetPageCache('oldmajor');
< 	$oldAuthor = &GetPageCache('oldauthor');
< 	
< 	if ($UseDiffLog) {
<   		my $editDiff = Diff::diffClassic($old, $new);  # add this line
<   		&WriteDiff($id, $editTime, $editDiff);
< 	}
< 	
< 	&SetPageCache( 'diff_default_minor', $editDiff );
< 	if ( $isEdit || !$newAuthor ) {
< 		&OpenKeptRevisions('text_default');
< 	}
< 	
< 	if ( !$isEdit ) {
< 		&SetPageCache( 'diff_default_major', "1" );
< 	}	
< 	else {
< 		&SetPageCache( 'diff_default_major',
< 			&GetKeptDiff( $new, $oldMajor, 0 ) );
< 	}
< 	
< 	if ($newAuthor) {
< 		&SetPageCache( 'diff_default_author', "1" );
< 	}	
< 	elsif ( $oldMajor == $oldAuthor ) {
< 		&SetPageCache( 'diff_default_author', "2" );
< 	}
< 	else {
< 		&SetPageCache( 'diff_default_author',
< 			&GetKeptDiff( $new, $oldAuthor, 0 ) );
< 	}
< }
< 
< # Translation note: the email messages are still sent in English
< # Send an email message.
< sub SendEmail {
< 	my ( $to, $from, $reply, $subject, $message ) = @_;
< 
< 	# sendmail options:
< 	#    -odq : send mail to queue (i.e. later when convenient)
< 	#    -oi  : do not wait for "." line to exit
< 	#    -t   : headers determine recipient.
< 	open( SENDMAIL, "| $SendMail -oi -t " ) or die "Can't send email: $!\n";
< 	print SENDMAIL "From: $from\n";
< 	print SENDMAIL "To: $to\n";
< 	print SENDMAIL "Reply-to: $reply\n";
< 	print SENDMAIL "Subject: $subject\n";
< 	print SENDMAIL "$message\n";
< 	close(SENDMAIL) or warn "sendmail didn't close nicely";
< }
< ## Email folks who want to know a note that a page has been modified. - JimM.
< sub EmailNotify {
< 	local $/ = "\n";    # don't slurp whole files in this sub.
< 	
< 	if ($EmailNotify) {
< 		my ( $id, $user ) = @_;
< 		
< 		if ($user) {
< 			$user = " by $user";
< 		}
< 		
< 		my $address;
< 		
< 		return if ( !-f $EmailFile );    # No notifications yet
< 		
< 		open( EMAIL, $EmailFile )
< 		  or die "Can't open $EmailFile: $!\n";
< 		$address = join ",", <EMAIL>;
< 		$address =~ s/\n//g;
< 		close(EMAIL);
< 		
< 		my $home_url        = $q->url();
< 		my $page_url        = $home_url . "?$id";
< 		my $editors_summary = $q->param("summary");
< 
< 		if ( ( $editors_summary eq "*" ) or ( $editors_summary eq "" ) ) {
< 			$editors_summary = "";
< 		}
< 		else {
< 			$editors_summary = " Summary: $editors_summary";
< 		}
< 		
< 		my $content = <<"END_MAIL_CONTENT";
< 
<  The $SiteName page $id at
<    $page_url
<  has been changed$user to revision $Page{revision}. $editors_summary
< 
<  (Replying to this notification will
<   send email to the entire mailing list,
<   so only do that if you mean to.
< 
<   To remove yourself from this list, visit
<   ${home_url}?action=editprefs .)
< END_MAIL_CONTENT
< 		my $subject = "The $id page at $SiteName has been changed.";
< 
< 		# I'm setting the "reply-to" field to be the same as the "to:" field
< 		# which seems appropriate for a mailing list, especially since the
< 		# $EmailFrom string needn't be a real email address.
< 		&SendEmail( $address, $EmailFrom, $address, $subject, $content );
< 	}
< }
< 
< sub SearchTitleAndBody {
< 	my ($term, $filter) = @_;
< 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
< 	
< 	#If the search term has a !preceding it, strip it and set the exclusion flag
< 	if ($term =~ m/^\!/){ 
< 		$excludeTerm = 1;
< 		$term = substr($term, 1);	
< 	}
< 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
< 	if ($filter =~ m/^\!/){ 
< 		$excludeFilter = 1;
< 		$filter = substr($filter, 1);	
< 	}
< 
< 	foreach $name ( &AllPagesList() ) {
< 		if ($excludeFilter){
< 			if ($filter) { next if ($name =~ m/$filter/); }
< 		}
< 		else {
< 			if ($filter) { next unless ($name =~ m/$filter/); }
< 
< 		}
< 		
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if (!$excludeTerm){  
< 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( $freeName =~ /$term/i ) {
< 					push( @found, $name );
< 				}
< 			}
< 		}
< 		else { 
< 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( ! ($freeName =~ /$term/i) ) {
< 					push( @found, $name );
< 				}
< 			}			
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub SearchBody {
< 	my ($string) = @_;
< 	my ( $name, @found );
< 	
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if ( $Text{'text'} =~ /$string/i ) {
< 			push( @found, $name );
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub UnlinkHtmlCache {
< 	my ($id) = @_;
< 	my $idFile;
< 	
< 	$idFile = &GetHtmlCacheFile($id);
< 	
< 	if ( -f $idFile ) {
< 		unlink($idFile);
< 	}
< }
< 
< sub NewPageCacheClear {
< 	my ($id) = @_;
< 	my $name;
< 	
< 	return if ( !$UseCache );
< 	
< 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
< 	                    # The following code used to search the body for the $id
< 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
< 		&UnlinkHtmlCache($name);
< 	}
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub DoUnlock {
< 	my $LockMessage = "Normal Unlock.";
< 	
< 	print &GetHeader( "", "Removing edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>This operation may take several seconds...</h2>\n";
< 	
< 	if ( &ForceReleaseLock('main') ) {
< 		$LockMessage = "Forced Unlock.";
< 	}
< 	
< 	&ForceReleaseLock('cache');
< 	&ForceReleaseLock('diff');
< 	&ForceReleaseLock('index');
< 	
< 	print "\n<br><h2>$LockMessage</h2>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub WriteRcLog {
< 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
< 	my ( $extraTemp, %extra );
< 	
< 	%extra = ();
< 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
< 	$extra{'name'}     = $name     if ( $name ne "" );
< 	$extra{'revision'} = $revision if ( $revision ne "" );
< 	$extraTemp = join( $FS2, %extra );
< 
< 	# The two fields at the end of a line are kind and extension-hash
< 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
< 	
< 	if ( !open( OUT, ">>$RcFile" ) ) {
< 		die( Ts( '%s log error:', $RCName ) . " $!" );
< 	}
< 	
< 	print OUT $rc_line . "\n";
< 	close(OUT);
< }
< 
< sub WriteDiff {
< 	my ( $id, $editTime, $diffString ) = @_;
< 	
< 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
< 	print OUT "------\n" . $id . "|" . $editTime . "\n";
< 	print OUT $diffString;
< 	close(OUT);
< }
< 
< # Actions are vetoable if someone edits the page before
< # the keep expiry time. For example, page deletion. If
< # no one edits the page by the time the keep expiry time
< # elapses, then no one has vetoed the last action, and the
< # action is accepted.
< # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
< sub ProcessVetos {
< 	my ($expirets);
< 	
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 	
< 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
< 	
< 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
< 		&DeletePage( $OpenPageName, 1, 1 );
< 		return ( 1, "(deleted)" );
< 	}
< 	
< 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
< 		my $fname = $1;
< 
< 		# Only replace an allowed, existing file.
< 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
< 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
< 				my $string = $1;
< 				
< 				$string =~ s/\r\n/\n/gms;
< 				open( OUT, ">$fname" ) or return 0;
< 				print OUT $string;
< 				close OUT;
< 				
< 				return ( 0, "(replaced)" );
< 			}
< 		}
< 	}
< 	return ( 0, "(done)" );
< }
< 
< sub DoMaintain {
< 	my ( $name, $fname, $data, $message, $status );
< 	
< 	print &GetHeader( "", "Maintenance on all pages", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	$fname = "$DataDir/maintain";
< 	
< 	if ( !&UserIsAdmin() ) {
< 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
< 			print "\nMaintenance not done. ";
< 			print "\n(Maintenance can only be done once every 12 hours.)";
< 			print "\nRemove the 'maintain' file or wait.";
< 			print "\n</div>";
< 			print &GetCommonFooter();
< 			print "\n</div></div></body></html>";
< 			
< 			return;
< 		}
< 	}
< 	
< 	&RequestLock() or die( "Could not get maintain-lock" );
< 
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		( $status, $message ) = &ProcessVetos();
< 		&ExpireKeepFile() unless $status;
< 		
< 		print "\n.... " if ( $name =~ m|/| );
< 		print &GetPageLink($name);
< 		print "\n $message<br>";
< 	}
< 
< 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
< 	&ReleaseLock();
< 
< 	# Do any rename/deletion commands
< 	# (Must be outside lock because it will grab its own lock)
< 	$fname = "$DataDir/editlinks";
< 	
< 	if ( -f $fname ) {
< 		$data = &ReadFileOrDie($fname);
< 		print "\n<hr>Processing rename/delete commands:<br>";
< 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
< 		unlink("$fname.old");
< 		rename( $fname, "$fname.old" );
< 	}
< 	
< 	if ($MaintTrimRc) {
< 		&RequestLock() or die( "Could not get lock for RC maintenance" );
< 		$status = &TrimRc();                # Consider error messages?
< 		&ReleaseLock();
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Must be called within a lock.
< # Thanks to Alex Schroeder for original code
< sub TrimRc {
< 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
< 
< 	# Determine the number of days to go back
< 	$days = 0;
< 	
< 	foreach (@RcDays) {
< 		$days = $_ if $_ > $days;
< 	}
< 	$starttime = $Now - $days * 24 * 60 * 60;
< 	return 1 if ( !-f $RcFile );    # No work if no file exists
< 	( $status, $data ) = &ReadFile($RcFile);
< 	
< 	if ( !$status ) {
< 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
< 		
< 		return 0;
< 	}
< 
< 	# Move the old stuff from rc to temp
< 	@rc = split( /\n/, $data );
< 	
< 	for ( $i = 0 ; $i < @rc ; $i++ ) {
< 		($ts) = split( /$FS3/, $rc[$i] );
< 		last if ( $ts >= $starttime );
< 	}
< 	
< 	return 1 if ( $i < 1 );    # No lines to move from new to old
< 	
< 	@temp = splice( @rc, 0, $i );
< 
< 	# Write new files and backups
< 	if ( !open( OUT, ">>$RcOldFile" ) ) {
< 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
< 		return 0;
< 	}
< 	print OUT join( "\n", @temp ) . "\n";
< 	close(OUT);
< 	
< 	&WriteStringToFile( $RcFile . '.old', $data );
< 	$data = join( "\n", @rc );
< 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
< 	&WriteStringToFile( $RcFile, $data );
< 	
< 	return 1;
< }
< 
< sub DoMaintainRc {
< 	print &GetHeader( "", "Maintaining RC log", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	return if ( !&UserIsAdminOrError() );
< 	&RequestLock() or die( "Could not get lock for RC maintenance" );
< 	
< 	if ( &TrimRc() ) {
< 		print "\n<br>RC maintenance done.<br>";
< 	}
< 	else {
< 		print "\n<br>RC maintenance not done.<br>";
< 	}
< 	&ReleaseLock();
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub UserIsEditorOrError {
< 	if ( !&UserIsEditor() ) {
< 		print "\n<h2>This operation is restricted to site editors only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></body></html>";
< 			
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub UserIsAdminOrError {
< 	if ( !&UserIsAdmin() ) {
< 		print "\n<h2>This operation is restricted to administrators only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></body></html>";	
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub CheckIsAuthUser {
< 	my ($id) = @_;
< 	my $auth = ""; 
< 	my $found = 0;
< 	my $authtype;
< 	my $authname; 
< 	my $aname;
< 	my $afname;
< 	my $linecount = 0;
< 
< 	if (!(&UserIsAdmin())) {
< 		$aname = $id;
< 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
< 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
< 		
< 		if (-r $afname) {			
< 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
< 			
< 			open (AFN,"<$afname");
< 			while (<AFN>) {
< 				if (/$FS1/) { next; }       	# skip header and footer
< 				if (/^>\s[^\w]/) { next; }  	# skip comments	
< 				if (/diff-/){ next; }		
< 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
< 					$authtype = $1;
< 					$authname = $2; 
< 					
< 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
< 					elsif ($authtype eq "r"){ $authtype = "1"; }
< 					else { $authtype = "1"; }
< 					
< 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
< 				}
< 			}
< 			close AFN;
< 			if ($linecount == 0){ $auth = "3"; }
< 			elsif ($found == 0) { $auth = ""; }
< 		}
< 		else {
< 			$auth = "3";
< 		}
< 	}
< 	else {
< 		$auth = "3";
< 	}
< 	return $auth;
< }
< 
< sub DoEditLock {
< 	my ($fname);
< 	
< 	print &GetHeader( "", "Set or Remove global edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	return if ( !&UserIsAdminOrError() );
< 	$fname = "$DataDir/noedit";
< 
< 	if ( &GetParam( "set", 1 ) ) {
< 		&WriteStringToFile( $fname, "editing locked." );
< 	}
< 	else {
< 		unlink($fname);
< 	}
< 	
< 	if ( -f $fname ) {
< 		print "\n<h2>Edit lock created.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Edit lock removed.</h2>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoPageLock {
< 	my ( $fname, $id );
< 	
< 	print &GetHeader( "", "Set or Remove page edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	# Consider allowing page lock/unlock at editor level?
< 	return if ( !&UserIsAdminOrError() );
< 		
< 	$id = &GetParam( "id", "" );
< 	if ( $id eq "" ) {
< 		print "\n<p>Missing page id to lock/unlock...</p>";
< 		
< 		return;
< 	}
< 	
< 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
< 	$fname = &GetLockedPageFile($id);
< 	
< 	if ( &GetParam( "set", 1 ) ) {
< 		&WriteStringToFile( $fname, "editing locked." );
< 	}
< 	else {
< 		unlink($fname);
< 	}
< 
< 	if ( -f $fname ) {
< 		print "\n<h2>Lock for '$id' created.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Lock for '$id' removed.</h2>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoEditBanned {
< 	my ( $banList, $status );
< 	
< 	print &GetHeader( "", "Editing Banned list", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	return if ( !&UserIsAdminOrError() );
< 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
< 	$banList = "" if ( !$status );
< 	
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print GetHiddenValue( "edit_ban", 1 );
< 	print "\n<h2> Banned IP/network/host list:</h2>";
< 	print "\nEach entry is either a commented line (starting with #), ";
< 	print "\nor a Perl regular expression (matching either an IP address or ";
< 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
< 	print "\ngive up your admin access (remove password in Preferences).";
< 	print "\n<p><br><b>Example:</b><br><br>";
< 	print "\n# blocks hosts ending with .foocorp.com<br>";
< 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
< 	print "\n# blocks exact IP address<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
< 	print "\n# blocks whole 123.21.3.* IP network<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
< 	print &GetTextArea( 'banlist', $banList, 12, 50 );
< 	print "\n<br><br>";
< 	print $q->submit( -name => 'Save' );
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	;
< }
< 
< sub DoUpdateBanned {
< 	my ( $newList, $fname );
< 	
< 	print &GetHeader( "", "Updating Banned list", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	$fname = "$DataDir/banlist";
< 	$newList = &GetParam( "banlist", "#Empty file" );
< 	
< 	if ( $newList eq "" ) {
< 		print "\n<p>Empty banned list or error.</p>";
< 		print "\n<p>Resubmit with at least one space character to remove.</p>";
< 	}
< 	elsif ( $newList =~ /^\s*$/s ) {
< 		unlink($fname);
< 		print "\n<p>Removed banned list</p>";
< 	}
< 	else {
< 		&WriteStringToFile( $fname, $newList );
< 		print "\n<p>Updated banned list</p>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # ==== Editing/Deleting pages and links ====
< sub DoEditLinks {
< 	print &GetHeader( "", "Editing Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
< 	}
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print GetHiddenValue( "edit_links", 1 );
< 	print "\n<h2>Editing/Deleting page titles:</h2>";
< 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
< 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
< 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
< 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
< 	print &GetTextArea( 'commandlist', "", 12, 50 );
< 	print "\n<br><br>";
< 	print $q->checkbox(
< 		-name     => "p_changerc",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Edit $RCName"
< 	);
< 	print "\n<br>";
< 	print $q->checkbox(
< 		-name     => "p_changetext",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Substitute text for rename"
< 	);
< 	print "\n<br><br>";
< 	print $q->submit( -name => 'Process Command' );
< 	print "\n</form>";
< 	print "\n</div>";
< 	
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub UpdateLinksList {
< 	my ( $commandList, $doRC, $doText ) = @_;
< 	
< 	if ($doText) {
< 		&BuildLinkIndex();
< 	}
< 	&RequestLock() or die "UpdateLinksList could not get main lock";
< 	unlink($IndexFile) if ($UseIndex);
< 	
< 	foreach ( split( /\n/, $commandList ) ) {
< 		s/\s+$//g;
< 		
< 		next if ( !(/^[=!|?]/) );    # Only valid commands.
< 		print "\nProcessing $_<br>\n";
< 		
< 		if (/^\!(.+)/) {
< 			&DeletePage( $1, $doRC, $doText );
< 		}
< 		elsif (/^\?(.+)/){
< 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
< 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
< 			print "\n<br><br>";
< 		}
< 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
<       		my $GivenPage = $1;
<       		my $GivenNewName = $2;
<       
<       		if ($GivenPage =~ s[\/\*][]) {
<        			print "\nRenaming subpages of $GivenPage too...<br>";
<         
<         		foreach (&AllSubPagesList($GivenPage)) {
< 					my $NewSubName = $_;
< 					
< 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
< 					print "\nrenaming $_ to $NewSubName<br>";
< 					&RenamePage($_, $NewSubName, $doRC, $doText);
< 		        }
<       		}
< 		      # rename the page itself
< 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
< 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
< 		}
< 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
< 			&RenameTextLinks( $1, $2 );
< 		}
< 	}
< 	
< 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
< 	unlink($IndexFile) if ($UseIndex);
< 	&ReleaseLock();
< }
< 
< sub BuildLinkIndex {
< 	my ( @pglist, $page, @links, $link, %seen );
< 	
< 	@pglist    = &AllPagesList();
< 	%LinkIndex = ();
< 	
< 	foreach $page (@pglist) {
< 		&BuildLinkIndexPage($page);
< 	}
< }
< 
< sub BuildLinkIndexPage {
< 	my ($page) = @_;
< 	my ( @links, $link, %seen );
< 	
< 	@links = &GetPageLinks( $page, 1, 0, 0 );
< 	%seen = ();
< 	
< 	foreach $link (@links) {
< 		if ( defined( $LinkIndex{$link} ) ) {
< 			if ( !$seen{$link} ) {
< 				$LinkIndex{$link} .= " " . $page;
< 			}
< 		}
< 		else {
< 			$LinkIndex{$link} .= " " . $page;
< 		}
< 		$seen{$link} = 1;
< 	}
< }
< 
< sub DoUpdateLinks {
< 	my ( $commandList, $doRC, $doText );
< 	
< 	print &GetHeader( "", "Updating Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
< 	}
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	$commandList = &GetParam( "commandlist", "" );
< 	$doRC        = &GetParam( "p_changerc",  "0" );
< 	$doRC = 1 if ( $doRC eq "on" );
< 	$doText = &GetParam( "p_changetext", "0" );
< 	$doText = 1 if ( $doText eq "on" );
< 	
< 	if ( $commandList eq "" ) {
< 		print "\n<p>Empty command list or error.</p>";
< 	}
< 	else {
< 		&UpdateLinksList( $commandList, $doRC, $doText );
< 		print "\n<p>Finished command list.</p>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub EditRecentChanges {
< 	my ( $action, $old, $new ) = @_;
< 	
< 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
< 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
< }
< 
< sub EditRecentChangesFile {
< 	my ( $fname, $action, $old, $new, $printError ) = @_;
< 	my ( $status, $fileData, $errorText, $rcline, @rclist );
< 	my ( $outrc, $ts, $page, $junk );
< 	
< 	( $status, $fileData ) = &ReadFile($fname);
< 	
< 	if ( !$status ) {
< 
< 		# Save error text if needed.
< 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
< 		print $errorText if ($printError);
< 		
< 		return;
< 	}
< 	
< 	$outrc = "";
< 	@rclist = split( /\n/, $fileData );
< 	
< 	foreach $rcline (@rclist) {
< 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
< 		if ( $page eq $old ) {
< 			if ( $action == 1 ) {    # Delete
< 				;                    # Do nothing (don't add line to new RC)
< 			}
< 			elsif ( $action == 2 ) {
< 				$junk = $rcline;
< 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
< 				$outrc .= $junk . "\n";
< 			}
< 		}
< 		else {
< 			$outrc .= $rcline . "\n";
< 		}
< 	}
< 	
< 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
< 	&WriteStringToFile( $fname, $outrc );
< }
< 
< # Delete and rename must be done inside locks.
< sub DeletePage {
< 	my ( $page, $doRC, $doText ) = @_;
< 	my ( $fname, $status );
< 	
< 	$page =~ s/ /_/g;
< 	$page =~ s/\[+//;
< 	$page =~ s/\]+//;
< 	$status = &ValidId($page);
< 	
< 	if ( $status ne "" ) {
< 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
< 		return;
< 	}
< 	
< 	$fname = &GetPageFile($page);
< 	unlink($fname) if ( -f $fname );
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	unlink($fname)     if ( -f $fname );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
< 	       # Currently don't do anything with page text
< }
< 
< # Given text, returns substituted text
< sub SubstituteTextLinks {
< 	my ( $old, $new, $text ) = @_;
< 
< 	# Much of this is taken from the common markup
< 	%SaveUrl      = ();
< 	$SaveUrlIndex = 0;
< 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
< 	
< 	if ($RawHtml) {
< 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
< 	}
< 	
< 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
< 	
< 	if ($FreeLinks) {
< 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
< 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
< 	}
< 	
< 	if ($BracketText) {         # Links like [URL text of link]
< 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
< 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
< 	}
< 	
< 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
< 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
< 	
< 	if ($WikiLinks) {
< 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
< 	}
< 
< 	# Thanks to David Claughton for the following fix
< 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
< 	
< 	return $text;
< }
< 
< sub SubFreeLink {
< 	my ( $link, $name, $old, $new ) = @_;
< 	my ($oldlink);
< 	
< 	$oldlink = $link;
< 	$link =~ s/^\s+//;
< 	$link =~ s/\s+$//;
< 	
< 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
< 	{
< 		$link = $new;
< 	}
< 	
< 	else {
< 		$link = $oldlink;    # Preserve spaces if no match
< 	}
< 	
< 	$link = "[[$link";
< 	
< 	if ( $name ne "" ) {
< 		$link .= "|$name";
< 	}
< 	
< 	$link .= "]]";
< 	
< 	return &StoreRaw($link);
< }
< 
< sub SubWikiLink {
< 	my ( $link, $old, $new ) = @_;
< 	my ($newBracket);
< 	
< 	$newBracket = 0;
< 	
< 	if ( $link eq $old ) {
< 		$link = $new;
< 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
< 			$link = "[[$link]]";
< 		}
< 	}
< 	
< 	return &StoreRaw($link);
< }
< 
< # Rename is mostly copied from expire
< sub RenameKeepText {
< 	my ( $page, $old, $new ) = @_;
< 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
< 	my ( $sectName, $newText );
< 	
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	return if ( !( -f $fname ) );
< 	( $status, $data ) = &ReadFile($fname);
< 	return if ( !$status );
< 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	%tempSection = split( /$FS2/, $kplist[0], -1 );
< 
< 	if ( !defined( $tempSection{'keepts'} ) ) {
< 		return;
< 	}
< 
< 	# First pass: optimize for nothing changed
< 	$changed = 0;
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$changed = 1 if ( $Text{'text'} ne $newText );
< 		}
< 	}
< 	
< 	return if ( !$changed );    # No sections changed
< 	open( OUT, ">$fname" ) or return;
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$Text{'text'} = $newText;
< 			$tempSection{'data'} = join( $FS3, %Text );
< 			print OUT $FS1, join( $FS2, %tempSection );
< 		}
< 		else {
< 			print OUT $FS1, $_;
< 		}
< 	}
< 	close(OUT);
< }
< 
< sub RenameTextLinks {
< 	my ( $old, $new ) = @_;
< 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
< 	my ( $oldCanonical, @pageList );
< 	
< 	$old =~ s/ /_/g;
< 	$oldCanonical = &FreeToNormal($old);
< 	$new =~ s/ /_/g;
< 	$status = &ValidId($old);
< 	
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
< 	
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$old =~ s/_/ /g;
< 	$new =~ s/_/ /g;
< 
< 	# Note: the LinkIndex must be built prior to this routine
< 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
< 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
< 	foreach $page (@pageList) {
< 		$changed = 0;
< 		&OpenPage($page);
< 		foreach $section ( keys %Page ) {
< 			if ( $section =~ /^text_/ ) {
< 				&OpenSection($section);
< 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
< 				$oldText = $Text{'text'};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Text{'text'} = $newText;
< 					$Section{'data'} = join( $FS3, %Text );
< 					$Page{$section} = join( $FS2, %Section );
< 					$changed = 1;
< 				}
< 			}
< 			elsif ( $section =~ /^cache_diff/ ) {
< 				$oldText = $Page{$section};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Page{$section} = $newText;
< 					$changed = 1;
< 				}
< 			}
< 
< 			# Add other text-sections (categories) here
< 		}
< 		if ($changed) {
< 			$file = &GetPageFile($page);
< 			&WriteStringToFile( $file, join( $FS1, %Page ) );
< 		}
< 		&RenameKeepText( $page, $old, $new );
< 	}
< }
< 
< sub RenamePage {
< 	my ( $old, $new, $doRC, $doText ) = @_;
< 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
< 	
< 	$old =~ s/ /_/g;
< 	$new    = &FreeToNormal($new);
< 	$status = &ValidId($old);
< 	
< 	if ( $status ne "" ) {
< 		print "\nRename: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename: new page $new is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$newfname = &GetPageFile($new);
< 	if ( -f $newfname ) {
< 		print "\nRename: new page $new already exists--not renamed.<br>";
< 		return;
< 	}
< 	$oldfname = &GetPageFile($old);
< 	if ( !( -f $oldfname ) ) {
< 		print "\nRename: old page $old does not exist--nothing done.<br>";
< 		return;
< 	}
< 	
< 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
< 	rename( $oldfname, $newfname );
< 	&CreatePageDir( $KeepDir, $new );
< 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
< 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
< 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
< 	rename( $oldkeep, $newkeep );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
< 
< 	if ($doText) {
< 		&BuildLinkIndexPage($new);          # Keep index up-to-date
< 		&RenameTextLinks( $old, $new );
< 	}
< }
< 
< sub DoShowVersion {
< 	print &GetHeader( "", "Displaying Wiki Version", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>NobleWiki</h2>";
< 	print "\n<p>derived from UseModWiki version 1.0</p>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Admin bar contributed by ElMoro (with some changes)
< sub GetPageLockLink {
< 	my ( $id, $status, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 	}
< 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
< }
< sub GetGallery {
< 	my ($params) = @_;
< 	my @lines = split(/\r?\n/, $params);
< 	my $lineNum = 0;
< 	my $imageNum = 0;
< 	my %options;
< 	my $images = "";
< 	my $text = "";
< 	
< 	my $defaultImage = "image1.jpg";
< 	my $defaultThumb = "thumb_image1.jpg";
< 	my $image;
< 	my $thumb;
< 	my $title;
< 	my $header;
< 	my $caption;
< 	my $description;
< 	my $thumbWidth = 100;
< 	
< 	$GLOBAL_galleryCount++;
< 		
< 	foreach my $line (@lines){
< 		%options = &GetOptions($line);
< 		
< 		if ($lineNum == 0){
< 			$lineNum++;
< 			
< 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
< 			if ($options{'description'}){ $description = $options{'description'}; }
< 			if ($options{'header'}){ $header = $options{'header'}; }
< 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
< 			
< 			next;	
< 		}
< 		else {		
< 			if ($options{'image'}){ $image = $options{'image'}; }
< 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
< 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
< 			
< 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
< 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
< 			
< 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
< 				
< 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
< 		}
< 	}
< 	
< 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
< 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
< 	
< 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
< 	
< 	$text .= "\n	    <ul>";	
< 	$text .= $images;
< 	$text .= "\n	    </ul>";
< 	
< 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
< 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
< 	
< 	$text .= "\n	</div>";		
< 	
< 	return $text;
< }
< 
< sub GetFlash {
< 	my ($options) = @_;
< 	my %options = &GetOptions($options);	
< 	my $fpath = "$UploadUrl/";
< 	my $defaultSWF = 'ufo.swf';
< 	my $maxWidth = 400;
< 	my $maxHeight = 300;
< 	my $ratio = 1;
< 	
< 	my $text = "";
< 	
< 	my $fname;
< 	my $fwidth;
< 	my $fheight;
< 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
< 	my $idFO = "FO_$GLOBAL_flashCount";
< 
< 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
< 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
< 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
< 	
< 	if ($fwidth > $maxWidth){
< 		$ratio = $maxWidth / $fwidth;
< 		$fwidth = $maxWidth;
< 		$fheight = int ($ratio * $fheight);
< 	}
< 	elsif ($fheight > $maxHeight){
< 		$ratio = $maxHeight / $fheight;
< 		$fheight = $maxHeight;
< 		$fwidth = int ($ratio * $fwidth);
< 	}
< 			
< 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
< 	
< 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
< 	$text .= "\n<script type='text/javascript'>";
< 	$text .= "\n			var fpath = '$fpath';";
< 	$text .= "\n			var fname = '$fname';";
< 	$text .= "\n			var fwidth = $fwidth;";
< 	$text .= "\n			var fheight = $fheight;";
< 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
< 	$text .= "\n			\$(window).load(function () {";
< 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
< 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
< 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
< 	$text .= "\n		    });";
< 	$text .= "\n		</script>";		
< 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
< 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
< 	$text .= "\n		<p style='clear: both;'></p>";
< 	$text .= "\n	</div>";
< 
< 	$GLOBAL_flashCount++;
< 	
< 	return $text;		
< }
< sub GetAdminBar {
< 	my ($id, $cssClass) = @_;
< 	my ($result);
< 
< 	$result .= "\n<div $cssClass>";
< 	$result .= "Administration: ";
< 	
< 	my ($notValid) = $id =~ /^\d*$/;
< 	
< 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
< 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
< 	} 
< 		
< 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
< 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
< 	
< 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
< 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
< 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
< 	$result .= " | " . &ScriptLink("action=orphans", "List Orphans" );
< 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
< 			
< 	if ( -f "$DataDir/noedit" ) {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
< 	}
< 	else {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
< 	}
< 	
< 	$result .= "</div>";
< 	
< 	return $result;
< }
< 
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
< 	my ($id) = @_;
< 	
< 	return if ( !&ValidIdOrDie($id) );
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
< 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
< 		print &GetLeftNav("");
< 		print "\n<div class='wikiadmin'>";
< 		print "\n<h2>Delete Page?</h2>";
< 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
< 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></body></html>";	
< 		
< 		return;
< 	}
< 	
< 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
< 	print &GetLeftNav("");	
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $id eq $HomePage ) {
< 		print Ts( '%s can not be deleted.', $HomePage );
< 	}
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) {
< 			print Ts( '%s can not be deleted because it is locked.', $id );
< 		}
< 		else {
< 
< 			# Must lock because of RC-editing
< 			&RequestLock() or die( "Could not get editing lock" );
< 			DeletePage( $id, 1, 1 );
< 			&ReleaseLock();
< 			print Ts( '%s has been deleted.', $id );
< 		}
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
< 	print &GetHeader( "", "File Upload Page", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	print "\n<h2>Select File</h2>";
< 	print "\nThe current upload size limit is $MaxPost.<br>";
< 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
< 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
< 	print "\n<input type='hidden' name='upload' value='1' />";
< 	print "\nFile to Upload: ";
< 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
< 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub SaveUpload {
< 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
< 	print &GetHeader( "", "Upload Finished", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
< 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
< 	$filename = $q->param('file');
< 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
< 	
< 	$uploadFilehandle = $filename;
< 	open UPLOADFILE, ">$UploadDir$filename";
< 	binmode(UPLOADFILE);	
< 	while (<$uploadFilehandle>) { print UPLOADFILE; }
< 	close UPLOADFILE;
< 	
< 	print "\n<h2>Upload Completed</h2>";
< 	print "\nThe wiki link to your file is:<br><br>";
< 	
< 	$printFilename = $filename;
< 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
< 	$fileUrl = $UploadUrl . $printFilename;
< 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
< 
< 	if ( $filename =~ /${ImageExtensions}$/ ) {
< 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub ConvertFsFile {
< 	my ( $oldFS, $newFS, $fname ) = @_;
< 	my ( $oldData, $newData, $status );
< 	
< 	return if ( !-f $fname );           # Convert only existing regular files
< 	( $status, $oldData ) = &ReadFile($fname);
< 	
< 	if ( !$status ) {
< 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
< 		
< 		return;
< 	}
< 	
< 	$newData = $oldData;
< 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
< 	
< 	return if ( $oldData eq $newData );    # Do not write if the same
< 	&WriteStringToFile( $fname, $newData );
< 
< 	# print $fname . '<br>';    # progress report
< }
< 
< # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
< # Note that top level directory (page/keep/user) contains only dirs
< sub ConvertFsDir {
< 	my ( $oldFS, $newFS, $topDir ) = @_;
< 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
< 	
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	@dirs = sort(@dirs);
< 	
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$topDir/$dir" );             # Top level directories only
< 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
< 		
< 		opendir( DIRLIST, "$topDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
< 		
< 		foreach $file (@files) {
< 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
< 			$fname = "$topDir/$dir/$file";
< 			if ( -f $fname ) {
< 				# print $fname . '<br>';   # progress
< 				&ConvertFsFile( $oldFS, $newFS, $fname );
< 			}
< 			elsif ( -d $fname ) {
< 				opendir( DIRLIST, $fname );
< 				@subFiles = readdir(DIRLIST);
< 				closedir(DIRLIST);
< 				
< 				foreach $subFile (@subFiles) {
< 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
< 					$subFname = "$fname/$subFile";
< 					if ( -f $subFname ) {
< 						# print $subFname . '<br>';   # progress
< 						&ConvertFsFile( $oldFS, $newFS, $subFname );
< 					}
< 				}
< 			}
< 		}
< 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
< 	}
< }
< 
< sub ConvertFsCleanup {
< 	my ($topDir) = @_;
< 	my ( @dirs, $dir );
< 	
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-f "$topDir/$dir" );             # Remove only files...
< 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
< 		unlink "$topDir/$dir";
< 	}
< }
< 
< sub DoConvert {
< 	my $oldFS = "\xb3";
< 	my $newFS = "\x1e\xff\xfe\x1e";
< 	
< 	print &GetHeader( "", "Convert wiki DB", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";	
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	if ( $FS ne $newFS ) {
< 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
< 		return;
< 	}
< 	
< 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
< 	print "\nWiki DB locked for conversion.<br>";
< 	print "\nConverting Wiki DB...<br>";
< 	
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
< 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
< 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
< 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
< 	&ConvertFsCleanup($PageDir);
< 	&ConvertFsCleanup($KeepDir);
< 	&ConvertFsCleanup($UserDir);
< 	
< 	print "\nFinished converting wiki DB.<br>";
< 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Remove user-id files if no useful preferences set
< sub DoTrimUsers {
< 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
< 	my ( @dirs, @files, $dir, $file, $item );
< 	
< 	print &GetHeader( "", "Trim wiki users", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	$removed = 0;
< 	$maxID   = 1001;
< 	opendir( DIRLIST, $UserDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
< 		
< 		opendir( DIRLIST, "$UserDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
< 		
< 		foreach $file (@files) {
< 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
< 				$id    = $1;
< 				$maxID = $id if ( $id > $maxID );
< 				%Data  = ();
< 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
< 				
< 				if ($status) {
< 					%Data =
< 					  split( /$FS1/, $data, -1 )
< 					  ;    # -1 keeps trailing null fields
< 					$keep = 0;
< 					
< 					foreach $item (qw(username password adminpw stylesheet)) {
< 						$keep = 1
< 						  if ( defined( $Data{$item} )
< 							&& ( $Data{$item} ne "" ) );
< 					}
< 					
< 					if ( !$keep ) {
< 						unlink "$UserDir/$dir/$file";
< 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
< 						$removed += 1;
< 					}
< 				}
< 			}
< 		}
< 	}
< 	print Ts( 'Removed %s files.', $removed ) . '<br>';
< 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoAssetsToc {
< 	## Check $DataDir and see if assets-toc exists
< 	## -- if not, then build TOC
< 	## -- if does, but is older than 1 minute, rebuild TOC
< 	## Return TOC	
< }
< sub DoFilterToc {
< 	## Given @filters, pageIndex, pageSize
< 	## Get TOC from DoAssetsTOC
< 	## Apply @filters; sort, apply pageIndex * pageSize as offset
< 	## Return FilteredTOC	
< }
< sub DoListFiles {
< 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
< 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
< 	my ( $id, $filter, $managedisabled ) = @_;
< 
< 	if ($managedisabled){ 
< 		$targetDir = "$DisabledDir";
< 	}
< 	else {
< 		$targetDir = "$UploadDir";
< 	}
< 
< 	# CREATE array of filters
< 	$filter = lc($filter);
< 	$filter =~ s/\s//go;
< 	if ($filter ne ""){ 
< 		if ($filter =~ m/,/){
< 			@filters = split(',', $filter);
< 			
< 		}
< 		else {
< 			push (@filters, $filter);
< 		}
< 		$term = "using '<em>$filter</em>'";
< 	}
< 		
< 	# READ DIRECTORY	
< 	opendir( DIRLIST, $targetDir );
< 	@list = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	
< 	# RUN INCLUSIVE FILTERS
< 	foreach $file (@list){		
< 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
< 		
< 		if ($filter eq ""){  push @includes, $file; next; }
< 		
< 		$qualifies = 0;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;
< 			$include = $item;
< 					
< 			if ($item =~ m/^\!/){ next; }
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
< 		}
< 		
< 		if ($qualifies){ push @includes, $file; }
< 	}
< 
< 	# RUN EXCLUSIVE FILTERS
< 	foreach $file (@includes){
< 		if ($filter eq ""){  push @files, $file; next; }
< 				
< 		$qualifies = 1;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;					
< 			unless ($item =~ m/^\!/){ next; }
< 			$include = substr($item, 1);
< 
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
< 		}
< 		
< 		if ($qualifies){ push @files, $file; }
< 	}
< 	
< 	print &GetHeader( "", "Manage Assets", "" );
< 	print &GetLeftNav($id);
< 	print "\n<div class='wikidiff'>";
< 	
< 	#return if ( !&UserIsEditorOrError() );
< 		
< 	if ($managedisabled){
< 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
< 		
< 		# MOVE file to disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $keeppath){
< 				if (-w $UploadDir){
< 					if (rename($keeppath, $uploadpath)){
< 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 	else {
< 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
< 		
< 		# MOVE file from disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $uploadpath){
< 				if (-w $DisabledDir){
< 					if (rename($uploadpath, $keeppath)){
< 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 
< 	print "\n<table class='wikilargelist'>";
< 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
< 	
< 	foreach $file (@files) {
< 		$filecount++;
< 		$linkname = "upload:$file";
< 		
< 		@links = SearchTitleAndBody($file, "", "");
< 		$numlinks = scalar(@links);
< 
< 		$title = "";
< 		$action = "";
< 			
< 		if ($managedisabled){			
< 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td>$file</td>";
< 			print "\n<td align='right'>$size</td>";			
< 			
< 			if ( &UserIsEditorOrAdmin() ){
< 				$title = "Click to re-enable file.";
< 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
< 			}
< 		}
< 		else {		
< 			$uploadpath = "$UploadUrl/$file";
< 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
< 			print "\n<td align='right'>$size</td>";
< 			
< 			if ($numlinks > 0){
< 				$title = "Click to see what pages link to this file.";
< 				$action = "href='$ScriptName?back=$file'";
< 			}
< 			elsif ( &UserIsEditorOrAdmin() ){
< 				$numlinks = "0";
< 				$title = "Click to disable file.";
< 				$action = "href='$ScriptName?action=listfiles&id=$file'";
< 			}		
< 		}
< 
< 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
< 		print "\n</tr>";
< 	}
< 	
< 	if (scalar(@files) == 0){
< 		print "\n<td colspan='4'>No files available</td></tr>";
< 	}
< 	print "\n</table>";
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
< 	print "\n<input type='submit' value='Apply Filter'>";
< 	
< 	
< 	if ($managedisabled){
< 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
< 	}
< 	else {
< 		print "\n<input type='hidden' name='action' value='listfiles'>";
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
< 	}
< 	print "\nUse ! to exclude a term, separate terms with a comma";
< 	print "\n</form>";
< 	print "\n</div>";
< 
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";				
< }
< 
< 
< #END_OF_OTHER_CODE
< &DoWikiRequest() if ( $RunCGI && ( $_ ne 'nocgi' ) );    # Do everything.
< 1;    # In case we are loaded from elsewhere
< 
< # == End of UseModWiki script. ===========================================
7402a2
> 
------
SandBox|1195625489
0a1,7403
> <pre><nowiki>
> #!E:/Program Files/perl/bin/perl.exe
> # UseModWiki version 1.0 (September 12, 2003)
> # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
> # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
> # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
> #    <marcus@ira.uka.de>
> # ...which was based on
> #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
> #    and The Original WikiWikiWeb  (C) Ward Cunningham
> #        <ward@c2.com> (code reused with permission)
> # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
> #
> # This program is free software; you can redistribute it and/or modify
> # it under the terms of the GNU General Public License as published by
> # the Free Software Foundation; either version 2 of the License, or
> # (at your option) any later version.
> #
> # This program is distributed in the hope that it will be useful,
> # but WITHOUT ANY WARRANTY; without even the implied warranty of
> # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> # GNU General Public License for more details.
> #
> # You should have received a copy of the GNU General Public License
> # along with this program; if not, write to the
> #    Free Software Foundation, Inc.
> #    59 Temple Place, Suite 330
> #    Boston, MA 02111-1307 USA
> use Diff;
> use MagicContent;
> use Image::Size;
> 
> package UseModWiki;
> use strict;
> local $| = 1;    # Do not buffer output (localized for mod_perl)
> 
> # Configuration/constant variables:
> use vars qw(@RcDays @HtmlPairs @HtmlSingle
>   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
>   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
>   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
>   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
>   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
>   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
>   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
>   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
>   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
>   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
>   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
>   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
>   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
>   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
>   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
>   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
>   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
>   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine
>   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
>   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
>   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton $HomePagePrefix
>   $EditNameLink $UseMetaWiki @ImageSites $BracketImg $DisabledDir
>   $AllowInclusion $InclusionDir $NumberDatesDelim);
>   
> # Note: $NotifyDefault is kept because it was a config variable in 0.90
> # Other global variables:
> use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
>   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
>   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
>   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
>   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
>   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
>   $ConfigError $UploadPattern $WikiLineHeader $WikiLineHeaderPreview $WikiLineFooter $WikiLineDiff
>   $WikiLine $WikiLine1 $WikiLine2 $WikiLinePref $AutoMailto
>   $GLOBAL_imageCount $GLOBAL_flashCount $GLOBAL_galleryCount
>   $WikiLeftNav %TableCellDefaults $DownloadExtensions
>   );
> 
> # == Configuration =====================================================
> $DataDir = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/wiki";    # Main wiki directory
> $UseConfig = 0;    # 1 = use config file,    0 = do not look for config
> $ConfigFile = "$DataDir/config";    # Configuration file
> 
> # Default configuration (used if UseConfig is 0)
> $CookieName = "NobleWiki";          # Name for this wiki (for multi-wiki sites)
> $SiteName   = "Noble Pursuit Games Wiki";          # Name of site (used for titles)
> $HomePage   = "HomePage";           # Home page (change space to _)
> $HomePagePrefix = "HomePage";      # Which page will be linked when a valid $username is clicked in the RC history.
> $RCName     = "RecentChanges";      # Name of changes page (change space to _)
> $LogoUrl    = "";                   # URL for site logo ("" for no logo)
> $ENV{PATH}  = "/usr/bin/";          # Path used to find "diff"
> $ScriptTZ   = "";                   # Local time zone ("" means do not print)
> $RcDefault  = 7;                    # Default number of RecentChanges days
> @RcDays     = qw(1 3 7 30 90 180);  # Days for links on RecentChanges
> $KeepDays   = 14;                   # Days to keep old revisions
> $SiteBase   = "";                   # Full URL for <BASE> header
> 
> 								    # Set if the auto-detected URL is wrong
> $FullUrl    = "http://wiki.kurcina.org/cgi-bin/index.cgi";                                 
> $RedirType  = 1;                    # 1 = CGI.pm, 2 = script, 3 = no redirect
> $AdminPass  = "linhson";            # Set to non-blank to enable password(s)
> $EditPass   = "emerald";            # Like AdminPass, but for editing only
> $StyleSheet = "/css/wiki.default.css";   # URL for CSS stylesheet (like "/wiki.css")
> $NotFoundPg = "PageNotFound";       # Page for not-found links ("" for blank pg)
> $EmailFrom  = "NobleWiki";          # Text for "From: " field of email notes.
> $SendMail   = "/usr/sbin/sendmail"; # Full path to sendmail executable
> $AutoMailto = 1;					# 0 = off; 1 = convert email address automatically to mailTo:<address>
> 									# HTML for bottom of every page
> $FooterNote = "<a href='?action=editprefs'><div id='anylogo' title='access username'>&nbsp;</div></a>";                   
> 
> $EditNote   = "";                   # HTML notice above buttons on edit page
> $MaxPost    = 1024 * 5000;          # Maximum 210K posts (about 200K for pages)
> $NewText    = "";                   # New page text ("" for default message)
> $HttpCharset      = "";           # Charset for pages, like "iso-8859-2"
> 
> $InterWikiMoniker = "NobleWiki";  # InterWiki moniker for this wiki. (for RSS)
> $SiteDescription  = $SiteName;    # Description of this wiki. (for RSS)
> $RssLogoUrl       = "";           # Optional image for RSS feed
> $EarlyRules       = "";           # Local syntax rules for wiki->html (evaled)
> $LateRules        = "";           # Local syntax rules for wiki->html (evaled)
> $KeepSize         = 0;            # If non-zero, maximum size of keep file
> $BGColor          = "";           # Background color ('' to disable)
> $DiffColor1       = "#ffffaf";    # Background color of old/deleted text
> $DiffColor2       = "#cfffcf";    # Background color of new/added text
> $FavIcon          = "";           # URL of bookmark/favorites icon, or ''
> $RssDays          = 7;            # Default number of days in RSS feed
> $UserGotoBar      = "";           # HTML added to end of goto bar
> $UserGotoBar     .= "<a href='$ScriptName?WikiHelp'>Help</a>";
> 
> $UserHeader       = "";           # Optional HTML header additional content
> $UserHeader		 .= "\n<link rel='stylesheet' type='text/css' media='screen' href='/css/jquery.lightbox-0.4.css'/>";
> $UserHeader      .= "\n<script src='/js/jquery-1.2.1.js'></script>";
> $UserHeader      .= "\n<script src='/js/ufo.js'></script>";
> $UserHeader		 .= "\n<script src='/js/jquery.lightbox-0.4.js'></script>";
> 
> $UserBody         = "";           # Optional <BODY> tag additional content
> $StartUID         = 1001;         # Starting number for user IDs
> 								  # Full path (like /foo/www/uploads) for files
> $UploadDir        = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/docs/attachments";
> 								  # Full URL (like http://foo.com/uploads)
> $UploadUrl        = "http://wiki.kurcina.org/attachments";
> $DisabledDir      = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/disabled";
>       
> @ImageSites       = qw();         # Url prefixes of good image sites: ()=all
> 
> # Major options:
> $UseSubpage  = 1;             # 1 = use subpages,       0 = do not use subpages
> $UseCache    = 0;             # 1 = cache HTML pages,   0 = generate every page
> $EditAllowed = 1;             # 1 = editing allowed,    0 = read-only
> $RawHtml     = 0;             # 1 = allow <HTML> tag,   0 = no raw HTML in pages
> $HtmlTags    = 1;             # 1 = "unsafe" HTML tags, 0 = only minimal tags
> $UseDiff     = 1;             # 1 = use diff features,  0 = do not use diff
> $FreeLinks   = 1;             # 1 = use [[word]] links, 0 = LinkPattern only
> $WikiLinks   = 1;             # 1 = use LinkPattern,    0 = use [[word]] only
> $AdminDelete = 1;             # 1 = Admin only deletes, 0 = Editor can delete
> $RunCGI      = 1;             # 1 = Run script as CGI,  0 = Load but do not run
> $EmailNotify = 0;             # 1 = use email notices,  0 = no email on changes
> $EmbedWiki   = 0;             # 1 = no headers/footers, 0 = normal wiki pages
> $DeletedPage = "DeletedPage"; # 0 = disable, 'PageName' = tag to delete page
> $ReplaceFile = "ReplaceFile"; # 0 = disable, 'PageName' = indicator tag
> @ReplaceableFiles = ();       # List of allowed server files to replace
> $TableSyntax      = 1;        # 1 = wiki syntax tables, 0 = no table syntax
> $NewFS            = 1;        # 1 = new multibyte $FS,  0 = old $FS
> $UseUpload        = 1;        # 1 = allow uploads,      0 = no uploads
> $AllowInclusion = 1;          # 1 = files (*.txt,*.html) may be included by include:file.html,
> 	                          # 0 = files will not be included
> 	                          # from where shall the files be included?
> $InclusionDir = "$DataDir/includes-data";
>   
> # Minor options:
> $LogoLeft     = 1;    # 1 = logo on left,       0 = logo on right
> $RecentTop    = 1;    # 1 = recent on top,      0 = recent on bottom
> $UseDiffLog   = 1;    # 1 = save diffs to log,  0 = do not save diffs
> $KeepMajor    = 1;    # 1 = keep major rev,     0 = expire all revisions
> $KeepAuthor   = 1;    # 1 = keep author rev,    0 = expire all revisions
> $ShowEdits    = 0;    # 1 = show minor edits,   0 = hide edits by default
> $HtmlLinks    = 1;    # 1 = allow A HREF links, 0 = no raw HTML links
> $SimpleLinks  = 0;    # 1 = only letters,       0 = allow _ and numbers
> $NonEnglish   = 0;    # 1 = extra link chars,   0 = only A-Za-z chars
> $ThinLine     = 0;    # 1 = fancy <hr> tags,    0 = classic wiki <hr>
> $BracketText  = 1;    # 1 = allow [URL text],   0 = no link descriptions
> $UseAmPm      = 0;    # 1 = use am/pm in times, 0 = use 24-hour times
> $UseIndex     = 0;    # 1 = use index file,     0 = slow/reliable method
> $UseHeadings  = 1;    # 1 = allow = h1 text =,  0 = no header formatting
> $NetworkFile  = 1;    # 1 = allow remote file:, 0 = no file:// links
> $BracketWiki  = 1;    # 1 = [WikiLnk txt] link, 0 = no local descriptions
> $UseLookup    = 1;    # 1 = lookup host names,  0 = skip lookup (IP only)
> $FreeUpper    = 1;    # 1 = force upper case,   0 = do not force case
> $FastGlob     = 1;    # 1 = new faster code,    0 = old compatible code
> $MetaKeywords = 1;    # 1 = Google-friendly,    0 = search-engine averse
> $NamedAnchors = 1;    # 0 = no anchors, 1 = enable anchors,
>                       # 2 = enable but suppress display
> $SlashLinks   = 0;    # 1 = use script/action links, 0 = script?action
> $UpperFirst   = 1;    # 1 = free links start uppercase, 0 = no ucfirst
> $AdminBar     = 1;    # 1 = admins see admin links, 0 = no admin bar
> $RepInterMap  = 0;    # 1 = intermap is replacable, 0 = not replacable
> $ConfirmDel   = 1;    # 1 = delete link confirm page, 0 = immediate delete
> $MaskHosts    = 0;    # 1 = mask hosts/IPs,      0 = no masking
> $LockCrash    = 0;    # 1 = crash if lock stuck, 0 = auto clear locks
> $HistoryEdit  = 0;    # 1 = edit links on history page, 0 = no edit links
> $OldThinLine  = 0;    # 1 = old ==== thick line, 0 = ------ for thick line
> $NumberDates  = 1;    # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
> $NumberDatesDelim = "-"; # If $NumberDates is 1, this character separate the year, month, day
> $ParseParas   = 1;    # 1 = new paragraph markup, 0 = old markup
> $AuthorFooter = 1;    # 1 = show last author in footer, 0 = do not show
> $AllUpload    = 0;    # 1 = anyone can upload,   0 = only editor/admins
> $LimitFileUrl = 1;    # 1 = limited use of file: URLs, 0 = no limits
> $MaintTrimRc  = 1;    # 1 = maintain action trims RC, 0 = only maintainrc
> $SearchButton = 1;    # 1 = search button on page, 0 = old behavior
> $EditNameLink = 0;    # 1 = edit links use name (CSS), 0 = '?' links
> $UseMetaWiki  = 0;    # 1 = add MetaWiki search links, 0 = no MW links
> $BracketImg   = 1;    # 1 = [url url.gif] becomes image link, 0 = no img
> 
> $WikiLineHeader = "\n<div class='wikilineheader'></div>";
> $WikiLineHeaderPreview = "\n<div class='wikilineheaderpreview'></div>";
> $WikiLineFooter = "\n<div class='wikilinefooter'></div>";
> $WikiLineDiff   = "\n<div class='wikilinediff'></div>";
> $WikiLinePref   = "\n<div class='wikilinepref'></div>";
> $WikiLine       = "\n<div class='wikiline'></div>";
> $WikiLine1      = "\n<div class='wikiline1'></div>";
> $WikiLine2      = "\n<div class='wikiline2'></div>";
> 
> # Names of sites.  (The first entry is used for the number link.)
> @IsbnNames = ( 'bn.com', 'amazon.com', 'search' );
> 
> # Full URL of each site before the ISBN
> @IsbnPre = (
> 	"http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=",
> 	"http://www.amazon.com/exec/obidos/ISBN=",
> 	"http://www.pricescan.com/books/BookDetail.asp?isbn="
> );
> 
> # Rest of URL of each site after the ISBN (usually '')
> @IsbnPost = ( "", "", "" );
> 
> # HTML tag lists, enabled if $HtmlTags is set.
> # Scripting is currently possible with these tags,
> # so they are *not* particularly "safe".
> # Tags that must be in <tag> ... </tag> pairs:
> @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
>   em s strike strong tt var div center blockquote ol ul dl caption);
> 
> # Single tags (that do not require a closing /tag)
> @HtmlSingle = qw(br p hr li dt dd tr td th);
> @HtmlPairs  = ( @HtmlPairs, @HtmlSingle );     # All singles can also be pairs
> 
> # == You should not have to change anything below this line. =============
> $IndentLimit = 20;                             # Maximum depth of nested lists
> $PageDir     = "$DataDir/page-data";           # Stores page data
> $HtmlDir     = "$DataDir/html-version";        # Stores HTML versions
> $UserDir     = "$DataDir/user-data";           # Stores user data
> $KeepDir     = "$DataDir/keep-data";           # Stores kept (old) page data
> $TempDir     = "$DataDir/temp-files";          # Temporary files and locks
> $LockDir     = "$TempDir/lock-dir";            # DB is locked if this exists
> $InterFile   = "$DataDir/intermap";            # Interwiki site->url map
> $RcFile      = "$DataDir/recent-log";          # New RecentChanges logfile
> $RcOldFile   = "$DataDir/oldrecent-log";       # Old RecentChanges logfile
> $IndexFile   = "$DataDir/page-index";          # List of all pages
> $EmailFile   = "$DataDir/email-list";          # Email notification lists
> if ($RepInterMap) {
> 	push @ReplaceableFiles, $InterFile;
> }
> 
> # The "main" program, called at the end of this script file.
> sub DoWikiRequest {
> 	if ( $UseConfig && ( -f $ConfigFile ) ) {
> 		$ConfigError = "";
> 		if ( !do $ConfigFile ) {               # Some error occurred
> 			$ConfigError = $@;
> 			if ( $ConfigError eq "" ) {
> 
> 			  # Unfortunately, if the last expr returns 0, one will get a false
> 			  # error above.  To remain compatible with existing installs the
> 			  # wiki must not report an error unless there is error text in $@.
> 			  # (Errors in "use strict" may not have error text.)
> 			  # Uncomment the line below if you want to catch use strict errors.
> 			  #       $ConfigError = "Unknown Error (no error text)";
> 			}
> 		}
> 	}
> 	&InitLinkPatterns();
> 	if ( !&DoCacheBrowse() ) {
> 		eval $BrowseCode;
> 		&InitRequest() or return;
> 		if ( !&DoBrowseRequest() ) {
> 			eval $OtherCode;
> 			&DoOtherRequest();
> 		}
> 	}
> }
> 
> # == Common and cache-browsing code ====================================
> sub InitLinkPatterns {
> 	my ( $UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim );
> 
> 	# Field separators are used in the URL-style patterns below.
> 	if ($NewFS) {
> 		$FS = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
> 	}
> 	else {
> 		$FS = "\xb3";                # The FS character is a superscript "3"
> 	}
> 	
> 	$FS1         = $FS . "1";  # The FS values are used to separate fields
> 	$FS2         = $FS . "2";  # in stored hashtables and other data structures.
> 	$FS3         = $FS . "3";  # The FS character is not allowed in user data.
> 	$UpperLetter = "[A-Z";
> 	$LowerLetter = "[a-z";
> 	$AnyLetter   = "[A-Za-z";
> 	
> 	if ($NonEnglish) {
> 		$UpperLetter .= "\xc0-\xde";
> 		$LowerLetter .= "\xdf-\xff";
> 		
> 		if ($NewFS) {
> 			$AnyLetter .= "\x80-\xff";
> 		}
> 		else {
> 			$AnyLetter .= "\xc0-\xff";
> 		}
> 	}
> 	if ( !$SimpleLinks ) {
> 		$AnyLetter .= "_0-9";
> 	}
> 	
> 	$UpperLetter .= "]";
> 	$LowerLetter .= "]";
> 	$AnyLetter   .= "]";
> 
> 	# Main link pattern: lowercase between uppercase, then anything
> 	$LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
> 
> 	# Optional subpage link pattern: uppercase, lowercase, then anything
> 	$LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
> 	if ($UseSubpage) {
> 
> 		# Loose pattern: If subpage is used, subpage may be simple name
> 		$LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
> 
> 		# Strict pattern: both sides must be the main LinkPattern
> 		# $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
> 	}
> 	else {
> 		$LinkPattern = "($LpA)";
> 	}
> 	
> 	$QDelim = '(?:"")?';    # Optional quote delimiter (not in output)
> 	$AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
> 	$LinkPattern .= $QDelim;
> 
> 	# Inter-site convention: sites must start with uppercase letter
> 	# (Uppercase letter avoids confusion with URLs)
> 	$InterSitePattern = $UpperLetter . $AnyLetter . "+";
> 	$InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
> 	
> 	if ($FreeLinks) {
> 
> 		# Note: the - character must be first in $AnyLetter definition
> 		if ($NonEnglish) {
> 			if ($NewFS) {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
> 			}
> 			else {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
> 			}
> 		}
> 		else {
> 			$AnyLetter = "[-,.()' _0-9A-Za-z]";
> 		}
> 	}
> 	$FreeLinkPattern = "($AnyLetter+";
> 	if ($UseSubpage) {
> 		$FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+";
> 	}
> 	
> 	if ($NamedAnchors){
> 		$FreeLinkPattern .= "(?:#(?:\\w+))?)";
> 	}
> 	else {
> 		$FreeLinkPattern .= ")";
> 	}
> 	
> 	$FreeLinkPattern .= $QDelim;
> 
> 	# Url-style links are delimited by one of:
> 	#   1.  Whitespace                           (kept in output)
> 	#   2.  Left or right angle-bracket (< or >) (kept in output)
> 	#   3.  Right square-bracket (])             (kept in output)
> 	#   4.  A single double-quote (")            (kept in output)
> 	#   5.  A $FS (field separator) character    (kept in output)
> 	#   6.  A double double-quote ("")           (removed from output)
> 	$UrlProtocols    = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|prospero|telnet|gopher";
> 	$UrlProtocols   .= '|file' if ( $NetworkFile || !$LimitFileUrl );
> 	
> 	$UrlPattern      = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
> 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
> 	$DownloadExtensions = "(pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)";
> 	$RFCPattern      = "RFC\\s?(\\d+)";
> 	$ISBNPattern     = "ISBN:?([0-9- xX]{10,})";
> 	$UploadPattern   = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
> }
> 
> # Simple HTML cache
> sub DoCacheBrowse {
> 	my ( $query, $idFile, $text );
> 	return 0 if ( !$UseCache );
> 	$query = $ENV{'QUERY_STRING'};
> 	if ( ( $query eq "" ) && ( $ENV{'REQUEST_METHOD'} eq "GET" ) ) {
> 		$query = $HomePage;    # Allow caching of home page.
> 	}
> 	if ( !( $query =~ /^$LinkPattern$/ ) ) {
> 		if ( !( $FreeLinks && ( $query =~ /^$FreeLinkPattern$/ ) ) ) {
> 			return 0;          # Only use cache for simple links
> 		}
> 	}
> 	$idFile = &GetHtmlCacheFile($query);
> 	if ( -f $idFile ) {
> 		local $/ = undef;      # Read complete files
> 		open( INFILE, "<$idFile" ) or return 0;
> 		$text = <INFILE>;
> 		close INFILE;
> 		print $text;
> 		return 1;
> 	}
> 	return 0;
> }
> 
> sub GetHtmlCacheFile {
> 	my ($id) = @_;
> 	return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
> }
> 
> sub GetPageDirectory {
> 	my ($id) = @_;
> 	
> 	if ( $id =~ /^([a-zA-Z])/ ) { return uc($1); }
> 	
> 	return "other";
> }
> 
> sub T {
> 	my ($text) = @_;
> 	
> 	if ( defined( $Translate{$text} ) && ( $Translate{$text} ne "" ) ) {
> 		return $Translate{$text};
> 	}
> 	
> 	return $text;
> }
> 
> sub Ts {
> 	my ( $text, $string ) = @_;
> 	
> 	$text = T($text);
> 	$text =~ s/\%s/$string/;
> 	
> 	return $text;
> }
> 
> sub Tss {
> 	my $text = @_[0];
> 	
> 	$text = T($text);
> 	$text =~ s/\%([1-9])/$_[$1]/ge;
> 	
> 	return $text;
> }
> 
> # == Normal page-browsing and RecentChanges code =======================
> $BrowseCode = "";    # Comment next line to always compile (slower)
> 
> #$BrowseCode = <<'#END_OF_BROWSE_CODE';
> use CGI;
> use CGI::Carp qw(fatalsToBrowser);
> 
> sub InitRequest {
> 	my @ScriptPath = split( '/', "$ENV{SCRIPT_NAME}" );
> 	
> 	$CGI::POST_MAX = $MaxPost;
> 	
> 	if ($UseUpload) {
> 		$CGI::DISABLE_UPLOADS = 0;    # allow uploads
> 	}
> 	else {
> 		$CGI::DISABLE_UPLOADS = 1;    # no uploads
> 	}
> 	
> 	if ($SlashLinks && length($ENV{'PATH_INFO'}>1)){
> 		$ENV{'QUERY_STRING'} .= '&' if($ENV{'QUERY_STRING'});
> 		$ENV{'QUERY_STRING'} .= substr($ENV{'PATH_INFO'},1);
> 	}
> 	
> 	$q = new CGI();
> 	
> 	if ($SlashLinks){
> 		my $numberOfSlashes = ($ENV{'PATH_INFO'} = tr[/][/]);
> 		$ScriptName = ('../' x $numberOfSlashes) . $ScriptName;
> 	}
> 
> 	# Fix some issues with editing UTF8 pages (if charset specified)
> 	if ( $HttpCharset ne "" ) {
> 		$q->charset($HttpCharset);
> 	}
> 	$Now           = time;                # Reset in case script is persistent
> 	$ScriptName    = pop(@ScriptPath);    # Name used in links
> 		
> 	$IndexInit     = 0;                   # Must be reset for each request
> 	$InterSiteInit = 0;
> 	%InterSite     = ();
> 	$MainPage     = ".";    # For subpages only, the name of the top-level page
> 	$OpenPageName = "";     # Currently open page
> 	&CreateDir($DataDir);   # Create directory if it doesn't exist
> 
> 	if ( !-d $DataDir ) {
> 		&ReportError( "Could not create $DataDir : $!" );
> 		return 0;
> 	}
> 	&InitCookie();          # Reads in user data
> 	return 1;
> }
> 
> sub InitCookie {
> 	%SetCookie      = ();
> 	$TimeZoneOffset = 0;
> 	undef $q->{'.cookies'};    # Clear cache if it exists (for SpeedyCGI)
> 	%UserData   = ();                        # Fix for persistent environments.
> 	%UserCookie = $q->cookie($CookieName);
> 	$UserID     = $UserCookie{'id'};
> 	$UserID =~ s/\D//g;                      # Numeric only
> 	
> 	if ( $UserID < 200 ) {
> 		$UserID = 111;
> 	}
> 	else {
> 		&LoadUserData($UserID);
> 	}
> 	if ( $UserID > 199 ) {
> 		if (   ( $UserData{'id'} != $UserCookie{'id'} )
> 			|| ( $UserData{'randkey'} != $UserCookie{'randkey'} ) )
> 		{
> 			$UserID   = 113;
> 			%UserData = ();    # Invalid.  Consider warning message.
> 		}
> 	}
> 	if ( $UserData{'tzoffset'} != 0 ) {
> 		$TimeZoneOffset = $UserData{'tzoffset'} * ( 60 * 60 );
> 	}
> }
> 
> sub DoBrowseRequest {
> 	my ( $id, $action, $text );
> 	
> 	if ( !$q->param ) {        # No parameter
> 		&BrowsePage($HomePage);
> 		return 1;
> 	}
> 	$id = &GetParam( 'keywords', "" );
> 	if ($id) {                 # Just script?PageName
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	$action = lc( &GetParam( 'action', "" ) );
> 	$id = &GetParam( 'id', "" );
> 	
> 	if ( $action eq 'browse' ) {
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	elsif ( $action eq 'rc' ) {
> 		&BrowsePage($RCName);
> 		return 1;
> 	}
> 	elsif ( $action eq 'random' ) {
> 		&DoRandom();
> 		return 1;
> 	}
> 	elsif ($action eq 'orphans') {
> 		&DoOrphanList();
> 		return 1;
> 	} 
> 	elsif ($action eq 'history') {
> 		&DoHistory($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	
> 	return 0;    # Request not handled
> }
> 
> sub BrowsePage {
> 	my ($id) = @_;
> 	my ( $fullHtml, $oldId, $allDiff, $showDiff, $openKept );
> 	my ( $revision, $goodRevision, $diffRevision, $newText );
> 	my ( $fragHtml );
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$openKept = 0;
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	$goodRevision = $revision;    # Non-blank only if exists
> 
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		$openKept = 1;
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$goodRevision = "";
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 		}
> 	}
> 
> 	# Raw mode: just untranslated wiki text
> 	if ( &GetParam( 'raw', 0 ) ) {
> 		print &GetHttpHeader('text/plain');
> 		print $Text{'text'};
> 		return;
> 	}
> 	$newText = $Text{'text'};              # For differences
> 	                                       # Handle a single-level redirect
> 	$oldId   = &GetParam( 'oldid', "" );
> 	if (   ( $oldId eq "" )
> 		&& ( substr( $Text{'text'}, 0, 10 ) eq '#REDIRECT ' ) )
> 	{
> 		$oldId = $id;
> 		if ( ($FreeLinks) && ( $Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/ ) ) {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/ );
> 			$id = &FreeToNormal($id);
> 		}
> 		else {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+(\S+)/ );
> 		}
> 		if ( &ValidId($id) eq "" ) {
> 
> 			# Consider revision in rebrowse?
> 			&ReBrowsePage( $id, $oldId, 0 );
> 			return;
> 		}
> 		else {    # Not a valid target, so continue as normal page
> 			$id    = $oldId;
> 			$oldId = "";
> 		}
> 	}
> 	$MainPage = $id;
> 	$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 	$fullHtml = &GetHeader( $id, &QuoteHtml($id), $oldId );
> 
> 	unless( $id eq $RCName ){ $fullHtml .= &GetLeftNav($id); }
> 	if ( $UseDiff && $showDiff ) {
> 		$fullHtml .= "\n<div class='wikiadmin'>";
> 	}
> 	else {
> 		unless ($id eq $RCName){ $fullHtml .= "\n<div class='wikitext'>"; }
> 		else { $fullHtml .= "\n<div class='wikiadmin'>"; }
> 	}
> 	
> 		if ( $revision ne "" ) {
> 		if ( ( $revision eq $Page{'revision'} ) || ( $goodRevision ne "" ) ) {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Showing revision $revision.</div>";
> 		}
> 		else {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Revision $revision not available, showing current revision instead.</div>";
> 		}
> 	}
> 	
> 	$fullHtml .= $fragHtml;
> 	
> 	$allDiff = &GetParam( 'alldiff', 0 );
> 	if ( $allDiff != 0 ) {
> 		$allDiff = &GetParam( 'defaultdiff', 1 );
> 	}
> 	
> 	if (
> 		(
> 			( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName )
> 		)
> 		&& &GetParam( 'norcdiff', 1 )
> 	  )
> 	{
> 		$allDiff = 0;    # Only show if specifically requested
> 	}
> 	
> 	$showDiff = &GetParam( 'diff', $allDiff );
> 	
> 	if ( $UseDiff && $showDiff ) {
> 		$diffRevision = $goodRevision;
> 		$diffRevision = &GetParam( 'diffrevision', $diffRevision );
> 
> 		# Eventually try to avoid the following keep-loading if possible?
> 		&OpenKeptRevisions('text_default') if ( !$openKept );
> 		$fullHtml .= &GetDiffHTML( $showDiff, $id, $diffRevision, $revision, $newText );
> 		$fullHtml .= $fragHtml;
> 
> 	}
> 
> 	# magiccontent patch - tarquin
> 	# Refactored and added position functionality --DavidClaughton.
> 	my ($magiccommand, $magicpos, $magicparams);
> 	my ($magicHTML, $magicDiv, $wikiHTML) = ("", "", "");
> 	
> 	if ( ($magicpos, $magiccommand, $magicparams) = $Text{'text'} =~ m[^\#MAGIC\s*(?:\@(top|bottom))?\s*(\w*)\s*(.*)\n] ){
> 		$Text{'text'} =~ s/^\#MAGIC.*\n//; # kill the magic command line in source
> 		$wikiHTML = &WikiToHTML($Text{'text'});
> 		
> 		#$magicDiv = "\n<hr>\n"; # Remove if using CSS.
> 		
> 		# call: MakeSection( current page, magic module, line of parameters)
> 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
> 		
> 		if (lc $magicpos eq "top"){
> 			$fullHtml .= $magicHTML . $magicDiv . $wikiHTML;
> 		}
> 		else {
> 			$fullHtml .= $wikiHTML . $magicDiv . $magicHTML;
> 		}
> 	}
> 	else {
> 		$fullHtml .= &WikiToHTML($Text{'text'});
> 	}
> 	
> 	if ( !&GetParam( 'embed', $EmbedWiki ) ) {
> 		$fullHtml .= "</div>";
> 		$fullHtml .= $WikiLineFooter;
> 	}
> 
> 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) )
> 	{
> 		print $fullHtml;
> 		print $WikiLineDiff;
> 		print &GetLeftNav($id);
> 		print "\n<div class='wikidiff'>";
> 		&DoRc(1);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter" if ( !&GetParam( 'embed', $EmbedWiki ) );
> 
> 		print &GetFooterText( $id, $goodRevision );
> 		print "\n</div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$fullHtml .= &GetFooterText( $id, $goodRevision );
> 	$fullHtml .= "</div></div></body></html>";
> 	print $fullHtml;
> 	
> 	return
> 	
> 	if ( $showDiff || ( $revision ne "" ) );    # Don't cache special version
> 	&UpdateHtmlCache( $id, $fullHtml ) if ( $UseCache && ( $oldId eq "" ) );
> }
> 
> sub ReBrowsePage {
> 	my ( $id, $oldId, $isEdit ) = @_;
> 	
> 	if ( $oldId ne "" ) {    
> 		# Target of #REDIRECT (loop breaking)
> 		print &GetRedirectPage( "action=browse&id=$id&oldid=$oldId", $id, $isEdit );
> 	}
> 	else {
> 		print &GetRedirectPage( $id, $id, $isEdit );
> 	}
> }
> 
> sub DoRc {
> 	my ($rcType) = @_;       # 0 = RSS, 1 = HTML
> 	my ( $fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly );
> 	my ( @fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML );
> 	my $starttime = 0;
> 	my $showbar   = 0;
> 	
> 	if ( 0 == $rcType ) {
> 		$showHTML = 0;
> 	}
> 	else {
> 		$showHTML = 1;
> 	}
> 	
> 	if ( &GetParam( "from", 0 ) ) {
> 		$starttime = &GetParam( "from", 0 );
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print "\nUpdates since " . &TimeToText($starttime);
> 			print "\n</h2>";
> 		}
> 	}
> 	else {
> 		$daysago = &GetParam( "days", 0 );
> 		$daysago = &GetParam( "rcdays", 0 ) if ( $daysago == 0 );
> 		if ($daysago) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $daysago );
> 			if ($showHTML) {
> 				print "\n<h2>";
> 				print Ts( 'Updates in the last %s day' . ( ( $daysago != 1 ) ? "s" : "" ), $daysago );
> 				print "\n</h2>";
> 			}
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('Updates in the last %s days', '');
> 		}
> 	}
> 	
> 	if ( $starttime == 0 ) {
> 		if ( 0 == $rcType ) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RssDays );
> 		}
> 		else {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RcDefault );
> 		}
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print Ts('Updates in the last %s day'. ( ( $RcDefault != 1 ) ? "s" : "" ),$RcDefault );
> 			print "\n</h2>";
> 		}
> 
> 		# Translation of above line is identical to previous version
> 	}
> 
> 	# Read rclog data (and oldrclog data if needed)
> 	( $status, $fileData ) = &ReadFile($RcFile);
> 	$errorText = "";
> 	
> 	if ( !$status ) {
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>";
> 		$errorText .= "Could not open $RCName log file";
> 		$errorText .= ":</strong> $RcFile</p>";
> 		$errorText .= "Error was ";
> 		$errorText .= ":<pre>$!</pre><p>";
> 		$errorText .= "Note: This error is normal if no changes have been made.";
> 
> 	}
> 	@fullrc = split( /\n/, $fileData );
> 	$firstTs = 0;
> 	
> 	if ( @fullrc > 0 ) {    # Only false if no lines in file
> 		($firstTs) = split( /$FS3/, $fullrc[0] );
> 	}
> 	if ( ( $firstTs == 0 ) || ( $starttime <= $firstTs ) ) {
> 		( $status, $oldFileData ) = &ReadFile($RcOldFile);
> 		if ($status) {
> 			@fullrc = split( /\n/, $oldFileData . $fileData );
> 		}
> 		else {
> 			if ( $errorText ne "" ) {    
> 			
> 				# could not open either rclog file
> 				print $errorText;
> 				print "\n<p><strong>";
> 				print "\nCould not open old $RCName log file";
> 				print "\n:</strong> $RcOldFile</p>";
> 				print "\nError was";
> 				print "\n:<pre>$!</pre>";
> 				
> 				return;
> 			}
> 		}
> 	}
> 	$lastTs = 0;
> 	if ( @fullrc > 0 ) {                 
> 		# Only false if no lines in file
> 		($lastTs) = split( /$FS3/, $fullrc[$#fullrc] );
> 	}
> 	$lastTs++ if ( ( $Now - $lastTs ) > 5 );    # Skip last unless very recent
> 	$idOnly = &GetParam( "rcidonly", "" );
> 	
> 	if ( $idOnly && $showHTML ) {
> 		print "\n<b>(";
> 		print "\nfor ";
> 		print &ScriptLink( $idOnly, $idOnly );
> 		print "\n only";
> 		print "\n)</b><br>";
> 	}
> 	
> 	if ($showHTML) {
> 		foreach $i (@RcDays) {
> 			print "\n | " if $showbar;
> 			$showbar = 1;
> 			print &ScriptLink( "action=rc&days=$i",
> 				Ts( '%s day' . ( ( $i != 1 ) ? 's' : '' ), $i ) );
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('%s days', '');
> 		}
> 		print "\n<br><br>";
> 		print &ScriptLink( "action=rc&from=$lastTs", "List new changes starting from" );
> 		print "\n " . &TimeToText($lastTs);
> 		print "\n<br><br>";
> 	}
> 	
> 	$i = 0;
> 	while ( $i < @fullrc ) {    
> 		# Optimization: skip old entries quickly
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		if ( $ts >= $starttime ) {
> 			$i -= 1000 if ( $i > 0 );
> 			last;
> 		}
> 		$i += 1000;
> 	}
> 	
> 	$i -= 1000 if ( ( $i > 0 ) && ( $i >= @fullrc ) );
> 	for ( ; $i < @fullrc ; $i++ ) {
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	
> 	if ( $i == @fullrc && $showHTML ) {
> 		print "\n<br><strong>";
> 		print "\nNo updates since ";
> 		print &TimeToText($starttime);
> 		print "\n</strong><br>";
> 	}
> 	else {
> 		splice( @fullrc, 0, $i );    # Remove items before index $i
> 		
> 		# Consider an end-time limit (items older than X)
> 		if ( 0 == $rcType ) {
> 			print &GetRcRss(@fullrc);
> 		}
> 		else {
> 			print &GetRcHtml(@fullrc);
> 		}
> 	}
> 	
> 	if ($showHTML) {
> 		print "\nPage generated ";
> 		print &TimeToText($Now);
> 		print "\n<br>";
> 	}
> }
> 
> sub GetRc {
> 	my $rcType = shift;
> 	my @outrc  = @_;
> 	my ( $rcline,   $date, $newtop, $author, $inlist,   $result );
> 	my ( $showedit, $link, $all,    $idOnly, $headItem, $item );
> 	my ( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp );
> 	my ( $rcchangehist, $tEdit, $tChanges, $tDiff );
> 	my ( $headList, $historyPrefix, $diffPrefix );
> 	my %extra      = ();
> 	my %changetime = ();
> 	my %pagecount  = ();
> 
> 	# Slice minor edits
> 	$showedit = &GetParam( "rcshowedit", $ShowEdits );
> 	$showedit = &GetParam( "showedit",   $showedit );
> 	if ( $showedit != 1 ) {
> 		my @temprc = ();
> 		foreach $rcline (@outrc) {
> 			( $ts, $pagename, $summary, $isEdit, $host ) =
> 			  split( /$FS3/, $rcline );
> 			if ( $showedit == 0 ) {    # 0 = No edits
> 				push( @temprc, $rcline ) if ( !$isEdit );
> 			}
> 			else {                     # 2 = Only edits
> 				push( @temprc, $rcline ) if ($isEdit);
> 			}
> 		}
> 		@outrc = @temprc;
> 	}
> 
> 	# Optimize param fetches out of main loop
> 	$rcchangehist = &GetParam( "rcchangehist", 1 );
> 
> 	# Optimize translations out of main loop
> 	$tEdit         = "(edit)";
> 	$tDiff         = "(diff)";
> 	$tChanges      = "changes";
> 	$diffPrefix    = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
> 	$historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
> 	
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename ) = split( /$FS3/, $rcline );
> 		$pagecount{$pagename}++;
> 		$changetime{$pagename} = $ts;
> 	}
> 	
> 	$date     = "";
> 	$all      = &GetParam( "rcall", 0 );
> 	$all      = &GetParam( "all", $all );
> 	$newtop   = &GetParam( "rcnewtop", $RecentTop );
> 	$newtop   = &GetParam( "newtop", $newtop );
> 	$idOnly   = &GetParam( "rcidonly", "" );
> 	$inlist   = 0;
> 	$headList = "";
> 	$result   = "";
> 	@outrc    = reverse @outrc if ($newtop);
> 
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp ) =
> 		  split( /$FS3/, $rcline );
> 		next if ( ( !$all ) && ( $ts < $changetime{$pagename} ) );
> 		next if ( ( $idOnly ne "" ) && ( $idOnly ne $pagename ) );
> 		
> 		%extra = split( /$FS2/, $extraTemp, -1 );
> 		
> 		if ( $date ne &CalcDay($ts) ) {
> 			$date = &CalcDay($ts);
> 			if ( 1 == $rcType ) {    # HTML
> 				                     # add date, properly closing lists first
> 				if ($inlist) {
> 					$result .= "</ul>";
> 					$inlist = 0;
> 				}
> 				$result .= "\n<p><strong>" . $date . "</strong></p>";
> 				if ( !$inlist ) {
> 					$result .= "\n<ul>";
> 					$inlist = 1;
> 				}
> 			}
> 		}
> 		
> 		if ( 0 == $rcType ) {        # RSS
> 			( $headItem, $item ) = &GetRssRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $diffPrefix,
> 				$historyPrefix
> 			);
> 			$headList .= $headItem;
> 			$result   .= $item;
> 		}
> 		else {                       # HTML
> 			$result .= &GetHtmlRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $tEdit,
> 				$tDiff,             $tChanges,
> 				$all,               $rcchangehist
> 			);
> 		}
> 	}
> 	
> 	if ( 1 == $rcType ) {
> 		$result .= "</ul>" if ($inlist);    # Close final tag
> 	}
> 	
> 	return ( $headList, $result );            # Just ignore headList for HTML
> }
> 
> sub GetRcHtml {
> 	my ( $html, $extra );
> 	
> 	( $extra, $html ) = &GetRc( 1, @_ );
> 	
> 	return $html;
> }
> 
> sub GetHtmlRcLine {
> 	my (
> 		$pagename, $timestamp, $host,      $userName, $userID,
> 		$summary,  $isEdit,    $pagecount, $revision, $tEdit,
> 		$tDiff,    $tChanges,  $all,       $rcchangehist
> 	  )
> 	  = @_;
> 	my ( $author, $sum, $edit, $count, $link, $html );
> 	
> 	$html = "";
> 	$host = &QuoteHtml($host);
> 	
> 	if ( defined($userName) && defined($userID) ) {
> 		$author = &GetAuthorLink( $host, $userName, $userID );
> 	}
> 	else {
> 		$author = &GetAuthorLink( $host, "", 0 );
> 	}
> 	
> 	$sum = "";
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);
> 		$sum     = "<strong>[$summary]</strong> ";
> 	}
> 	
> 	$edit  = "";
> 	$edit  = "<em>$tEdit</em> " if ($isEdit);
> 	$count = "";	
> 	
> 	if ( ( !$all ) && ( $pagecount > 1 ) ) {
> 		$count = "($pagecount ";
> 		if ($rcchangehist) {
> 			$count .= &GetHistoryLink( $pagename, $tChanges, "Click to view revision history" );
> 		}
> 		else {
> 			$count .= $tChanges;
> 		}
> 		$count .= ") ";
> 	}
> 	
> 	$link = "";
> 	
> 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) { $link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  "; }
> 	
> 	$link .= &GetPageLink($pagename);
> 	$html .= "\n<li>$link ";
> 	$html .= &CalcTime($timestamp) . " : $count$edit" . " $sum";
> 	$html .= ". . . . . $author";
> 	
> 	return $html;
> }
> 
> sub GetRcRss {
> 	my ( $rssHeader, $headList, $items );
> 
> 	# Normally get URL from script, but allow override
> 	$FullUrl         = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$QuotedFullUrl   = &QuoteHtml($FullUrl);
> 	$SiteDescription = &QuoteHtml($SiteDescription);
> 	
> 	my $ChannelAbout = &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
> 	
> 	$rssHeader = <<RSS ;
> <?xml version="1.0" encoding="ISO-8859-1"?>
> <rdf:RDF
>     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
>     xmlns="http://purl.org/rss/1.0/"
>     xmlns:dc="http://purl.org/dc/elements/1.1/"
>     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
> >
>     <channel rdf:about="$ChannelAbout">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
>         <description>${\(&QuoteHtml($SiteDescription))}</description>
>         <wiki:interwiki>
>             <rdf:Description link="$QuotedFullUrl">
>                 <rdf:value>$InterWikiMoniker</rdf:value>
>             </rdf:Description>
>         </wiki:interwiki>
>         <items>
>             <rdf:Seq>
> RSS
> 	( $headList, $items ) = &GetRc( 0, @_ );
> 	$rssHeader .= $headList;
> 	return <<RSS ;
> $rssHeader
>             </rdf:Seq>
>         </items>
>     </channel>
>     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <url>$RssLogoUrl</url>
>         <link>$QuotedFullUrl</link>
>     </image>
> $items
> </rdf:RDF>
> RSS
> }
> 
> sub GetRssRcLine {
> 	my (
> 		$pagename, $timestamp,  $host,   $userName,
> 		$userID,   $summary,    $isEdit, $pagecount,
> 		$revision, $diffPrefix, $historyPrefix
> 	  )
> 	  = @_;
> 	my (
> 		$itemID,     $description, $authorLink, $author, $status,
> 		$importance, $date,        $item,       $headItem
> 	);
> 
> 	# Add to list of items in the <channel/>
> 	$itemID = $FullUrl
> 	  . &ScriptLinkChar()
> 	  . &GetOldPageParameters( 'browse', $pagename, $revision );
> 	$itemID   = &QuoteHtml($itemID);
> 	$headItem = "                <rdf:li rdf:resource=\"$itemID\"/>";
> 
> 	# Add to list of items proper.
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$description = &QuoteHtml($summary);
> 	}
> 	
> 	$host = &QuoteHtml($host);
> 	if ($userName) {
> 		$author     = &QuoteHtml($userName);
> 		$authorLink = "link=\"$QuotedFullUrl?$author\"";
> 	}
> 	else {
> 		$author = $host;
> 	}
> 	
> 	$status     = ( 1 == $revision ) ? 'new'   : 'updated';
> 	$importance = $isEdit            ? 'minor' : 'major';
> 	$timestamp += $TimeZoneOffset;
> 	
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($timestamp);
> 	
> 	$year += 1900;
> 	$date = sprintf( "%4d-%02d-%02dT%02d:%02d:%02d+%02d:00", $year, $mon + 1, $mday, $hour, $min, $sec, $TimeZoneOffset / ( 60 * 60 ) );
> 	$pagename = &QuoteHtml($pagename);
> 
> 	# Write it out longhand
> 	$item = <<RSS ;
>     <item rdf:about="$itemID">
>         <title>$pagename</title>
>         <link>$QuotedFullUrl?$pagename</link>
>         <description>$description</description>
>         <dc:date>$date</dc:date>
>         <dc:contributor>
>             <rdf:Description wiki:host="$host" $authorLink>
>                 <rdf:value>$author</rdf:value>
>             </rdf:Description>
>         </dc:contributor>
>         <wiki:status>$status</wiki:status>
>         <wiki:importance>$importance</wiki:importance>
>         <wiki:diff>$diffPrefix$pagename</wiki:diff>
>         <wiki:version>$revision</wiki:version>
>         <wiki:history>$historyPrefix$pagename</wiki:history>
>     </item>
> RSS
> 	return ( $headItem, $item );
> }
> 
> sub DoRss {
> 	print "\nContent-type: text/xml\n\n";
> 	&DoRc(0);
> }
> 
> sub DoRandom {
> 	my ( $id, @pageList );
> 	
> 	@pageList = &AllPagesList();       # Optimize?
> 	$id       = $pageList[ int( rand( $#pageList + 1 ) ) ];
> 	
> 	&ReBrowsePage( $id, "", 0 );
> }
>    
> sub DoHistory {
> 	my ($id) = @_;
> 	my ( $html, $canEdit, $row, $newText );
> 
> 	print &GetHeader( "", Ts( 'History of %s', $id ), "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikiadmin'>";
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$newText = $Text{'text'};
> 	$canEdit = 0;
> 	$canEdit = &UserCanEdit($id) if ($HistoryEdit);
> 		
> 	if ($UseDiff) {
>       print "\n<form id='wikiform' action='$ScriptName' method='get'>";
>       print "\n<input type='hidden' name='action' value='browse'/>";
>       print "\n<input type='hidden' name='diff' value='1'/>";
>       print "\n<input type='hidden' name='id' value=\"$id\"/>";
>       print "\n<table class='wikihistory' border='0' width='90%'>";
> 	}
> 	
> 	$html = &GetHistoryLine( $id, $Page{'text_default'}, $canEdit, $row++ );
> 	&OpenKeptRevisions('text_default');
> 	
> 	foreach ( reverse sort { $a <=> $b } keys %KeptRevisions ) {
> 		next if ( $_ eq "" );    # (needed?)
> 		$html .= &GetHistoryLine( $id, $KeptRevisions{$_}, $canEdit, $row++ );
> 	}
> 	
> 	print $html;
> 	
> 	if ($UseDiff) {
> 		my $label = "Compare";
> 		
> 		print "\n<tr><td align='center'><br>";
> 		print "\n<input type='submit' value='$label'/>&nbsp;&nbsp;</td></tr></table></form>";
> 		print &GetDiffHTML( &GetParam( 'defaultdiff', 1 ), $id, "", "", $newText );
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 
> 	print "\n</div></div></body></html>";
> }
> 
> sub GetMaskedHost {
> 	my ($text) = @_;
> 	my ($logText);
> 	if ( !$MaskHosts ) {
> 		return $text;
> 	}
> 	$logText = "(logged)";
> 	if ( !( $text =~ s/\d+$/$logText/ ) ) { # IP address (ending numbers masked)
> 		$text =~ s/^[^\.\(]+/$logText/;     # Host name: mask until first .
> 	}
> 	return $text;
> }
> 
> sub GetHistoryLine {
> 	my ( $id, $section, $canEdit, $row ) = @_;
> 	my ( $html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor );
> 	my ( %sect, %revtext );
> 	
> 	%sect = split( /$FS2/, $section, -1 );
> 	%revtext = split( /$FS3/, $sect{'data'} );
> 	$rev     = $sect{'revision'};
> 	$summary = $revtext{'summary'};
> 	
> 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) { $host = $sect{'host'}; }
> 	else { $host = $sect{'ip'};	}
> 	
> 	$host     = &GetMaskedHost($host);
> 	$user     = $sect{'username'};
> 	$uid      = $sect{'id'};
> 	$ts       = $sect{'ts'};
> 	$minor    = "";
> 	$minor    = "<i>(edited) </i>" if ( $revtext{'minor'} );
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 
> 	if ($UseDiff) {
> 		my ( $c1, $c2 );
> 		
> 		$c1 = "checked='checked'" if 1 == $row;
> 		$c2 = "checked='checked'" if 0 == $row;
> 		$html .= "\n<tr>";
> 		$html .= "\n<td align='center'>";
> 		$html .= "\n<input type='radio' name='diffrevision' value='$rev' $c1/>";
> 		$html .= "\n<input type='radio' name='revision' value='$rev' $c2/>";
> 		$html .= "</td><td>";
> 	}
> 	
> 	if ( 0 == $row ) {    
> 		# current revision
> 		$html .= &GetPageLinkText( $id, Ts( 'RevisionB %s', $rev ) ) . ' ';
> 		
> 		if ($canEdit) {
> 			$html .= &GetEditLink( $id, "Edit" ) . ' ';
> 		}
> 	}
> 	else {
> 		$html .= &GetOldPageLink( 'browse', $id, $rev, Ts( 'RevisionA %s', $rev ) ) . ' ';
> 		if ($canEdit) {
> 			$html .= &GetOldPageLink( 'edit', $id, $rev, "Edit" ) . ' ';
> 		}
> 	}
> 	
> 	$html .= "\n<td>" . &TimeToText($ts) . "</td>";
> 	$html .= "\n<td> by " . &GetAuthorLink( $host, $user, $uid ) . " $minor</td>";
> 	
> 	if ( defined($summary) && ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);    # Thanks Sunir! :-)
> 		$html .= "\n<td>[$summary]</td>";
> 	}
> 	else {
> 		$html .= "\n<td>&nbsp;</td>";
> 	}
> 	
> 	$html .= $UseDiff ? "</tr>" : "\n<br>";
> 	
> 	return $html;
> }
> 
> # ==== HTML and page-oriented functions ====
> sub ScriptLinkChar {
> 	if ($SlashLinks) { return '/'; }
> 	
> 	return '?';
> }
> 
> sub ScriptLink {
> 	my ( $action, $text ) = @_;
> 	
> 	return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\" class='wikiscriptlink' title='Click to visit page'>$text</a>";
> }
> 
> sub ScriptLinkClass {
> 	my ( $action, $text, $class, $title ) = @_;
> 	my $result = "<a href='$ScriptName" . &ScriptLinkChar() . "$action' class='$class' title='$title'>$text</a>";
> 	
> 	return $result;
> }
> 
> sub ScriptLinkLeftNav {
> 	my ($id, $action, $target, $label, $type) = @_;
> 	my $html;
> 	my $title;
> 	my $class;	
> 	
> 	if ($type eq "1"){
> 		if ($action eq $target){ $html .= "\n<li class='disabled'>$label</li>"; }
> 		else { $html .= "\n<li><a class='wikipagelink' title='Click to visit this page.' href='\?action=$target'>$label</a></li>"; }	
> 		
> 	}
> 	else {
> 		my $authtype = &CheckIsAuthUser($target);
> 		
> 		if ($authtype eq ""){
> 			$title = "This page is private.";
> 			$class = "wikipagelink private";
> 			$label .= "!";
> 		}
> 		elsif ( $authtype eq "1"){
> 			$title = "Click to visit this locked page.";
> 			$class = "wikipagelink locked";
> 			$label .= "&not;";
> 		}
> 		else {
> 			$title = "Click to visit this page.";
> 			$class = "wikipagelink";		
> 		}
> 		
> 		if ($id eq $target){ $html .= "\n<li class='selected'>$label</li>"; }
> 		else { $html .= "\n<li><a class='$class' title='$title' href='\?$target'>$label</a></li>"; }		
> 	}
> }
> 
> sub GetOrphanLink {
> 	return &ScriptLink("action=orphans", 'Orphans');
> }
> 
> sub DoOrphanList {
> 	print &GetHeader("", &QuoteHtml('Full Orphan List'), "");
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print &PrintPageList( "", &GetOrphanList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetOrphanList {
> 	my @found;	
> 	my %seen = ();
> 	my @pglist = &AllPagesList();
> 	
> 	foreach my $name (@pglist) { $seen{$name} = 0; }
> 	
> 	# pages linked from menu bar aren't orphans
> 	$seen{$HomePage} = 1;
> 	$seen{$RCName} = 1;
> 	
> 	foreach my $name (@pglist) {
> 		my @links = &GetPageLinks($name, 1, 0, 0, 0);
> 		
> 		foreach my $link (@links) {
> 			#don't include self links
> 			unless ($link eq $name) {
> 				$seen{$link}++ if exists $seen{$link};
> 			}
> 		}
> 	}
> 	
> 	foreach my $name (sort keys %seen) { push(@found, $name) if $seen{$name} < 1; }
> 	
> 	return @found;
> }
> 
> 
> sub GetPageLinkText {
> 	my ( $id, $name ) = @_;
> 	$id =~ s|^/|$MainPage/|;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 
> 	if ($authtype eq ""){
> 		return &ScriptLinkClass( $id, "$name!", 'wikipagelink private', 'This page is private.' );
> 	}
> 		
> 	if ( -f &GetLockedPageFile($id) || $authtype eq "1"){
> 		return &ScriptLinkClass( $id, "$name&not;", 'wikipagelink locked', 'Click to visit this locked page' );
> 	}
> 	
> 	return &ScriptLinkClass( $id, $name, 'wikipagelink', 'Click to visit page' );
> }
> 
> sub GetPageLink {
> 	my ($id) = @_;
> 	
> 	return &GetPageLinkText( $id, $id );
> }
> 
> sub GetEditLink {
> 	my ( $id, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	return &ScriptLinkClass( "action=edit&id=$id", $name, 'wikipageedit', 'Click to edit page' );
> }
> 
> sub GetCreateNewLink {
> 	my ( $id, $name ) = @_;
> 	my ( $html );
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	$html  = "<a href='$ScriptName";
> 	$html .= &ScriptLinkChar();
> 	$html .= "action=edit&id=$id' class='wikicreatepagelink' title='Create this entry'>";
> 	$html .= $name;
> 	$html .= "<span class='wikilinkicon'>&nbsp;</span>";
> 	$html .= "</a>";
> 	
> 	return $html;
> }
> 
> sub GetDeleteLink {
> 	my ( $id, $name, $confirm ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	return &ScriptLink( "action=delete&id=$id&confirm=$confirm", $name );
> }
> 
> sub GetOldPageParameters {
> 	my ( $kind, $id, $revision ) = @_;
> 	
> 	$id = &FreeToNormal($id) if $FreeLinks;
> 	
> 	return "action=$kind&id=$id&revision=$revision";
> }
> 
> sub GetOldPageLink {
> 	my ( $kind, $id, $revision, $name ) = @_;
> 	
> 	$name =~ s/_/ /g if $FreeLinks;
> 	
> 	return &ScriptLink( &GetOldPageParameters( $kind, $id, $revision ), $name );
> }
> 
> sub GetPageOrEditAnchoredLink {
> 	my ( $id, $anchor, $name ) = @_;
> 	my ( @temp, $exists );
> 	my $NamedFreeLink = 0;
> 	
> 	if ( $name eq "" ) {
> 		$name = $id;
> 		if ($FreeLinks) {
> 			$name =~ s/_/ /g;
> 		}
> 	}
> 	else {
> 		$NamedFreeLink = 1;
> 	}
> 	
> 	$id =~ s|^/|$MainPage/|;
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	$exists = 0;
> 	
> 	if ($UseIndex) {
> 		if ( !$IndexInit ) {
> 			@temp = &AllPagesList();    # Also initializes hash
> 		}
> 		$exists = 1 if ( $IndexHash{$id} );
> 	}
> 	elsif ( -f &GetPageFile($id) ) {    # Page file exists
> 		$exists = 1;
> 	}
> 	
> 	if ($exists) {
> 		$id = "$id#$anchor" if $anchor;
> 		$name = "$name#$anchor"  if $anchor && $NamedAnchors != 2 && !$NamedFreeLink;
> 		
> 		return &GetPageLinkText( $id, $name );
> 	}
> 	
> 	if ( $FreeLinks && !$EditNameLink ) {
> 		if ( $name =~ m| | ) {          # Not a single word
> 			$name = "[$name]";          # Add brackets so boundaries are obvious
> 		}
> 	}
> 	
> 	if ($EditNameLink) { return &GetEditLink( $id, $name ); }
> 	else { return &GetCreateNewLink( $id, $name ); }
> }
> 
> sub GetPageOrEditLink {
> 	my ( $id, $name ) = @_;
> 	my ($link, $anchor) = split( /#/, $id, 2);
> 	
> 	return &GetPageOrEditAnchoredLink($link, $anchor, $name);
> }
> 
> sub GetBackLinksSearchLink {
> 	my ($id) = @_;
> 	my $name = $id;
> 	
> 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
> 	
> 	if ($FreeLinks) {
> 		$name =~ s/_/ /g;    # Display with spaces
> 		$id   =~ s/_/+/g;    # Search for url-escaped spaces
> 	}
> 	return &ScriptLinkTitle( "back=$id", $name, "Click to see which pages link to this one" );
> }
> 
> sub GetPrefsLink {
> 	return &ScriptLink( "action=editprefs", "Preferences" );
> }
> 
> sub GetRandomLink {
> 	return &ScriptLink( "action=random", "Random Page" );
> }
> 
> sub ScriptLinkDiff {
> 	my ( $diff, $id, $text, $rev ) = @_;
> 	
> 	$rev = "&revision=$rev" if ( $rev ne "" );
> 	$diff = &GetParam( "defaultdiff", 1 ) if ( $diff == 4 );
> 	
> 	return &ScriptLinkTitle( "action=browse&diff=$diff&id=$id$rev", $text, "Click to view last revision" );
> }
> 
> sub GetUploadLink {
> 	return &ScriptLink( 'action=upload', "Upload" );
> }
> 
> sub ScriptLinkTitle {
> 	my ( $action, $text, $title ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$action =~ s/ /_/g;
> 	}
> 	
> 	return "<a href=\"$ScriptName"
> 	  . &ScriptLinkChar()
> 	  . "$action\" title=\"$title\" class='wikiscriptlinktitle'>$text</a>";
> }
> 
> sub GetAuthorLink {
> 	my ( $host, $userName, $uid ) = @_;
> 	my ( $html, $title, $userNameShow );
> 	$userNameShow = $userName;
> 	
> 	if ($FreeLinks) {
> 		$userName     =~ s/ /_/g;
> 		$userNameShow =~ s/_/ /g;
> 	}
> 	
> 	if ( &ValidId($userName) ne "" ) {    # Invalid under current rules
> 		$userName = "";                   # Just pretend it isn't there.
> 	}
> 	
> 	if ( ( $uid > 0 ) && ( $userName ne "" ) ) {
> 		$html = &ScriptLinkTitle( "$HomePagePrefix/$userName", $userNameShow, Ts( 'ID %s', $uid ) . ' ' . Ts( 'from %s', $host ) );
> 	}
> 	else {
> 		$html = $host;
> 	}
> 	
> 	return $html;
> }
> 
> sub GetHistoryLink {
> 	my ( $id, $text, $title ) = @_;
> 	
> 	if ($FreeLinks) { $id =~ s/ /_/g; }
> 	
> 	return &ScriptLinkTitle( "action=history&id=$id", $text, $title );
> }
> 
> sub GetHeader {
> 	my ( $id, $title, $oldId ) = @_;
> 	my $header    = "";
> 	my $logoImage = "";
> 	my $result    = "";
> 	my $embed     = &GetParam( 'embed', $EmbedWiki );
> 	my $altText   = "[Home]";
> 	my $temp      = "";
> 	
> 	$result = &GetHttpHeader("");
> 	
> 	if ($FreeLinks) {
> 		$title =~ s/_/ /g;    # Display as spaces
> 	}
> 	
> 	$result .= &GetHtmlHeader("$SiteName: $title", $id);
> 	
> 	return $result if ($embed);
> 	$result .= "<div class='wikiheader'>";
> 	
> 	if ( $oldId ne "" ) {
> 		$result .=
> 		  $q->h3( '(' . Ts( 'redirected from %s', &GetEditLink( $oldId, $oldId ) )  . ')' );
> 	}
> 	
> 	if ( ( !$embed ) && ( $LogoUrl ne "" ) ) {
> 		$logoImage = "img class='wikilogo' src=\"$LogoUrl\" alt=\"$altText\" border=0";
> 		
> 		if ( !$LogoLeft ) {
> 			$logoImage .= " align=\"right\"";
> 		}
> 		$header = &ScriptLink( $HomePage, "\n<$logoImage>" );
> 	}
> 	
> 	if ( $id ne "" ) {
> 		my $authtype = &CheckIsAuthUser($id);
> 		if (&PageIsLocked($id, 1) || $authtype eq "1"){
> 			$temp = "<span class='wikilockicon' title='This page is locked.'>&nbsp;</span>";
> 		}
> 		else {	
> 			if ( -f &GetLockedPageFile($id) ) {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='This page locked for others. Click to edit page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 			else {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='Click to edit this page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 		}		
> 		$result .= $q->h1( $header . &GetBackLinksSearchLink($id) . $temp );
> 	}
> 	else {
> 		$result .= $q->h1( $header . $title );
> 	}
> 	
> 
> 	if ( &GetParam( "toplinkbar", 1 ) ) {		
> 		$result .= &GetGotoBar($id);
> 		$result .= $WikiLineHeader;
> 	}
> 	
> 	$result .= "</div>";
> 		
> 	return $result;
> }
> 
> sub GetHttpHeader {
> 	my ($type) = @_;
> 	my $cookie;
> 	
> 	$type = "text/html" if ( $type eq "" );
> 	if ( defined( $SetCookie{'id'} ) ) {
> 		$cookie =
> 		   "$CookieName=" . "rev&"
> 		  . $SetCookie{'rev'} . "&id&"
> 		  . $SetCookie{'id'}
> 		  . "&randkey&"
> 		  . $SetCookie{'randkey'};
> 		$cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
> 		if ( $HttpCharset ne "" ) {
> 			return $q->header(
> 				-cookie => $cookie,
> 				-type   => "$type; charset=$HttpCharset"
> 			);
> 		}
> 		return $q->header( -cookie => $cookie );
> 	}
> 	if ( $HttpCharset ne "" ) {
> 		return $q->header( -type => "$type; charset=$HttpCharset" );
> 	}
> 	
> 	return $q->header( -type => $type );
> }
> 
> sub GetHtmlHeader {
> 	my ($title, $id) = @_;
> 	my ( $dtd, $html, $bodyExtra, $stylesheet );
> 	
> 	$html  = "";
> 	$dtd   = "-//IETF//DTD HTML//EN";
> 	$html  = qq(<!DOCTYPE HTML PUBLIC "$dtd">);
> 	$title = $q->escapeHTML($title);
> 	$html .= "\n<html><head><title>$title</title>";
> 	
> 	if ( $FavIcon ne "" ) {
> 		$html .= "<link rel='SHORTCUT ICON' href='$FavIcon'>";
> 	}
> 	
> 	if ($MetaKeywords) {
> 		my $keywords = $OpenPageName;
> 		$keywords =~ s/([a-z])([A-Z])/$1, $2/g;
> 		$html .= "\n<meta name='keywords' content='$keywords'/>" if $keywords;
> 	}
> 	
> 	if ( $SiteBase ne "" ) {
> 		$html .= qq(<base href="$SiteBase">);
> 	}
> 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
> 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
> 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
> 	
> 	if ( $stylesheet ne "" ) {
> 		$html .= qq(<link rel="stylesheet" href="$stylesheet">);
> 	}
> 
>    my $bots = "";
>    # actions and non-existant page views don't get indexed or followed by robots
>    if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
>    $bots = $bots . 'index,' . $bots . 'follow';
>    $html .= qq(<meta name="robots" content="$bots" />\n);
> 	
> 	$html .= $UserHeader;
> 	$bodyExtra = "";
> 	
> 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
> 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
> 	
> 	$html .= "</head><body$bodyExtra>";
> 	$html .= "\n<div id='wikicontainer'>";
> 	
> 	return $html;
> }
> 
> sub GetLeftNav {
> 	my $id = shift;
> 	my $action = &GetParam( "action", "" );
> 	my $html = "";
> 	
> 	$html .= "\n<div class='wikileftnav'>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'HomePage', 'Home page', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'NobleWiki', 'Wiki Info', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'CategoryCategory', 'Contents', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'FeaturedContent', 'Featured', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'random', 'Random Article', "1");	
> 	
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>	";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'RecentChanges', 'Recent changes', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'ListOfWantedPages', 'Wanted Pages', "");
> 					
> 	if ($id ne ""){
> 		unless ($id eq 'ListOfWantedPages' or $id eq 'RecentChanges'){	
> 			if (&UserCanEdit( $id, 0 )){ $html .= "\n<li><a href='?action=edit&id=$id'>Edit this Page</a></li>";	}
> 			else { $html .= "\n<li class='disabled'>Edit this Page</li>"; }
> 							
> 			if ($action eq 'history'){ $html .= "\n<li class='disabled'>Version History</li>"; }
> 			else { $html .= "\n<li><a href='?action=history&id=$id'>Version History</a></li>"; }
> 		}
> 		else {
> 			$html .= "\n<li class='disabled'>Edit this Page</li>"; 
> 			$html .= "\n<li class='disabled'>Version History</li>"; 
> 		}
> 	}
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'SandBox', 'SandBox', "");
> 	
> 	$html .= "\n	</ul></div>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'editprefs', 'Preferences', "1");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiContacts', 'Contact Us', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiHelp', 'Help', "");
> 		
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>";
> 	$html .= "\n	<div class='wikileftnavsearch' style='text-align:right;'>";
> 	$html .= "\n		<form>";
> 	$html .= "\n			<div class='wikisearchlabel' style='text-align:left;'><b>Search</b></div>";
> 	$html .= "\n			<input type='text' title='Enter ! before search term for exclusion' name='search' id='searchterm' />";
> 	$html .= "\n			<input type='submit' value='Go!' name='dosearch' title='Click to perform your search request.' />";
> 	$html .= "\n		</form></div>";
> 	$html .= "\n</div>";
> 	
> 	return $html;	
> }
> 
> sub GetFooterText {
> 	my ( $id, $rev ) = @_;
> 	my $result;
> 	
> 	if ( &GetParam( 'embed', $EmbedWiki ) ) { return ""; }
> 	
> 	$result = "<div class='wikifooter'>";
> 	$result .= &GetGotoBar($id);
> 	$result .= "<div class='wikirevision'>";
> 	
> 	if ($id ne ""){
> 		if ( &UserCanEdit( $id, 0 )) {
> 			if ( $rev ne "" ) {
> 				$result .=
> 				  &GetOldPageLink( 'edit', $id, $rev, Ts( 'Edit revision %s of this page', $rev ) );
> 			}
> 			else {
> 				$result .= &GetEditLink( $id, "Edit text of this page" );
> 			}
> 		}
> 		else {
> 			$result .= "This page is read-only";
> 		}
> 	}
> 	
> 	if ($id ne ""){ $result .= " | " . &GetHistoryLink( $id, "View other revisions", "Click to view revision history" ); }	
> 	if ( $rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
> 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?$id' class='wikiusemetalink'>Search MetaWiki</a>"; }
> 	
> 	$result .= "</div>";
> 	
> 	if ($id ne ""){ 
> 		if ( $Section{'revision'} > 0 ) {
> 			$result .= "<div class='wikirevision'>";		
> 			$result .= "Created " . &TimeToText($Page{'tscreate'});
> 			
> 			if ($Page{'authorcreate'}) { $result .= " by " . $Page{'authorcreate'}; } 
> 			
> 			$result .= " | ";	
> 			if ( $rev eq "" ) { $result .= "Last edited"; }
> 			else { $result .= "Edited"; }
> 			
> 			$result .= " " . &TimeToText( $Section{ts} );
> 				
> 			if ($AuthorFooter) { $result .= " by " . &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}); }
> 		}
> 		
> 		if ($UseDiff) { $result .= " " . &ScriptLinkDiff( 4, $id, "(diff)", $rev ); }
> 	}
> 	
> 	$result .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$result .= &GetSearchForm();	
> 	if ( $DataDir =~ m|/tmp/| ) {
> 		$result .= "\n<br><b>";
> 		$result .= "Warning";
> 		$result .= ":</b> ";
> 		$result .= "Database is stored in temporary directory $DataDir";
> 		$result .= "\n<br>";
> 	}
> 	
> 	if ( $ConfigError ne "" ) {
> 		$result .= "\n<br>";
> 		$result .= "\n<b>Config file error:</b>";
> 		$result .= "$ConfigError <br>";
> 	}
> 	
> 	$result .= "</form>";
> 	$result .= &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { $result .= &GetAdminBar($id, ""); }
> 	$result .= "</div>";
> 		
> 	return $result;
> }
> 
> sub getFooterNote {
> 	my $html;
> 	my $userid = &GetParam("username", "");
> 	my $access = "Guest ";
> 	my $username = "Anonymous";
> 
> 	if (UserIsAdmin()){
> 		$access = "Admin ";
> 	}
> 	elsif (UserIsEditor()){
> 		$access = "Editor ";
> 	}
> 	
> 	if ($userid ne ""){
> 		$username = $userid;
> 	}
> 	
> 	if ($FooterNote ne ""){
> 		$html = $FooterNote;
> 		$html =~ s/access/$access/;
> 		$html =~ s/username/$userid/;
> 	}
> 	
> 	return $html;
> }
> 
> sub GetCommonFooter {
> 	my ($html);
> 	my $id = &GetParam( "id",     "" );
> 	
> 	$html = $WikiLineFooter;
> 	$html .= "\n<div class='wikifooter'>";
> 	$html .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$html .= &GetGotoBar("");
> 	$html .= &GetSearchForm();
> 	$html .= "</form>";	
> 	$html .= &getFooterNote();
> 	
> 	if ( $AdminBar && &UserIsAdmin() ) { $html .= &GetAdminBar($id, "class='wikirevision'"); }
> 	$html .= "\n<div>"; ## ??NEEDED ??
> 	
> 	return $html;
> }
> 
> sub GetGotoBar {
> 	my ($id) = @_;
> 	my ( $main, $bartext );
> 	
> 	$bartext = "\n<div class='wikigotobar'>";
> 	$bartext .= &GetPageLink($HomePage);
> 	
> 	if ( $id =~ m|/| ) {
> 		$main = $id;
> 		$main =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		unless ($main eq $HomePage){
> 			$bartext .= " | " . &GetPageLink($main);
> 		}
> 	}
> 	
> 	$bartext .= " | " . &GetPageLink($RCName);
> 	$bartext .= " | " . &GetPrefsLink();
> 	
> 	if ( $UseUpload && &UserCanUpload() ) { $bartext .= " | " . &GetUploadLink(); }
> 	
> 	$bartext .= " | " . &ScriptLink( "action=listfiles&filter=sample", "List Assets" );
> 	
> 	if ( &GetParam( "linkrandom", 0 ) ) { $bartext .= " | " . &GetRandomLink(); }
> 	if ( $UserGotoBar ne "" ) { $bartext .= " | " . $UserGotoBar; }
> 	
> 	$bartext .= "</div>";
> 	
> 	return $bartext;
> }
> 
> sub GetSearchForm {
> 	my ($html);
> 	
> 	$html =  "\n<div class='wikisearch'>";
> 	$html .= "\n<div class='wikisearchlabel'>Search:</div>";
> 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";
> 		
> 	if ($SearchButton) { $html .= " " . $q->submit( 'dosearch', "Go!" ); }
> 	else { $html .= &GetHiddenValue( "dosearch", 1 ); }
> 	
> 	$html .= "</div>";
> 	
> 	return $html;
> }
> 
> sub GetRedirectPage {
> 	my ( $newid, $name, $isEdit ) = @_;
> 	my ( $url, $html );
> 	my ($nameLink);
> 
> 	# Normally get URL from script, but allow override.
> 	$FullUrl  = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$url      = $FullUrl . &ScriptLinkChar() . $newid;
> 	$nameLink = "<a href='$url' class='wikiredirect'>$name</a>";
> 	
> 	if ( $RedirType < 3 ) {
> 		if ( $RedirType == 1 ) {    # Use CGI.pm
> 			 # NOTE: do NOT use -method (does not work with old CGI.pm versions)
> 			 # Thanks to Daniel Neri for fixing this problem.
> 			$html = $q->redirect( -uri => $url );
> 		}
> 		else {    # Minimal header
> 			$html = "Status: 302 Moved\n";
> 			$html .= "Location: $url\n";
> 			$html .= "Content-Type: text/html\n";   # Needed for browser failure
> 		}
> 		$html .= " Your browser should go to the $newid page.";
> 		$html .= " If it does not, click $nameLink to continue.";
> 	}
> 	else {
> 		if ($isEdit) {
> 			$html  = &GetHeader( "", "Thanks for editing...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
>  			$html .= "Thank you for editing $nameLink ";
> 		}
> 		else {
> 			$html = &GetHeader( "", "Link to another page...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
> 		}
> 		
> 		$html .= "Follow the $nameLink link to continue.";
> 		$html .= "</div>";
> 		$html .= "</div></div></body></html>";	
> 	}
> 	
> 	return $html;
> }
> 
> # ==== Common wiki markup ====
> sub RestoreSavedText {
> 	my ($text) = @_;
> 	
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
> }
> 
> sub RemoveFS {
> 	my ($text) = @_;
> 
> 	# Note: must remove all $FS, and $FS may be multi-byte/char separator
> 	$text =~ s/($FS)+(\d)/$2/g;
> 	
> 	return $text;
> }
> 
> sub WikiToHTML {
> 	my ($pageText) = @_;
> 	$TableMode       = 0;
> 	%SaveUrl         = ();
> 	%SaveNumUrl      = ();
> 	$SaveUrlIndex    = 0;
> 	$SaveNumUrlIndex = 0;
> 	$pageText        = &RemoveFS($pageText);
> 	
> 	if ($RawHtml) { $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige; }
> 	
> 	$pageText = &QuoteHtml($pageText);
> 	$pageText =~ s/\\ *\r?\n/ /g;    # Join lines with backslash at end
> 		
> 	if ($ParseParas) {
> 
> 		# Note: The following 3 rules may span paragraphs, so they are
> 		#       copied from CommonMarkup
> 		$pageText =~ s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 		$pageText =~ s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		$pageText =~ s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		$pageText =~ s/\{{template:(\w+\s*.*?)}}/&StoreTemplate($1)/iges;
> 		$pageText =~ s/\{{flash:\s*(.*?)}}/&StoreRaw(&GetFlash($1))/iges;
> 		$pageText =~ s/\{{gallery:\s*(.*?)}}/&StoreRaw(&GetGallery($1))/iges;
> 		
> 		$pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
> 		$pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
> 		
> 	}
> 	else {
> 		$pageText = &WikiLinesToHtml($pageText);         # Line-oriented markup
> 		$pageText = &CommonMarkup( $pageText, 1, 0 );    # Multi-line markup
> 	}
> 	
> 	while (@HeadingNumbers) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$pageText =~ s/&lt;toc&gt;/<div class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/&lt;toc ((\d)+)?&gt;/<div style='width: $1;' class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/\#SUBPAGES\s+(\w+.*?)/&StoreRaw("\n<h6>" . Ts('Subpages of: %s', &QuoteHtml($1)) . "<\/h6>" . &GetPageList(&GetSubpages($1)))/ige;
> 	$pageText =~ s/\#SUBPAGES/&StoreRaw("\n<h6>" . Ts('Subpages for %s', $MainPage) . "<\/h6>" . &GetPageList(&GetSubpages($MainPage)))/ige;
> 	
> 	if ( $LateRules ne "" ) { $pageText = &EvalLocalRules( $LateRules, $pageText, 0 ); }
> 	
> 	return &RestoreSavedText($pageText);
> }
> 
> sub CommonMarkup {
> 	my ( $text, $useImage, $doLines ) = @_;
> 	local $_ = $text;
> 	
> 	if ( $doLines < 2 ) {    # 2 = do line-oriented only
> 		
> 		while ( m!\#INCLUDE\s*((\w+\.?\w*|/)+)!gi and $AllowInclusion ) {		
> 			my $FileName = $1;
> 			
> 			open FILE, "$InclusionDir/$FileName"
> 			or &ReportError("Cannot open $FileName: $!");
> 			
> 			local $/;			
> 			my $FileContent = <FILE>;
> 			
> 			close FILE
> 			or &ReportError("Cannot close $FileName: $!");
> 			s!\#INCLUDE\s*$FileName!$FileContent!i unless $FileName !~ /(html?|txt)$/i;
> 		}
>   
> 		# The <nowiki> tag stores text with no markup (except quoting HTML)
> 		s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 
> 		# The <pre> tag wraps the stored text with the HTML <pre> tag
> 		s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		
> 		if ( $EarlyRules ne "" ) {
> 			$_ = &EvalLocalRules( $EarlyRules, $_, !$useImage );
> 		}
> 		
> 		s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
> 		
> 		if ($HtmlTags) {
> 			my ($t);
> 			foreach $t (@HtmlPairs) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
> 			}
> 			foreach $t (@HtmlSingle) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
> 			}
> 		}
> 		else {
> 
> 			# Note that these tags are restricted to a single line
> 			s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
> 			s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
> 			s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
> 			s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
> 		}
> 
> 		# Auto signature if use ~~~~ ; useful for quick comments
> 	    my $id = &GetParam("username", "");
> 		my $idLink = "$HomePagePrefix/$id";
> 		my $timestamp = &TimeToText($Now);
> 		my $finalText = "";
> 		
> 		$id =~ s/ /_/g;
> 
> 		if ($id){
> 			$finalText = &StorePageOrEditLink($idLink, $id);
> 			s/\~\~\~\~/<i>\[$finalText]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$finalText at $timestamp]<\/i>/gi;
> 		}
> 		else {
> 			$id = "Guest";			
> 			s/\~\~\~\~/<i>\[$id at $timestamp]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$id at $timestamp]<\/i>/gi;
> 		}
> 		
> 		s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;    # <tt> (MeatBall)
> 		s/\&lt;br\&gt;/<br>/gi;    # Allow simple line break anywhere
> 		
> 		if ($HtmlLinks) {
> 			s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
> 		}
> 		
> 		if ($FreeLinks) {
> 
> 			# Consider: should local free-link descriptions be conditional?
> 			# Also, consider that one could write [[Bad Page|Good Page]]?
> 			s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
> 			s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
> 		}
> 		
> 		if ($BracketText) {        
> 			# Links like [URL text of link]
> 			s/\[$UrlPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketUrl($1, $2, $useImage, $3)/geos;
> 			s/\[$InterLinkPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketInterPage($1, $2, $useImage, $3)/geos;
> 			
> 			if ( $WikiLinks && $BracketWiki ) {    # Local bracket-links
> 				s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
> 				s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1, $2, $3)/geos if $NamedAnchors;
> 			}
> 		}
> 		
> 		s/\[$UrlPattern(\|(.*))?\]/&StoreBracketUrl($1, "", 0, "")/geo;
> 		s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0, "")/geo;
> 		s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
> 		s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
> 		
> 		if ($WikiLinks) {
> 			s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1, $2, ""))/geo if $NamedAnchors;
> 
> 			# CAA: Putting \b in front of $LinkPattern breaks /SubPage links
> 			#      (subpage links without the main page)
> 			s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
> 		}
> 		s/\b$RFCPattern/&StoreRFC($1)/geo;
> 		s/\b$ISBNPattern/&StoreISBN($1)/geo;
> 		
> 		if ($UseUpload) {
> 			s/$UploadPattern/&StoreUpload($1)/geo;
> 		}
> 		
> 		if ($ThinLine) {
> 			if ($OldThinLine) {   
> 				# Backwards compatible, conflicts with headers
> 				s/====+/$WikiLine2/g;
> 			}
> 			else {                
> 				# New behavior--no conflict
> 				s/------+/$WikiLine2/g;
> 			}
> 			s/----+/$WikiLine1/g;
> 		}
> 		else {
> 			s/----+/$WikiLine/g;
> 		}
> 		
> 		if ($AutoMailto) {
> 			s/([A-z0-9-_]+(?:\.[A-z0-9-_]+)*)\@([A-z0-9-_]+(?:\.[A-z0-9-_]+)*(?:\.[A-z]{2,})+)/<a href="mailto:$1\@$2">$1\@$2<\/a>/g;
> 		}
> 	}
> 	
> 	if ($doLines) {    
> 		# 0 = no line-oriented, 1 or 2 = do line-oriented
> 	    # The quote markup patterns avoid overlapping tags (with 5 quotes)
> 	    # by matching the inner quotes for the strong pattern.
> 		s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g; #'REMARK
> 		s/''(.*?)''/<em>$1<\/em>/g;
> 		
> 		if ($UseHeadings) {
> 			s/(^|\n)\s*(\=+)\s*(#)?\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $4, $3)/geo;
> 		}
> 		
> 		if ($TableMode == 1) {
> 			my @cells = split(/\|\|/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\|\|)+([^\|<]+)/) {	
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\|\|)+)/"<\/td><td $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;
> 			} 
> 			s/(\|\w*=\w*)+([^\|<]+)//g;   
> 		}
> 		elsif  ($TableMode == 2) {
> 			my @cells = split(/\!\!/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\!\!)+([^\!<]+)/) {			
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\!\!)+)/"<\/th><th $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;				
> 			}
> 			s/(\|\w*=\w*)+([^\!<]+)//g;
> 		}
> 	}
> 	
> 	return $_;
> }
> 
> sub GetTableCellModifiers {
> 	my ($given, $initialCell, $cellIndex) = @_;	
> 	my ($options) = $given;
> 
> 	/^(\s*(\w+)\s*)\|/;
> 	my $align = $2;
> 	if ($initialCell ne ""){ $align = $initialCell; }
> 		
> 	$align = $align =~ /^  / ? ($align =~ /  $/ ? 'center' : 'right') : 'left';
> 	$align = "align='$align'";
> 	
> 	my ($options) = $options =~ /(\|\S*=\S*)+/g;
> 	my %options = &GetOptions($options);
> 
> 	my $class;
> 	my $style;
> 	my $width;	
> 	my $rowclass;
> 	my $rowstyle;
> 	my $rowalign;
> 	my $tablewidth;
> 	my $tableclass;
> 	my $tablestyle;
> 		
> 	if ($TableCellDefaults{"rowclass"} =~ /clear/){ $TableCellDefaults{"rowclass"} = ""; }
> 	if ($TableCellDefaults{"rowstyle"} =~ /clear/){ $TableCellDefaults{"rowstyle"} = ""; }
> 	if ($TableCellDefaults{"rowalign"} =~ /clear/){ $TableCellDefaults{"rowalign"} = ""; }
> 				
> 	if ($TableCellDefaults{"rowclass"}){ $rowclass = $TableCellDefaults{"rowclass"}; }
> 	if ($TableCellDefaults{"rowstyle"}){ $rowstyle = $TableCellDefaults{"rowstyle"}; }
> 	if ($TableCellDefaults{"rowalign"}){ $rowalign = $TableCellDefaults{"rowalign"}; }
> 		
> 	if ($options{'rowclass'}){ $rowclass = "class='" . $options{'rowclass'} . "'"; $TableCellDefaults{"rowclass"} = $rowclass; }
> 	if ($options{'rowstyle'}){ $rowstyle = "style='" . $options{'rowstyle'} . "'"; $TableCellDefaults{"rowstyle"} = $rowstyle; }
> 	if ($options{'rowalign'}){ $rowalign = "align='" . $options{'rowalign'} . "'"; $TableCellDefaults{"rowalign"} = $rowalign; }
> 	
> 	if ($rowclass){ $class = $rowclass; }
> 	if ($rowstyle){ $style = $rowstyle; }
> 	if ($rowalign){ $align = $rowalign; }
> 
> 	if ($TableCellDefaults{"class$cellIndex"} =~ /clear/){ $TableCellDefaults{"class$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"style$cellIndex"} =~ /clear/){ $TableCellDefaults{"style$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"align$cellIndex"} =~ /clear/){ $TableCellDefaults{"align$cellIndex"} = ""; }
> 			
> 	if ($TableCellDefaults{"class$cellIndex"}){ $class = $TableCellDefaults{"class$cellIndex"}; }
> 	if ($TableCellDefaults{"style$cellIndex"}){ $style = $TableCellDefaults{"style$cellIndex"}; }
> 	if ($TableCellDefaults{"align$cellIndex"}){ $align = $TableCellDefaults{"align$cellIndex"}; }
> 
> 	if ($options{'class'}){ $class = "class='" . $options{'class'} . "'"; $TableCellDefaults{"class$cellIndex"} = $class; }
> 	if ($options{'style'}){ $style = "style='" . $options{'style'} . "'"; $TableCellDefaults{"style$cellIndex"} = $style; }
> 	if ($options{'align'}){ $align = "align='" . $options{'align'} . "'"; $TableCellDefaults{"align$cellIndex"} = $align; }
> 	if ($options{'width'}){ $width = "width='" . $options{'width'} . "'"; }
> 	if ($options{'tablewidth'}){ $tablewidth = "width='" . $options{'tablewidth'} . "'"; }
> 	if ($options{'tablestyle'}){ $tablestyle = "style='" . $options{'tablestyle'} . "'"; }
> 	if ($options{'tableclass'}){ $tableclass = "class='" . $options{'tableclass'} . "'"; } else { $tableclass = "class='wikilargelist'"; }
> 					
> 	return ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass);				
> }
> 
> sub WikiLinesToHtml {
> 	my ($pageText) = @_;
> 	my ( $pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode );
> 	
> 	@htmlStack = ();
> 	$depth     = 0;
> 	$pageHtml  = "";
> 	
> 	foreach ( split( /\r?\n/, $pageText ) ) {    # Process lines one-at-a-time
> 		$code           = "";
> 		$codeAttributes = "";
> 		$TableMode      = 0;
> 		$_ .= "\n";
> 		
> 		if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\:+)/<dt><dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\*+)/<li>/) {
> 			$code  = "ul";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\#+)/<li>/) {
> 			$code  = "ol";
> 			$depth = length $1;
> 		}
> 		elsif ($TableSyntax && /^(\!\!)+.*\!\!\s*$/) {
> 			/^(\!\!)+([^\!]+)/;
> 			
> 			%TableCellDefaults = {};
> 			
> 			my $switches = $2;
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, "", 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/th><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 2;
> 			$depth = 1;
> 		}
> 		elsif ($TableSyntax && /^(\|\|)+.*\|\|\s*$/) {
> 			/^((\|\|)+)(.*?)\|\|/;	
> 	
> 			my ($alignInitial) = $3;
> 			my $switches = $3;
> 			($alignInitial) = $alignInitial =~ /(.*)\|/;	
> 
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, $alignInitial, 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/td><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 1;
> 			$depth = 1;
> 		}
> 		elsif (/^[ \t].*\S/) {
> 			$code  = "pre";
> 			$depth = 1;
> 		}
> 		else {
> 			$depth = 0;
> 		}
> 		
> 		while ( @htmlStack > $depth ) {    
> 			# Close tags as needed
> 			$pageHtml .= "</" . pop(@htmlStack) . ">";
> 		}
> 		
> 		if ( $depth > 0 ) {
> 			$depth = $IndentLimit if ( $depth > $IndentLimit );
> 			if (@htmlStack) {              
> 				# Non-empty stack
> 				$oldCode = pop(@htmlStack);
> 				
> 				if ( $oldCode ne $code ) {
> 					$pageHtml .= "</$oldCode><$code>";
> 				}
> 				push( @htmlStack, $code );
> 			}
> 			
> 			while ( @htmlStack < $depth ) {
> 				push( @htmlStack, $code );
> 				$pageHtml .= "\n<$code $codeAttributes>";
> 			}
> 		}
> 		
> 		if ( !$ParseParas ) {
> 			s/^\s*$/<p>\n/;    # Blank lines become <p> tags
> 		}
> 		$pageHtml .= &CommonMarkup( $_, 1, 2 );    # Line-oriented common markup
> 	}
> 	
> 	while ( @htmlStack > 0 ) {                     
> 		# Clear stack
> 		$pageHtml .= "</" . pop(@htmlStack) . ">";
> 	}
> 	
> 	return $pageHtml;
> }
> 
> sub EvalLocalRules {
> 	my ( $rules, $origText, $isDiff ) = @_;
> 	my ( $text, $reportError, $errorText );
> 	
> 	$text        = $origText;
> 	$reportError = 1;
> 
> 	# Basic idea: the $rules should change $text, possibly with different
> 	# behavior if $isDiff is true (no images or color changes?)
> 	# Note: for fun, the $rules could also change $reportError and $origText
> 	if ( !eval $rules ) {
> 		$errorText = $@;
> 		
> 		if ( $errorText eq "" ) {
> 
> 		  # Search for "Unknown Error" for the reason the next line is commented
> 		  #     $errorText = "Unknown Error (no error text)";
> 		}
> 		if ( $errorText ne "" ) {
> 			$text = $origText;    # Consider: should partial results be kept?
> 			
> 			if ($reportError) {
> 				$text .= "\n<hr>";
> 				$text .= "<b>";
> 				$text .= "Local rule error:";
> 				$text .= "</b><br>";
> 				$text .= &QuoteHtml($errorText);
> 			}
> 		}
> 	}
> 	
> 	return $text;
> }
> 
> sub QuoteHtml {
> 	my ($html) = @_;
> 	
> 	$html =~ s/&/&amp;/g;
> 	$html =~ s/</&lt;/g;
> 	$html =~ s/>/&gt;/g;
> 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
> 	
> 	return $html;
> }
> 
> sub ParseParagraph {
> 	my ($text) = @_;
> 	
> 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
> 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
> 	
> 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
> 	
> 	return "\n<p>$text</p>";
> }
> 
> sub StoreInterPage {
> 	my ( $id, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &InterPageLink( $id, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
> }
> 
> sub InterPageLink {
> 	my ( $id, $useImage ) = @_;
> 	my ( $name, $site, $remotePage, $url, $punct );
> 	
> 	( $id, $punct ) = &SplitUrlPunct($id);
> 	$name = $id;
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$url = &GetSiteUrl($site);
> 	
> 	return ( "", $id . $punct ) if ( $url eq "" );
> 	
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url .= $remotePage;
> 	
> 	return ( &UrlLinkOrImage( $url, $name, $useImage ), $punct );
> }
> 
> sub StoreBracketInterPage {
> 	my ( $id, $text, $useImage, $options ) = @_;
> 	my ( $site, $remotePage, $url, $index );
> 	
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url = &GetSiteUrl($site);
> 	
> 	if ( $text ne "" ) {
> 		return "[$id $text]" if ( $url eq "" );
> 	}
> 	else {
> 		return "[$id]" if ( $url eq "" );
> 		$text = &GetBracketUrlIndex($id);
> 	}
> 	
> 	$url .= $remotePage;
> 	
> 	$text = StoreBracketUrl( $url, $text, $useImage, $options);
> 	
> 	return $text;
> }
> 
> sub GetBracketUrlIndex {
> 	my ($id) = @_;
> 	my ( $index, $key );
> 
> 	# Consider plain array?
> 	if ( $SaveNumUrl{$id} > 0 ) { return $SaveNumUrl{$id}; }
> 	
> 	$SaveNumUrlIndex++;    # Start with 1
> 	$SaveNumUrl{$id} = $SaveNumUrlIndex;
> 	
> 	return $SaveNumUrlIndex;
> }
> 
> sub GetSiteUrl {
> 	my ($site) = @_;
> 	my ( $data, $status );
> 	
> 	if ( !$InterSiteInit ) {
> 		( $status, $data ) = &ReadFile($InterFile);
> 		
> 		if ($status) {
> 			%InterSite = split( /\s+/, $data );    # Consider defensive code
> 		}
> 
> 		# Check for definitions to allow file to override automatic settings
> 		if ( !defined( $InterSite{'LocalWiki'} ) ) {
> 			$InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		if ( !defined( $InterSite{'Local'} ) ) {
> 			$InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		$InterSiteInit = 1;                        # Init only once per request
> 	}
> 	
> 	return $InterSite{$site} if ( defined( $InterSite{$site} ) );
> 	return "";
> }
> 
> sub StoreRaw {
> 	my ($html) = @_;
> 	
> 	$SaveUrl{$SaveUrlIndex} = $html;
> 	
> 	return $FS . $SaveUrlIndex++ . $FS;
> }
> 
> sub StorePre {
> 	my ( $html, $tag ) = @_;
> 	
> 	return &StoreRaw( "<$tag>" . $html . "</$tag>" );
> }
> 
> sub ReadWikiFile {
> 	my ($fileName) = @_;
> 	my ($fileData, %tempPage, %tempSection, %tempText);
> 	
> 	return unless -f $fileName;
> 	
> 	$fileData = &ReadFileOrDie($fileName);
> 	%tempPage = split(/$FS1/, $fileData, -1);
> 	%tempSection = split(/$FS2/, $tempPage{'text_default'}, -1);
> 	%tempText = split(/$FS3/, $tempSection{'data'}, -1);
> 	
> 	return $tempText{'text'};
> }
> 
> sub WikiFileToHTML {
> 	my ($text) = @_;
> 	my ($output);
> 	my ($mySaveUrlIndex, $mySaveNumUrlIndex, $myTableMode, %mySaveUrl, %mySaveNumUrl);
> 	
> 	return unless $text;
> 	
> 	# Global variables do not help this code. Nasty, but easiest solution.
> 	%mySaveUrl= %SaveUrl;
> 	%mySaveNumUrl= %SaveNumUrl;
> 	$mySaveUrlIndex= $SaveUrlIndex;
> 	$mySaveNumUrlIndex = $SaveNumUrlIndex;
> 	$myTableMode= $TableMode;
> 	
> 	$output = &WikiToHTML($text);
> 	
> 	%SaveUrl = %mySaveUrl;
> 	%SaveNumUrl = %mySaveNumUrl;
> 	$SaveUrlIndex = $mySaveUrlIndex;
> 	$SaveNumUrlIndex = $mySaveNumUrlIndex;
> 	$TableMode = $myTableMode;
> 	
> 	return $output;
> }
> 
> sub StoreTemplate {
> 	my ($params) = @_;
> 	my ($templateId, $templateFile, $templateText, $output, %substitutes);
> 	
> 	$params =~ s/^\s*(\S+)\s*/$templateId=$1,''/e;
> 	return &StoreRaw('No template name') unless $templateId;
> 	
> 	$templateFile = &GetPageFile($templateId);
> 	return &StoreRaw(Ts('Template %s not found', $templateId)) unless -f $templateFile;
> 	
> 	while ($params =~ /^(\S+)\s*=(.*)$/gm) {
> 		$substitutes{$1} = $2;
> 	}
> 	
> 	$templateText = &ReadWikiFile($templateFile);
> 	$templateText =~ s/\$(\S+)\$/$substitutes{$1}/gi;
> 	$templateText =~ s/{{//g; # Avoid nesting.
> 	$output = &WikiFileToHTML($templateText);
> 	
> 	return &StoreRaw($output);
> }
> 
> sub StoreHref {
> 	my ( $anchor, $text ) = @_;
> 	
> 	return "<a" . &StoreRaw($anchor) . ">$text</a>";
> }
> 
> sub StoreUrl {
> 	my ( $name, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &UrlLink( $name, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
> }
> 
> sub UrlLink {
> 	my ( $rawname, $useImage ) = @_;
> 	my ( $name, $punct );
> 	
> 	( $name, $punct ) = &SplitUrlPunct($rawname);
> 	
> 	if ( $LimitFileUrl && ( $NetworkFile && $name =~ m|^file:| ) ) {
> 
> 		# Only do remote file:// links. No file:///c|/windows.
> 		if ( $name =~ m|^file://[^/]| ) {
> 			return ( "<a href='$name' class='wikiurllink'>$name</a>", $punct );
> 		}
> 		
> 		return ( $rawname, "" );
> 	}
> 	
> 	return ( &UrlLinkOrImage( $name, $name, $useImage ), $punct );
> }
> 
> sub UrlLinkOrImage {
> 	my ( $url, $name, $useImage ) = @_;
> 	
> 	# Restricted image URLs so that mailto:foo@bar.gif is not an image
> 	if ( $useImage && &ImageAllowed($url) ) {
> 		return "<a href='$url' class='wikiurlorimage' target='_blank'><img class='wikiurlorimage' src='$url'></a>";
> 	}
> 	
> 	return "<a href='$url' class='wikiurlorimage'>$name</a>";
> }
> 
> sub ImageAllowed {
> 	my ($url) = @_;
> 	my ( $site, $imagePrefixes );
> 	
> 	$imagePrefixes = 'http:|https:|ftp:|upload:';
> 	$imagePrefixes .= '|file:' if ( !$LimitFileUrl );
> 	
> 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
> 	return 0 if ( $url =~ /"/ );    #" No HTML-breaking quotes allowed
> 	return 1 if ( @ImageSites < 1 );    # Most common case: () means all allowed
> 	return 0 if ( $ImageSites[0] eq 'none' );    # Special case: none allowed
> 
> 	foreach $site (@ImageSites) {
> 		return 1
> 		  if ( $site eq substr( $url, 0, length($site) ) );    # Match prefix
> 	}
> 	
> 	return 0;
> }
> 
> sub ExtensionAllowed {
> 	my ($file) = @_;
> 	
> 	return 1 if ( $file =~ m/\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
> 	
> 	return 0;	
> }
> 
> sub GetUploadUrl {
> 	my ($url) = @_;
> 	
> 	&StoreRaw($url);
> }
> 
> sub GetOptions {
> 	my ($text) = @_;
> 	my %options;
> 	
> 	foreach my $pair (split(/\|/, $text)){
> 		my @keyvalues = split (/=/, $pair);
> 		$options{$keyvalues[0]} = $keyvalues[1];
> 	}
> 	
> 	return %options;	
> }
> 
> sub ComputeImageRatio {
> 	my ($imageName, $desiredWidth, $desiredHeight, $okayLarger) = @_;
> 	my $filepath = "$UploadDir/$imageName";
> 	my ($imageWidth, $imageHeight) = Image::Size::imgsize($filepath);
> 	
> 	my $ratioWidth = 1;
> 	my $ratioHeight = 1;
> 	my $ratioFinal = 1;
> 	
> 	if ($desiredWidth){ $ratioWidth = $desiredWidth/$imageWidth; }
> 	if ($desiredHeight){ $ratioHeight = $desiredHeight/$imageHeight; }
> 	
> 	if ($okayLarger){
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioWidth; }
> 		else { $ratioFinal = $ratioHeight; }
> 	}
> 	else {
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioHeight; }
> 		else { $ratioFinal = $ratioWidth; }
> 	
> 	}
> 	
> 	my $finalWidth = int($ratioFinal * $imageWidth);
> 	my $finalHeight = int($ratioFinal * $imageHeight);
> 	
> 	return ($finalWidth, $finalHeight);
> }
> 
> sub StoreBracketUrl {
> 	my ( $url, $text, $useImage, $options ) = @_;
> 	my %options = &GetOptions($options);
> 	my $imageFloat;
> 	my $imageClear = "\n<br class='clear$options{clear}'/>";
> 	my $boxFloat = " float" . $options{'boxfloat'};
> 	my $boxClear = "\n<br class='clear$options{boxclear}'/>";
> 	my $width;
> 	my $height;
> 	my $title;
> 	my $caption;
> 	my $description;
> 	my $imageLink;
> 	my $boxWidth = "style='width: 300px !important;'";
> 
> 	if ( $text eq "" ) { $text = &GetBracketUrlIndex($url); }
> 
> 	if ($options{'float'}){ $imageFloat = "float" . $options{'float'}; }
> 	if ($options{'clear'}){ $imageClear = "\n<br class='clear$options{clear}'/>"; }
> 	if ($options{'title'}){ $title = $options{title}; } else { $title = $text; }
> 	if ($options{'width'}){ $width = $options{'width'}; }
> 	if ($options{'height'}){ $height = $options{'height'}; }
> 			
> 	if ($options{'boxfloat'}){ $boxFloat = "float" . $options{'boxfloat'}; }
> 	if ($options{'boxclear'}){ $boxClear = "\n<br class='clear$options{boxclear}'/>"; }
> 	if ($options{'boxwidth'}){ $boxWidth = "style='width: $options{boxwidth} !important;'"; }
> 	if ($options{'caption'}){ 
> 		if ($options{'description'}){ $description = $options{description}; } 
> 		else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 		
> 		$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div><div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 	}
> 	
> 	if ($url =~ /$UploadPattern/){ $url = "$UploadUrl/$1"; }	
> 	if ( $BracketImg && $useImage && &ImageAllowed($text) ) {		
> 		if ($text =~ /$UploadPattern/){
> 			my $imageName = $1;
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($imageName, $width, $height, "");
> 			my $imageStyle = "style='width: $imageWidth; height: $imageHeight;'";
> 			
> 			$imageLink = "$UploadUrl/" . &GetUploadUrl($1);			
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' $imageStyle src='$imageLink'></a>";
> 		}
> 		else {
> 			$imageLink = $text;
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' src='$imageLink'></a>";
> 		}
> 		my $expandlink =  "<a target='_blank' class='wikiexpandimageicon' href='$imageLink' title='View source image'>&nbsp;</a>";
> 		
> 		if ($options{'caption'}){ 
> 			if ($options{'description'}){ $description = $options{description}; } 
> 			else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 			
> 			$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div>$expandlink<div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 		}
> 			
> 		if ($imageClear){ $text .= $imageClear; }		
> 					
> 		if ($caption){
> 			$text = "\n<div title='$title' class='wikibracketbox $boxFloat' $boxWidth>$text$caption</div>";		
> 		}
> 		else {
> 			$text = "\n<div title='$title' class='$boxFloat'>$text</div>";	
> 		}
> 		
> 		if ($boxClear){ $text .= $boxClear; }
> 	}
> 	else {
> 		$text = "<a href='$url' title='$title' class='wikibracketurl'>[$text]</a>";
> 	}
> 	
> 	return &StoreRaw($text);
> }
> 
> sub StoreBracketLink {
> 	my ( $name, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( $name, "[$text]" ) );
> }
> 
> sub StoreBracketAnchoredLink {
> 	my ( $name, $anchor, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( "$name#$anchor", "[$text]" ) );
> }
> 
> sub StorePageOrEditLink {
> 	my ( $page, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$page =~ s/^\s+//;        # Trim extra spaces
> 		$page =~ s/\s+$//;
> 		$page =~ s|\s*/\s*|/|;    # ...also before/after subpages
> 	}
> 	$name =~ s/^\s+//;
> 	$name =~ s/\s+$//;
> 	
> 	return &StoreRaw( &GetPageOrEditLink( $page, $name ) );
> }
> 
> sub StoreRFC {
> 	my ($num) = @_;
> 	
> 	return &StoreRaw( &RFCLink($num) );
> }
> 
> sub RFCLink {
> 	my ($num) = @_;
> 	
> 	return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\" class='wikirfclink'>RFC $num</a>";
> }
> 
> sub StoreUpload {
> 	my ($url) = @_;
> 	
> 	return &StoreRaw( &UploadLink($url) );
> }
> 
> sub UploadLink {
> 	my ($filename) = @_;
> 	my ( $html, $url );
> 	
> 	return $filename if ( $UploadUrl eq "" );    # No bad links if misconfigured
> 	
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$url  = $UploadUrl . $filename;
> 	$html = "<a href='$url' class='wikiuploadlink' target='_blank'>";
> 	
> 	if ( &ImageAllowed($url) ) {
> 		$html .= "<img class='wikiuploadlink' src='$url' alt='upload:$filename'>";
> 	}
> 	else {
> 		$html .= "upload:$filename";
> 	}
> 	$html .= "</a>";
> 	
> 	return $html;
> }
> 
> sub StoreISBN {
> 	my ($num) = @_;
> 	
> 	return &StoreRaw( &ISBNLink($num) );
> }
> 
> sub ISBNALink {
> 	my ( $num, $pre, $post, $text ) = @_;
> 	
> 	return "<a href='$pre$num$post' class='wikiisbnalink'>$text</a>";
> }
> 
> sub ISBNLink {
> 	my ($rawnum) = @_;
> 	my ( $rawprint, $html, $num, $numSites, $i );
> 	
> 	$num      = $rawnum;
> 	$rawprint = $rawnum;
> 	$rawprint =~ s/ +$//;
> 	$num      =~ s/[- ]//g;
> 	$numSites = scalar @IsbnNames;    # Number of entries
> 	
> 	if ( ( length($num) != 10 ) || ( $numSites < 1 ) ) {
> 		return "ISBN $rawnum";
> 	}
> 	
> 	$html = &ISBNALink( $num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint );
> 	
> 	if ( $numSites > 1 ) {
> 		$html .= " (";
> 		$i = 1;
> 		while ( $i < $numSites ) {
> 			$html .=
> 			  &ISBNALink( $num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i] );
> 			if ( $i < ( $numSites - 1 ) ) {    # Not the last site
> 				$html .= ", ";
> 			}
> 			$i++;
> 		}
> 		$html .= ")";
> 	}
> 	
> 	$html .= " " if ( $rawnum =~ / $/ );    # Add space if old ISBN had space.
> 	
> 	return $html;
> }
> 
> sub SplitUrlPunct {
> 	my ($url) = @_;
> 	my ($punct);
> 	
> 	if ( $url =~ s/\"\"$// ) {  #"REMARK
> 		return ( $url, "" );    # Delete double-quote delimiters here
> 	}
> 	
> 	$punct = "";
> 	if ($NewFS) {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	else {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	
> 	return ( $url, $punct );
> }
> 
> sub StripUrlPunct {
> 	my ($url) = @_;
> 	my ($junk);
> 	
> 	( $url, $junk ) = &SplitUrlPunct($url);
> 	
> 	return $url;
> }
> 
> sub WikiHeadingNumber {
> 	my ( $depth, $text, $useNumber) = @_;
> 	my ( $anchor, $number );
> 	
> 	return "" unless --$depth > 0;
> 		
> 	while ( scalar @HeadingNumbers < ( $depth - 1 ) ) {
> 		push @HeadingNumbers, 1;
> 		$TableOfContents .= "<dl><dt></dt><dd>";
> 	}
> 	
> 	if ( scalar @HeadingNumbers < $depth ) {
> 		push @HeadingNumbers, 0;
> 		$TableOfContents .= "<dl><dt></dt><dd>";
> 	}
> 	
> 	while ( scalar @HeadingNumbers > $depth ) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$HeadingNumbers[$#HeadingNumbers]++;
> 	$number = ( join '.', @HeadingNumbers ) . '. ';
> 
> 	# Remove embedded links. THIS IS FRAGILE!
> 	$text = &RestoreSavedText($text);
> 	$text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si;        # No such page syntax
> 	$text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
> 
> 	# Cook anchor by canonicalizing $text.
> 	$anchor = $text;
> 	$anchor =~ s/\<.*?\>//g;
> 	$anchor =~ s/\W/_/g;
> 	$anchor =~ s/__+/_/g;
> 	$anchor =~ s/^_//;
> 	$anchor =~ s/_$//;
> 
> 	# Last ditch effort
> 	$anchor = "_" . ( join '_', @HeadingNumbers ) unless $anchor;
> 	$TableOfContents .= ('&nbsp;' x (2 * $depth)) . $number;
> 	$TableOfContents .= &ScriptLink( "$OpenPageName#$anchor", $text );
> 	$TableOfContents .= "</dd><dt>";
> 	$TableOfContents .= "</dt><dd>";
> 	  
> 	## return &StoreHref(" name='$anchor'") . $number;
> 	if ($useNumber) {
> 		return &StoreHref(" name='$anchor'") . $number;
> 	} else {
> 		return &StoreHref(" name='$anchor'");
> 	}
> }
> 
> sub WikiHeading {
> 	## my ( $pre, $depth, $text ) = @_;
> 	my ($pre, $depth, $text, $useNumber) = @_;
> 	
> 	$depth = length($depth);
> 	$depth = 6 if ( $depth > 6 );
> 		
> 	if ($useNumber) {
> 		$text = &WikiHeadingNumber($depth,$text, 1) . $text;
> 	} else {
> 		$text = &WikiHeadingNumber($depth,$text, 0) . $text;
> 	}	
> 	
> 	return $pre . "<H$depth>$text</H$depth>";
> }
> 
> # ==== Difference markup and HTML ====
> sub GetDiffHTML {
> 	my ( $diffType, $id, $revOld, $revNew, $newText ) = @_;
> 	my ( $html, $diffText, $diffTextTwo, $priorName, $links, $usecomma );
> 	my ( $major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName );
> 	
> 	$links     = " (";
> 	$usecomma  = 0;
> 	$major     = &ScriptLinkDiff( 1, $id, "major diff", "" );
> 	$minor     = &ScriptLinkDiff( 2, $id, "minor diff", "" );
> 	$author    = &ScriptLinkDiff( 3, $id, "author diff", "" );
> 	$useMajor  = 1;
> 	$useMinor  = 1;
> 	$useAuthor = 1;
> 	$diffType  = &GetParam( "defaultdiff", 1 ) if ( $diffType == 4 );
> 	
> 	if ( $diffType == 1 ) {
> 		$priorName = "major";
> 		$cacheName = "major";
> 		$useMajor  = 0;
> 	}
> 	elsif ( $diffType == 2 ) {
> 		$priorName = "minor";
> 		$cacheName = "minor";
> 		$useMinor  = 0;
> 	}
> 	elsif ( $diffType == 3 ) {
> 		$priorName = "author";
> 		$cacheName = "author";
> 		$useAuthor = 0;
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 
> 		# Note: OpenKeptRevisions must have been done by caller.
> 		# Eventually optimize if same as cached revision
> 		$diffText = &GetKeptDiff( $newText, $revOld, 1 );    # 1 = get lock
> 		if ( $diffText eq "" ) {
> 			$diffText = "(The revisions are identical or unavailable.)";
> 		}
> 	}
> 	else {
> 		$diffText = &GetCacheDiff($cacheName);
> 	}
> 	
> 	$useMajor = 0 if ( $useMajor && ( $diffText eq &GetCacheDiff("major") ) );
> 	$useMinor = 0 if ( $useMinor && ( $diffText eq &GetCacheDiff("minor") ) );
> 	$useAuthor = 0 if ( $useAuthor && ( $diffText eq &GetCacheDiff("author") ) );
> 	$useMajor = 0 if ( ( !defined( &GetPageCache('oldmajor') ) ) || ( &GetPageCache("oldmajor") < 1 ) );
> 	$useAuthor = 0 if ( ( !defined( &GetPageCache('oldauthor') ) ) || ( &GetPageCache("oldauthor") < 1 ) );
> 	
> 	if ($useMajor) {
> 		$links .= $major;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useMinor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $minor;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useAuthor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $author;
> 	}
> 	
> 	if ( !( $useMajor || $useMinor || $useAuthor ) ) {
> 		$links .= "no other diffs";
> 	}
> 	$links .= ")";
> 	
> 	if ( ( !defined($diffText) ) || ( $diffText eq "" ) ) {
> 		$diffText = "No diff available.";
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 		my $currentRevision = "current revision";
> 		
> 		$currentRevision = "revision $revNew " if $revNew;
> 		$html .= "<h4>Difference (from revision $revOld to $currentRevision)</h4>";
> 		$html .= "$links<br><br>";
> 		$html .= &DiffToHTML($diffText);
> 	}
> 	else {
> 		if (
> 			( $diffType != 2 )
> 			&& (   ( !defined( &GetPageCache("old$cacheName") ) )
> 				|| ( &GetPageCache("old$cacheName") < 1 ) )
> 		  )
> 		{
> 			$html .= "<h4>No diff available -- this is the first $priorName revision.</h4>";
> 			$html .= "$links<br><br>";
> 		}
> 		else {
> 			$html .= "<h4>Difference from prior $priorName revision</h4>";
> 			$html .= "$links<br><br>";
> 			$html .= &DiffToHTML($diffText);
> 		}
> 	}
> 	@HeadingNumbers  = ();
> 	$TableOfContents = "";
> 		
> 	return $html;
> }
> 
> sub GetCacheDiff {
> 	my ($type) = @_;
> 	my ($diffText);
> 	
> 	$diffText = &GetPageCache("diff_default_$type");
> 	$diffText = &GetCacheDiff('minor') if ( $diffText eq "1" );
> 	$diffText = &GetCacheDiff('major') if ( $diffText eq "2" );
> 	
> 	return $diffText;
> }
> 
> # Must be done after minor diff is set and OpenKeptRevisions called
> sub GetKeptDiff {
> 	my ( $newText, $oldRevision, $lock ) = @_;
> 	my ( %sect, %data, $oldText );
> 	
> 	$oldText = "";
> 	if ( defined( $KeptRevisions{$oldRevision} ) ) {
> 		%sect = split( /$FS2/, $KeptRevisions{$oldRevision}, -1 );
> 		%data = split( /$FS3/, $sect{'data'}, -1 );
> 		$oldText = $data{'text'};
> 	}
> 	
> 	return "" if ( $oldText eq "" );    # Old revision not found
> 	return &GetDiff( $oldText, $newText, $lock );
> }
> 
> sub GetDiff {
>   my $textOld = shift;
>   my $textNew = shift;
> 
>   my %format = (
>     paraIdent     => '<tr valign=top><td class="diff-para-ident">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident">%text%</td></tr>',
>     paraAdded     => '<tr valign=top><td class="diff-para-ident"></td><td class="diff-vertical"></td><td class="diff-para-added">%text%</td></tr>',
>     paraDeleted   => '<tr valign=top><td class="diff-para-deleted">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident"></td></tr>',
>     paraChanged   => '<tr valign=top><td class="diff-para-changed-old">%text%</td><td class="diff-vertical"></td><td class="diff-para-changed-new">%text%</td></tr>',
>     paraReplaced  => '<tr valign=top><td class="diff-para-deleted">%textDeleted%</td><td class="diff-vertical"></td><td class="diff-para-added">%textAdded%</td></tr>',
>   
>     changeContext => 1,
>     changeHeader  => '<tr valign=top><td class="diff-header">Paragraph %oldFrom%</td><td class="diff-vertical">&nbsp;</td><td class="diff-header">Paragraph %newFrom%</td></tr>',
>   
>     spanIdent     => '<span class="diff-span-ident">%text%</span>',
>     spanAdded     => '<span class="diff-span-added">%text%</span>',
>     spanDeleted   => '<span class="diff-span-deleted">%text%</span>',
> 
>     processText => sub {
> 
>       my $text = shift;
> 
>       $text =~ s[&]               [&amp;]g;
>       $text =~ s[<]               [&lt;]g;
>       $text =~ s[>]               [&gt;]g;
>       $text =~ s[\n]              [<br>\n]g;
>       $text =~ s[\r]              []g;
>       $text =~ s[([\t ]+)([\t ])] [('&nbsp;' x length($1)) . $2]ge;
>       $text =~ s[^[\t ]]          [&nbsp;];
> 
>       return $text;
>     }
>   );
> 
>   my $diff = Diff::diffText($textOld, $textNew, %format);
>   
>   if ($diff ne "") {
>     $diff =~ s[<td class="diff-para-changed-old">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-added">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>     
>     $diff =~ s[<td class="diff-para-changed-new">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-deleted">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>   
>     $diff = qq[<div id=wikidiffdiv><table id=wikidifftable>$diff</table></div>];
>   }
> 
>   return $diff;
> }
> 
> sub DiffToHTML { shift }
> 
> # ==== Database (Page, Section, Text, Kept, User) functions ====
> sub OpenNewPage {
> 	my ($id) = @_;
> 	
> 	%Page             = ();
> 	$Page{'version'}  = 3;       # Data format version
> 	$Page{'revision'} = 0;       # Number of edited times
> 	$Page{'tscreate'} = $Now;    # Set once at creation
> 	$Page{'ts'}       = $Now;    # Updated every edit
> 	$Page{'authorcreate'} = GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
> }
> 
> sub OpenNewSection {
> 	my ( $name, $data ) = @_;
> 	
> 	%Section             = ();
> 	$Section{'name'}     = $name;
> 	$Section{'version'}  = 1;                   # Data format version
> 	$Section{'revision'} = 0;                   # Number of edited times
> 	$Section{'tscreate'} = $Now;                # Set once at creation
> 	$Section{'ts'}       = $Now;                # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'host'} 	 = "";        # Updated only for real edits (can be slow)
> 	$Section{'id'}   	 = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} 		 = join( $FS2, %Section );    # Replace with save?
> 	$Page{'authorcreate'}= GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
> }
> 
> sub OpenNewText {
> 	my ($name) = @_;                          # Name of text (usually "default")
> 	
> 	%Text = ();
> 	
> 	if ( $NewText ne "" ) { $Text{'text'} = $NewText; }
> 	else { $Text{'text'} = "Describe the new page here."; }
> 	
> 	$Text{'text'} .= "\n" if ( substr( $Text{'text'}, -1, 1 ) ne "\n" );
> 	$Text{'minor'}     = 0;                   # Default as major edit
> 	$Text{'newauthor'} = 1;                   # Default as new author
> 	$Text{'summary'}   = "";
> 	
> 	&OpenNewSection( "text_$name", join( $FS3, %Text ) );
> }
> 
> sub GetPageFile {
> 	my ($id) = @_;
> 	
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
> }
> 
> sub OpenPage {
> 	my ($id) = @_;
> 	my ( $fname, $data );
> 	
> 	if (!CheckIsAuthUser($id)) { $id = "AuthError"; } #auth patch
> 	if ( $OpenPageName eq $id ) { return; }
> 	if ( $id eq ""){ return; }
> 		
> 	%Section = ();
> 	%Text    = ();
> 	$fname   = &GetPageFile($id);
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		%Page = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	}
> 	else {
> 		&OpenNewPage($id);
> 	}
> 	
> 	if ( $Page{'version'} != 3 ) { &UpdatePageVersion(); }
> 	
> 	$OpenPageName = $id;
> }
> 
> sub OpenSection {
> 	my ($name) = @_;
> 	
> 	if ( !defined( $Page{$name} ) ) { &OpenNewSection( $name, "" ); }
> 	else { %Section = split( /$FS2/, $Page{$name}, -1 ); }
> }
> 
> sub OpenText {
> 	my ($name) = @_;
> 	
> 	if ( !defined( $Page{"text_$name"} ) ) {
> 		&OpenNewText($name);
> 	}
> 	else {
> 		&OpenSection("text_$name");
> 		%Text = split( /$FS3/, $Section{'data'}, -1 );
> 	}
> }
> 
> sub OpenDefaultText {
> 	&OpenText('default');
> }
> 
> # Called after OpenKeptRevisions
> sub OpenKeptRevision {
> 	my ($revision) = @_;
> 	
> 	%Section = split( /$FS2/, $KeptRevisions{$revision}, -1 );
> 	%Text = split( /$FS3/, $Section{'data'}, -1 );
> }
> 
> sub GetPageCache {
> 	my ($name) = @_;
> 	
> 	return $Page{"cache_$name"};
> }
> 
> # Always call SavePage within a lock.
> sub SavePage {
> 	my $file = &GetPageFile($OpenPageName);
> 	
> 	$Page{'revision'} += 1;    # Number of edited times
> 	$Page{'ts'} = $Now;        # Updated every edit
> 	&CreatePageDir( $PageDir, $OpenPageName );
> 	&WriteStringToFile( $file, join( $FS1, %Page ) );
> }
> 
> sub SaveSection {
> 	my ( $name, $data ) = @_;
> 	
> 	$Section{'revision'} += 1;    # Number of edited times
> 	$Section{'ts'}       = $Now;                          # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'id'}       = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} = join( $FS2, %Section );
> }
> 
> sub SaveText {
> 	my ($name) = @_;
> 	
> 	&SaveSection( "text_$name", join( $FS3, %Text ) );
> }
> 
> sub SaveDefaultText {
> 	&SaveText('default');
> }
> 
> sub SetPageCache {
> 	my ( $name, $data ) = @_;
> 	
> 	$Page{"cache_$name"} = $data;
> }
> 
> sub UpdatePageVersion {
> 	&ReportError( "Bad page version (or corrupt page)." );
> }
> 
> sub KeepFileName {
> 	return $KeepDir . "/"
> 	  . &GetPageDirectory($OpenPageName)
> 	  . "/$OpenPageName.kp";
> }
> 
> sub SaveKeepSection {
> 	my $file = &KeepFileName();
> 	my $data;
> 	
> 	return if ( $Section{'revision'} < 1 );    # Don't keep "empty" revision
> 	
> 	$Section{'keepts'} = $Now;
> 	$data = $FS1 . join( $FS2, %Section );
> 	&CreatePageDir( $KeepDir, $OpenPageName );
> 	&AppendStringToFileLimited( $file, $data, $KeepSize );
> }
> 
> sub ExpireKeepFile {
> 	my ( $fname, $data, @kplist, %tempSection, $expirets );
> 	my ( $anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev );
> 	my ( $oldMajor, $oldAuthor );
> 	
> 	$fname = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );    # Also empty
> 	
> 	shift(@kplist) if ( $kplist[0] eq "" );    # First can be empty
> 	return if ( length(@kplist) < 1 );         # Also empty
> 	
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;                                # Bad keep file
> 	}
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	return if ( $tempSection{'keepts'} >= $expirets );    # Nothing old enough
> 	
> 	$anyExpire = 0;
> 	$anyKeep   = 0;
> 	%keepFlag  = ();
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	foreach ( reverse @kplist ) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		$expire      = 0;
> 		
> 		if ( $sectName eq "text_default" ) {
> 			if (   ( $KeepMajor && ( $sectRev == $oldMajor ) )
> 				|| ( $KeepAuthor && ( $sectRev == $oldAuthor ) ) )
> 			{
> 				$expire = 0;
> 			}
> 			elsif ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		else {
> 			if ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		if ( !$expire ) {
> 			$keepFlag{ $sectRev . "," . $sectName } = 1;
> 			$anyKeep = 1;
> 		}
> 		else {
> 			$anyExpire = 1;
> 		}
> 	}
> 	if ( !$anyKeep ) {    # Empty, so remove file
> 		unlink($fname);
> 		return;
> 	}
> 	return if ( !$anyExpire );    # No sections expired
> 	
> 	open( OUT, ">$fname" ) or die( Ts( 'cant write %s', $fname ) . ": $!" );
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		
> 		if ( $keepFlag{ $sectRev . "," . $sectName } ) {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
> }
> 
> sub OpenKeptList {
> 	my ( $fname, $data );
> 	
> 	@KeptList = ();
> 	$fname    = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@KeptList = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> }
> 
> sub OpenKeptRevisions {
> 	my ($name) = @_;    # Name of section
> 	my ( $fname, $data, %tempSection );
> 	
> 	%KeptRevisions = ();
> 	&OpenKeptList();
> 	
> 	foreach (@KeptList) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		next if ( $tempSection{'name'} ne $name );
> 		$KeptRevisions{ $tempSection{'revision'} } = $_;
> 	}
> }
> 
> sub LoadUserData {
> 	my ( $data, $status );
> 	
> 	%UserData = ();
> 	( $status, $data ) = &ReadFile( &UserDataFilename($UserID) );
> 	
> 	if ( !$status ) {
> 		$UserID = 112;    # Could not open file.  Consider warning message?
> 		return;
> 	}
> 	
> 	%UserData = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> }
> 
> sub UserDataFilename {
> 	my ($id) = @_;
> 	
> 	if ($id =~ /(\d+)/){
> 		$id = $1;
> 	}
> 	else { die "The userid must be a positive integer"; }
> 	
> 	return "" if ( $id < 1 );
> 	return $UserDir . "/" . ( $id % 10 ) . "/$id.db";
> }
> 
> # ==== Misc. functions ====
> sub ReportError {
> 	my ($errmsg) = @_;
> 	
> 	print &GetHeader( "", "ERROR!", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>$errmsg</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub ValidId {
> 	my ($id) = @_;
> 	
> 	if ( length($id) > 120 ) {
> 		return Ts( 'Page name is too long: %s', $id );
> 	}
> 	
> 	if ( $id =~ m| | ) {
> 		return Ts( 'Page name may not contain space characters: %s', $id );
> 	}
> 	
> 	if ($UseSubpage) {
> 		if ( $id =~ m|.*/.*/| ) {
> 			return Ts( 'Too many / characters in page %s', $id );
> 		}
> 		if ( $id =~ /^\// ) {
> 			return Ts( 'Invalid Page %s (subpage without main page)', $id );
> 		}
> 		if ( $id =~ /\/$/ ) {
> 			return Ts( 'Invalid Page %s (missing subpage name)', $id );
> 		}
> 	}
> 	
> 	if ($FreeLinks) {
> 		$id =~ s/ /_/g;
> 		if ( !$UseSubpage ) {
> 			if ( $id =~ /\// ) {
> 				return Ts( 'Invalid Page %s (/ not allowed)', $id );
> 			}
> 		}
> 		if ( !( $id =~ m|^$FreeLinkPattern$| ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 		if ( $id =~ m|\.db$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .db)', $id );
> 		}
> 		if ( $id =~ m|\.lck$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .lck)', $id );
> 		}
> 		return "";
> 	}
> 	else {
> 		if ( !( $id =~ /^$LinkPattern$/ ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 	}
> 	
> 	return "";
> }
> 
> sub ValidIdOrDie {
> 	my ($id) = @_;
> 	my $error;
> 	
> 	$error = &ValidId($id);
> 	
> 	if ( $error ne "" ) {
> 		&ReportError($error);
> 		return 0;
> 	}
> 	
> 	return 1;
> }
> 
> sub UserCanEdit {
> 	my ( $id, $deepCheck ) = @_;
> 	my $authtype = &CheckIsAuthUser($id);
> 	
> 	# Optimized for the "everyone can edit" case (don't check passwords)
> 	if ( ( $id ne "" ) && ( -f &GetLockedPageFile($id) ) ) {
> 		return 1 if ( &UserIsAdmin() );    # Requires more privledges
> 		     # Consider option for editor-level to edit these pages?
> 		return 0;
> 	}
> 	if ( !$EditAllowed ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ( -f "$DataDir/noedit" ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ($deepCheck) {    # Deeper but slower checks (not every page)
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0 if ( &UserIsBanned() );
> 	}
> 	
> 	return 1;
> }
> 
> sub UserIsBanned {
> 	my ( $host, $ip, $data, $status );
> 	( $status, $data ) = &ReadFile("$DataDir/banlist");
> 	
> 	return 0 if ( !$status );    # No file exists, so no ban
> 	$data =~ s/\r//g;
> 	$ip   = $ENV{'REMOTE_ADDR'};
> 	$host = &GetRemoteHost(0);
> 	
> 	foreach ( split( /\n/, $data ) ) {
> 		next if ( (/^\s*$/) || (/^#/) );    # Skip empty, spaces, or comments
> 		return 1 if ( $ip   =~ /$_/i );
> 		return 1 if ( $host =~ /$_/i );
> 	}
> 	
> 	return 0;
> }
> 
> sub UserIsAdmin {
> 	my ( @pwlist, $userPassword );
> 	
> 	return 0 if ( $AdminPass eq "" );
> 	$userPassword = &GetParam( "adminpw", "" );
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $AdminPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
> }
> 
> sub UserIsEditor {
> 	my ( @pwlist, $userPassword );
> 	
> 	return 1 if ( &UserIsAdmin() );    # Admin includes editor
> 	return 0 if ( $EditPass eq "" );
> 	$userPassword = &GetParam( "password", "" );    # Used for both
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $EditPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
> }
> 
> sub UserIsEditorOrAdmin {
> 	return (UserIsEditor || UserIsAdmin);	
> }
> 
> sub UserCanUpload {
> 	return 1 if ( &UserIsEditor() );
> 	return $AllUpload;
> }
> 
> sub GetLockedPageFile {
> 	my ($id) = @_;
> 	
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
> }
> 
> sub RequestLockDir {
> 	my ( $name, $tries, $wait, $errorDie ) = @_;
> 	my ( $lockName, $n );
> 	
> 	&CreateDir($TempDir);
> 	$lockName = $LockDir . $name;
> 	$n        = 0;
> 	
> 	while ( mkdir( $lockName, 0555 ) == 0 ) {
> 		if ( $! != 17 ) {
> 			die( Ts( 'can not make %s', $LockDir ) . ": $!\n" ) if $errorDie;
> 			return 0;
> 		}
> 		return 0 if ( $n++ >= $tries );
> 		sleep($wait);
> 	}
> 	
> 	return 1;
> }
> 
> sub ReleaseLockDir {
> 	my ($name) = @_;
> 	
> 	rmdir( $LockDir . $name );
> }
> 
> sub RequestLock {
> 	# 10 tries, 3 second wait, possibly die on error
> 	return &RequestLockDir( "main", 10, 3, $LockCrash );
> }
> 
> sub ReleaseLock {
> 	&ReleaseLockDir('main');
> }
> 
> sub ForceReleaseLock {
> 	my ($name) = @_;
> 	my $forced;
> 
> 	# First try to obtain lock (in case of normal edit lock)
> 	# 5 tries, 3 second wait, do not die on error
> 	$forced = !&RequestLockDir( $name, 5, 3, 0 );
> 	&ReleaseLockDir($name);    # Release the lock, even if we didn't get it.
> 	
> 	return $forced;
> }
> 
> sub RequestCacheLock {
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'cache', 4, 2, 0 );
> }
> 
> sub ReleaseCacheLock {
> 	&ReleaseLockDir('cache');
> }
> 
> sub RequestDiffLock {
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'diff', 4, 2, 0 );
> }
> 
> sub ReleaseDiffLock {
> 	&ReleaseLockDir('diff');
> }
> 
> # Index lock is not very important--just return error if not available
> sub RequestIndexLock {
> 	# 1 try, 2 second wait, do not die on error
> 	return &RequestLockDir( 'index', 1, 2, 0 );
> }
> 
> sub ReleaseIndexLock {
> 	&ReleaseLockDir('index');
> }
> 
> sub ReadFile {
> 	my ($fileName) = @_;
> 	my ($data);
> 	
> 	local $/ = undef;    # Read complete files
> 	if ( open( IN, "<$fileName" ) ) {
> 		$data = <IN>;
> 		close IN;
> 		return ( 1, $data );
> 	}
> 	
> 	return ( 0, "" );
> }
> 
> sub ReadFileOrDie {
> 	my ($fileName) = @_;
> 	my ( $status, $data );
> 	
> 	( $status, $data ) = &ReadFile($fileName);
> 	if ( !$status ) {
> 		die( Ts( 'Can not open %s', $fileName ) . ": $!" );
> 	}
> 	
> 	return $data;
> }
> 
> sub WriteStringToFile {
> 	my ( $file, $string ) = @_;
> 	
> 	open( OUT, ">$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
> }
> 
> sub AppendStringToFile {
> 	my ( $file, $string ) = @_;
> 	
> 	open( OUT, ">>$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
> }
> 
> sub AppendStringToFileLimited {
> 	my ( $file, $string, $limit ) = @_;
> 	
> 	if ( ( $limit < 1 ) || ( ( ( -s $file ) + length($string) ) <= $limit ) ) {
> 		&AppendStringToFile( $file, $string );
> 	}
> }
> 
> sub CreateDir {
> 	my ($newdir) = @_;
> 	
> 	mkdir( $newdir, 0775 ) if ( !( -d $newdir ) );
> }
> 
> sub CreatePageDir {
> 	my ( $dir, $id ) = @_;
> 	my $subdir;
> 	
> 	&CreateDir($dir);    # Make sure main page exists
> 	$subdir = $dir . "/" . &GetPageDirectory($id);
> 	&CreateDir($subdir);
> 	
> 	if ( $id =~ m|([^/]+)/| ) {
> 		$subdir = $subdir . "/" . $1;
> 		&CreateDir($subdir);
> 	}
> }
> 
> sub UpdateHtmlCache {
> 	my ( $id, $html ) = @_;
> 	my $idFile;
> 	
> 	$idFile = &GetHtmlCacheFile($id);
> 	&CreatePageDir( $HtmlDir, $id );
> 	if ( &RequestCacheLock() ) {
> 		&WriteStringToFile( $idFile, $html );
> 		&ReleaseCacheLock();
> 	}
> }
> 
> sub GenerateAllPagesList {
> 	my ( @pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId );
> 	
> 	@pages = ();
> 	if ($FastGlob) {
> 		# The following was inspired by the FastGlob code by Marc W. Mengel.
> 		# Thanks to Bob Showalter for pointing out the improvement.
> 		opendir( PAGELIST, $PageDir );
> 		@dirs = readdir(PAGELIST);
> 		closedir(PAGELIST);
> 		@dirs = sort(@dirs);
> 		foreach $dir (@dirs) {
> 			next
> 			  if ( substr( $dir, 0, 1 ) eq '.' );  # No ., .., or .dirs or files
> 			opendir( PAGELIST, "$PageDir/$dir" );
> 			@pageFiles = readdir(PAGELIST);
> 			closedir(PAGELIST);
> 			foreach $id (@pageFiles) {
> 				next if ( ( $id eq '.' ) || ( $id eq '..' ) );
> 				if ( substr( $id, -3 ) eq '.db' ) {
> 					push( @pages, substr( $id, 0, -3 ) );
> 				}
> 				elsif ( substr( $id, -4 ) ne '.lck' ) {
> 					opendir( PAGELIST, "$PageDir/$dir/$id" );
> 					@subpageFiles = readdir(PAGELIST);
> 					closedir(PAGELIST);
> 					foreach $subId (@subpageFiles) {
> 						if ( substr( $subId, -3 ) eq '.db' ) {
> 							push( @pages, "$id/" . substr( $subId, 0, -3 ) );
> 						}
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		# Old slow/compatible method.
> 		@dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
> 		
> 		foreach $dir (@dirs) {
> 			if ( -e "$PageDir/$dir" ) {    # Thanks to Tim Holt
> 				while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
> 					s|^$PageDir/||;
> 					m|^[^/]+/(\S*).db|;
> 					$id = $1;
> 					push( @pages, $id );
> 				}
> 			}
> 		}
> 	}
> 	
> 	return sort(@pages);
> }
> 
> sub AllPagesList {
> 	my ( $rawIndex, $refresh, $status );
> 	
> 	if ( !$UseIndex ) {
> 		return &GenerateAllPagesList();
> 	}
> 	
> 	$refresh = &GetParam( "refresh", 0 );
> 	if ( $IndexInit && !$refresh ) {
> 
> 		# Note for mod_perl: $IndexInit is reset for each query
> 		# Eventually consider some timestamp-solution to keep cache?
> 		return @IndexList;
> 	}
> 	
> 	if ( ( !$refresh ) && ( -f $IndexFile ) ) {
> 		( $status, $rawIndex ) = &ReadFile($IndexFile);
> 		
> 		if ($status) {
> 			%IndexHash = split( /\s+/, $rawIndex );
> 			@IndexList = sort( keys %IndexHash );
> 			$IndexInit = 1;
> 			
> 			return @IndexList;
> 		}
> 
> 		# If open fails just refresh the index
> 	}
> 	
> 	@IndexList = ();
> 	%IndexHash = ();
> 	@IndexList = &GenerateAllPagesList();
> 	
> 	foreach (@IndexList) {
> 		$IndexHash{$_} = 1;
> 	}
> 	
> 	$IndexInit = 1;    # Initialized for this run of the script
> 	                   # Try to write out the list for future runs
> 	&RequestIndexLock() or return @IndexList;
> 	&WriteStringToFile( $IndexFile, join( " ", %IndexHash ) );
> 	&ReleaseIndexLock();
> 	
> 	return @IndexList;
> }
> 
> sub AllSubPagesList {
> 	my $GivenPage = shift;
> 	my @PageList = &AllPagesList();
> 	my @Results;
> 	
> 	foreach (@PageList){
> 		if (/^$GivenPage\//i){
> 			push @Results, $_;	
> 		}
> 	}
> 	
> 	return @Results;
> }
> 
> sub CalcDay {
> 	my ($ts) = @_;
> 	
> 	$ts += $TimeZoneOffset;
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	
> 	if ($NumberDates) {
> 		$year = $year + 1900;
> 		$mon = $mon + 1;
> 		if ($mon < 10){ $mon = "0$mon"; }
> 		if ($mday < 10){ $mday = "0$mday"; }
> 		
> 		return "$year$NumberDatesDelim$mon$NumberDatesDelim$mday";
> 	}
> 	
> 	return (
> 		"January",   "February", "March",    "April",
> 		"May",       "June",     "July",     "August",
> 		"September", "October",  "November", "December"
> 	  )[$mon]
> 	  . " "
> 	  . $mday . ", "
> 	  . ( $year + 1900 );
> }
> 
> sub CalcTime {
> 	my ($ts) = @_;
> 	my ( $ampm, $mytz );
> 	
> 	$ts += $TimeZoneOffset;
> 	
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	$mytz = "";
> 	
> 	if ( ( $TimeZoneOffset == 0 ) && ( $ScriptTZ ne "" ) ) {
> 		$mytz = " " . $ScriptTZ;
> 	}
> 	$ampm = "";
> 	
> 	if ($UseAmPm) {
> 		$ampm = " am";
> 		if ( $hour > 11 ) {
> 			$ampm = " pm";
> 			$hour = $hour - 12;
> 		}
> 		$hour = 12 if ( $hour == 0 );
> 	}
> 	
> 	$min = "0" . $min if ( $min < 10 );
> 	
> 	return $hour . ":" . $min . $ampm . $mytz;
> }
> 
> sub TimeToText {
> 	my ($t) = @_;
> 	
> 	return &CalcDay($t) . " " . &CalcTime($t);
> }
> 
> sub GetParam {
> 	my ( $name, $default ) = @_;
> 	my $result;
> 	
> 	$result = $q->param($name);
> 	
> 	if ( !defined($result) ) {
> 		if ( defined( $UserData{$name} ) ) {
> 			$result = $UserData{$name};
> 		}
> 		else {
> 			$result = $default;
> 		}
> 	}
> 	
> 	return $result;
> }
> 
> sub GetHiddenValue {
> 	my ( $name, $value ) = @_;
> 	
> 	$q->param( $name, $value );
> 	
> 	return $q->hidden($name);
> }
> 
> sub GetRemoteHost {
> 	my ($doMask) = @_;
> 	my ( $rhost, $iaddr );
> 	
> 	$rhost = $ENV{REMOTE_HOST};
> 	
> 	if ( $UseLookup && ( $rhost eq "" ) ) {
> 
> 		# Catch errors (including bad input) without aborting the script
> 		eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
> 		  . '$rhost = gethostbyaddr($iaddr, AF_INET)';
> 	}
> 	
> 	if ( $rhost eq "" ) {
> 		$rhost = $ENV{REMOTE_ADDR};
> 	}
> 	
> 	$rhost = &GetMaskedHost($rhost) if ($doMask);
> 	
> 	return $rhost;
> }
> 
> sub FreeToNormal {
> 	my ($id) = @_;
> 	
> 	$id =~ s/ /_/g;
> 	$id = ucfirst($id) if ( $UpperFirst || $FreeUpper );
> 	
> 	if ( index( $id, '_' ) > -1 ) {    # Quick check for any space/underscores
> 		$id =~ s/__+/_/g;
> 		$id =~ s/^_//;
> 		$id =~ s/_$//;
> 		
> 		if ($UseSubpage) {
> 			$id =~ s|_/|/|g;
> 			$id =~ s|/_|/|g;
> 		}
> 	}
> 	
> 	if ($FreeUpper) {
> 
> 		# Note that letters after ' are *not* capitalized
> 		if ( $id =~ m|[-_.,\(\)/][a-z]| ) { # Quick check for non-canonical case
> 			$id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
> 		}
> 	}
> 	
> 	return $id;
> }
> 
> #END_OF_BROWSE_CODE
> # == Page-editing and other special-action code ========================
> $OtherCode = "";    # Comment next line to always compile (slower)
> 
> #$OtherCode = <<'#END_OF_OTHER_CODE';
> sub DoOtherRequest {
> 	my ( $id, $action, $filter, $text, $search );
> 	
> 	$action = &GetParam( "action", "" );
> 	$id     = &GetParam( "id",     "" );
> 	$filter = &GetParam( "filter", "" );
> 	
> 	if ( $action ne "" ) {
> 		$action = lc($action);
> 		
> 		if ( $action eq "edit" ) {
> 			&DoEdit( $id, 0, 0, "", 0 ) if &ValidIdOrDie($id);
> 		}
> 		elsif ( $action eq "unlock" ) {
> 			&DoUnlock();
> 		}
> 		elsif ( $action eq "index" ) {
> 			&DoIndex();
> 		}
> 		elsif ( $action eq "links" ) {
> 			&DoLinks();
> 		}
> 		elsif ( $action eq "maintain" ) {
> 			&DoMaintain();
> 		}
> 		elsif ( $action eq "pagelock" ) {
> 			&DoPageLock();
> 		}
> 		elsif ( $action eq "editlock" ) {
> 			&DoEditLock();
> 		}
> 		elsif ( $action eq "editprefs" ) {
> 			&DoEditPrefs();
> 		}
> 		elsif ( $action eq "editbanned" ) {
> 			&DoEditBanned();
> 		}
> 		elsif ( $action eq "editlinks" ) {
> 			&DoEditLinks();
> 		}
> 		elsif ( $action eq "login" ) {
> 			&DoEnterLogin();
> 		}
> 		elsif ( $action eq "newlogin" ) {
> 			$UserID = 0;
> 			&DoEditPrefs();    # Also creates new ID
> 		}
> 		elsif ( $action eq "version" ) {
> 			&DoShowVersion();
> 		}
> 		elsif ( $action eq "rss" ) {
> 			&DoRss();
> 		}
> 		elsif ( $action eq "delete" ) {
> 			&DoDeletePage($id);
> 		}
> 		elsif ( $UseUpload && ( $action eq "upload" ) ) {
> 			&DoUpload();
> 		}
> 		elsif ( $action eq "maintainrc" ) {
> 			&DoMaintainRc();
> 		}
> 		elsif ( $action eq "convert" ) {
> 			&DoConvert();
> 		}
> 		elsif ( $action eq "trimusers" ) {
> 			&DoTrimUsers();
> 		}
> 		elsif ( $action eq "listfiles" ) {
> 			&DoListFiles($id, $filter, 0);	
> 		}
> 		elsif ( $action eq "listdisabled" ) {
> 			&DoListFiles($id, $filter, 1);	
> 		}
> 		else {
> 			&ReportError( Ts( 'Invalid action parameter %s', $action ) );
> 		}
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_prefs", 0 ) ) {
> 		&DoUpdatePrefs();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_ban", 0 ) ) {
> 		&DoUpdateBanned();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "enter_login", 0 ) ) {
> 		&DoLogin();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_links", 0 ) ) {
> 		&DoUpdateLinks();
> 		return;
> 	}
> 	
> 	if ( $UseUpload && ( &GetParam( "upload", 0 ) ) ) {
> 		&SaveUpload();
> 		return;
> 	}
> 	
> 	$search = &GetParam( "search", "" );
> 	
> 	if ( ( $search ne "" ) || ( &GetParam( "dosearch", "" ) ne "" ) ) {
> 		&DoSearch($search, $filter);
> 		return;
> 	}
> 	else {
> 		$search = &GetParam( "back", "" );
> 		if ( $search ne "" ) {
> 			&DoBackLinks($search, $filter);
> 			
> 			return;
> 		}
> 	}
> 
> 	# Handle posted pages
> 	if ( &GetParam( "oldtime", "" ) ne "" ) {
> 		$id = &GetParam( "title", "" );
> 		&DoPost() if &ValidIdOrDie($id);
> 		
> 		return;
> 	}
> 	
> 	&ReportError( "Invalid URL." );
> }
> 
> sub PageIsLocked {
> 	my ($id, $deepedit) = @_;
> 	my ($result) = 0;
> 	
> 	if ( !&UserCanEdit( $id, $deepedit ) ) {
> 			$result = 1;
> 		if ( &UserIsBanned() ) {
> 			$result = 2;
> 		}
> 		else {
> 			$result = 3;
> 		}
> 	}
> 	
> 	return $result;
> }
> 
> sub DoEdit {
> 	my ( $id, $isConflict, $oldTime, $newText, $preview ) = @_;
> 	my ( $header, $editRows, $editCols, $userName, $revision, $oldText );
> 	my ( $summary, $isEdit, $pageTime, $isLocked );
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 	if (!$authtype) { $id = "AuthError"; } #auth patch	
> 	if ($FreeLinks) { $id = &FreeToNormal($id); }   # Take care of users like Markus Lude :-)	
> 	
> 	$isLocked = &PageIsLocked( $id, 1 );
> 	
> 	if ( $isLocked > 0 or $authtype eq "" || $authtype eq "1") {
> 		print &GetHeader( "", "Editing Denied", "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		
> 		if ( $isLocked == 2 ) {
> 			print "\n<h2>Editing not allowed: user, ip, or network is blocked.</h2>";
> 			print "\nContact the wiki administrator for more information.";
> 		}
> 		else {
> 			print "\n<h2>Editing not allowed: $id is read-only.</h2>";
> 		}
> 		
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";
> 			
> 		return;
> 	}
> 
> 	# Consider sending a new user-ID cookie if user does not have one
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$pageTime = $Section{'ts'};
> 	$header   = Ts( 'Editing %s', $id );
> 
> 	# Old revision handling
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$revision = "";
> 
> 			# Consider better solution like error message?
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 			$header = Ts( 'Editing revision %s of ', $revision ) . $id;
> 		}
> 	}
> 	
> 	$oldText = $Text{'text'};
> 	
> 	if ( $preview && !$isConflict ) { $oldText = $newText; }
> 	
> 	$editRows = &GetParam( "editrows", 20 );
> 	$editCols = &GetParam( "editcols", 65 );
> 	
> 	print &GetHeader( "", &QuoteHtml($header), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $revision ne "" ) {
> 		print "\n<b>Editing old revision $revision. Saving this page will replace the latest revision with this text.</b><br>";
> 	}
> 	
> 	if ($isConflict) {
> 		$editRows -= 10 if ( $editRows > 19 );
> 		print "\n<H1>Edit Conflict!</H1>";
> 		
> 		if ( $isConflict > 1 ) {
> 
> 			# The main purpose of a new warning is to display more text
> 			# and move the save button down from its old location.
> 			print "\n<h2>(This is a new conflict)</h2>";
> 		}
> 		
> 		print "\n<p><strong>";
> 		print "\nSomeone saved this page after you started editing. ";
> 		print "\nThe top textbox contains the saved text. ";
> 		print "\nOnly the text in the top textbox will be saved.";
> 		print "\n</strong></p><br>";
> 		print "\nScroll down to see your edited text.";
> 		print "\n<br>";
> 		print "\nLast save time: ";
> 		print &TimeToText($oldTime);
> 		print "\n(Current time is: ";
> 		print &TimeToText($Now);
> 		print "\n)<br>";
> 	}
> 	
> 	print "\n<div id='wikieditbar'>";
> 	print "<a href='$ScriptName?WikiStyleGuide'>WikiStyleGuide</a> | ";
> 	print "<a href='$ScriptName?WikiHeadings'>WikiHeadings</a> | ";
> 	print "<a href='$ScriptName?WikiGallery'>WikiGallery</a>| ";
> 	print "<a href='$ScriptName?WikiFlash'>WikiFlash</a>| ";
> 	print "<a href='$ScriptName?WikiTOCs'>WikiTOCs</a> | ";
> 	print "<a href='$ScriptName?WikiURLs'>WikiURLs</a> | ";
> 	print "<a href='$ScriptName?WikiImages'>WikiImages</a> | ";
> 	print "<a href='$ScriptName?WikiTables'>WikiTables</a> | ";
> 	print "<a href='$ScriptName?WikiLists'>WikiLists</a> | ";
> 	print "<a href='$ScriptName?WikiMarkup'>WikiMarkup</a>";
> 	print "\n</div>";
> 	
> 	print "\n<br>";
> 	print "\n<form id='wikiform' action='$ScriptName#preview-anchor' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "title",   $id );
> 	print &GetHiddenValue( "oldtime",     $pageTime );
> 	print &GetHiddenValue( "oldconflict", $isConflict );
> 	  
> 	if ( $revision ne "" ) { print &GetHiddenValue( "revision", $revision ); }
> 	
> 	print &GetTextArea( 'text', $oldText, $editRows, $editCols );
> 	$summary = &GetParam( "summary", "*" );
> 	
> 	print "\n<br><br><div id='wikisaveedit'>Summary:";
> 	print
> 	  $q->textfield(
> 		-name      => 'summary',
> 		-id		   => 'summarytext',
> 		-default   => $summary,
> 		-override  => 1,
> 		-size      => 60,
> 		-maxlength => 200
> 	  );
> 	  
> 	if ( &GetParam("recent_edit") eq "on" ) {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name    => 'recent_edit',
> 			-checked => 1,
> 			-label   => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	else {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name  => 'recent_edit',
> 			-checked => 0,
> 			-label => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n&nbsp;&nbsp;&nbsp;"
> 		  . $q->checkbox(
> 			-name  => 'do_email_notify',
> 			-label =>
> 			  Ts( 'Send email notification that %s has been changed.', $id )
> 		  );
> 	}
> 	
> 	print "\n<br>";
> 	
> 	if ( $EditNote ne "" ) { print $EditNote . '<br>'; }
> 	
> 	$userName = &GetParam( "username", "" );
> 	print $q->submit( -name => 'Preview', -value => 'Preview' );
> 	print $q->button( -name => 'Cancel', -value => 'Cancel', -onclick => 'window.location="' . $ScriptName . '?' . $id . '";' );
> 	print $q->submit( -name => 'Save', -value => "Save" );	
> 	
> 	if ( $userName ne "" ) {
> 		print "\n (Your user name is ";
> 		print &GetPageLinkText($HomePagePrefix . '/' . $userName, $userName);
> 		print "\n )";
> 	}
> 	else {
> 		print ' (', Ts( 'Visit %s to set your user name.', &GetPrefsLink() ), ') ';
> 	}
> 
> 	if ($isConflict) {
> 		print "\n<br><hr><p><strong>";
> 		print "\nThis is the text you submitted:";
> 		print  "</strong><p>";
> 		print &GetTextArea( 'newtext', $newText, $editRows, $editCols );
> 	}
> 	
> 	print "\n</div>";
> 	print "\n</form>";
> 	print "<a name='preview-anchor'></a>";
> 	print "\n</div>";			
> 	print "\n$WikiLineFooter";
> 	
> 	if ($preview) {
> 		
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print $WikiLineHeaderPreview;
> 		print "\n<div id='wikipreview' class='wikipreview'>";
> 					
> 		if ($isConflict) {
> 			print "\n<b>NOTE: This preview shows the revision of the other author.</b><hr>";
> 		}
> 		
> 		$MainPage = $id;
> 		$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		print &WikiToHTML($oldText);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter";
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print "\n<div id='wikibar'>&nbsp</div>";
> 	}
> 
> 	print "\n<div class='wikifooter'>";	
> 	print "<div class='wikirevision'>";
> 	print &GetHistoryLink( $id, "View other revisions<br>", "Click to view revision history");
> 	print "</div>";
> 	print &GetGotoBar($id);
> 	print &getFooterNote();
> 	
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
> 			
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetTextArea {
> 	my ( $name, $text, $rows, $cols ) = @_;
> 	my ( $html );
> 	
> 	$html = "\n<div style='width: 100%;'>";
> 	if ( &GetParam( "editwide", 1 ) ) {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-style    => 'width:100%',
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	else {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	
> 	$html .= "</div>";
> 	
> 	return $html;
> }
> 
> sub DoEditPrefs {
> 	my ( $check, $recentName, %labels );
> 	
> 	$recentName = $RCName;
> 	$recentName =~ s/_/ /g;
> 	
> 	&DoNewLogin() if ( $UserID < 400 );
> 	
> 	print &GetHeader( "", "Editing Preferences", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikidiff'>";
> 	print "\n<h2>Access Controls</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "edit_prefs", 1 );
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th colspan='2'><b>User Information </b></th></tr>";
> 	print "\n<tr><td>Your User ID number </td><td>$UserID</td></tr>";
> 	print "\n<tr><td>UserName</td>";
> 	print "\n<td>" . &GetFormText( 'username', "", 30, 50 );
> 	print "\n<br>(blank to remove, or valid page name)</td></tr>";
> 	print "\n<tr><td>Set Password </td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => '*',
> 		-size      => 30,
> 		-maxlength => 50
> 	  );
> 	 print "\n<br>(blank to remove password)";
> 	 print "\n<br>Passwords allow sharing preferences between multiple systems. Passwords are completely optional. ";
> 	 print "\n</td></tr>";
> 
> 
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		print "\n<tr><td>Administrator Password </td>";
> 		print "\n<td>";
> 		print
> 		  $q->password_field(
> 			-name      => 'p_adminpw',
> 			-value     => '*',
> 			-size      => 30,
> 			-maxlength => 50
> 		  );
> 		print "\n<br>(blank to remove password)";
> 		print "\n<br>(Administrator passwords are used for special maintenance.)";
> 		print "\n</td></tr>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n<tr><td>Email Address</td>";
> 		print "\n<td>" . &GetFormText( 'email', "", 30, 60 );
> 		print "\n<br>" . &GetFormCheck( 'notify', 1, "Include this address in the site email list." );
> 		print "\n<br>(Uncheck the box to remove the address.) ";
> 		
> 		print "\n</td></tr>";
> 	}
> 	
> 	print "\n</table>";
> 	
> 	print "\n$WikiLinePref<b>$recentName:</b>";
> 	print "\n<br>Default days to display: ";
> 	print &GetFormText( 'rcdays', $RcDefault, 4, 9 );
> 	print "\n<br>", &GetFormCheck( 'rcnewtop', $RecentTop, "Most recent changes on top" );
> 	print "\n<br>", &GetFormCheck( 'rcall', 0, "Show all changes (not just most recent)" );
> 	
> 	%labels = (
> 		0 => "Hide minor edits",
> 		1 => "Show minor edits",
> 		2 => "Show only minor edits"
> 	);
> 	
> 	print "\n<br>Minor edit display: ";
> 	print $q->popup_menu(
> 		-name   => 'p_rcshowedit',
> 		-values => [ 0, 1, 2 ],
> 		-labels => \%labels,
> 		-default => &GetParam( "rcshowedit", $ShowEdits )
> 	);
> 	
> 	print "\n<br>", &GetFormCheck( 'rcchangehist', 1, "Use 'changes' as link to history" );
> 
> 	if ($UseDiff) {
> 		print "\n$WikiLinePref<b>Differences:</b>";
> 		print "\n<br>", &GetFormCheck( 'diffrclink', 1, "Show (diff) links on $recentName " );
> 		print "\n<br>", &GetFormCheck( 'alldiff', 0, "Show differences on all pages" );
> 		print "\n  (", &GetFormCheck( 'norcdiff', 1, "No differences on $recentName " ), ")";
> 		%labels = ( 1 => "Major", 2 => "Minor", 3 => "Author" );
> 		print "\n<br>Default difference type: ";
> 		print $q->popup_menu(
> 			-name   => 'p_defaultdiff',
> 			-values => [ 1, 2, 3 ],
> 			-labels => \%labels,
> 			-default => &GetParam( "defaultdiff", 1 )
> 		);
> 	}
> 	
> 	print "\n$WikiLinePref<b>Misc:</b>";
> 
> 	# Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
> 	print "\n<br>";
> 	print "\nServer time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print &GetFormText( 'tzoffset', 0, 4, 9 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'editwide', 1, "Use 100% wide edit area (if supported)" );
> 	print "\n<br>";
> 	print "\nEdit area rows: ";
> 	print &GetFormText( 'editrows', 20, 4, 4 );
> 	print "\n columns: ";
> 	print &GetFormText( 'editcols', 65, 4, 4 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'toplinkbar', 1, "Show link bar on top" );
> 	print "\n<br>";
> 	print &GetFormCheck( 'linkrandom', 0, "Add 'Random Page' link to link bar" );
> 	print "\n<br>";
> 	print "\nStyleSheet URL: ";
> 	print &GetFormText( 'stylesheet', "", 30, 150 );
> 	print "\n<br><br>";
> 	print "\n<input type='button' name='Cancel' value='Cancel' onclick='history.go(-1);' style='margin-right: 20px;'>";
> 	print "\n<input type='reset' name='Reset'> ";
> 	print $q->submit( -name => 'Save', -value => "Save" );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print "\n$WikiLineFooter";
> 	print "\n<div class='wikifooter'>";
> 	print &GetGotoBar("");
> 
> 	print &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
> 	print "\n</div></div></body></html>";	
> }
> 
> sub GetFormText {
> 	my ( $name, $default, $size, $max ) = @_;
> 	my $text = &GetParam( $name, $default );
> 	
> 	return $q->textfield(
> 		-name      => "p_$name",
> 		-default   => $text,
> 		-override  => 1,
> 		-size      => $size,
> 		-maxlength => $max
> 	);
> }
> 
> sub GetFormCheck {
> 	my ( $name, $default, $label ) = @_;
> 	my $checked = ( &GetParam( $name, $default ) > 0 );
> 	
> 	return $q->checkbox(
> 		-name     => "p_$name",
> 		-override => 1,
> 		-checked  => $checked,
> 		-label    => $label
> 	);
> }
> 
> sub DoUpdatePrefs {
> 	my ( $username, $password, $stylesheet );
> 
> 	# All link bar settings should be updated before printing the header
> 	&UpdatePrefCheckbox("toplinkbar");
> 	&UpdatePrefCheckbox("linkrandom");
> 	
> 	print &GetHeader( "", "Saving Preferences" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $UserID < 1001 ) {
> 		print "\n<h2>Invalid UserID $UserID, preferences not saved.</h2>";
> 		
> 		if ( $UserID == 111 ) {
> 			print "\n<br>(Preferences require cookies, but no cookie was sent.)";
> 		}
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$username = &GetParam( "p_username", "" );
> 	
> 	if ($FreeLinks) {
> 		$username =~ s/^\[\[(.+)\]\]/$1/;    # Remove [[ and ]] if added
> 		$username = &FreeToNormal($username);
> 		$username =~ s/_/ /g;
> 	}
> 	
> 	if ( $username eq "" ) {
> 		print "\n<h2>UserName removed.</h2>";
> 		undef $UserData{'username'};
> 	}
> 	elsif ( ( !$FreeLinks ) && ( !( $username =~ /^$LinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( $FreeLinks && ( !( $username =~ /^$FreeLinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( length($username) > 50 ) {    # Too long
> 		print "\n<h2>UserName must be 50 characters or less. (not saved)</h2>";
> 	}
> 	else {
> 		print "\n<h2>UserName $username saved.</h2>";
> 		$UserData{'username'} = $username;
> 	}
> 	
> 	$password = &GetParam( "p_password", "" );
> 	
> 	if ( $password eq "" ) {
> 		print "\nPassword removed.<br>";
> 		undef $UserData{'password'};
> 	}
> 	elsif ( $password ne "*" ) {
> 		print "\nPassword changed.<br>";
> 		$UserData{'password'} = $password;
> 	}
> 	
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		$password = &GetParam( "p_adminpw", "" );
> 		if ( $password eq "" ) {
> 			print "\nAdministrator password removed.<br>";
> 			undef $UserData{'adminpw'};
> 		}
> 		elsif ( $password ne "*" ) {
> 			print "\nAdministrator password changed.<br>";
> 			$UserData{'adminpw'} = $password;
> 			
> 			if ( &UserIsAdmin() ) {
> 				print "\nUser has administrative abilities.<br>";
> 			}
> 			elsif ( &UserIsEditor() ) {
> 				print "\nUser has editor abilities.<br>";
> 			}
> 			else {
> 				print "\nUser does not have administrative abilities. (Password does not match administrative password(s).) <br>";
> 			}
> 		}
> 	}
> 	
> 	if ($EmailNotify) {
> 		&UpdatePrefCheckbox("notify");
> 		&UpdateEmailList();
> 	}
> 	
> 	&UpdatePrefNumber( "rcdays", 0, 0, 999999 );
> 	&UpdatePrefCheckbox("rcnewtop");
> 	&UpdatePrefCheckbox("rcall");
> 	&UpdatePrefCheckbox("rcchangehist");
> 	&UpdatePrefCheckbox("editwide");
> 	
> 	if ($UseDiff) {
> 		&UpdatePrefCheckbox("norcdiff");
> 		&UpdatePrefCheckbox("diffrclink");
> 		&UpdatePrefCheckbox("alldiff");
> 		&UpdatePrefNumber( "defaultdiff", 1, 1, 3 );
> 	}
> 	
> 	&UpdatePrefNumber( "rcshowedit", 1, 0,    2 );
> 	&UpdatePrefNumber( "tzoffset",   0, -999, 999 );
> 	&UpdatePrefNumber( "editrows",   1, 1,    999 );
> 	&UpdatePrefNumber( "editcols",   1, 1,    999 );
> 	
> 	print "\n<br>Server time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print "\n<br>";
> 	$TimeZoneOffset = &GetParam( "tzoffset", 0 ) * ( 60 * 60 );
> 	
> 	print"Local time: ";
> 	print &TimeToText($Now);
> 	print "\n<br>";
> 	$stylesheet = &GetParam( 'p_stylesheet', "" );
> 
> 	if ( $stylesheet eq "" ) {
> 		if ( &GetParam( 'stylesheet', "" ) ne "" ) {
> 			print "\nStyleSheet URL removed.<br>";
> 		}
> 		undef $UserData{'stylesheet'};
> 	}
> 	else {
> 		$stylesheet =~ s/[">]//g;  # Remove characters that would cause problems"
> 		$UserData{'stylesheet'} = $stylesheet;
> 		print "\nStyleSheet setting saved.<br>";
> 	}
> 	
> 	&SaveUserData();
> 	
> 	print "\n<br><b>Preferences saved.</b>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # add or remove email address from preferences to $EmailFile
> sub UpdateEmailList {
> 	my (@old_emails);
> 	local $/ = "\n";               # don't slurp whole files in this sub.
> 	
> 	if ( my $new_email = $UserData{'email'} = &GetParam( "p_email", "" ) ) {
> 		my $notify = $UserData{'notify'};
> 		if ( -f $EmailFile ) {
> 			open( NOTIFY, $EmailFile ) or die( Ts( 'Could not read from %s:', $EmailFile ) . " $!\n" );
> 			@old_emails = <NOTIFY>;
> 			close(NOTIFY);
> 		}
> 		else {
> 			@old_emails = ();
> 		}
> 		
> 		my $already_in_list = grep /$new_email/, @old_emails;
> 		
> 		if ( $notify and ( not $already_in_list ) ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">>$EmailFile" ) ) {
> 				&ReleaseLock();    # Don't leave hangling locks
> 				die( "Could not append to $EmailFile : $!\n" );
> 			}
> 			
> 			print NOTIFY $new_email, "\n";
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 		elsif ( ( not $notify ) and $already_in_list ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">$EmailFile" ) ) {
> 				&ReleaseLock();
> 				die( "Could not overwrite $EmailFile : $!\n" );
> 			}
> 			foreach (@old_emails) {
> 				print NOTIFY "$_" unless /$new_email/;
> 			}
> 			
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 	}
> }
> 
> sub UpdatePrefCheckbox {
> 	my ($param) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	$UserData{$param} = 1 if ( $temp eq "on" );
> 	$UserData{$param} = 0 if ( $temp eq "*" );
> 
> 	# It is possible to skip updating by using another value, like "2"
> }
> 
> sub UpdatePrefNumber {
> 	my ( $param, $integer, $min, $max ) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	return if ( $temp eq "*" );
> 	
> 	$temp =~ s/[^-\d\.]//g;
> 	$temp =~ s/\..*// if ($integer);
> 	
> 	return if ( $temp eq "" );
> 	return if ( ( $temp < $min ) || ( $temp > $max ) );
> 	
> 	$UserData{$param} = $temp;
> }
> 
> sub DoIndex {
> 	print &GetHeader( "", "Index of all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( "", &AllPagesList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Create a new user file/cookie pair
> sub DoNewLogin {
> 	# Consider warning if cookie already exists
> 	# (maybe use "replace=1" parameter)
> 	&CreateUserDir();
> 	$SetCookie{'id'}      = &GetNewUserId();
> 	$SetCookie{'randkey'} = int( rand(1000000000) );
> 	$SetCookie{'rev'}     = 1;
> 	%UserCookie           = %SetCookie;
> 	$UserID               = $SetCookie{'id'};
> 
> 	# The cookie will be transmitted in the next header
> 	%UserData               = %UserCookie;
> 	$UserData{'createtime'} = $Now;
> 	$UserData{'createip'}   = $ENV{REMOTE_ADDR};
> 	&SaveUserData();
> }
> 
> sub DoEnterLogin {
> 	print &GetHeader( "", "Login", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>Enter UserID</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( 'enter_login', 1 );
> 	print "\n<table><tr>";
> 	print "\n<td>User ID number &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->textfield(
> 		-name      => 'p_userid',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n<tr>";
> 	print "\n<td>Password  &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n</tr></table><br>";
> 	print $q->submit( -name => 'Login', -value => 'Login' );
> 	print "\n<br></form></div>";
> 	print &GetCommonFooter();
> 	print "\n</div></body></html>";	
> }
> 
> sub DoLogin {
> 	my ( $uid, $password, $success );
> 	
> 	$success = 0;
> 	$uid = &GetParam( "p_userid", "" );
> 	$uid =~ s/\D//g;
> 	$password = &GetParam( "p_password", "" );
> 	
> 	print &GetHeader( "", "Login Results", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( ( $uid > 199 ) && ( $password ne "" ) && ( $password ne "*" ) ) {
> 		$UserID = $uid;
> 		&LoadUserData();
> 		if ( $UserID > 199 ) {
> 			if ( defined( $UserData{'password'} ) && ( $UserData{'password'} eq $password ) ) {
> 				$SetCookie{'id'}      = $uid;
> 				$SetCookie{'randkey'} = $UserData{'randkey'};
> 				$SetCookie{'rev'}     = 1;
> 				$success              = 1;
> 			}
> 			else {
> 				print "\nUserID Account Undefined<br>";
> 			}
> 		}
> 		else {
> 			print "\nUserID must be above 199<br>";
> 		}
> 	}
> 	
> 	
> 	if ($success) { print "\n<h2>Login for user ID $uid complete.</h2>"; }
> 	else { print "\n<h2>Login for user ID $uid failed.</h2>"; }
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter;
> 	print "\n</div></body></html>";	
> }
> 
> sub GetNewUserId {
> 	my ($id);
> 	
> 	$id = $StartUID;
> 	
> 	while ( -f &UserDataFilename( $id + 1000 ) ) { $id += 1000; }
> 	while ( -f &UserDataFilename( $id + 100 ) ) { $id += 100; }
> 	while ( -f &UserDataFilename( $id + 10 ) ) { $id += 10; }
> 	
> 	&RequestLock() or die( "Could not get user-ID lock" );
> 
> 	while ( -f &UserDataFilename($id) ) { $id++; }
> 	
> 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
> 	&ReleaseLock();
> 	
> 	return $id;
> }
> 
> # Consider user-level lock?
> sub SaveUserData {
> 	my ( $userFile, $data );
> 	
> 	&CreateUserDir();
> 	$userFile = &UserDataFilename($UserID);
> 	$data = join( $FS1, %UserData );
> 	&WriteStringToFile( $userFile, $data );
> }
> 
> sub CreateUserDir {
> 	my ( $n, $subdir );
> 	
> 	if ( !( -d "$UserDir/0" ) ) {
> 		&CreateDir($UserDir);
> 		foreach $n ( 0 .. 9 ) {
> 			$subdir = "$UserDir/$n";
> 			&CreateDir($subdir);
> 		}
> 	}
> }
> 
> sub DoSearch {
> 	my ($string, $filter) = @_;
> 	my ( $title );
> 	
> 	if ( $string eq "" ) {
> 		&DoIndex();
> 		return;
> 	}
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( "Search for: $title %s", $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( $filter, &SearchTitleAndBody($string, $filter) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='search' value='$string'>";
> 	print "\n<input type='hidden' name='dosearch' value='1'>";	
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoBackLinks {
> 	my ($string, $filter) = @_;
> 	my ($title);
> 	
> 	$title = $string;
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( 'Backlinks for: %s', $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	# At this time the backlinks are mostly a renamed search.
> 	# An initial attempt to match links only failed on subpages and free links.
> 	# Escape some possibly problematic characters:
> 	
> 	$string =~ s/([_ ])/( |_)/g;
> 	$string =~ s/([-'(),])/\\$1/g; #'REMARK
> 	$string =~ m,/, ? "\\b$string\\b" : "$string\\b";
> 	
> 	print PrintPageList( grep($_ !~ $title, $filter, &SearchTitleAndBody($string, $filter, "")) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='back' value='$string'>";
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub PrintPageList {
> 	my ($filter, @results) = @_;
> 	my $term;
>     my $pagename;
>     my $html = "";
>     my $pagecount = scalar(@results);
>     my $currentInitial = "";
>     my $thisInitial;
>     my $lastInitial;
>     my $letterGrouping = ($pagecount > 25);
>     my $currentParent = "";
>     my $linktext = "";
>     my $notFirst;
> 
> 	if ($filter ne ""){ $term = " using filter '<em>$filter</em>'"; }
> 	$html .= "<h2>" . ( scalar(@results) ) . " pages found: $term</h2>";
>     #$html .= "<ol>\n" if ($letterGrouping ne 1); # commented to keep a 'original' usemod look
>     
>     if ($letterGrouping) {
>         $html .= "<h3 class='lettergroup'>";
>         foreach $pagename (@results) {
>             $thisInitial = substr($pagename,0,1);
>             if ($thisInitial ne $lastInitial) {
>                     $html .= "<a href=\"#letter".$thisInitial."\">".$thisInitial."</a> ";
>                     $lastInitial = $thisInitial;
>             }
>         }
>         $html .= "</h3>";
>     }
>     
>     foreach $pagename (@results) {
>         if ($letterGrouping) {
>             $thisInitial = substr($pagename,0,1);
>             if ($currentInitial ne $thisInitial) {
>                 #$html .= "</ol>" if ($currentInitial ne ""); # commented to keep a 'original' usemod look
>                 $html .= "\n<br><br><h3 class='lettergroup'><a name=\"letter$thisInitial\"> $thisInitial </h3>\n$WikiLine\n";
>                 #$html .= "<ol>\n"; # commented to keep a 'original' usemod look
>                 $currentInitial = $thisInitial; 
>                 $notFirst = 0;
>             }
>         }
>         #$html .= "<li>"; # commented to keep a 'original' usemod look
>         $html .= "   ";
>         if (not($pagename =~ m|(.*)/(.*)|)) {
>             $currentParent = $pagename;
>             $linktext = $pagename;
>         } 
>         else {
>             if ($1 eq $currentParent) {
>                 if ($letterGrouping){  $linktext = "$currentParent/$2";}
>                 else { $html .= "... "; $linktext = "/$2";}                
>             } 
>             else {
>                 $linktext = $pagename;
>             }
>         }
>         if ($notFirst){ $notFirst = 1; $linktext = ", $linktext"; }
>         $html .= &GetPageLinkText($pagename,$linktext);
> 
>         if ($letterGrouping){ if ($notFirst){ $html .= ", "; }}
>         else { $html .= "\n<br>"; }
>     }
>     #$html .= "</ol>\n"; # commented to keep a 'original' usemod look
>     $html .= "\n<br>";
>     
>     return $html;
> }
> 
> sub DoLinks {	
> 	print &GetHeader( "", &QuoteHtml( "Full Link List" ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<hr><pre>\n\n\n\n";    # Extra lines to get below the logo
> 
> 	print &PrintLinkList(&GetFullLinkList(
> 		&GetParam("unique", 1),
> 		&GetParam("sort", 1),
> 		&GetParam("page", 1),
> 		&GetParam("inter", 0),
> 		&GetParam("url", 0),
> 		&GetParam("exists", 2),
> 		&GetParam("empty", 0),
> 		&GetParam("search", "")
> 	));
> 	
> 	print "\n</pre>";
> 	print "\n</div>";
> 	print "\n</div></div></body></html>";	
> }
> 
> sub PrintLinkList {
> 	my ( $pagelines, $page,  $names, $editlink );
> 	my ( $link, $text, $extra, @links, %pgExists );
> 	
> 	%pgExists = ();
> 	
> 	foreach $page ( &AllPagesList() ) {
> 		$pgExists{$page} = 1;
> 	}
> 	
> 	$names    = &GetParam( "names",    1 );
> 	$editlink = &GetParam( "editlink", 0 );
> 	
> 	foreach $pagelines (@_) {
> 		@links = ();
> 		
> 		foreach $page ( split( ' ', $pagelines ) ) {
> 			if ( $page =~ /\:/ ) {    # URL or InterWiki form
> 				if ( $page =~ /$UrlPattern/ ) {
> 					( $link, $extra ) = &UrlLink( $page, 0 );    # No images
> 				}
> 				else {
> 					( $link, $extra ) = &InterPageLink( $page, 0 );  # No images
> 				}
> 			}
> 			else {
> 				if ( $pgExists{$page} ) {
> 					$link = &GetPageLink($page);
> 				}
> 				else {
> 					$link = $page;
> 					if ($editlink) {
> 						$link .= &GetEditLink( $page, "?" );
> 					}
> 				}
> 			}
> 			
> 			push( @links, $link );
> 		}
> 		if ( !$names ) {
> 			shift(@links);
> 		}
> 		
> 		$text .= join(' ', @links) . "\n";
> 	}
> 	
> 	return $text;
> }
> 
> sub GetFullLinkList {
> 	my ($unique, $sort, $pagelink, $interlink, $urllink, $exists, $empty, $search, $listWantedPages )= @_ ;
> 	my ($name, $link ); # foreach iterators (though why not use $_ ?)
> 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
> 
> 	#my ($name, $unique, $sort, $exists, $empty, $link, $search);
> 	#my ($pagelink, $interlink, $urllink);	
> 	#$unique = &GetParam("unique", 1);
> 	#$sort = &GetParam("sort", 1);
> 	#$pagelink = &GetParam("page", 1);
> 	#$interlink = &GetParam("inter", 0);
> 	#$urllink = &GetParam("url", 0);
> 	#$exists = &GetParam("exists", 2);
> 	#$empty = &GetParam("empty", 0);
> 	#$search = &GetParam("search", "");
> 	
> 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) {
> 		$pagelink = 0;
> 	}
> 	%pgExists = ();
> 	@pglist   = &AllPagesList();
> 	
> 	foreach $name (@pglist) {
> 		$pgExists{$name} = 1;
> 	}
> 	%seen = ();
> 	
> 	foreach $name (@pglist) {
> 		@newlinks = ();
> 		if ( $unique != 2 ) {
> 			%seen = ();
> 		}
> 		
> 		@links = &GetPageLinks($name, $pagelink, $interlink, $urllink, $listWantedPages);
> 	
> 	    foreach $link (@links) {
> 			if ($link =~ m/^\//){
> 				$name =~ m/(.*)\//;
> 				
> 				if ($1){ $link = $1 . $link; }
> 				else { $link = $name . $link; }
> 			}
> 			
> 			$seen{$link}++;
> 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) {
> 				next;
> 			}
> 			push( @newlinks, $link );
> 		}
> 		
> 		@links = @newlinks;
> 		if ($sort) {
> 			@links = sort(@links);
> 		}
> 		unshift( @links, $name );
> 		
> 		if ( $empty || ( $#links > 0 ) ) {    # If only one item, list is empty.
> 			push( @found, join( ' ', @links ) );
> 		}
> 	}
> 	
> 	return @found;
> }
> 
> sub GetSubpages {
> 	my ($parentPage) = @_;
> 	my ($dir, @subpageFiles, @pages, $subId);
> 	
> 	return "" unless $parentPage;
> 	$dir = GetPageDirectory($parentPage);
> 	
> 	opendir(PAGELIST, "$PageDir/$dir/$parentPage") or return "";
> 	@subpageFiles = readdir(PAGELIST);
> 	closedir(PAGELIST);
> 	
> 	foreach $subId (@subpageFiles) {
> 		if (substr($subId, -3) eq '.db') {
> 		  push(@pages, "$parentPage/" . substr($subId, 0, -3));
> 		}
> 	}
> 	
> 	return @pages;
> }
> 
> sub GetPageList {
> 	my ($pagename, $retval);
> 	my (@list) = @_;
> 
> 	foreach $pagename (@list) {
> 	##	$retval .= ".... " if ($pagename =~ m|/|);
> 		$retval .= "&nbsp;" . &GetPageLink($pagename) . "<br>";
> 	}
> 
> 	return $retval;
> }
> 
> sub GetPageLinks {
> 	my ( $name, $pagelink, $interlink, $urllink, $listWantedPages ) = @_;
> 	my ( $text, @links );
> 	
> 	@links = ();
> 	&OpenPage($name);
> 	&OpenDefaultText();
> 	
> 	$text = $Text{'text'};
> 	$text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
> 	$text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
> 	$text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
> 	$text =~ s/<tt>(.|\n)*?\<\/tt>/ /ig;
> 	
> 	if ($interlink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to inter-site links
> 		$text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$InterLinkPattern/ /g;
> 	}
> 	
> 	if ($urllink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to URLs
> 		$text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$UrlPattern/ /g;
> 	}
> 	
> 	if ($pagelink) {
> 		if ($FreeLinks) {
> 			my $f2 = $FreeLinkPattern;
> 			
> 			$text =~ s/\[\[$f2\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 			$text =~ s/\[\[$f2\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 		}
> 		
> 		if ($listWantedPages){ $text =~ s/\[((.|\n)*?)\]/ /ig; }
> 			
> 		if ($WikiLinks) {
> 			$text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 		}
> 	}
> 	
> 	return @links;
> }
> 
> sub DoPost {
> 	my ( $editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user );
> 	my $string      = &GetParam( "text",        undef );
> 	my $id          = &GetParam( "title",       "" );
> 	my $summary     = &GetParam( "summary",     "" );
> 	my $oldtime     = &GetParam( "oldtime",     "" );
> 	my $oldconflict = &GetParam( "oldconflict", "" );
> 	my $isEdit      = 0;
> 	my $editTime    = $Now;
> 	my $authorAddr  = $ENV{REMOTE_ADDR};
> 	
> 	if ($id =~ /()/){
> 		$id = $1;
> 	}
> 	else {
> 		die "The page name $id is not valid";
> 	}
> 	
> 	if ($FreeLinks){
> 		$id = &FreeToNormal($id);
> 	}
> 	
> 	if ( !&UserCanEdit( $id, 1 ) ) {
> 		# This is an internal interface--we don't need to explain
> 		&ReportError( Ts( 'Editing not allowed for %s.', $id ) );
> 		return;
> 	}
> 	
> 	if (   ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'Sample_Undefined_Page' )
> 		|| ( $id eq 'Sample_Undefined_Page' ) )
> 	{
> 		&ReportError( " $id cannot be defined." );
> 		return;
> 	}
> 	
> 	$string  = &RemoveFS($string);
> 	$summary = &RemoveFS($summary);
> 	$summary =~ s/[\r\n]//g;
> 	
> 	if ( length($summary) > 300 ) {    # Too long (longer than form allows)
> 		$summary = substr( $summary, 0, 300 );
> 	}
> 
> 	# Add a newline to the end of the string (if it doesn't have one)
> 	$string .= "\n" if ( !( $string =~ /\n$/ ) );
> 
> 
> 	# Lock before getting old page to prevent races
> 	# Consider extracting lock section into sub, and eval-wrap it?
> 	# (A few called routines can die, leaving locks.)
> 	if ($LockCrash) {
> 		&RequestLock() or die( "Could not get editing lock" );
> 	}
> 	else {
> 		if ( !&RequestLock() ) {
> 			&ForceReleaseLock('main');
> 		}
> 
> 		# Clear all other locks.
> 		&ForceReleaseLock('cache');
> 		&ForceReleaseLock('diff');
> 		&ForceReleaseLock('index');
> 	}
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$old     = $Text{'text'};
> 	$oldrev  = $Section{'revision'};
> 	$pgtime  = $Section{'ts'};
> 	$preview = 0;
> 	$preview = 1 if ( &GetParam( "Preview", "" ) ne "" );
> 	
> 	if ( !$preview && ( $old eq $string ) ) {    # No changes (ok for preview)
> 		&ReleaseLock();
> 		&ReBrowsePage( $id, "", 1 );
> 		return;
> 	}
> 	
> 	if ( ( $UserID > 399 ) || ( $Section{'id'} > 399 ) ) {
> 		$newAuthor = ( $UserID ne $Section{'id'} );    # known user(s)
> 	}
> 	else {
> 		$newAuthor = ( $Section{'ip'} ne $authorAddr );    # hostname fallback
> 	}
> 	
> 	$newAuthor = 1 if ( $oldrev == 0 );    # New page
> 	$newAuthor = 0 if ( !$newAuthor );     # Standard flag form, not empty
> 	                                       # Detect editing conflicts and resubmit edit
> 	                                       
> 	if ( ( $oldrev > 0 ) && ( $newAuthor && ( $oldtime != $pgtime ) ) ) {
> 		&ReleaseLock();
> 		if ( $oldconflict > 0 ) {    # Conflict again...
> 			&DoEdit( $id, 2, $pgtime, $string, $preview );
> 		}
> 		else {
> 			&DoEdit( $id, 1, $pgtime, $string, $preview );
> 		}
> 		return;
> 	}
> 	
> 	if ($preview) {
> 		&ReleaseLock();
> 		&DoEdit( $id, 0, $pgtime, $string, 1 );
> 		return;
> 	}
> 	
> 	$user = &GetParam( "username", "" );
> 
> 	# If the person doing editing chooses, send out email notification
> 	if ($EmailNotify) {
> 		&EmailNotify( $id, $user )
> 		  if &GetParam( "do_email_notify", "" ) eq 'on';
> 	}
> 	
> 	if ( &GetParam( "recent_edit", "" ) eq 'on' ) {
> 		$isEdit = 1;
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'oldmajor', $Section{'revision'} );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'oldauthor', $Section{'revision'} );
> 	}
> 	
> 	&SaveKeepSection();
> 	&ExpireKeepFile();
> 	
> 	if ($UseDiff) {
> 		&UpdateDiffs( $id, $editTime, $old, $string, $isEdit, $newAuthor );
> 	}
> 	
> 	$Text{'text'}      = $string;
> 	$Text{'minor'}     = $isEdit;
> 	$Text{'newauthor'} = $newAuthor;
> 	$Text{'summary'}   = $summary;
> 	$Section{'host'}   = &GetRemoteHost(1);
> 	
> 	&SaveDefaultText();
> 	&SavePage();
> 	&WriteRcLog( $id, $summary, $isEdit, $editTime, $Section{'revision'}, $user,
> 		$Section{'host'} );
> 
> 	if ($UseCache) {
> 		&UnlinkHtmlCache($id);    # Old cached copy is invalid
> 		if ( $Page{'revision'} < 2 ) {    # If this is a new page...
> 			&NewPageCacheClear($id);      # ...uncache pages linked to this one.
> 		}
> 	}
> 	
> 	if ( $UseIndex && ( $Page{'revision'} == 1 ) ) {
> 		unlink($IndexFile);               # Regenerate index on next request
> 	}
> 	
> 	&ReleaseLock();
> 	&ReBrowsePage( $id, "", 1 );
> }
> 
> sub UpdateDiffs {
> 	my ( $id, $editTime, $old, $new, $isEdit, $newAuthor ) = @_;
> 	my ( $editDiff, $oldMajor, $oldAuthor );
> 	
> 	$editDiff  = &GetDiff( $old, $new, 0 );    # 0 = already in lock
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	if ($UseDiffLog) {
>   		my $editDiff = Diff::diffClassic($old, $new);  # add this line
>   		&WriteDiff($id, $editTime, $editDiff);
> 	}
> 	
> 	&SetPageCache( 'diff_default_minor', $editDiff );
> 	if ( $isEdit || !$newAuthor ) {
> 		&OpenKeptRevisions('text_default');
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'diff_default_major', "1" );
> 	}	
> 	else {
> 		&SetPageCache( 'diff_default_major',
> 			&GetKeptDiff( $new, $oldMajor, 0 ) );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'diff_default_author', "1" );
> 	}	
> 	elsif ( $oldMajor == $oldAuthor ) {
> 		&SetPageCache( 'diff_default_author', "2" );
> 	}
> 	else {
> 		&SetPageCache( 'diff_default_author',
> 			&GetKeptDiff( $new, $oldAuthor, 0 ) );
> 	}
> }
> 
> # Translation note: the email messages are still sent in English
> # Send an email message.
> sub SendEmail {
> 	my ( $to, $from, $reply, $subject, $message ) = @_;
> 
> 	# sendmail options:
> 	#    -odq : send mail to queue (i.e. later when convenient)
> 	#    -oi  : do not wait for "." line to exit
> 	#    -t   : headers determine recipient.
> 	open( SENDMAIL, "| $SendMail -oi -t " ) or die "Can't send email: $!\n";
> 	print SENDMAIL "From: $from\n";
> 	print SENDMAIL "To: $to\n";
> 	print SENDMAIL "Reply-to: $reply\n";
> 	print SENDMAIL "Subject: $subject\n";
> 	print SENDMAIL "$message\n";
> 	close(SENDMAIL) or warn "sendmail didn't close nicely";
> }
> ## Email folks who want to know a note that a page has been modified. - JimM.
> sub EmailNotify {
> 	local $/ = "\n";    # don't slurp whole files in this sub.
> 	
> 	if ($EmailNotify) {
> 		my ( $id, $user ) = @_;
> 		
> 		if ($user) {
> 			$user = " by $user";
> 		}
> 		
> 		my $address;
> 		
> 		return if ( !-f $EmailFile );    # No notifications yet
> 		
> 		open( EMAIL, $EmailFile )
> 		  or die "Can't open $EmailFile: $!\n";
> 		$address = join ",", <EMAIL>;
> 		$address =~ s/\n//g;
> 		close(EMAIL);
> 		
> 		my $home_url        = $q->url();
> 		my $page_url        = $home_url . "?$id";
> 		my $editors_summary = $q->param("summary");
> 
> 		if ( ( $editors_summary eq "*" ) or ( $editors_summary eq "" ) ) {
> 			$editors_summary = "";
> 		}
> 		else {
> 			$editors_summary = " Summary: $editors_summary";
> 		}
> 		
> 		my $content = <<"END_MAIL_CONTENT";
> 
>  The $SiteName page $id at
>    $page_url
>  has been changed$user to revision $Page{revision}. $editors_summary
> 
>  (Replying to this notification will
>   send email to the entire mailing list,
>   so only do that if you mean to.
> 
>   To remove yourself from this list, visit
>   ${home_url}?action=editprefs .)
> END_MAIL_CONTENT
> 		my $subject = "The $id page at $SiteName has been changed.";
> 
> 		# I'm setting the "reply-to" field to be the same as the "to:" field
> 		# which seems appropriate for a mailing list, especially since the
> 		# $EmailFrom string needn't be a real email address.
> 		&SendEmail( $address, $EmailFrom, $address, $subject, $content );
> 	}
> }
> 
> sub SearchTitleAndBody {
> 	my ($term, $filter) = @_;
> 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
> 	
> 	#If the search term has a !preceding it, strip it and set the exclusion flag
> 	if ($term =~ m/^\!/){ 
> 		$excludeTerm = 1;
> 		$term = substr($term, 1);	
> 	}
> 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
> 	if ($filter =~ m/^\!/){ 
> 		$excludeFilter = 1;
> 		$filter = substr($filter, 1);	
> 	}
> 
> 	foreach $name ( &AllPagesList() ) {
> 		if ($excludeFilter){
> 			if ($filter) { next if ($name =~ m/$filter/); }
> 		}
> 		else {
> 			if ($filter) { next unless ($name =~ m/$filter/); }
> 
> 		}
> 		
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if (!$excludeTerm){  
> 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( $freeName =~ /$term/i ) {
> 					push( @found, $name );
> 				}
> 			}
> 		}
> 		else { 
> 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( ! ($freeName =~ /$term/i) ) {
> 					push( @found, $name );
> 				}
> 			}			
> 		}
> 	}
> 	
> 	return @found;
> }
> 
> sub SearchBody {
> 	my ($string) = @_;
> 	my ( $name, @found );
> 	
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if ( $Text{'text'} =~ /$string/i ) {
> 			push( @found, $name );
> 		}
> 	}
> 	
> 	return @found;
> }
> 
> sub UnlinkHtmlCache {
> 	my ($id) = @_;
> 	my $idFile;
> 	
> 	$idFile = &GetHtmlCacheFile($id);
> 	
> 	if ( -f $idFile ) {
> 		unlink($idFile);
> 	}
> }
> 
> sub NewPageCacheClear {
> 	my ($id) = @_;
> 	my $name;
> 	
> 	return if ( !$UseCache );
> 	
> 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
> 	                    # The following code used to search the body for the $id
> 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
> 		&UnlinkHtmlCache($name);
> 	}
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub DoUnlock {
> 	my $LockMessage = "Normal Unlock.";
> 	
> 	print &GetHeader( "", "Removing edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>This operation may take several seconds...</h2>\n";
> 	
> 	if ( &ForceReleaseLock('main') ) {
> 		$LockMessage = "Forced Unlock.";
> 	}
> 	
> 	&ForceReleaseLock('cache');
> 	&ForceReleaseLock('diff');
> 	&ForceReleaseLock('index');
> 	
> 	print "\n<br><h2>$LockMessage</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub WriteRcLog {
> 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
> 	my ( $extraTemp, %extra );
> 	
> 	%extra = ();
> 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
> 	$extra{'name'}     = $name     if ( $name ne "" );
> 	$extra{'revision'} = $revision if ( $revision ne "" );
> 	$extraTemp = join( $FS2, %extra );
> 
> 	# The two fields at the end of a line are kind and extension-hash
> 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
> 	
> 	if ( !open( OUT, ">>$RcFile" ) ) {
> 		die( Ts( '%s log error:', $RCName ) . " $!" );
> 	}
> 	
> 	print OUT $rc_line . "\n";
> 	close(OUT);
> }
> 
> sub WriteDiff {
> 	my ( $id, $editTime, $diffString ) = @_;
> 	
> 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
> 	print OUT "------\n" . $id . "|" . $editTime . "\n";
> 	print OUT $diffString;
> 	close(OUT);
> }
> 
> # Actions are vetoable if someone edits the page before
> # the keep expiry time. For example, page deletion. If
> # no one edits the page by the time the keep expiry time
> # elapses, then no one has vetoed the last action, and the
> # action is accepted.
> # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
> sub ProcessVetos {
> 	my ($expirets);
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	
> 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
> 	
> 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
> 		&DeletePage( $OpenPageName, 1, 1 );
> 		return ( 1, "(deleted)" );
> 	}
> 	
> 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
> 		my $fname = $1;
> 
> 		# Only replace an allowed, existing file.
> 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
> 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
> 				my $string = $1;
> 				
> 				$string =~ s/\r\n/\n/gms;
> 				open( OUT, ">$fname" ) or return 0;
> 				print OUT $string;
> 				close OUT;
> 				
> 				return ( 0, "(replaced)" );
> 			}
> 		}
> 	}
> 	return ( 0, "(done)" );
> }
> 
> sub DoMaintain {
> 	my ( $name, $fname, $data, $message, $status );
> 	
> 	print &GetHeader( "", "Maintenance on all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	$fname = "$DataDir/maintain";
> 	
> 	if ( !&UserIsAdmin() ) {
> 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
> 			print "\nMaintenance not done. ";
> 			print "\n(Maintenance can only be done once every 12 hours.)";
> 			print "\nRemove the 'maintain' file or wait.";
> 			print "\n</div>";
> 			print &GetCommonFooter();
> 			print "\n</div></div></body></html>";
> 			
> 			return;
> 		}
> 	}
> 	
> 	&RequestLock() or die( "Could not get maintain-lock" );
> 
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		( $status, $message ) = &ProcessVetos();
> 		&ExpireKeepFile() unless $status;
> 		
> 		print "\n.... " if ( $name =~ m|/| );
> 		print &GetPageLink($name);
> 		print "\n $message<br>";
> 	}
> 
> 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
> 	&ReleaseLock();
> 
> 	# Do any rename/deletion commands
> 	# (Must be outside lock because it will grab its own lock)
> 	$fname = "$DataDir/editlinks";
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		print "\n<hr>Processing rename/delete commands:<br>";
> 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
> 		unlink("$fname.old");
> 		rename( $fname, "$fname.old" );
> 	}
> 	
> 	if ($MaintTrimRc) {
> 		&RequestLock() or die( "Could not get lock for RC maintenance" );
> 		$status = &TrimRc();                # Consider error messages?
> 		&ReleaseLock();
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Must be called within a lock.
> # Thanks to Alex Schroeder for original code
> sub TrimRc {
> 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
> 
> 	# Determine the number of days to go back
> 	$days = 0;
> 	
> 	foreach (@RcDays) {
> 		$days = $_ if $_ > $days;
> 	}
> 	$starttime = $Now - $days * 24 * 60 * 60;
> 	return 1 if ( !-f $RcFile );    # No work if no file exists
> 	( $status, $data ) = &ReadFile($RcFile);
> 	
> 	if ( !$status ) {
> 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
> 		
> 		return 0;
> 	}
> 
> 	# Move the old stuff from rc to temp
> 	@rc = split( /\n/, $data );
> 	
> 	for ( $i = 0 ; $i < @rc ; $i++ ) {
> 		($ts) = split( /$FS3/, $rc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	
> 	return 1 if ( $i < 1 );    # No lines to move from new to old
> 	
> 	@temp = splice( @rc, 0, $i );
> 
> 	# Write new files and backups
> 	if ( !open( OUT, ">>$RcOldFile" ) ) {
> 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
> 		return 0;
> 	}
> 	print OUT join( "\n", @temp ) . "\n";
> 	close(OUT);
> 	
> 	&WriteStringToFile( $RcFile . '.old', $data );
> 	$data = join( "\n", @rc );
> 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
> 	&WriteStringToFile( $RcFile, $data );
> 	
> 	return 1;
> }
> 
> sub DoMaintainRc {
> 	print &GetHeader( "", "Maintaining RC log", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	&RequestLock() or die( "Could not get lock for RC maintenance" );
> 	
> 	if ( &TrimRc() ) {
> 		print "\n<br>RC maintenance done.<br>";
> 	}
> 	else {
> 		print "\n<br>RC maintenance not done.<br>";
> 	}
> 	&ReleaseLock();
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub UserIsEditorOrError {
> 	if ( !&UserIsEditor() ) {
> 		print "\n<h2>This operation is restricted to site editors only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></body></html>";
> 			
> 		return 0;
> 	}
> 	
> 	return 1;
> }
> 
> sub UserIsAdminOrError {
> 	if ( !&UserIsAdmin() ) {
> 		print "\n<h2>This operation is restricted to administrators only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></body></html>";	
> 		return 0;
> 	}
> 	
> 	return 1;
> }
> 
> sub CheckIsAuthUser {
> 	my ($id) = @_;
> 	my $auth = ""; 
> 	my $found = 0;
> 	my $authtype;
> 	my $authname; 
> 	my $aname;
> 	my $afname;
> 	my $linecount = 0;
> 
> 	if (!(&UserIsAdmin())) {
> 		$aname = $id;
> 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
> 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
> 		
> 		if (-r $afname) {			
> 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
> 			
> 			open (AFN,"<$afname");
> 			while (<AFN>) {
> 				if (/$FS1/) { next; }       	# skip header and footer
> 				if (/^>\s[^\w]/) { next; }  	# skip comments	
> 				if (/diff-/){ next; }		
> 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
> 					$authtype = $1;
> 					$authname = $2; 
> 					
> 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
> 					elsif ($authtype eq "r"){ $authtype = "1"; }
> 					else { $authtype = "1"; }
> 					
> 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
> 				}
> 			}
> 			close AFN;
> 			if ($linecount == 0){ $auth = "3"; }
> 			elsif ($found == 0) { $auth = ""; }
> 		}
> 		else {
> 			$auth = "3";
> 		}
> 	}
> 	else {
> 		$auth = "3";
> 	}
> 	return $auth;
> }
> 
> sub DoEditLock {
> 	my ($fname);
> 	
> 	print &GetHeader( "", "Set or Remove global edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	$fname = "$DataDir/noedit";
> 
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 	
> 	if ( -f $fname ) {
> 		print "\n<h2>Edit lock created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Edit lock removed.</h2>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoPageLock {
> 	my ( $fname, $id );
> 	
> 	print &GetHeader( "", "Set or Remove page edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	# Consider allowing page lock/unlock at editor level?
> 	return if ( !&UserIsAdminOrError() );
> 		
> 	$id = &GetParam( "id", "" );
> 	if ( $id eq "" ) {
> 		print "\n<p>Missing page id to lock/unlock...</p>";
> 		
> 		return;
> 	}
> 	
> 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
> 	$fname = &GetLockedPageFile($id);
> 	
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 
> 	if ( -f $fname ) {
> 		print "\n<h2>Lock for '$id' created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Lock for '$id' removed.</h2>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoEditBanned {
> 	my ( $banList, $status );
> 	
> 	print &GetHeader( "", "Editing Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	return if ( !&UserIsAdminOrError() );
> 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
> 	$banList = "" if ( !$status );
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_ban", 1 );
> 	print "\n<h2> Banned IP/network/host list:</h2>";
> 	print "\nEach entry is either a commented line (starting with #), ";
> 	print "\nor a Perl regular expression (matching either an IP address or ";
> 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
> 	print "\ngive up your admin access (remove password in Preferences).";
> 	print "\n<p><br><b>Example:</b><br><br>";
> 	print "\n# blocks hosts ending with .foocorp.com<br>";
> 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
> 	print "\n# blocks exact IP address<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
> 	print "\n# blocks whole 123.21.3.* IP network<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
> 	print &GetTextArea( 'banlist', $banList, 12, 50 );
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Save' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	;
> }
> 
> sub DoUpdateBanned {
> 	my ( $newList, $fname );
> 	
> 	print &GetHeader( "", "Updating Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$fname = "$DataDir/banlist";
> 	$newList = &GetParam( "banlist", "#Empty file" );
> 	
> 	if ( $newList eq "" ) {
> 		print "\n<p>Empty banned list or error.</p>";
> 		print "\n<p>Resubmit with at least one space character to remove.</p>";
> 	}
> 	elsif ( $newList =~ /^\s*$/s ) {
> 		unlink($fname);
> 		print "\n<p>Removed banned list</p>";
> 	}
> 	else {
> 		&WriteStringToFile( $fname, $newList );
> 		print "\n<p>Updated banned list</p>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # ==== Editing/Deleting pages and links ====
> sub DoEditLinks {
> 	print &GetHeader( "", "Editing Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_links", 1 );
> 	print "\n<h2>Editing/Deleting page titles:</h2>";
> 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
> 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
> 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
> 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
> 	print &GetTextArea( 'commandlist', "", 12, 50 );
> 	print "\n<br><br>";
> 	print $q->checkbox(
> 		-name     => "p_changerc",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Edit $RCName"
> 	);
> 	print "\n<br>";
> 	print $q->checkbox(
> 		-name     => "p_changetext",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Substitute text for rename"
> 	);
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Process Command' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub UpdateLinksList {
> 	my ( $commandList, $doRC, $doText ) = @_;
> 	
> 	if ($doText) {
> 		&BuildLinkIndex();
> 	}
> 	&RequestLock() or die "UpdateLinksList could not get main lock";
> 	unlink($IndexFile) if ($UseIndex);
> 	
> 	foreach ( split( /\n/, $commandList ) ) {
> 		s/\s+$//g;
> 		
> 		next if ( !(/^[=!|?]/) );    # Only valid commands.
> 		print "\nProcessing $_<br>\n";
> 		
> 		if (/^\!(.+)/) {
> 			&DeletePage( $1, $doRC, $doText );
> 		}
> 		elsif (/^\?(.+)/){
> 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
> 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
> 			print "\n<br><br>";
> 		}
> 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
>       		my $GivenPage = $1;
>       		my $GivenNewName = $2;
>       
>       		if ($GivenPage =~ s[\/\*][]) {
>        			print "\nRenaming subpages of $GivenPage too...<br>";
>         
>         		foreach (&AllSubPagesList($GivenPage)) {
> 					my $NewSubName = $_;
> 					
> 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
> 					print "\nrenaming $_ to $NewSubName<br>";
> 					&RenamePage($_, $NewSubName, $doRC, $doText);
> 		        }
>       		}
> 		      # rename the page itself
> 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
> 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
> 		}
> 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
> 			&RenameTextLinks( $1, $2 );
> 		}
> 	}
> 	
> 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
> 	unlink($IndexFile) if ($UseIndex);
> 	&ReleaseLock();
> }
> 
> sub BuildLinkIndex {
> 	my ( @pglist, $page, @links, $link, %seen );
> 	
> 	@pglist    = &AllPagesList();
> 	%LinkIndex = ();
> 	
> 	foreach $page (@pglist) {
> 		&BuildLinkIndexPage($page);
> 	}
> }
> 
> sub BuildLinkIndexPage {
> 	my ($page) = @_;
> 	my ( @links, $link, %seen );
> 	
> 	@links = &GetPageLinks( $page, 1, 0, 0 );
> 	%seen = ();
> 	
> 	foreach $link (@links) {
> 		if ( defined( $LinkIndex{$link} ) ) {
> 			if ( !$seen{$link} ) {
> 				$LinkIndex{$link} .= " " . $page;
> 			}
> 		}
> 		else {
> 			$LinkIndex{$link} .= " " . $page;
> 		}
> 		$seen{$link} = 1;
> 	}
> }
> 
> sub DoUpdateLinks {
> 	my ( $commandList, $doRC, $doText );
> 	
> 	print &GetHeader( "", "Updating Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$commandList = &GetParam( "commandlist", "" );
> 	$doRC        = &GetParam( "p_changerc",  "0" );
> 	$doRC = 1 if ( $doRC eq "on" );
> 	$doText = &GetParam( "p_changetext", "0" );
> 	$doText = 1 if ( $doText eq "on" );
> 	
> 	if ( $commandList eq "" ) {
> 		print "\n<p>Empty command list or error.</p>";
> 	}
> 	else {
> 		&UpdateLinksList( $commandList, $doRC, $doText );
> 		print "\n<p>Finished command list.</p>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub EditRecentChanges {
> 	my ( $action, $old, $new ) = @_;
> 	
> 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
> 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
> }
> 
> sub EditRecentChangesFile {
> 	my ( $fname, $action, $old, $new, $printError ) = @_;
> 	my ( $status, $fileData, $errorText, $rcline, @rclist );
> 	my ( $outrc, $ts, $page, $junk );
> 	
> 	( $status, $fileData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
> 		print $errorText if ($printError);
> 		
> 		return;
> 	}
> 	
> 	$outrc = "";
> 	@rclist = split( /\n/, $fileData );
> 	
> 	foreach $rcline (@rclist) {
> 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
> 		if ( $page eq $old ) {
> 			if ( $action == 1 ) {    # Delete
> 				;                    # Do nothing (don't add line to new RC)
> 			}
> 			elsif ( $action == 2 ) {
> 				$junk = $rcline;
> 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
> 				$outrc .= $junk . "\n";
> 			}
> 		}
> 		else {
> 			$outrc .= $rcline . "\n";
> 		}
> 	}
> 	
> 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
> 	&WriteStringToFile( $fname, $outrc );
> }
> 
> # Delete and rename must be done inside locks.
> sub DeletePage {
> 	my ( $page, $doRC, $doText ) = @_;
> 	my ( $fname, $status );
> 	
> 	$page =~ s/ /_/g;
> 	$page =~ s/\[+//;
> 	$page =~ s/\]+//;
> 	$status = &ValidId($page);
> 	
> 	if ( $status ne "" ) {
> 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$fname = &GetPageFile($page);
> 	unlink($fname) if ( -f $fname );
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	unlink($fname)     if ( -f $fname );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
> 	       # Currently don't do anything with page text
> }
> 
> # Given text, returns substituted text
> sub SubstituteTextLinks {
> 	my ( $old, $new, $text ) = @_;
> 
> 	# Much of this is taken from the common markup
> 	%SaveUrl      = ();
> 	$SaveUrlIndex = 0;
> 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
> 	
> 	if ($RawHtml) {
> 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
> 	}
> 	
> 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
> 	
> 	if ($FreeLinks) {
> 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
> 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
> 	}
> 	
> 	if ($BracketText) {         # Links like [URL text of link]
> 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 	}
> 	
> 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
> 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
> 	
> 	if ($WikiLinks) {
> 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
> 	}
> 
> 	# Thanks to David Claughton for the following fix
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
> }
> 
> sub SubFreeLink {
> 	my ( $link, $name, $old, $new ) = @_;
> 	my ($oldlink);
> 	
> 	$oldlink = $link;
> 	$link =~ s/^\s+//;
> 	$link =~ s/\s+$//;
> 	
> 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
> 	{
> 		$link = $new;
> 	}
> 	
> 	else {
> 		$link = $oldlink;    # Preserve spaces if no match
> 	}
> 	
> 	$link = "[[$link";
> 	
> 	if ( $name ne "" ) {
> 		$link .= "|$name";
> 	}
> 	
> 	$link .= "]]";
> 	
> 	return &StoreRaw($link);
> }
> 
> sub SubWikiLink {
> 	my ( $link, $old, $new ) = @_;
> 	my ($newBracket);
> 	
> 	$newBracket = 0;
> 	
> 	if ( $link eq $old ) {
> 		$link = $new;
> 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
> 			$link = "[[$link]]";
> 		}
> 	}
> 	
> 	return &StoreRaw($link);
> }
> 
> # Rename is mostly copied from expire
> sub RenameKeepText {
> 	my ( $page, $old, $new ) = @_;
> 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
> 	my ( $sectName, $newText );
> 	
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	return if ( !( -f $fname ) );
> 	( $status, $data ) = &ReadFile($fname);
> 	return if ( !$status );
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;
> 	}
> 
> 	# First pass: optimize for nothing changed
> 	$changed = 0;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$changed = 1 if ( $Text{'text'} ne $newText );
> 		}
> 	}
> 	
> 	return if ( !$changed );    # No sections changed
> 	open( OUT, ">$fname" ) or return;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$Text{'text'} = $newText;
> 			$tempSection{'data'} = join( $FS3, %Text );
> 			print OUT $FS1, join( $FS2, %tempSection );
> 		}
> 		else {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
> }
> 
> sub RenameTextLinks {
> 	my ( $old, $new ) = @_;
> 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
> 	my ( $oldCanonical, @pageList );
> 	
> 	$old =~ s/ /_/g;
> 	$oldCanonical = &FreeToNormal($old);
> 	$new =~ s/ /_/g;
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$old =~ s/_/ /g;
> 	$new =~ s/_/ /g;
> 
> 	# Note: the LinkIndex must be built prior to this routine
> 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
> 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
> 	foreach $page (@pageList) {
> 		$changed = 0;
> 		&OpenPage($page);
> 		foreach $section ( keys %Page ) {
> 			if ( $section =~ /^text_/ ) {
> 				&OpenSection($section);
> 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
> 				$oldText = $Text{'text'};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Text{'text'} = $newText;
> 					$Section{'data'} = join( $FS3, %Text );
> 					$Page{$section} = join( $FS2, %Section );
> 					$changed = 1;
> 				}
> 			}
> 			elsif ( $section =~ /^cache_diff/ ) {
> 				$oldText = $Page{$section};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Page{$section} = $newText;
> 					$changed = 1;
> 				}
> 			}
> 
> 			# Add other text-sections (categories) here
> 		}
> 		if ($changed) {
> 			$file = &GetPageFile($page);
> 			&WriteStringToFile( $file, join( $FS1, %Page ) );
> 		}
> 		&RenameKeepText( $page, $old, $new );
> 	}
> }
> 
> sub RenamePage {
> 	my ( $old, $new, $doRC, $doText ) = @_;
> 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
> 	
> 	$old =~ s/ /_/g;
> 	$new    = &FreeToNormal($new);
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$newfname = &GetPageFile($new);
> 	if ( -f $newfname ) {
> 		print "\nRename: new page $new already exists--not renamed.<br>";
> 		return;
> 	}
> 	$oldfname = &GetPageFile($old);
> 	if ( !( -f $oldfname ) ) {
> 		print "\nRename: old page $old does not exist--nothing done.<br>";
> 		return;
> 	}
> 	
> 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
> 	rename( $oldfname, $newfname );
> 	&CreatePageDir( $KeepDir, $new );
> 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
> 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
> 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
> 	rename( $oldkeep, $newkeep );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
> 
> 	if ($doText) {
> 		&BuildLinkIndexPage($new);          # Keep index up-to-date
> 		&RenameTextLinks( $old, $new );
> 	}
> }
> 
> sub DoShowVersion {
> 	print &GetHeader( "", "Displaying Wiki Version", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>NobleWiki</h2>";
> 	print "\n<p>derived from UseModWiki version 1.0</p>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
> 	my ( $id, $status, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
> }
> sub GetGallery {
> 	my ($params) = @_;
> 	my @lines = split(/\r?\n/, $params);
> 	my $lineNum = 0;
> 	my $imageNum = 0;
> 	my %options;
> 	my $images = "";
> 	my $text = "";
> 	
> 	my $defaultImage = "image1.jpg";
> 	my $defaultThumb = "thumb_image1.jpg";
> 	my $image;
> 	my $thumb;
> 	my $title;
> 	my $header;
> 	my $caption;
> 	my $description;
> 	my $thumbWidth = 100;
> 	
> 	$GLOBAL_galleryCount++;
> 		
> 	foreach my $line (@lines){
> 		%options = &GetOptions($line);
> 		
> 		if ($lineNum == 0){
> 			$lineNum++;
> 			
> 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
> 			if ($options{'description'}){ $description = $options{'description'}; }
> 			if ($options{'header'}){ $header = $options{'header'}; }
> 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
> 			
> 			next;	
> 		}
> 		else {		
> 			if ($options{'image'}){ $image = $options{'image'}; }
> 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
> 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
> 			
> 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
> 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
> 			
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
> 				
> 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
> 		}
> 	}
> 	
> 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
> 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
> 	
> 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
> 	
> 	$text .= "\n	    <ul>";	
> 	$text .= $images;
> 	$text .= "\n	    </ul>";
> 	
> 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
> 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
> 	
> 	$text .= "\n	</div>";		
> 	
> 	return $text;
> }
> 
> sub GetFlash {
> 	my ($options) = @_;
> 	my %options = &GetOptions($options);	
> 	my $fpath = "$UploadUrl/";
> 	my $defaultSWF = 'ufo.swf';
> 	my $maxWidth = 400;
> 	my $maxHeight = 300;
> 	my $ratio = 1;
> 	
> 	my $text = "";
> 	
> 	my $fname;
> 	my $fwidth;
> 	my $fheight;
> 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
> 	my $idFO = "FO_$GLOBAL_flashCount";
> 
> 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
> 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
> 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
> 	
> 	if ($fwidth > $maxWidth){
> 		$ratio = $maxWidth / $fwidth;
> 		$fwidth = $maxWidth;
> 		$fheight = int ($ratio * $fheight);
> 	}
> 	elsif ($fheight > $maxHeight){
> 		$ratio = $maxHeight / $fheight;
> 		$fheight = $maxHeight;
> 		$fwidth = int ($ratio * $fwidth);
> 	}
> 			
> 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
> 	
> 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
> 	$text .= "\n<script type='text/javascript'>";
> 	$text .= "\n			var fpath = '$fpath';";
> 	$text .= "\n			var fname = '$fname';";
> 	$text .= "\n			var fwidth = $fwidth;";
> 	$text .= "\n			var fheight = $fheight;";
> 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
> 	$text .= "\n			\$(window).load(function () {";
> 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
> 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
> 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
> 	$text .= "\n		    });";
> 	$text .= "\n		</script>";		
> 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
> 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
> 	$text .= "\n		<p style='clear: both;'></p>";
> 	$text .= "\n	</div>";
> 
> 	$GLOBAL_flashCount++;
> 	
> 	return $text;		
> }
> sub GetAdminBar {
> 	my ($id, $cssClass) = @_;
> 	my ($result);
> 
> 	$result .= "\n<div $cssClass>";
> 	$result .= "Administration: ";
> 	
> 	my ($notValid) = $id =~ /^\d*$/;
> 	
> 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
> 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
> 	} 
> 		
> 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
> 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
> 	
> 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
> 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
> 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
> 	$result .= " | " . &ScriptLink("action=orphans", "List Orphans" );
> 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
> 			
> 	if ( -f "$DataDir/noedit" ) {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
> 	}
> 	else {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
> 	}
> 	
> 	$result .= "</div>";
> 	
> 	return $result;
> }
> 
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
> 	my ($id) = @_;
> 	
> 	return if ( !&ValidIdOrDie($id) );
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
> 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		print "\n<h2>Delete Page?</h2>";
> 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
> 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></body></html>";	
> 		
> 		return;
> 	}
> 	
> 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
> 	print &GetLeftNav("");	
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $id eq $HomePage ) {
> 		print Ts( '%s can not be deleted.', $HomePage );
> 	}
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) {
> 			print Ts( '%s can not be deleted because it is locked.', $id );
> 		}
> 		else {
> 
> 			# Must lock because of RC-editing
> 			&RequestLock() or die( "Could not get editing lock" );
> 			DeletePage( $id, 1, 1 );
> 			&ReleaseLock();
> 			print Ts( '%s has been deleted.', $id );
> 		}
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
> 	print &GetHeader( "", "File Upload Page", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<h2>Select File</h2>";
> 	print "\nThe current upload size limit is $MaxPost.<br>";
> 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
> 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
> 	print "\n<input type='hidden' name='upload' value='1' />";
> 	print "\nFile to Upload: ";
> 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
> 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub SaveUpload {
> 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
> 	print &GetHeader( "", "Upload Finished", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$filename = $q->param('file');
> 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
> 	
> 	$uploadFilehandle = $filename;
> 	open UPLOADFILE, ">$UploadDir$filename";
> 	binmode(UPLOADFILE);	
> 	while (<$uploadFilehandle>) { print UPLOADFILE; }
> 	close UPLOADFILE;
> 	
> 	print "\n<h2>Upload Completed</h2>";
> 	print "\nThe wiki link to your file is:<br><br>";
> 	
> 	$printFilename = $filename;
> 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
> 	$fileUrl = $UploadUrl . $printFilename;
> 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
> 
> 	if ( $filename =~ /${ImageExtensions}$/ ) {
> 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub ConvertFsFile {
> 	my ( $oldFS, $newFS, $fname ) = @_;
> 	my ( $oldData, $newData, $status );
> 	
> 	return if ( !-f $fname );           # Convert only existing regular files
> 	( $status, $oldData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
> 		
> 		return;
> 	}
> 	
> 	$newData = $oldData;
> 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
> 	
> 	return if ( $oldData eq $newData );    # Do not write if the same
> 	&WriteStringToFile( $fname, $newData );
> 
> 	# print $fname . '<br>';    # progress report
> }
> 
> # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
> # Note that top level directory (page/keep/user) contains only dirs
> sub ConvertFsDir {
> 	my ( $oldFS, $newFS, $topDir ) = @_;
> 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	@dirs = sort(@dirs);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$topDir/$dir" );             # Top level directories only
> 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
> 		
> 		opendir( DIRLIST, "$topDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
> 			$fname = "$topDir/$dir/$file";
> 			if ( -f $fname ) {
> 				# print $fname . '<br>';   # progress
> 				&ConvertFsFile( $oldFS, $newFS, $fname );
> 			}
> 			elsif ( -d $fname ) {
> 				opendir( DIRLIST, $fname );
> 				@subFiles = readdir(DIRLIST);
> 				closedir(DIRLIST);
> 				
> 				foreach $subFile (@subFiles) {
> 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
> 					$subFname = "$fname/$subFile";
> 					if ( -f $subFname ) {
> 						# print $subFname . '<br>';   # progress
> 						&ConvertFsFile( $oldFS, $newFS, $subFname );
> 					}
> 				}
> 			}
> 		}
> 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
> 	}
> }
> 
> sub ConvertFsCleanup {
> 	my ($topDir) = @_;
> 	my ( @dirs, $dir );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-f "$topDir/$dir" );             # Remove only files...
> 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
> 		unlink "$topDir/$dir";
> 	}
> }
> 
> sub DoConvert {
> 	my $oldFS = "\xb3";
> 	my $newFS = "\x1e\xff\xfe\x1e";
> 	
> 	print &GetHeader( "", "Convert wiki DB", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";	
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $FS ne $newFS ) {
> 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
> 		return;
> 	}
> 	
> 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
> 	print "\nWiki DB locked for conversion.<br>";
> 	print "\nConverting Wiki DB...<br>";
> 	
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
> 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
> 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
> 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
> 	&ConvertFsCleanup($PageDir);
> 	&ConvertFsCleanup($KeepDir);
> 	&ConvertFsCleanup($UserDir);
> 	
> 	print "\nFinished converting wiki DB.<br>";
> 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> # Remove user-id files if no useful preferences set
> sub DoTrimUsers {
> 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
> 	my ( @dirs, @files, $dir, $file, $item );
> 	
> 	print &GetHeader( "", "Trim wiki users", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$removed = 0;
> 	$maxID   = 1001;
> 	opendir( DIRLIST, $UserDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
> 		
> 		opendir( DIRLIST, "$UserDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
> 				$id    = $1;
> 				$maxID = $id if ( $id > $maxID );
> 				%Data  = ();
> 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
> 				
> 				if ($status) {
> 					%Data =
> 					  split( /$FS1/, $data, -1 )
> 					  ;    # -1 keeps trailing null fields
> 					$keep = 0;
> 					
> 					foreach $item (qw(username password adminpw stylesheet)) {
> 						$keep = 1
> 						  if ( defined( $Data{$item} )
> 							&& ( $Data{$item} ne "" ) );
> 					}
> 					
> 					if ( !$keep ) {
> 						unlink "$UserDir/$dir/$file";
> 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
> 						$removed += 1;
> 					}
> 				}
> 			}
> 		}
> 	}
> 	print Ts( 'Removed %s files.', $removed ) . '<br>';
> 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";	
> }
> 
> sub DoAssetsToc {
> 	## Check $DataDir and see if assets-toc exists
> 	## -- if not, then build TOC
> 	## -- if does, but is older than 1 minute, rebuild TOC
> 	## Return TOC	
> }
> sub DoFilterToc {
> 	## Given @filters, pageIndex, pageSize
> 	## Get TOC from DoAssetsTOC
> 	## Apply @filters; sort, apply pageIndex * pageSize as offset
> 	## Return FilteredTOC	
> }
> sub DoListFiles {
> 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
> 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
> 	my ( $id, $filter, $managedisabled ) = @_;
> 
> 	if ($managedisabled){ 
> 		$targetDir = "$DisabledDir";
> 	}
> 	else {
> 		$targetDir = "$UploadDir";
> 	}
> 
> 	# CREATE array of filters
> 	$filter = lc($filter);
> 	$filter =~ s/\s//go;
> 	if ($filter ne ""){ 
> 		if ($filter =~ m/,/){
> 			@filters = split(',', $filter);
> 			
> 		}
> 		else {
> 			push (@filters, $filter);
> 		}
> 		$term = "using '<em>$filter</em>'";
> 	}
> 		
> 	# READ DIRECTORY	
> 	opendir( DIRLIST, $targetDir );
> 	@list = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	# RUN INCLUSIVE FILTERS
> 	foreach $file (@list){		
> 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
> 		
> 		if ($filter eq ""){  push @includes, $file; next; }
> 		
> 		$qualifies = 0;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;
> 			$include = $item;
> 					
> 			if ($item =~ m/^\!/){ next; }
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
> 		}
> 		
> 		if ($qualifies){ push @includes, $file; }
> 	}
> 
> 	# RUN EXCLUSIVE FILTERS
> 	foreach $file (@includes){
> 		if ($filter eq ""){  push @files, $file; next; }
> 				
> 		$qualifies = 1;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;					
> 			unless ($item =~ m/^\!/){ next; }
> 			$include = substr($item, 1);
> 
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
> 		}
> 		
> 		if ($qualifies){ push @files, $file; }
> 	}
> 	
> 	print &GetHeader( "", "Manage Assets", "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikidiff'>";
> 	
> 	#return if ( !&UserIsEditorOrError() );
> 		
> 	if ($managedisabled){
> 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
> 		
> 		# MOVE file to disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $keeppath){
> 				if (-w $UploadDir){
> 					if (rename($keeppath, $uploadpath)){
> 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
> 		
> 		# MOVE file from disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $uploadpath){
> 				if (-w $DisabledDir){
> 					if (rename($uploadpath, $keeppath)){
> 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
> 	
> 	foreach $file (@files) {
> 		$filecount++;
> 		$linkname = "upload:$file";
> 		
> 		@links = SearchTitleAndBody($file, "", "");
> 		$numlinks = scalar(@links);
> 
> 		$title = "";
> 		$action = "";
> 			
> 		if ($managedisabled){			
> 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td>$file</td>";
> 			print "\n<td align='right'>$size</td>";			
> 			
> 			if ( &UserIsEditorOrAdmin() ){
> 				$title = "Click to re-enable file.";
> 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
> 			}
> 		}
> 		else {		
> 			$uploadpath = "$UploadUrl/$file";
> 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
> 			print "\n<td align='right'>$size</td>";
> 			
> 			if ($numlinks > 0){
> 				$title = "Click to see what pages link to this file.";
> 				$action = "href='$ScriptName?back=$file'";
> 			}
> 			elsif ( &UserIsEditorOrAdmin() ){
> 				$numlinks = "0";
> 				$title = "Click to disable file.";
> 				$action = "href='$ScriptName?action=listfiles&id=$file'";
> 			}		
> 		}
> 
> 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
> 		print "\n</tr>";
> 	}
> 	
> 	if (scalar(@files) == 0){
> 		print "\n<td colspan='4'>No files available</td></tr>";
> 	}
> 	print "\n</table>";
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
> 	print "\n<input type='submit' value='Apply Filter'>";
> 	
> 	
> 	if ($managedisabled){
> 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
> 	}
> 	else {
> 		print "\n<input type='hidden' name='action' value='listfiles'>";
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
> 	}
> 	print "\nUse ! to exclude a term, separate terms with a comma";
> 	print "\n</form>";
> 	print "\n</div>";
> 
> 	print &GetCommonFooter();
> 	print "\n</div></div></body></html>";				
> }
> 
> 
> #END_OF_OTHER_CODE
> &DoWikiRequest() if ( $RunCGI && ( $_ ne 'nocgi' ) );    # Do everything.
> 1;    # In case we are loaded from elsewhere
> 
> # == End of UseModWiki script. ===========================================
> </nowiki></pre>
2d7404
< 
------
GRoWWII|1195627199
39a40
>  /Mutators
------
GRoWWII/Mutators|1195627485
1c1,23
< Describe the new page here.
---
> == List of Mutators =
> Mutators are either categories of rules, or aspects of rules that can be target for adjustment in order to create variety in gameplay via the concept of 'Special Abilities'.  This list is probably complete.
> 
>  Die Roll Modifiers
>  Reinforcements
>  Weather Conditions
>  Initiative
>  Decoys
>  Activations per Impulse
>  Impulse Frequency
>  Regroup
>  Recon
>  Spotter
>  Attack Roll Modifier [ ARM ]
>  Breakpoint Values
>  Tie Breakers
>  Wireless Range
>  Attack Range
>  Movement Rate
>  Attack Dice
>  Defense Value
>  Indication and Application
>  Retreat and Advance
------
CategoryPeople|1195662477
8,12d7
< == Wiki Community =
<  Wiki:WardCunningham
<  MeatBall:SunirShah
<  UseMod:CliffordAdams
< 
------
WikiTemplates/HomePage|1195697194
3c3
< !!!! Information for $NAME$!!
---
> !!!! $PID Information for $NAME$!!
8a10
> [LocalWiki:HomePage upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd]
------
WikiTemplates/HomePage|1195697413
3c3
< !!!! $PID Information for $NAME$!!
---
> !!!! $PID$ Information for $NAME$!!
------
WikiTemplates/HomePage|1195697477
3c3
< !!!! $PID$ Information for $NAME$!!
---
> !!!!Information for $NAME$!!
9a10,11
> $PID$
> 
------
WikiTemplates/HomePage|1195697517
10c10,11
< $PID$
---
>  $PID$
>  $NAME$
------
WikiTemplates/HomePage|1195697759
10,13c10
<  $PID$
<  $NAME$
< 
< [LocalWiki:HomePage upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd]
---
> [LocalWiki:$PID$ upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd]
------
WikiTemplates/HomePage|1195697858
4c4
< ||<b>Image</b>|width=100|style=background-color:#eeeeee;||$UPLOADIMAGE$||
---
> ||<b>Image</b>|width=100|style=background-color:#eeeeee;||[LocalWiki:HomePage$PID$ $UPLOADIMAGE$]||
10d8
< [LocalWiki:$PID$ upload:SAMPLE.churcill.jpg|boxwidth=350|boxfloat=left|float=left|caption=fantaia diaia dias asiasdiasdia asdiasd asdiasd]
------
WikiTemplates/HomePage|1195698052
------
WikiTemplates/HomePage|1195698130
4c4
< ||<b>Image</b>|width=100|style=background-color:#eeeeee;||[LocalWiki:HomePage$PID$ $UPLOADIMAGE$]||
---
> ||<b>Image</b>|width=100|style=background-color:#eeeeee;||$UPLOADIMAGE$||
------
HomePage/RobertKurcina|1195698447
10a13
> upload:homepage-RobertKurcina.jpg
------
HomePage/RobertKurcina|1195698458
13d10
< upload:homepage-RobertKurcina.jpg
------
WikiTemplates|1195698661
62a64,75
> == Related Entries =
>  WikiStyleGuide
>  WikiMarkup
>  WikiTOCs
>  WikiHeadings
>  WikiLists
>  WikiTables
>  WikiImages
>  WikiURLs
>  WikiTemplates
>  WikiGallery
>  WikiFlash
------
AdminActions|1195698762
0a1
> <toc>
111a113
>  WikiAdmin
------
AdminActions|1195698807
111c111
< ====== Related Entries =
---
> == Related Entries =
------
WikiEditing|1195698914
60c60
< ====== Related Entries =
---
> == Related Entries =
------
AdminFeatures|1195698931
0a1
> <toc>
62c63
< ====== Related Entries =
---
> == Related Entries =
63a65
>  WikiAdmin
------
CategoryCategory|1195698979
5c5
< ||CategoryOverview  ||FAQs, TourBusStop, and other information related to the goals of this wiki           ||
---
> ||CategoryOverview  ||FAQs, TourBusStop, and other information related to the goals of this wiki       ||
10,11c10,11
< !!Site-centric      !!Purpose                                                                            !!
< ||CategoryGames     ||Lists of all games grouped by their purpose, with links to their own subsections.  ||
---
> !!Site-centric      !!Purpose                                                                          !!
> ||CategoryGames     ||Lists of all games grouped by their purpose, with links to their own subsections.||
16c16
< ||CategoryMisc      ||A bucket category to catch small things until a separate category can be created.  ||
---
> ||CategoryMisc      ||A bucket category to catch small things until a separate category can be created.||
19c19
< ====== Related Entries =
---
> == Related Entries =
------
CategoryOverview|1195699003
23c23
< ====== Related Entries =
---
> == Related Entries =
------
CategoryPeople|1195699016
8c8
< ====== Related Entries =
---
> == Related Entries =
------
CategoryWiki|1195699033
41c41
< ====== Related Entries =
---
> == Related Entries =
------
GameDesignsInProgress|1195699050
0a1
> <toc>
35c36
< ====== Related Entries =
---
> == Related Entries =
------
HomePage|1195699092
14c14
< ====== Related Entries =
---
> == Related Entries =
------
NobleMission|1195699107
10c10
< ====== Related Entries =
---
> == Related Entries =
------
NoblePursuit|1195699125
0a1
> <toc>
18c19
< ====== Related Entries =
---
> == Related Entries =
------
NoblePursuit|1195699159
1d0
< <toc>
3a2
> <toc>
------
NobleWiki|1195699180
1,2d0
< <toc>
< 
4a2,3
> <toc>
> 
87c86
< ====== Related Entries =
---
> == Related Entries =
------
ReallyLongPage|1195699200
37,38d35
< ====== Related Entries =
<  None
------
WikiFlash|1195699229
34c34
< ====== Related Entries =
---
> == Related Entries =
------
WikiGallery|1195699244
58c59
< ====== Related Entries =
---
> == Related Entries =
------
WikiHeadings|1195699265
22c22
< ====== Related Entries =
---
> == Related Entries =
------
WikiHelp|1195699277
4c4
< ====== Related Entries =
---
> == Related Entries =
------
WikiImages|1195699291
88c88
< ====== Related Entries =
---
> == Related Entries =
------
WikiLists|1195699304
53c53
< ====== Related Entries =
---
> == Related Entries =
------
WikiMarkup|1195699317
94c94
< ====== Related Entries =
---
> == Related Entries =
------
WikiSearch|1195699333
13c13
< ====== Related Entries =
---
> == Related Entries =
------
WikiStyleGuide|1195699347
30c30
< ====== Related Entries =
---
> == Related Entries =
------
WikiTOCs|1195699368
39c39
< ====== Related Entries =
---
> == Related Entries =
------
WikiTables|1195699383
74c74
< ====== Related Entries =
---
> == Related Entries =
------
AdminActions|1195699620
70,72c70,72
< '''Q:''' Is there a way to prune the difflog file? One of my wikis has a 4-meg file. &quot;maintain&quot; does not seem to prune any of the reference log files. -- [UseMod:JerryMuelver JerryMuelver]
< 
< '''A:''' Not within the wiki.  You can simply remove the difflog file--it is not used by the wiki (it is a write-only log).  I probably should have disabled it by default in 1.0  The purpose of the difflog file is to allow an admin to track changes (and possibly undo them) if wanted, but the new <nowiki><tt>KeptPages</tt></nowiki> functionality makes this feature almost useless.  --[UseMod:CliffordAdams CliffordAdams]
---
> <b>Q</b> Is there a way to prune the difflog file? One of my wikis has a 4-meg file. &quot;maintain&quot; does not seem to prune any of the reference log files. -- [UseMod:JerryMuelver JerryMuelver]
> 
> <b>A</b> Not within the wiki.  You can simply remove the difflog file--it is not used by the wiki (it is a write-only log).  I probably should have disabled it by default in 1.0  The purpose of the difflog file is to allow an admin to track changes (and possibly undo them) if wanted, but the new <nowiki><tt>KeptPages</tt></nowiki> functionality makes this feature almost useless.  --[UseMod:CliffordAdams CliffordAdams]
74,76c74,76
< '''Q:''' Is there a parameter to make the wiki spit out the raw wiki text for a page?
< 
< '''A:''' Yes, there is.  :-)  More helpfully, you can use the browse action and add the &quot;raw=1&quot; parameter, like <nowiki><tt>LocalWiki?action=browse&amp;id=Free_Links&amp;raw=1</tt></nowiki>
---
> <b>Q</b> Is there a parameter to make the wiki spit out the raw wiki text for a page?
> 
> <b>A</b> Yes, there is.  :-)  More helpfully, you can use the browse action and add the &quot;raw=1&quot; parameter, like <nowiki><tt>LocalWiki?action=browse&amp;id=Free_Links&amp;raw=1</tt></nowiki>
79,81c79,81
< '''Q:''' I want to ban a user that has set up an account (strange thing for a spammer). Can I just add his username or ID to the ban list or do I have to figure out his IP? --[http://wiki.musicbrainz.org/wiki.pl?DonRedman DonRedman]
< 
< '''A:''' AFAIK there is no possibility to block based on username or id. If you need to block someone, you could use the ip, host name, subnet order (sub)domain.
---
> <b>Q</b> I want to ban a user that has set up an account (strange thing for a spammer). Can I just add his username or ID to the ban list or do I have to figure out his IP? --[http://wiki.musicbrainz.org/wiki.pl?DonRedman DonRedman]
> 
> <b>A</b> AFAIK there is no possibility to block based on username or id. If you need to block someone, you could use the ip, host name, subnet order (sub)domain.
83,85c83,85
< '''Q:''' Is there a way to restore a page that has been spammed, preferably using one of the backup pages?  I saw a reference to &quot;previous author backup&quot;, but haven't discovered if this is what I need, and if so how to trigger it. 
< 
< '''A:''' Click &quot;View other revisions&quot; on the bottom of the page. Then choose the revision. Maybe look at the differences between certain revisions. Click on the right revision. Click on &quot;Edit revision XX of this page&quot;. Then save that old revision. It's now the new version.
---
> <b>Q</b> Is there a way to restore a page that has been spammed, preferably using one of the backup pages?  I saw a reference to &quot;previous author backup&quot;, but haven't discovered if this is what I need, and if so how to trigger it. 
> 
> <b>A</b> Click &quot;View other revisions&quot; on the bottom of the page. Then choose the revision. Maybe look at the differences between certain revisions. Click on the right revision. Click on &quot;Edit revision XX of this page&quot;. Then save that old revision. It's now the new version.
87,89c87,89
< '''Q:''' I want to use a textbox for filling in a new page. Example. I type &quot;Rover&quot; in the textbox, and get sent to URL:  http://www.usemod.com/cgi-bin/wiki.pl?Rover , is there any easy solution?
< 
< '''A:''' Set your <nowiki><tt>$FooterNote</tt></nowiki> variable (in the config) to this:
---
> <b>Q</b> I want to use a textbox for filling in a new page. Example. I type &quot;Rover&quot; in the textbox, and get sent to URL:  http://www.usemod.com/cgi-bin/wiki.pl?Rover , is there any easy solution?
> 
> <b>A</b> Set your <nowiki><tt>$FooterNote</tt></nowiki> variable (in the config) to this:
101,105c101,105
< '''Q:''' I'd like to remove the revision history for a page on my wiki which has been spammed several times.  I've found people link to one of the previous versions which contain the spam.  Is there a simple way to remove the past revisions?  Thank you!
< 
< '''A:''' You may call the maintain action. This will remove versions older than <nowiki><tt>$KeepDays</tt></nowiki>. A more radical way would be to delete the file with all the older versions. This is placed somewhere under keep/ in the <nowiki><tt>$DataDir</tt></nowiki>. Maybe make a backup before removing. Why is it a problem, if people link to some older version of a page? --[UseMod:MarkusLude MarkusLude]
< 
< '''A2:''' Thanks for the advice.  To answer your question, it's a problem because of this: someone puts a link to porn in a wiki page.  I delete this, but the link remains in one of the revisions.  A bunch of other people link to that revision from their porn pages.  Google indexes these.  Now, when someone searches for my wiki in Google, several of the returned hits are pornographic web sites.  Also, users who are curious about the diffs in that page will end up seeing links to porn.  Given my user base, I'd prefer if neither of these happened.  I realize there's a limit to what I can do, but getting rid of old revisions would help.
---
> <b>Q</b> I'd like to remove the revision history for a page on my wiki which has been spammed several times.  I've found people link to one of the previous versions which contain the spam.  Is there a simple way to remove the past revisions?  Thank you!
> 
> <b>A</b> You may call the maintain action. This will remove versions older than <nowiki><tt>$KeepDays</tt></nowiki>. A more radical way would be to delete the file with all the older versions. This is placed somewhere under keep/ in the <nowiki><tt>$DataDir</tt></nowiki>. Maybe make a backup before removing. Why is it a problem, if people link to some older version of a page? --[UseMod:MarkusLude MarkusLude]
> 
> <b>A</b> Thanks for the advice.  To answer your question, it's a problem because of this: someone puts a link to porn in a wiki page.  I delete this, but the link remains in one of the revisions.  A bunch of other people link to that revision from their porn pages.  Google indexes these.  Now, when someone searches for my wiki in Google, several of the returned hits are pornographic web sites.  Also, users who are curious about the diffs in that page will end up seeing links to porn.  Given my user base, I'd prefer if neither of these happened.  I realize there's a limit to what I can do, but getting rid of old revisions would help.
113a114
>  AdminActions
------
WikiURLs|1195699680
34c34
< ====== Related Entries =
---
> == Related Entries =
------
GRoWWII|1195699928
1d0
< <toc 225>
4a3
> <toc 225>
36c35
< ====== Related =
---
> == Related =
------
GRoWWII/TOandE|1195699967
1d0
< <toc 200>
4a3,4
> <toc 200>
> 
------
NoblePursuit|1195700007
2c2
< <toc>
---
> <toc 180>
------
NobleWiki|1195700024
2c2
< <toc>
---
> <toc 170>
------
WikiEditing|1195700088
1,2c1
< <toc>
< = # Wiki Text Formatting Rules =
---
> = Wiki Text Formatting Rules =
6c5,7
< == # Basic Syntax =
---
> <toc 170>
> 
> == Basic Syntax =
16c17
< === # Decoration =
---
> === Decoration =
21c22
< === # Miscellaneous =
---
> === Miscellaneous =
27c28
< == # Advanced Syntax =
---
> == Advanced Syntax =
31c33
< === # Directives =
---
> === Directives =
------
WikiMarkup|1195700184
0a1,2
> = Wiki Markup Syntax =
> 
18,21c20,22
< You create '''bold''' and ''italic'' text by using a repeated "'" single quote character before and after the text to be emphasised.
< Use two quotes for italic and three single quotes for bold.
< eg<pre>
< ''italic'' '''bold''' '''''bold & italic'''''
---
> Create bold and italicized text via HTML tags, eg;
> <pre>
> <b>bold</b> <i>italic</i> <b><i>bold and italic</i></b> <u>underline</u> <s>strikeout</s> <sup>superscript</sup> <sub>subscript</sub><br /> <big>big</big> <small>small</small>
23,25c24,27
< ''italic'' '''bold''' '''''bold & italic'''''
< ----
< Alternatively use HTML tags
---
> <b>bold</b> <i>italic</i> <b><i>bold and italic</i></b> <u>underline</u><s>strikeout</s><sup>superscript</sup>*** <sub>subscript</sub>*** <big>big</big>*** <small>small</small>***
> 
> === Monospace text =
> Create monospace text by using a " " space as the first character on a line,
27c29
< <b>bold</b> <i>italic</i> <b><i>bold and italic</i></b> <u>underline</u> <s>strikeout</s> <sup>superscript</sup> <sub>subscript</sub><br /> <big>big</big> <small>small</small>
---
>  This is text in a monospace font
29,33d30
< <b>bold</b> <i>italic</i> <b><i>bold and italic</i></b> <u>underline</u><s>strikeout</s><sup>superscript</sup>*** <sub>subscript</sub>*** <big>big</big>*** <small>small</small>***
< 
< === Monospace text =
< Create monospace text by using a " " space as the first character on a line,
< eg<pre>
35,36d31
< </pre>
<  This is text in a monospace font
------
WikiImages|1195700312
0a1,2
> = Insert Images into Noble Wiki =
> 
2c5
< == # Images and Assets ==
---
> == Images and Assets ==
25c28
< === # Remote File Linking ===
---
> === Remote File Linking ===
31c34
< === # Local Assets ===
---
> === Local Assets ===
37c40
< === # Alternate Linking ===
---
> === Alternate Linking ===
47c50
< === # Customized Formatting ===
---
> === Customized Formatting ===
------
WikiStyleGuide|1195700352
1,2d0
< <toc>
< 
5a4,5
> <toc>
> 
------
WikiTOCs|1195700419
1c1,3
< == Generating a Table of Contents =
---
> = Generating a Table of Contents =
> The Table of Contents shown here was created automatically by the wiki engine.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section.  If the TOC needs to be of a specific width, insert that value in pixels right before the closing angle bracket as in <tt><nowiki><toc NNN></nowiki></tt>
> 
3,6c6
< === Overview =
< The Table of Contents shown above was created automatically by the wiki engine.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section.  If the TOC needs to be of a specific width, insert that value in pixels right before the closing angle bracket as in <tt><nowiki><toc NNN></nowiki></tt>
< 
< === Example =
---
> == Example =
------
WikiTables|1195700456
0a1,3
> = Creating Tabular Views ==
> Tables can be inserted directly into wiki entries.  Below are two ways of describing how show a table using either custom wiki syntax or using HTML.  The preferred method for this wiki as a practice should be to limit the creation of tables entirely and instead insert images that are bitmap renders of a table.
> 
3,6c6
< == Creating Tabular Views ==
< Tables can be inserted directly into wiki entries.  Below are two ways of describing how show a table using either custom wiki syntax or using HTML.  The preferred method for this wiki as a practice should be to limit the creation of tables entirely and instead insert images that are bitmap renders of a table.
< 
< === Standard Wiki Tables ===
---
> == Standard Wiki Tables ===
26c26
< ==== Cell Alignment ===
---
> === Cell Alignment ===
36c36
< ==== Option Switches ===
---
> === Option Switches ===
------
WikiTemplates|1195700519
0a1,3
> = Using Templated Layouts =
> A template is an entry with a specific layout and place-holder variables.  Any other entry may then make reference to the template and send variables to it.  This allows a standardized presentation of commonly provided information, such as profile pages.
> 
3,5c6
< == Templates =
< A template is an entry with a specific layout and place-holder variables.  Any other entry may then make reference to the template and send variables to it.  This allows a standardized presentation of commonly provided information, such as profile pages.
< 
---
> == Examples =
------
WikiURLs|1195700665
1,3c1
< <toc 225>
< 
< == Page and URL Links =
---
> = Page and URL Links =
8c6,8
< === Plain URLs =
---
> <toc 225>
> 
> == Plain URLs =
11c11
< === Named URLs =
---
> == Named URLs =
14c14
< === On-Site URLS =
---
> == On-Site URLS =
19c19
< === [#anchor] URLs Using Anchors =
---
> == [#anchor] URLs Using Anchors =
22c22
< === [#freelinks] Free Links =
---
> == [#freelinks] Free Links =
27c27
< === <nowiki>LocalWiki</nowiki> =
---
> == <nowiki>LocalWiki</nowiki> =
31c31
< === <nowiki>InterWiki</nowiki> =
---
> == <nowiki>InterWiki</nowiki> =
------
SandBox|1195705167
1,7403d0
< <pre><nowiki>
< #!E:/Program Files/perl/bin/perl.exe
< # UseModWiki version 1.0 (September 12, 2003)
< # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
< # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
< # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
< #    <marcus@ira.uka.de>
< # ...which was based on
< #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
< #    and The Original WikiWikiWeb  (C) Ward Cunningham
< #        <ward@c2.com> (code reused with permission)
< # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
< #
< # This program is free software; you can redistribute it and/or modify
< # it under the terms of the GNU General Public License as published by
< # the Free Software Foundation; either version 2 of the License, or
< # (at your option) any later version.
< #
< # This program is distributed in the hope that it will be useful,
< # but WITHOUT ANY WARRANTY; without even the implied warranty of
< # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< # GNU General Public License for more details.
< #
< # You should have received a copy of the GNU General Public License
< # along with this program; if not, write to the
< #    Free Software Foundation, Inc.
< #    59 Temple Place, Suite 330
< #    Boston, MA 02111-1307 USA
< use Diff;
< use MagicContent;
< use Image::Size;
< 
< package UseModWiki;
< use strict;
< local $| = 1;    # Do not buffer output (localized for mod_perl)
< 
< # Configuration/constant variables:
< use vars qw(@RcDays @HtmlPairs @HtmlSingle
<   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
<   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
<   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
<   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
<   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
<   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
<   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
<   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
<   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
<   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
<   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
<   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
<   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
<   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
<   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
<   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
<   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
<   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine
<   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
<   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
<   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton $HomePagePrefix
<   $EditNameLink $UseMetaWiki @ImageSites $BracketImg $DisabledDir
<   $AllowInclusion $InclusionDir $NumberDatesDelim);
<   
< # Note: $NotifyDefault is kept because it was a config variable in 0.90
< # Other global variables:
< use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
<   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
<   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
<   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
<   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
<   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
<   $ConfigError $UploadPattern $WikiLineHeader $WikiLineHeaderPreview $WikiLineFooter $WikiLineDiff
<   $WikiLine $WikiLine1 $WikiLine2 $WikiLinePref $AutoMailto
<   $GLOBAL_imageCount $GLOBAL_flashCount $GLOBAL_galleryCount
<   $WikiLeftNav %TableCellDefaults $DownloadExtensions
<   );
< 
< # == Configuration =====================================================
< $DataDir = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/wiki";    # Main wiki directory
< $UseConfig = 0;    # 1 = use config file,    0 = do not look for config
< $ConfigFile = "$DataDir/config";    # Configuration file
< 
< # Default configuration (used if UseConfig is 0)
< $CookieName = "NobleWiki";          # Name for this wiki (for multi-wiki sites)
< $SiteName   = "Noble Pursuit Games Wiki";          # Name of site (used for titles)
< $HomePage   = "HomePage";           # Home page (change space to _)
< $HomePagePrefix = "HomePage";      # Which page will be linked when a valid $username is clicked in the RC history.
< $RCName     = "RecentChanges";      # Name of changes page (change space to _)
< $LogoUrl    = "";                   # URL for site logo ("" for no logo)
< $ENV{PATH}  = "/usr/bin/";          # Path used to find "diff"
< $ScriptTZ   = "";                   # Local time zone ("" means do not print)
< $RcDefault  = 7;                    # Default number of RecentChanges days
< @RcDays     = qw(1 3 7 30 90 180);  # Days for links on RecentChanges
< $KeepDays   = 14;                   # Days to keep old revisions
< $SiteBase   = "";                   # Full URL for <BASE> header
< 
< 								    # Set if the auto-detected URL is wrong
< $FullUrl    = "http://wiki.kurcina.org/cgi-bin/index.cgi";                                 
< $RedirType  = 1;                    # 1 = CGI.pm, 2 = script, 3 = no redirect
< $AdminPass  = "linhson";            # Set to non-blank to enable password(s)
< $EditPass   = "emerald";            # Like AdminPass, but for editing only
< $StyleSheet = "/css/wiki.default.css";   # URL for CSS stylesheet (like "/wiki.css")
< $NotFoundPg = "PageNotFound";       # Page for not-found links ("" for blank pg)
< $EmailFrom  = "NobleWiki";          # Text for "From: " field of email notes.
< $SendMail   = "/usr/sbin/sendmail"; # Full path to sendmail executable
< $AutoMailto = 1;					# 0 = off; 1 = convert email address automatically to mailTo:<address>
< 									# HTML for bottom of every page
< $FooterNote = "<a href='?action=editprefs'><div id='anylogo' title='access username'>&nbsp;</div></a>";                   
< 
< $EditNote   = "";                   # HTML notice above buttons on edit page
< $MaxPost    = 1024 * 5000;          # Maximum 210K posts (about 200K for pages)
< $NewText    = "";                   # New page text ("" for default message)
< $HttpCharset      = "";           # Charset for pages, like "iso-8859-2"
< 
< $InterWikiMoniker = "NobleWiki";  # InterWiki moniker for this wiki. (for RSS)
< $SiteDescription  = $SiteName;    # Description of this wiki. (for RSS)
< $RssLogoUrl       = "";           # Optional image for RSS feed
< $EarlyRules       = "";           # Local syntax rules for wiki->html (evaled)
< $LateRules        = "";           # Local syntax rules for wiki->html (evaled)
< $KeepSize         = 0;            # If non-zero, maximum size of keep file
< $BGColor          = "";           # Background color ('' to disable)
< $DiffColor1       = "#ffffaf";    # Background color of old/deleted text
< $DiffColor2       = "#cfffcf";    # Background color of new/added text
< $FavIcon          = "";           # URL of bookmark/favorites icon, or ''
< $RssDays          = 7;            # Default number of days in RSS feed
< $UserGotoBar      = "";           # HTML added to end of goto bar
< $UserGotoBar     .= "<a href='$ScriptName?WikiHelp'>Help</a>";
< 
< $UserHeader       = "";           # Optional HTML header additional content
< $UserHeader		 .= "\n<link rel='stylesheet' type='text/css' media='screen' href='/css/jquery.lightbox-0.4.css'/>";
< $UserHeader      .= "\n<script src='/js/jquery-1.2.1.js'></script>";
< $UserHeader      .= "\n<script src='/js/ufo.js'></script>";
< $UserHeader		 .= "\n<script src='/js/jquery.lightbox-0.4.js'></script>";
< 
< $UserBody         = "";           # Optional <BODY> tag additional content
< $StartUID         = 1001;         # Starting number for user IDs
< 								  # Full path (like /foo/www/uploads) for files
< $UploadDir        = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/docs/attachments";
< 								  # Full URL (like http://foo.com/uploads)
< $UploadUrl        = "http://wiki.kurcina.org/attachments";
< $DisabledDir      = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org/disabled";
<       
< @ImageSites       = qw();         # Url prefixes of good image sites: ()=all
< 
< # Major options:
< $UseSubpage  = 1;             # 1 = use subpages,       0 = do not use subpages
< $UseCache    = 0;             # 1 = cache HTML pages,   0 = generate every page
< $EditAllowed = 1;             # 1 = editing allowed,    0 = read-only
< $RawHtml     = 0;             # 1 = allow <HTML> tag,   0 = no raw HTML in pages
< $HtmlTags    = 1;             # 1 = "unsafe" HTML tags, 0 = only minimal tags
< $UseDiff     = 1;             # 1 = use diff features,  0 = do not use diff
< $FreeLinks   = 1;             # 1 = use [[word]] links, 0 = LinkPattern only
< $WikiLinks   = 1;             # 1 = use LinkPattern,    0 = use [[word]] only
< $AdminDelete = 1;             # 1 = Admin only deletes, 0 = Editor can delete
< $RunCGI      = 1;             # 1 = Run script as CGI,  0 = Load but do not run
< $EmailNotify = 0;             # 1 = use email notices,  0 = no email on changes
< $EmbedWiki   = 0;             # 1 = no headers/footers, 0 = normal wiki pages
< $DeletedPage = "DeletedPage"; # 0 = disable, 'PageName' = tag to delete page
< $ReplaceFile = "ReplaceFile"; # 0 = disable, 'PageName' = indicator tag
< @ReplaceableFiles = ();       # List of allowed server files to replace
< $TableSyntax      = 1;        # 1 = wiki syntax tables, 0 = no table syntax
< $NewFS            = 1;        # 1 = new multibyte $FS,  0 = old $FS
< $UseUpload        = 1;        # 1 = allow uploads,      0 = no uploads
< $AllowInclusion = 1;          # 1 = files (*.txt,*.html) may be included by include:file.html,
< 	                          # 0 = files will not be included
< 	                          # from where shall the files be included?
< $InclusionDir = "$DataDir/includes-data";
<   
< # Minor options:
< $LogoLeft     = 1;    # 1 = logo on left,       0 = logo on right
< $RecentTop    = 1;    # 1 = recent on top,      0 = recent on bottom
< $UseDiffLog   = 1;    # 1 = save diffs to log,  0 = do not save diffs
< $KeepMajor    = 1;    # 1 = keep major rev,     0 = expire all revisions
< $KeepAuthor   = 1;    # 1 = keep author rev,    0 = expire all revisions
< $ShowEdits    = 0;    # 1 = show minor edits,   0 = hide edits by default
< $HtmlLinks    = 1;    # 1 = allow A HREF links, 0 = no raw HTML links
< $SimpleLinks  = 0;    # 1 = only letters,       0 = allow _ and numbers
< $NonEnglish   = 0;    # 1 = extra link chars,   0 = only A-Za-z chars
< $ThinLine     = 0;    # 1 = fancy <hr> tags,    0 = classic wiki <hr>
< $BracketText  = 1;    # 1 = allow [URL text],   0 = no link descriptions
< $UseAmPm      = 0;    # 1 = use am/pm in times, 0 = use 24-hour times
< $UseIndex     = 0;    # 1 = use index file,     0 = slow/reliable method
< $UseHeadings  = 1;    # 1 = allow = h1 text =,  0 = no header formatting
< $NetworkFile  = 1;    # 1 = allow remote file:, 0 = no file:// links
< $BracketWiki  = 1;    # 1 = [WikiLnk txt] link, 0 = no local descriptions
< $UseLookup    = 1;    # 1 = lookup host names,  0 = skip lookup (IP only)
< $FreeUpper    = 1;    # 1 = force upper case,   0 = do not force case
< $FastGlob     = 1;    # 1 = new faster code,    0 = old compatible code
< $MetaKeywords = 1;    # 1 = Google-friendly,    0 = search-engine averse
< $NamedAnchors = 1;    # 0 = no anchors, 1 = enable anchors,
<                       # 2 = enable but suppress display
< $SlashLinks   = 0;    # 1 = use script/action links, 0 = script?action
< $UpperFirst   = 1;    # 1 = free links start uppercase, 0 = no ucfirst
< $AdminBar     = 1;    # 1 = admins see admin links, 0 = no admin bar
< $RepInterMap  = 0;    # 1 = intermap is replacable, 0 = not replacable
< $ConfirmDel   = 1;    # 1 = delete link confirm page, 0 = immediate delete
< $MaskHosts    = 0;    # 1 = mask hosts/IPs,      0 = no masking
< $LockCrash    = 0;    # 1 = crash if lock stuck, 0 = auto clear locks
< $HistoryEdit  = 0;    # 1 = edit links on history page, 0 = no edit links
< $OldThinLine  = 0;    # 1 = old ==== thick line, 0 = ------ for thick line
< $NumberDates  = 1;    # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
< $NumberDatesDelim = "-"; # If $NumberDates is 1, this character separate the year, month, day
< $ParseParas   = 1;    # 1 = new paragraph markup, 0 = old markup
< $AuthorFooter = 1;    # 1 = show last author in footer, 0 = do not show
< $AllUpload    = 0;    # 1 = anyone can upload,   0 = only editor/admins
< $LimitFileUrl = 1;    # 1 = limited use of file: URLs, 0 = no limits
< $MaintTrimRc  = 1;    # 1 = maintain action trims RC, 0 = only maintainrc
< $SearchButton = 1;    # 1 = search button on page, 0 = old behavior
< $EditNameLink = 0;    # 1 = edit links use name (CSS), 0 = '?' links
< $UseMetaWiki  = 0;    # 1 = add MetaWiki search links, 0 = no MW links
< $BracketImg   = 1;    # 1 = [url url.gif] becomes image link, 0 = no img
< 
< $WikiLineHeader = "\n<div class='wikilineheader'></div>";
< $WikiLineHeaderPreview = "\n<div class='wikilineheaderpreview'></div>";
< $WikiLineFooter = "\n<div class='wikilinefooter'></div>";
< $WikiLineDiff   = "\n<div class='wikilinediff'></div>";
< $WikiLinePref   = "\n<div class='wikilinepref'></div>";
< $WikiLine       = "\n<div class='wikiline'></div>";
< $WikiLine1      = "\n<div class='wikiline1'></div>";
< $WikiLine2      = "\n<div class='wikiline2'></div>";
< 
< # Names of sites.  (The first entry is used for the number link.)
< @IsbnNames = ( 'bn.com', 'amazon.com', 'search' );
< 
< # Full URL of each site before the ISBN
< @IsbnPre = (
< 	"http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=",
< 	"http://www.amazon.com/exec/obidos/ISBN=",
< 	"http://www.pricescan.com/books/BookDetail.asp?isbn="
< );
< 
< # Rest of URL of each site after the ISBN (usually '')
< @IsbnPost = ( "", "", "" );
< 
< # HTML tag lists, enabled if $HtmlTags is set.
< # Scripting is currently possible with these tags,
< # so they are *not* particularly "safe".
< # Tags that must be in <tag> ... </tag> pairs:
< @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
<   em s strike strong tt var div center blockquote ol ul dl caption);
< 
< # Single tags (that do not require a closing /tag)
< @HtmlSingle = qw(br p hr li dt dd tr td th);
< @HtmlPairs  = ( @HtmlPairs, @HtmlSingle );     # All singles can also be pairs
< 
< # == You should not have to change anything below this line. =============
< $IndentLimit = 20;                             # Maximum depth of nested lists
< $PageDir     = "$DataDir/page-data";           # Stores page data
< $HtmlDir     = "$DataDir/html-version";        # Stores HTML versions
< $UserDir     = "$DataDir/user-data";           # Stores user data
< $KeepDir     = "$DataDir/keep-data";           # Stores kept (old) page data
< $TempDir     = "$DataDir/temp-files";          # Temporary files and locks
< $LockDir     = "$TempDir/lock-dir";            # DB is locked if this exists
< $InterFile   = "$DataDir/intermap";            # Interwiki site->url map
< $RcFile      = "$DataDir/recent-log";          # New RecentChanges logfile
< $RcOldFile   = "$DataDir/oldrecent-log";       # Old RecentChanges logfile
< $IndexFile   = "$DataDir/page-index";          # List of all pages
< $EmailFile   = "$DataDir/email-list";          # Email notification lists
< if ($RepInterMap) {
< 	push @ReplaceableFiles, $InterFile;
< }
< 
< # The "main" program, called at the end of this script file.
< sub DoWikiRequest {
< 	if ( $UseConfig && ( -f $ConfigFile ) ) {
< 		$ConfigError = "";
< 		if ( !do $ConfigFile ) {               # Some error occurred
< 			$ConfigError = $@;
< 			if ( $ConfigError eq "" ) {
< 
< 			  # Unfortunately, if the last expr returns 0, one will get a false
< 			  # error above.  To remain compatible with existing installs the
< 			  # wiki must not report an error unless there is error text in $@.
< 			  # (Errors in "use strict" may not have error text.)
< 			  # Uncomment the line below if you want to catch use strict errors.
< 			  #       $ConfigError = "Unknown Error (no error text)";
< 			}
< 		}
< 	}
< 	&InitLinkPatterns();
< 	if ( !&DoCacheBrowse() ) {
< 		eval $BrowseCode;
< 		&InitRequest() or return;
< 		if ( !&DoBrowseRequest() ) {
< 			eval $OtherCode;
< 			&DoOtherRequest();
< 		}
< 	}
< }
< 
< # == Common and cache-browsing code ====================================
< sub InitLinkPatterns {
< 	my ( $UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim );
< 
< 	# Field separators are used in the URL-style patterns below.
< 	if ($NewFS) {
< 		$FS = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
< 	}
< 	else {
< 		$FS = "\xb3";                # The FS character is a superscript "3"
< 	}
< 	
< 	$FS1         = $FS . "1";  # The FS values are used to separate fields
< 	$FS2         = $FS . "2";  # in stored hashtables and other data structures.
< 	$FS3         = $FS . "3";  # The FS character is not allowed in user data.
< 	$UpperLetter = "[A-Z";
< 	$LowerLetter = "[a-z";
< 	$AnyLetter   = "[A-Za-z";
< 	
< 	if ($NonEnglish) {
< 		$UpperLetter .= "\xc0-\xde";
< 		$LowerLetter .= "\xdf-\xff";
< 		
< 		if ($NewFS) {
< 			$AnyLetter .= "\x80-\xff";
< 		}
< 		else {
< 			$AnyLetter .= "\xc0-\xff";
< 		}
< 	}
< 	if ( !$SimpleLinks ) {
< 		$AnyLetter .= "_0-9";
< 	}
< 	
< 	$UpperLetter .= "]";
< 	$LowerLetter .= "]";
< 	$AnyLetter   .= "]";
< 
< 	# Main link pattern: lowercase between uppercase, then anything
< 	$LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
< 
< 	# Optional subpage link pattern: uppercase, lowercase, then anything
< 	$LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
< 	if ($UseSubpage) {
< 
< 		# Loose pattern: If subpage is used, subpage may be simple name
< 		$LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
< 
< 		# Strict pattern: both sides must be the main LinkPattern
< 		# $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
< 	}
< 	else {
< 		$LinkPattern = "($LpA)";
< 	}
< 	
< 	$QDelim = '(?:"")?';    # Optional quote delimiter (not in output)
< 	$AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
< 	$LinkPattern .= $QDelim;
< 
< 	# Inter-site convention: sites must start with uppercase letter
< 	# (Uppercase letter avoids confusion with URLs)
< 	$InterSitePattern = $UpperLetter . $AnyLetter . "+";
< 	$InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
< 	
< 	if ($FreeLinks) {
< 
< 		# Note: the - character must be first in $AnyLetter definition
< 		if ($NonEnglish) {
< 			if ($NewFS) {
< 				$AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
< 			}
< 			else {
< 				$AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
< 			}
< 		}
< 		else {
< 			$AnyLetter = "[-,.()' _0-9A-Za-z]";
< 		}
< 	}
< 	$FreeLinkPattern = "($AnyLetter+";
< 	if ($UseSubpage) {
< 		$FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+";
< 	}
< 	
< 	if ($NamedAnchors){
< 		$FreeLinkPattern .= "(?:#(?:\\w+))?)";
< 	}
< 	else {
< 		$FreeLinkPattern .= ")";
< 	}
< 	
< 	$FreeLinkPattern .= $QDelim;
< 
< 	# Url-style links are delimited by one of:
< 	#   1.  Whitespace                           (kept in output)
< 	#   2.  Left or right angle-bracket (< or >) (kept in output)
< 	#   3.  Right square-bracket (])             (kept in output)
< 	#   4.  A single double-quote (")            (kept in output)
< 	#   5.  A $FS (field separator) character    (kept in output)
< 	#   6.  A double double-quote ("")           (removed from output)
< 	$UrlProtocols    = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|prospero|telnet|gopher";
< 	$UrlProtocols   .= '|file' if ( $NetworkFile || !$LimitFileUrl );
< 	
< 	$UrlPattern      = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
< 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
< 	$DownloadExtensions = "(pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)";
< 	$RFCPattern      = "RFC\\s?(\\d+)";
< 	$ISBNPattern     = "ISBN:?([0-9- xX]{10,})";
< 	$UploadPattern   = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
< }
< 
< # Simple HTML cache
< sub DoCacheBrowse {
< 	my ( $query, $idFile, $text );
< 	return 0 if ( !$UseCache );
< 	$query = $ENV{'QUERY_STRING'};
< 	if ( ( $query eq "" ) && ( $ENV{'REQUEST_METHOD'} eq "GET" ) ) {
< 		$query = $HomePage;    # Allow caching of home page.
< 	}
< 	if ( !( $query =~ /^$LinkPattern$/ ) ) {
< 		if ( !( $FreeLinks && ( $query =~ /^$FreeLinkPattern$/ ) ) ) {
< 			return 0;          # Only use cache for simple links
< 		}
< 	}
< 	$idFile = &GetHtmlCacheFile($query);
< 	if ( -f $idFile ) {
< 		local $/ = undef;      # Read complete files
< 		open( INFILE, "<$idFile" ) or return 0;
< 		$text = <INFILE>;
< 		close INFILE;
< 		print $text;
< 		return 1;
< 	}
< 	return 0;
< }
< 
< sub GetHtmlCacheFile {
< 	my ($id) = @_;
< 	return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
< }
< 
< sub GetPageDirectory {
< 	my ($id) = @_;
< 	
< 	if ( $id =~ /^([a-zA-Z])/ ) { return uc($1); }
< 	
< 	return "other";
< }
< 
< sub T {
< 	my ($text) = @_;
< 	
< 	if ( defined( $Translate{$text} ) && ( $Translate{$text} ne "" ) ) {
< 		return $Translate{$text};
< 	}
< 	
< 	return $text;
< }
< 
< sub Ts {
< 	my ( $text, $string ) = @_;
< 	
< 	$text = T($text);
< 	$text =~ s/\%s/$string/;
< 	
< 	return $text;
< }
< 
< sub Tss {
< 	my $text = @_[0];
< 	
< 	$text = T($text);
< 	$text =~ s/\%([1-9])/$_[$1]/ge;
< 	
< 	return $text;
< }
< 
< # == Normal page-browsing and RecentChanges code =======================
< $BrowseCode = "";    # Comment next line to always compile (slower)
< 
< #$BrowseCode = <<'#END_OF_BROWSE_CODE';
< use CGI;
< use CGI::Carp qw(fatalsToBrowser);
< 
< sub InitRequest {
< 	my @ScriptPath = split( '/', "$ENV{SCRIPT_NAME}" );
< 	
< 	$CGI::POST_MAX = $MaxPost;
< 	
< 	if ($UseUpload) {
< 		$CGI::DISABLE_UPLOADS = 0;    # allow uploads
< 	}
< 	else {
< 		$CGI::DISABLE_UPLOADS = 1;    # no uploads
< 	}
< 	
< 	if ($SlashLinks && length($ENV{'PATH_INFO'}>1)){
< 		$ENV{'QUERY_STRING'} .= '&' if($ENV{'QUERY_STRING'});
< 		$ENV{'QUERY_STRING'} .= substr($ENV{'PATH_INFO'},1);
< 	}
< 	
< 	$q = new CGI();
< 	
< 	if ($SlashLinks){
< 		my $numberOfSlashes = ($ENV{'PATH_INFO'} = tr[/][/]);
< 		$ScriptName = ('../' x $numberOfSlashes) . $ScriptName;
< 	}
< 
< 	# Fix some issues with editing UTF8 pages (if charset specified)
< 	if ( $HttpCharset ne "" ) {
< 		$q->charset($HttpCharset);
< 	}
< 	$Now           = time;                # Reset in case script is persistent
< 	$ScriptName    = pop(@ScriptPath);    # Name used in links
< 		
< 	$IndexInit     = 0;                   # Must be reset for each request
< 	$InterSiteInit = 0;
< 	%InterSite     = ();
< 	$MainPage     = ".";    # For subpages only, the name of the top-level page
< 	$OpenPageName = "";     # Currently open page
< 	&CreateDir($DataDir);   # Create directory if it doesn't exist
< 
< 	if ( !-d $DataDir ) {
< 		&ReportError( "Could not create $DataDir : $!" );
< 		return 0;
< 	}
< 	&InitCookie();          # Reads in user data
< 	return 1;
< }
< 
< sub InitCookie {
< 	%SetCookie      = ();
< 	$TimeZoneOffset = 0;
< 	undef $q->{'.cookies'};    # Clear cache if it exists (for SpeedyCGI)
< 	%UserData   = ();                        # Fix for persistent environments.
< 	%UserCookie = $q->cookie($CookieName);
< 	$UserID     = $UserCookie{'id'};
< 	$UserID =~ s/\D//g;                      # Numeric only
< 	
< 	if ( $UserID < 200 ) {
< 		$UserID = 111;
< 	}
< 	else {
< 		&LoadUserData($UserID);
< 	}
< 	if ( $UserID > 199 ) {
< 		if (   ( $UserData{'id'} != $UserCookie{'id'} )
< 			|| ( $UserData{'randkey'} != $UserCookie{'randkey'} ) )
< 		{
< 			$UserID   = 113;
< 			%UserData = ();    # Invalid.  Consider warning message.
< 		}
< 	}
< 	if ( $UserData{'tzoffset'} != 0 ) {
< 		$TimeZoneOffset = $UserData{'tzoffset'} * ( 60 * 60 );
< 	}
< }
< 
< sub DoBrowseRequest {
< 	my ( $id, $action, $text );
< 	
< 	if ( !$q->param ) {        # No parameter
< 		&BrowsePage($HomePage);
< 		return 1;
< 	}
< 	$id = &GetParam( 'keywords', "" );
< 	if ($id) {                 # Just script?PageName
< 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
< 			$id = &FreeToNormal($id);
< 		}
< 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
< 			$id = $NotFoundPg;
< 		}
< 		&BrowsePage($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	$action = lc( &GetParam( 'action', "" ) );
< 	$id = &GetParam( 'id', "" );
< 	
< 	if ( $action eq 'browse' ) {
< 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
< 			$id = &FreeToNormal($id);
< 		}
< 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
< 			$id = $NotFoundPg;
< 		}
< 		&BrowsePage($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	elsif ( $action eq 'rc' ) {
< 		&BrowsePage($RCName);
< 		return 1;
< 	}
< 	elsif ( $action eq 'random' ) {
< 		&DoRandom();
< 		return 1;
< 	}
< 	elsif ($action eq 'orphans') {
< 		&DoOrphanList();
< 		return 1;
< 	} 
< 	elsif ($action eq 'history') {
< 		&DoHistory($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	
< 	return 0;    # Request not handled
< }
< 
< sub BrowsePage {
< 	my ($id) = @_;
< 	my ( $fullHtml, $oldId, $allDiff, $showDiff, $openKept );
< 	my ( $revision, $goodRevision, $diffRevision, $newText );
< 	my ( $fragHtml );
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$openKept = 0;
< 	$revision = &GetParam( 'revision', "" );
< 	$revision =~ s/\D//g;    # Remove non-numeric chars
< 	$goodRevision = $revision;    # Non-blank only if exists
< 
< 	if ( $revision ne "" ) {
< 		&OpenKeptRevisions('text_default');
< 		$openKept = 1;
< 		if ( !defined( $KeptRevisions{$revision} ) ) {
< 			$goodRevision = "";
< 		}
< 		else {
< 			&OpenKeptRevision($revision);
< 		}
< 	}
< 
< 	# Raw mode: just untranslated wiki text
< 	if ( &GetParam( 'raw', 0 ) ) {
< 		print &GetHttpHeader('text/plain');
< 		print $Text{'text'};
< 		return;
< 	}
< 	$newText = $Text{'text'};              # For differences
< 	                                       # Handle a single-level redirect
< 	$oldId   = &GetParam( 'oldid', "" );
< 	if (   ( $oldId eq "" )
< 		&& ( substr( $Text{'text'}, 0, 10 ) eq '#REDIRECT ' ) )
< 	{
< 		$oldId = $id;
< 		if ( ($FreeLinks) && ( $Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/ ) ) {
< 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/ );
< 			$id = &FreeToNormal($id);
< 		}
< 		else {
< 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+(\S+)/ );
< 		}
< 		if ( &ValidId($id) eq "" ) {
< 
< 			# Consider revision in rebrowse?
< 			&ReBrowsePage( $id, $oldId, 0 );
< 			return;
< 		}
< 		else {    # Not a valid target, so continue as normal page
< 			$id    = $oldId;
< 			$oldId = "";
< 		}
< 	}
< 	$MainPage = $id;
< 	$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
< 	$fullHtml = &GetHeader( $id, &QuoteHtml($id), $oldId );
< 
< 	unless( $id eq $RCName ){ $fullHtml .= &GetLeftNav($id); }
< 	if ( $UseDiff && $showDiff ) {
< 		$fullHtml .= "\n<div class='wikiadmin'>";
< 	}
< 	else {
< 		unless ($id eq $RCName){ $fullHtml .= "\n<div class='wikitext'>"; }
< 		else { $fullHtml .= "\n<div class='wikiadmin'>"; }
< 	}
< 	
< 		if ( $revision ne "" ) {
< 		if ( ( $revision eq $Page{'revision'} ) || ( $goodRevision ne "" ) ) {
< 			$fragHtml = "\n<div class='wikidifftexttitle'>Showing revision $revision.</div>";
< 		}
< 		else {
< 			$fragHtml = "\n<div class='wikidifftexttitle'>Revision $revision not available, showing current revision instead.</div>";
< 		}
< 	}
< 	
< 	$fullHtml .= $fragHtml;
< 	
< 	$allDiff = &GetParam( 'alldiff', 0 );
< 	if ( $allDiff != 0 ) {
< 		$allDiff = &GetParam( 'defaultdiff', 1 );
< 	}
< 	
< 	if (
< 		(
< 			( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName )
< 		)
< 		&& &GetParam( 'norcdiff', 1 )
< 	  )
< 	{
< 		$allDiff = 0;    # Only show if specifically requested
< 	}
< 	
< 	$showDiff = &GetParam( 'diff', $allDiff );
< 	
< 	if ( $UseDiff && $showDiff ) {
< 		$diffRevision = $goodRevision;
< 		$diffRevision = &GetParam( 'diffrevision', $diffRevision );
< 
< 		# Eventually try to avoid the following keep-loading if possible?
< 		&OpenKeptRevisions('text_default') if ( !$openKept );
< 		$fullHtml .= &GetDiffHTML( $showDiff, $id, $diffRevision, $revision, $newText );
< 		$fullHtml .= $fragHtml;
< 
< 	}
< 
< 	# magiccontent patch - tarquin
< 	# Refactored and added position functionality --DavidClaughton.
< 	my ($magiccommand, $magicpos, $magicparams);
< 	my ($magicHTML, $magicDiv, $wikiHTML) = ("", "", "");
< 	
< 	if ( ($magicpos, $magiccommand, $magicparams) = $Text{'text'} =~ m[^\#MAGIC\s*(?:\@(top|bottom))?\s*(\w*)\s*(.*)\n] ){
< 		$Text{'text'} =~ s/^\#MAGIC.*\n//; # kill the magic command line in source
< 		$wikiHTML = &WikiToHTML($Text{'text'});
< 		
< 		#$magicDiv = "\n<hr>\n"; # Remove if using CSS.
< 		
< 		# call: MakeSection( current page, magic module, line of parameters)
< 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
< 		
< 		if (lc $magicpos eq "top"){
< 			$fullHtml .= $magicHTML . $magicDiv . $wikiHTML;
< 		}
< 		else {
< 			$fullHtml .= $wikiHTML . $magicDiv . $magicHTML;
< 		}
< 	}
< 	else {
< 		$fullHtml .= &WikiToHTML($Text{'text'});
< 	}
< 	
< 	if ( !&GetParam( 'embed', $EmbedWiki ) ) {
< 		$fullHtml .= "</div>";
< 		$fullHtml .= $WikiLineFooter;
< 	}
< 
< 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) )
< 	{
< 		print $fullHtml;
< 		print $WikiLineDiff;
< 		print &GetLeftNav($id);
< 		print "\n<div class='wikidiff'>";
< 		&DoRc(1);
< 		print "\n</div>";
< 		print "\n$WikiLineFooter" if ( !&GetParam( 'embed', $EmbedWiki ) );
< 
< 		print &GetFooterText( $id, $goodRevision );
< 		print "\n</div></div></body></html>";
< 		
< 		return;
< 	}
< 	
< 	$fullHtml .= &GetFooterText( $id, $goodRevision );
< 	$fullHtml .= "</div></div></body></html>";
< 	print $fullHtml;
< 	
< 	return
< 	
< 	if ( $showDiff || ( $revision ne "" ) );    # Don't cache special version
< 	&UpdateHtmlCache( $id, $fullHtml ) if ( $UseCache && ( $oldId eq "" ) );
< }
< 
< sub ReBrowsePage {
< 	my ( $id, $oldId, $isEdit ) = @_;
< 	
< 	if ( $oldId ne "" ) {    
< 		# Target of #REDIRECT (loop breaking)
< 		print &GetRedirectPage( "action=browse&id=$id&oldid=$oldId", $id, $isEdit );
< 	}
< 	else {
< 		print &GetRedirectPage( $id, $id, $isEdit );
< 	}
< }
< 
< sub DoRc {
< 	my ($rcType) = @_;       # 0 = RSS, 1 = HTML
< 	my ( $fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly );
< 	my ( @fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML );
< 	my $starttime = 0;
< 	my $showbar   = 0;
< 	
< 	if ( 0 == $rcType ) {
< 		$showHTML = 0;
< 	}
< 	else {
< 		$showHTML = 1;
< 	}
< 	
< 	if ( &GetParam( "from", 0 ) ) {
< 		$starttime = &GetParam( "from", 0 );
< 		if ($showHTML) {
< 			print "\n<h2>";
< 			print "\nUpdates since " . &TimeToText($starttime);
< 			print "\n</h2>";
< 		}
< 	}
< 	else {
< 		$daysago = &GetParam( "days", 0 );
< 		$daysago = &GetParam( "rcdays", 0 ) if ( $daysago == 0 );
< 		if ($daysago) {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $daysago );
< 			if ($showHTML) {
< 				print "\n<h2>";
< 				print Ts( 'Updates in the last %s day' . ( ( $daysago != 1 ) ? "s" : "" ), $daysago );
< 				print "\n</h2>";
< 			}
< 
< 			# Note: must have two translations (for "day" and "days")
< 			# Following comment line is for translation helper script
< 			# Ts('Updates in the last %s days', '');
< 		}
< 	}
< 	
< 	if ( $starttime == 0 ) {
< 		if ( 0 == $rcType ) {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RssDays );
< 		}
< 		else {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RcDefault );
< 		}
< 		if ($showHTML) {
< 			print "\n<h2>";
< 			print Ts('Updates in the last %s day'. ( ( $RcDefault != 1 ) ? "s" : "" ),$RcDefault );
< 			print "\n</h2>";
< 		}
< 
< 		# Translation of above line is identical to previous version
< 	}
< 
< 	# Read rclog data (and oldrclog data if needed)
< 	( $status, $fileData ) = &ReadFile($RcFile);
< 	$errorText = "";
< 	
< 	if ( !$status ) {
< 		# Save error text if needed.
< 		$errorText = "\n<p><strong>";
< 		$errorText .= "Could not open $RCName log file";
< 		$errorText .= ":</strong> $RcFile</p>";
< 		$errorText .= "Error was ";
< 		$errorText .= ":<pre>$!</pre><p>";
< 		$errorText .= "Note: This error is normal if no changes have been made.";
< 
< 	}
< 	@fullrc = split( /\n/, $fileData );
< 	$firstTs = 0;
< 	
< 	if ( @fullrc > 0 ) {    # Only false if no lines in file
< 		($firstTs) = split( /$FS3/, $fullrc[0] );
< 	}
< 	if ( ( $firstTs == 0 ) || ( $starttime <= $firstTs ) ) {
< 		( $status, $oldFileData ) = &ReadFile($RcOldFile);
< 		if ($status) {
< 			@fullrc = split( /\n/, $oldFileData . $fileData );
< 		}
< 		else {
< 			if ( $errorText ne "" ) {    
< 			
< 				# could not open either rclog file
< 				print $errorText;
< 				print "\n<p><strong>";
< 				print "\nCould not open old $RCName log file";
< 				print "\n:</strong> $RcOldFile</p>";
< 				print "\nError was";
< 				print "\n:<pre>$!</pre>";
< 				
< 				return;
< 			}
< 		}
< 	}
< 	$lastTs = 0;
< 	if ( @fullrc > 0 ) {                 
< 		# Only false if no lines in file
< 		($lastTs) = split( /$FS3/, $fullrc[$#fullrc] );
< 	}
< 	$lastTs++ if ( ( $Now - $lastTs ) > 5 );    # Skip last unless very recent
< 	$idOnly = &GetParam( "rcidonly", "" );
< 	
< 	if ( $idOnly && $showHTML ) {
< 		print "\n<b>(";
< 		print "\nfor ";
< 		print &ScriptLink( $idOnly, $idOnly );
< 		print "\n only";
< 		print "\n)</b><br>";
< 	}
< 	
< 	if ($showHTML) {
< 		foreach $i (@RcDays) {
< 			print "\n | " if $showbar;
< 			$showbar = 1;
< 			print &ScriptLink( "action=rc&days=$i",
< 				Ts( '%s day' . ( ( $i != 1 ) ? 's' : '' ), $i ) );
< 
< 			# Note: must have two translations (for "day" and "days")
< 			# Following comment line is for translation helper script
< 			# Ts('%s days', '');
< 		}
< 		print "\n<br><br>";
< 		print &ScriptLink( "action=rc&from=$lastTs", "List new changes starting from" );
< 		print "\n " . &TimeToText($lastTs);
< 		print "\n<br><br>";
< 	}
< 	
< 	$i = 0;
< 	while ( $i < @fullrc ) {    
< 		# Optimization: skip old entries quickly
< 		($ts) = split( /\W/, $fullrc[$i] );
< 		if ( $ts >= $starttime ) {
< 			$i -= 1000 if ( $i > 0 );
< 			last;
< 		}
< 		$i += 1000;
< 	}
< 	
< 	$i -= 1000 if ( ( $i > 0 ) && ( $i >= @fullrc ) );
< 	for ( ; $i < @fullrc ; $i++ ) {
< 		($ts) = split( /\W/, $fullrc[$i] );
< 		last if ( $ts >= $starttime );
< 	}
< 	
< 	if ( $i == @fullrc && $showHTML ) {
< 		print "\n<br><strong>";
< 		print "\nNo updates since ";
< 		print &TimeToText($starttime);
< 		print "\n</strong><br>";
< 	}
< 	else {
< 		splice( @fullrc, 0, $i );    # Remove items before index $i
< 		
< 		# Consider an end-time limit (items older than X)
< 		if ( 0 == $rcType ) {
< 			print &GetRcRss(@fullrc);
< 		}
< 		else {
< 			print &GetRcHtml(@fullrc);
< 		}
< 	}
< 	
< 	if ($showHTML) {
< 		print "\nPage generated ";
< 		print &TimeToText($Now);
< 		print "\n<br>";
< 	}
< }
< 
< sub GetRc {
< 	my $rcType = shift;
< 	my @outrc  = @_;
< 	my ( $rcline,   $date, $newtop, $author, $inlist,   $result );
< 	my ( $showedit, $link, $all,    $idOnly, $headItem, $item );
< 	my ( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp );
< 	my ( $rcchangehist, $tEdit, $tChanges, $tDiff );
< 	my ( $headList, $historyPrefix, $diffPrefix );
< 	my %extra      = ();
< 	my %changetime = ();
< 	my %pagecount  = ();
< 
< 	# Slice minor edits
< 	$showedit = &GetParam( "rcshowedit", $ShowEdits );
< 	$showedit = &GetParam( "showedit",   $showedit );
< 	if ( $showedit != 1 ) {
< 		my @temprc = ();
< 		foreach $rcline (@outrc) {
< 			( $ts, $pagename, $summary, $isEdit, $host ) =
< 			  split( /$FS3/, $rcline );
< 			if ( $showedit == 0 ) {    # 0 = No edits
< 				push( @temprc, $rcline ) if ( !$isEdit );
< 			}
< 			else {                     # 2 = Only edits
< 				push( @temprc, $rcline ) if ($isEdit);
< 			}
< 		}
< 		@outrc = @temprc;
< 	}
< 
< 	# Optimize param fetches out of main loop
< 	$rcchangehist = &GetParam( "rcchangehist", 1 );
< 
< 	# Optimize translations out of main loop
< 	$tEdit         = "(edit)";
< 	$tDiff         = "(diff)";
< 	$tChanges      = "changes";
< 	$diffPrefix    = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
< 	$historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
< 	
< 	foreach $rcline (@outrc) {
< 		( $ts, $pagename ) = split( /$FS3/, $rcline );
< 		$pagecount{$pagename}++;
< 		$changetime{$pagename} = $ts;
< 	}
< 	
< 	$date     = "";
< 	$all      = &GetParam( "rcall", 0 );
< 	$all      = &GetParam( "all", $all );
< 	$newtop   = &GetParam( "rcnewtop", $RecentTop );
< 	$newtop   = &GetParam( "newtop", $newtop );
< 	$idOnly   = &GetParam( "rcidonly", "" );
< 	$inlist   = 0;
< 	$headList = "";
< 	$result   = "";
< 	@outrc    = reverse @outrc if ($newtop);
< 
< 	foreach $rcline (@outrc) {
< 		( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp ) =
< 		  split( /$FS3/, $rcline );
< 		next if ( ( !$all ) && ( $ts < $changetime{$pagename} ) );
< 		next if ( ( $idOnly ne "" ) && ( $idOnly ne $pagename ) );
< 		
< 		%extra = split( /$FS2/, $extraTemp, -1 );
< 		
< 		if ( $date ne &CalcDay($ts) ) {
< 			$date = &CalcDay($ts);
< 			if ( 1 == $rcType ) {    # HTML
< 				                     # add date, properly closing lists first
< 				if ($inlist) {
< 					$result .= "</ul>";
< 					$inlist = 0;
< 				}
< 				$result .= "\n<p><strong>" . $date . "</strong></p>";
< 				if ( !$inlist ) {
< 					$result .= "\n<ul>";
< 					$inlist = 1;
< 				}
< 			}
< 		}
< 		
< 		if ( 0 == $rcType ) {        # RSS
< 			( $headItem, $item ) = &GetRssRcLine(
< 				$pagename,          $ts,
< 				$host,              $extra{'name'},
< 				$extra{'id'},       $summary,
< 				$isEdit,            $pagecount{$pagename},
< 				$extra{'revision'}, $diffPrefix,
< 				$historyPrefix
< 			);
< 			$headList .= $headItem;
< 			$result   .= $item;
< 		}
< 		else {                       # HTML
< 			$result .= &GetHtmlRcLine(
< 				$pagename,          $ts,
< 				$host,              $extra{'name'},
< 				$extra{'id'},       $summary,
< 				$isEdit,            $pagecount{$pagename},
< 				$extra{'revision'}, $tEdit,
< 				$tDiff,             $tChanges,
< 				$all,               $rcchangehist
< 			);
< 		}
< 	}
< 	
< 	if ( 1 == $rcType ) {
< 		$result .= "</ul>" if ($inlist);    # Close final tag
< 	}
< 	
< 	return ( $headList, $result );            # Just ignore headList for HTML
< }
< 
< sub GetRcHtml {
< 	my ( $html, $extra );
< 	
< 	( $extra, $html ) = &GetRc( 1, @_ );
< 	
< 	return $html;
< }
< 
< sub GetHtmlRcLine {
< 	my (
< 		$pagename, $timestamp, $host,      $userName, $userID,
< 		$summary,  $isEdit,    $pagecount, $revision, $tEdit,
< 		$tDiff,    $tChanges,  $all,       $rcchangehist
< 	  )
< 	  = @_;
< 	my ( $author, $sum, $edit, $count, $link, $html );
< 	
< 	$html = "";
< 	$host = &QuoteHtml($host);
< 	
< 	if ( defined($userName) && defined($userID) ) {
< 		$author = &GetAuthorLink( $host, $userName, $userID );
< 	}
< 	else {
< 		$author = &GetAuthorLink( $host, "", 0 );
< 	}
< 	
< 	$sum = "";
< 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$summary = &QuoteHtml($summary);
< 		$sum     = "<strong>[$summary]</strong> ";
< 	}
< 	
< 	$edit  = "";
< 	$edit  = "<em>$tEdit</em> " if ($isEdit);
< 	$count = "";	
< 	
< 	if ( ( !$all ) && ( $pagecount > 1 ) ) {
< 		$count = "($pagecount ";
< 		if ($rcchangehist) {
< 			$count .= &GetHistoryLink( $pagename, $tChanges, "Click to view revision history" );
< 		}
< 		else {
< 			$count .= $tChanges;
< 		}
< 		$count .= ") ";
< 	}
< 	
< 	$link = "";
< 	
< 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) { $link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  "; }
< 	
< 	$link .= &GetPageLink($pagename);
< 	$html .= "\n<li>$link ";
< 	$html .= &CalcTime($timestamp) . " : $count$edit" . " $sum";
< 	$html .= ". . . . . $author";
< 	
< 	return $html;
< }
< 
< sub GetRcRss {
< 	my ( $rssHeader, $headList, $items );
< 
< 	# Normally get URL from script, but allow override
< 	$FullUrl         = $q->url( -full => 1 ) if ( $FullUrl eq "" );
< 	$QuotedFullUrl   = &QuoteHtml($FullUrl);
< 	$SiteDescription = &QuoteHtml($SiteDescription);
< 	
< 	my $ChannelAbout = &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
< 	
< 	$rssHeader = <<RSS ;
< <?xml version="1.0" encoding="ISO-8859-1"?>
< <rdf:RDF
<     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
<     xmlns="http://purl.org/rss/1.0/"
<     xmlns:dc="http://purl.org/dc/elements/1.1/"
<     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
< >
<     <channel rdf:about="$ChannelAbout">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
<         <description>${\(&QuoteHtml($SiteDescription))}</description>
<         <wiki:interwiki>
<             <rdf:Description link="$QuotedFullUrl">
<                 <rdf:value>$InterWikiMoniker</rdf:value>
<             </rdf:Description>
<         </wiki:interwiki>
<         <items>
<             <rdf:Seq>
< RSS
< 	( $headList, $items ) = &GetRc( 0, @_ );
< 	$rssHeader .= $headList;
< 	return <<RSS ;
< $rssHeader
<             </rdf:Seq>
<         </items>
<     </channel>
<     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <url>$RssLogoUrl</url>
<         <link>$QuotedFullUrl</link>
<     </image>
< $items
< </rdf:RDF>
< RSS
< }
< 
< sub GetRssRcLine {
< 	my (
< 		$pagename, $timestamp,  $host,   $userName,
< 		$userID,   $summary,    $isEdit, $pagecount,
< 		$revision, $diffPrefix, $historyPrefix
< 	  )
< 	  = @_;
< 	my (
< 		$itemID,     $description, $authorLink, $author, $status,
< 		$importance, $date,        $item,       $headItem
< 	);
< 
< 	# Add to list of items in the <channel/>
< 	$itemID = $FullUrl
< 	  . &ScriptLinkChar()
< 	  . &GetOldPageParameters( 'browse', $pagename, $revision );
< 	$itemID   = &QuoteHtml($itemID);
< 	$headItem = "                <rdf:li rdf:resource=\"$itemID\"/>";
< 
< 	# Add to list of items proper.
< 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$description = &QuoteHtml($summary);
< 	}
< 	
< 	$host = &QuoteHtml($host);
< 	if ($userName) {
< 		$author     = &QuoteHtml($userName);
< 		$authorLink = "link=\"$QuotedFullUrl?$author\"";
< 	}
< 	else {
< 		$author = $host;
< 	}
< 	
< 	$status     = ( 1 == $revision ) ? 'new'   : 'updated';
< 	$importance = $isEdit            ? 'minor' : 'major';
< 	$timestamp += $TimeZoneOffset;
< 	
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($timestamp);
< 	
< 	$year += 1900;
< 	$date = sprintf( "%4d-%02d-%02dT%02d:%02d:%02d+%02d:00", $year, $mon + 1, $mday, $hour, $min, $sec, $TimeZoneOffset / ( 60 * 60 ) );
< 	$pagename = &QuoteHtml($pagename);
< 
< 	# Write it out longhand
< 	$item = <<RSS ;
<     <item rdf:about="$itemID">
<         <title>$pagename</title>
<         <link>$QuotedFullUrl?$pagename</link>
<         <description>$description</description>
<         <dc:date>$date</dc:date>
<         <dc:contributor>
<             <rdf:Description wiki:host="$host" $authorLink>
<                 <rdf:value>$author</rdf:value>
<             </rdf:Description>
<         </dc:contributor>
<         <wiki:status>$status</wiki:status>
<         <wiki:importance>$importance</wiki:importance>
<         <wiki:diff>$diffPrefix$pagename</wiki:diff>
<         <wiki:version>$revision</wiki:version>
<         <wiki:history>$historyPrefix$pagename</wiki:history>
<     </item>
< RSS
< 	return ( $headItem, $item );
< }
< 
< sub DoRss {
< 	print "\nContent-type: text/xml\n\n";
< 	&DoRc(0);
< }
< 
< sub DoRandom {
< 	my ( $id, @pageList );
< 	
< 	@pageList = &AllPagesList();       # Optimize?
< 	$id       = $pageList[ int( rand( $#pageList + 1 ) ) ];
< 	
< 	&ReBrowsePage( $id, "", 0 );
< }
<    
< sub DoHistory {
< 	my ($id) = @_;
< 	my ( $html, $canEdit, $row, $newText );
< 
< 	print &GetHeader( "", Ts( 'History of %s', $id ), "" );
< 	print &GetLeftNav($id);
< 	print "\n<div class='wikiadmin'>";
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$newText = $Text{'text'};
< 	$canEdit = 0;
< 	$canEdit = &UserCanEdit($id) if ($HistoryEdit);
< 		
< 	if ($UseDiff) {
<       print "\n<form id='wikiform' action='$ScriptName' method='get'>";
<       print "\n<input type='hidden' name='action' value='browse'/>";
<       print "\n<input type='hidden' name='diff' value='1'/>";
<       print "\n<input type='hidden' name='id' value=\"$id\"/>";
<       print "\n<table class='wikihistory' border='0' width='90%'>";
< 	}
< 	
< 	$html = &GetHistoryLine( $id, $Page{'text_default'}, $canEdit, $row++ );
< 	&OpenKeptRevisions('text_default');
< 	
< 	foreach ( reverse sort { $a <=> $b } keys %KeptRevisions ) {
< 		next if ( $_ eq "" );    # (needed?)
< 		$html .= &GetHistoryLine( $id, $KeptRevisions{$_}, $canEdit, $row++ );
< 	}
< 	
< 	print $html;
< 	
< 	if ($UseDiff) {
< 		my $label = "Compare";
< 		
< 		print "\n<tr><td align='center'><br>";
< 		print "\n<input type='submit' value='$label'/>&nbsp;&nbsp;</td></tr></table></form>";
< 		print &GetDiffHTML( &GetParam( 'defaultdiff', 1 ), $id, "", "", $newText );
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 
< 	print "\n</div></div></body></html>";
< }
< 
< sub GetMaskedHost {
< 	my ($text) = @_;
< 	my ($logText);
< 	if ( !$MaskHosts ) {
< 		return $text;
< 	}
< 	$logText = "(logged)";
< 	if ( !( $text =~ s/\d+$/$logText/ ) ) { # IP address (ending numbers masked)
< 		$text =~ s/^[^\.\(]+/$logText/;     # Host name: mask until first .
< 	}
< 	return $text;
< }
< 
< sub GetHistoryLine {
< 	my ( $id, $section, $canEdit, $row ) = @_;
< 	my ( $html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor );
< 	my ( %sect, %revtext );
< 	
< 	%sect = split( /$FS2/, $section, -1 );
< 	%revtext = split( /$FS3/, $sect{'data'} );
< 	$rev     = $sect{'revision'};
< 	$summary = $revtext{'summary'};
< 	
< 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) { $host = $sect{'host'}; }
< 	else { $host = $sect{'ip'};	}
< 	
< 	$host     = &GetMaskedHost($host);
< 	$user     = $sect{'username'};
< 	$uid      = $sect{'id'};
< 	$ts       = $sect{'ts'};
< 	$minor    = "";
< 	$minor    = "<i>(edited) </i>" if ( $revtext{'minor'} );
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 
< 	if ($UseDiff) {
< 		my ( $c1, $c2 );
< 		
< 		$c1 = "checked='checked'" if 1 == $row;
< 		$c2 = "checked='checked'" if 0 == $row;
< 		$html .= "\n<tr>";
< 		$html .= "\n<td align='center'>";
< 		$html .= "\n<input type='radio' name='diffrevision' value='$rev' $c1/>";
< 		$html .= "\n<input type='radio' name='revision' value='$rev' $c2/>";
< 		$html .= "</td><td>";
< 	}
< 	
< 	if ( 0 == $row ) {    
< 		# current revision
< 		$html .= &GetPageLinkText( $id, Ts( 'RevisionB %s', $rev ) ) . ' ';
< 		
< 		if ($canEdit) {
< 			$html .= &GetEditLink( $id, "Edit" ) . ' ';
< 		}
< 	}
< 	else {
< 		$html .= &GetOldPageLink( 'browse', $id, $rev, Ts( 'RevisionA %s', $rev ) ) . ' ';
< 		if ($canEdit) {
< 			$html .= &GetOldPageLink( 'edit', $id, $rev, "Edit" ) . ' ';
< 		}
< 	}
< 	
< 	$html .= "\n<td>" . &TimeToText($ts) . "</td>";
< 	$html .= "\n<td> by " . &GetAuthorLink( $host, $user, $uid ) . " $minor</td>";
< 	
< 	if ( defined($summary) && ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$summary = &QuoteHtml($summary);    # Thanks Sunir! :-)
< 		$html .= "\n<td>[$summary]</td>";
< 	}
< 	else {
< 		$html .= "\n<td>&nbsp;</td>";
< 	}
< 	
< 	$html .= $UseDiff ? "</tr>" : "\n<br>";
< 	
< 	return $html;
< }
< 
< # ==== HTML and page-oriented functions ====
< sub ScriptLinkChar {
< 	if ($SlashLinks) { return '/'; }
< 	
< 	return '?';
< }
< 
< sub ScriptLink {
< 	my ( $action, $text ) = @_;
< 	
< 	return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\" class='wikiscriptlink' title='Click to visit page'>$text</a>";
< }
< 
< sub ScriptLinkClass {
< 	my ( $action, $text, $class, $title ) = @_;
< 	my $result = "<a href='$ScriptName" . &ScriptLinkChar() . "$action' class='$class' title='$title'>$text</a>";
< 	
< 	return $result;
< }
< 
< sub ScriptLinkLeftNav {
< 	my ($id, $action, $target, $label, $type) = @_;
< 	my $html;
< 	my $title;
< 	my $class;	
< 	
< 	if ($type eq "1"){
< 		if ($action eq $target){ $html .= "\n<li class='disabled'>$label</li>"; }
< 		else { $html .= "\n<li><a class='wikipagelink' title='Click to visit this page.' href='\?action=$target'>$label</a></li>"; }	
< 		
< 	}
< 	else {
< 		my $authtype = &CheckIsAuthUser($target);
< 		
< 		if ($authtype eq ""){
< 			$title = "This page is private.";
< 			$class = "wikipagelink private";
< 			$label .= "!";
< 		}
< 		elsif ( $authtype eq "1"){
< 			$title = "Click to visit this locked page.";
< 			$class = "wikipagelink locked";
< 			$label .= "&not;";
< 		}
< 		else {
< 			$title = "Click to visit this page.";
< 			$class = "wikipagelink";		
< 		}
< 		
< 		if ($id eq $target){ $html .= "\n<li class='selected'>$label</li>"; }
< 		else { $html .= "\n<li><a class='$class' title='$title' href='\?$target'>$label</a></li>"; }		
< 	}
< }
< 
< sub GetOrphanLink {
< 	return &ScriptLink("action=orphans", 'Orphans');
< }
< 
< sub DoOrphanList {
< 	print &GetHeader("", &QuoteHtml('Full Orphan List'), "");
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print &PrintPageList( "", &GetOrphanList() );
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub GetOrphanList {
< 	my @found;	
< 	my %seen = ();
< 	my @pglist = &AllPagesList();
< 	
< 	foreach my $name (@pglist) { $seen{$name} = 0; }
< 	
< 	# pages linked from menu bar aren't orphans
< 	$seen{$HomePage} = 1;
< 	$seen{$RCName} = 1;
< 	
< 	foreach my $name (@pglist) {
< 		my @links = &GetPageLinks($name, 1, 0, 0, 0);
< 		
< 		foreach my $link (@links) {
< 			#don't include self links
< 			unless ($link eq $name) {
< 				$seen{$link}++ if exists $seen{$link};
< 			}
< 		}
< 	}
< 	
< 	foreach my $name (sort keys %seen) { push(@found, $name) if $seen{$name} < 1; }
< 	
< 	return @found;
< }
< 
< 
< sub GetPageLinkText {
< 	my ( $id, $name ) = @_;
< 	$id =~ s|^/|$MainPage/|;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	my $authtype = &CheckIsAuthUser($id);
< 
< 	if ($authtype eq ""){
< 		return &ScriptLinkClass( $id, "$name!", 'wikipagelink private', 'This page is private.' );
< 	}
< 		
< 	if ( -f &GetLockedPageFile($id) || $authtype eq "1"){
< 		return &ScriptLinkClass( $id, "$name&not;", 'wikipagelink locked', 'Click to visit this locked page' );
< 	}
< 	
< 	return &ScriptLinkClass( $id, $name, 'wikipagelink', 'Click to visit page' );
< }
< 
< sub GetPageLink {
< 	my ($id) = @_;
< 	
< 	return &GetPageLinkText( $id, $id );
< }
< 
< sub GetEditLink {
< 	my ( $id, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	return &ScriptLinkClass( "action=edit&id=$id", $name, 'wikipageedit', 'Click to edit page' );
< }
< 
< sub GetCreateNewLink {
< 	my ( $id, $name ) = @_;
< 	my ( $html );
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	$html  = "<a href='$ScriptName";
< 	$html .= &ScriptLinkChar();
< 	$html .= "action=edit&id=$id' class='wikicreatepagelink' title='Create this entry'>";
< 	$html .= $name;
< 	$html .= "<span class='wikilinkicon'>&nbsp;</span>";
< 	$html .= "</a>";
< 	
< 	return $html;
< }
< 
< sub GetDeleteLink {
< 	my ( $id, $name, $confirm ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	return &ScriptLink( "action=delete&id=$id&confirm=$confirm", $name );
< }
< 
< sub GetOldPageParameters {
< 	my ( $kind, $id, $revision ) = @_;
< 	
< 	$id = &FreeToNormal($id) if $FreeLinks;
< 	
< 	return "action=$kind&id=$id&revision=$revision";
< }
< 
< sub GetOldPageLink {
< 	my ( $kind, $id, $revision, $name ) = @_;
< 	
< 	$name =~ s/_/ /g if $FreeLinks;
< 	
< 	return &ScriptLink( &GetOldPageParameters( $kind, $id, $revision ), $name );
< }
< 
< sub GetPageOrEditAnchoredLink {
< 	my ( $id, $anchor, $name ) = @_;
< 	my ( @temp, $exists );
< 	my $NamedFreeLink = 0;
< 	
< 	if ( $name eq "" ) {
< 		$name = $id;
< 		if ($FreeLinks) {
< 			$name =~ s/_/ /g;
< 		}
< 	}
< 	else {
< 		$NamedFreeLink = 1;
< 	}
< 	
< 	$id =~ s|^/|$MainPage/|;
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 	}
< 	$exists = 0;
< 	
< 	if ($UseIndex) {
< 		if ( !$IndexInit ) {
< 			@temp = &AllPagesList();    # Also initializes hash
< 		}
< 		$exists = 1 if ( $IndexHash{$id} );
< 	}
< 	elsif ( -f &GetPageFile($id) ) {    # Page file exists
< 		$exists = 1;
< 	}
< 	
< 	if ($exists) {
< 		$id = "$id#$anchor" if $anchor;
< 		$name = "$name#$anchor"  if $anchor && $NamedAnchors != 2 && !$NamedFreeLink;
< 		
< 		return &GetPageLinkText( $id, $name );
< 	}
< 	
< 	if ( $FreeLinks && !$EditNameLink ) {
< 		if ( $name =~ m| | ) {          # Not a single word
< 			$name = "[$name]";          # Add brackets so boundaries are obvious
< 		}
< 	}
< 	
< 	if ($EditNameLink) { return &GetEditLink( $id, $name ); }
< 	else { return &GetCreateNewLink( $id, $name ); }
< }
< 
< sub GetPageOrEditLink {
< 	my ( $id, $name ) = @_;
< 	my ($link, $anchor) = split( /#/, $id, 2);
< 	
< 	return &GetPageOrEditAnchoredLink($link, $anchor, $name);
< }
< 
< sub GetBackLinksSearchLink {
< 	my ($id) = @_;
< 	my $name = $id;
< 	
< 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
< 	
< 	if ($FreeLinks) {
< 		$name =~ s/_/ /g;    # Display with spaces
< 		$id   =~ s/_/+/g;    # Search for url-escaped spaces
< 	}
< 	return &ScriptLinkTitle( "back=$id", $name, "Click to see which pages link to this one" );
< }
< 
< sub GetPrefsLink {
< 	return &ScriptLink( "action=editprefs", "Preferences" );
< }
< 
< sub GetRandomLink {
< 	return &ScriptLink( "action=random", "Random Page" );
< }
< 
< sub ScriptLinkDiff {
< 	my ( $diff, $id, $text, $rev ) = @_;
< 	
< 	$rev = "&revision=$rev" if ( $rev ne "" );
< 	$diff = &GetParam( "defaultdiff", 1 ) if ( $diff == 4 );
< 	
< 	return &ScriptLinkTitle( "action=browse&diff=$diff&id=$id$rev", $text, "Click to view last revision" );
< }
< 
< sub GetUploadLink {
< 	return &ScriptLink( 'action=upload', "Upload" );
< }
< 
< sub ScriptLinkTitle {
< 	my ( $action, $text, $title ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$action =~ s/ /_/g;
< 	}
< 	
< 	return "<a href=\"$ScriptName"
< 	  . &ScriptLinkChar()
< 	  . "$action\" title=\"$title\" class='wikiscriptlinktitle'>$text</a>";
< }
< 
< sub GetAuthorLink {
< 	my ( $host, $userName, $uid ) = @_;
< 	my ( $html, $title, $userNameShow );
< 	$userNameShow = $userName;
< 	
< 	if ($FreeLinks) {
< 		$userName     =~ s/ /_/g;
< 		$userNameShow =~ s/_/ /g;
< 	}
< 	
< 	if ( &ValidId($userName) ne "" ) {    # Invalid under current rules
< 		$userName = "";                   # Just pretend it isn't there.
< 	}
< 	
< 	if ( ( $uid > 0 ) && ( $userName ne "" ) ) {
< 		$html = &ScriptLinkTitle( "$HomePagePrefix/$userName", $userNameShow, Ts( 'ID %s', $uid ) . ' ' . Ts( 'from %s', $host ) );
< 	}
< 	else {
< 		$html = $host;
< 	}
< 	
< 	return $html;
< }
< 
< sub GetHistoryLink {
< 	my ( $id, $text, $title ) = @_;
< 	
< 	if ($FreeLinks) { $id =~ s/ /_/g; }
< 	
< 	return &ScriptLinkTitle( "action=history&id=$id", $text, $title );
< }
< 
< sub GetHeader {
< 	my ( $id, $title, $oldId ) = @_;
< 	my $header    = "";
< 	my $logoImage = "";
< 	my $result    = "";
< 	my $embed     = &GetParam( 'embed', $EmbedWiki );
< 	my $altText   = "[Home]";
< 	my $temp      = "";
< 	
< 	$result = &GetHttpHeader("");
< 	
< 	if ($FreeLinks) {
< 		$title =~ s/_/ /g;    # Display as spaces
< 	}
< 	
< 	$result .= &GetHtmlHeader("$SiteName: $title", $id);
< 	
< 	return $result if ($embed);
< 	$result .= "<div class='wikiheader'>";
< 	
< 	if ( $oldId ne "" ) {
< 		$result .=
< 		  $q->h3( '(' . Ts( 'redirected from %s', &GetEditLink( $oldId, $oldId ) )  . ')' );
< 	}
< 	
< 	if ( ( !$embed ) && ( $LogoUrl ne "" ) ) {
< 		$logoImage = "img class='wikilogo' src=\"$LogoUrl\" alt=\"$altText\" border=0";
< 		
< 		if ( !$LogoLeft ) {
< 			$logoImage .= " align=\"right\"";
< 		}
< 		$header = &ScriptLink( $HomePage, "\n<$logoImage>" );
< 	}
< 	
< 	if ( $id ne "" ) {
< 		my $authtype = &CheckIsAuthUser($id);
< 		if (&PageIsLocked($id, 1) || $authtype eq "1"){
< 			$temp = "<span class='wikilockicon' title='This page is locked.'>&nbsp;</span>";
< 		}
< 		else {	
< 			if ( -f &GetLockedPageFile($id) ) {
< 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='This page locked for others. Click to edit page'><span class='wikiediticon'>&nbsp;</span></a>";
< 			}
< 			else {
< 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='Click to edit this page'><span class='wikiediticon'>&nbsp;</span></a>";
< 			}
< 		}		
< 		$result .= $q->h1( $header . &GetBackLinksSearchLink($id) . $temp );
< 	}
< 	else {
< 		$result .= $q->h1( $header . $title );
< 	}
< 	
< 
< 	if ( &GetParam( "toplinkbar", 1 ) ) {		
< 		$result .= &GetGotoBar($id);
< 		$result .= $WikiLineHeader;
< 	}
< 	
< 	$result .= "</div>";
< 		
< 	return $result;
< }
< 
< sub GetHttpHeader {
< 	my ($type) = @_;
< 	my $cookie;
< 	
< 	$type = "text/html" if ( $type eq "" );
< 	if ( defined( $SetCookie{'id'} ) ) {
< 		$cookie =
< 		   "$CookieName=" . "rev&"
< 		  . $SetCookie{'rev'} . "&id&"
< 		  . $SetCookie{'id'}
< 		  . "&randkey&"
< 		  . $SetCookie{'randkey'};
< 		$cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
< 		if ( $HttpCharset ne "" ) {
< 			return $q->header(
< 				-cookie => $cookie,
< 				-type   => "$type; charset=$HttpCharset"
< 			);
< 		}
< 		return $q->header( -cookie => $cookie );
< 	}
< 	if ( $HttpCharset ne "" ) {
< 		return $q->header( -type => "$type; charset=$HttpCharset" );
< 	}
< 	
< 	return $q->header( -type => $type );
< }
< 
< sub GetHtmlHeader {
< 	my ($title, $id) = @_;
< 	my ( $dtd, $html, $bodyExtra, $stylesheet );
< 	
< 	$html  = "";
< 	$dtd   = "-//IETF//DTD HTML//EN";
< 	$html  = qq(<!DOCTYPE HTML PUBLIC "$dtd">);
< 	$title = $q->escapeHTML($title);
< 	$html .= "\n<html><head><title>$title</title>";
< 	
< 	if ( $FavIcon ne "" ) {
< 		$html .= "<link rel='SHORTCUT ICON' href='$FavIcon'>";
< 	}
< 	
< 	if ($MetaKeywords) {
< 		my $keywords = $OpenPageName;
< 		$keywords =~ s/([a-z])([A-Z])/$1, $2/g;
< 		$html .= "\n<meta name='keywords' content='$keywords'/>" if $keywords;
< 	}
< 	
< 	if ( $SiteBase ne "" ) {
< 		$html .= qq(<base href="$SiteBase">);
< 	}
< 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
< 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
< 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
< 	
< 	if ( $stylesheet ne "" ) {
< 		$html .= qq(<link rel="stylesheet" href="$stylesheet">);
< 	}
< 
<    my $bots = "";
<    # actions and non-existant page views don't get indexed or followed by robots
<    if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
<    $bots = $bots . 'index,' . $bots . 'follow';
<    $html .= qq(<meta name="robots" content="$bots" />\n);
< 	
< 	$html .= $UserHeader;
< 	$bodyExtra = "";
< 	
< 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
< 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
< 	
< 	$html .= "</head><body$bodyExtra>";
< 	$html .= "\n<div id='wikicontainer'>";
< 	
< 	return $html;
< }
< 
< sub GetLeftNav {
< 	my $id = shift;
< 	my $action = &GetParam( "action", "" );
< 	my $html = "";
< 	
< 	$html .= "\n<div class='wikileftnav'>";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'HomePage', 'Home page', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'NobleWiki', 'Wiki Info', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'CategoryCategory', 'Contents', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'FeaturedContent', 'Featured', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'random', 'Random Article', "1");	
< 	
< 	$html .= "\n		</ul>";
< 	$html .= "\n	</div>	";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'RecentChanges', 'Recent changes', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'ListOfWantedPages', 'Wanted Pages', "");
< 					
< 	if ($id ne ""){
< 		unless ($id eq 'ListOfWantedPages' or $id eq 'RecentChanges'){	
< 			if (&UserCanEdit( $id, 0 )){ $html .= "\n<li><a href='?action=edit&id=$id'>Edit this Page</a></li>";	}
< 			else { $html .= "\n<li class='disabled'>Edit this Page</li>"; }
< 							
< 			if ($action eq 'history'){ $html .= "\n<li class='disabled'>Version History</li>"; }
< 			else { $html .= "\n<li><a href='?action=history&id=$id'>Version History</a></li>"; }
< 		}
< 		else {
< 			$html .= "\n<li class='disabled'>Edit this Page</li>"; 
< 			$html .= "\n<li class='disabled'>Version History</li>"; 
< 		}
< 	}
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'SandBox', 'SandBox', "");
< 	
< 	$html .= "\n	</ul></div>";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'editprefs', 'Preferences', "1");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiContacts', 'Contact Us', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiHelp', 'Help', "");
< 		
< 	$html .= "\n		</ul>";
< 	$html .= "\n	</div>";
< 	$html .= "\n	<div class='wikileftnavsearch' style='text-align:right;'>";
< 	$html .= "\n		<form>";
< 	$html .= "\n			<div class='wikisearchlabel' style='text-align:left;'><b>Search</b></div>";
< 	$html .= "\n			<input type='text' title='Enter ! before search term for exclusion' name='search' id='searchterm' />";
< 	$html .= "\n			<input type='submit' value='Go!' name='dosearch' title='Click to perform your search request.' />";
< 	$html .= "\n		</form></div>";
< 	$html .= "\n</div>";
< 	
< 	return $html;	
< }
< 
< sub GetFooterText {
< 	my ( $id, $rev ) = @_;
< 	my $result;
< 	
< 	if ( &GetParam( 'embed', $EmbedWiki ) ) { return ""; }
< 	
< 	$result = "<div class='wikifooter'>";
< 	$result .= &GetGotoBar($id);
< 	$result .= "<div class='wikirevision'>";
< 	
< 	if ($id ne ""){
< 		if ( &UserCanEdit( $id, 0 )) {
< 			if ( $rev ne "" ) {
< 				$result .=
< 				  &GetOldPageLink( 'edit', $id, $rev, Ts( 'Edit revision %s of this page', $rev ) );
< 			}
< 			else {
< 				$result .= &GetEditLink( $id, "Edit text of this page" );
< 			}
< 		}
< 		else {
< 			$result .= "This page is read-only";
< 		}
< 	}
< 	
< 	if ($id ne ""){ $result .= " | " . &GetHistoryLink( $id, "View other revisions", "Click to view revision history" ); }	
< 	if ( $rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
< 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?$id' class='wikiusemetalink'>Search MetaWiki</a>"; }
< 	
< 	$result .= "</div>";
< 	
< 	if ($id ne ""){ 
< 		if ( $Section{'revision'} > 0 ) {
< 			$result .= "<div class='wikirevision'>";		
< 			$result .= "Created " . &TimeToText($Page{'tscreate'});
< 			
< 			if ($Page{'authorcreate'}) { $result .= " by " . $Page{'authorcreate'}; } 
< 			
< 			$result .= " | ";	
< 			if ( $rev eq "" ) { $result .= "Last edited"; }
< 			else { $result .= "Edited"; }
< 			
< 			$result .= " " . &TimeToText( $Section{ts} );
< 				
< 			if ($AuthorFooter) { $result .= " by " . &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}); }
< 		}
< 		
< 		if ($UseDiff) { $result .= " " . &ScriptLinkDiff( 4, $id, "(diff)", $rev ); }
< 	}
< 	
< 	$result .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	$result .= &GetSearchForm();	
< 	if ( $DataDir =~ m|/tmp/| ) {
< 		$result .= "\n<br><b>";
< 		$result .= "Warning";
< 		$result .= ":</b> ";
< 		$result .= "Database is stored in temporary directory $DataDir";
< 		$result .= "\n<br>";
< 	}
< 	
< 	if ( $ConfigError ne "" ) {
< 		$result .= "\n<br>";
< 		$result .= "\n<b>Config file error:</b>";
< 		$result .= "$ConfigError <br>";
< 	}
< 	
< 	$result .= "</form>";
< 	$result .= &getFooterNote();
< 	if ( $AdminBar && &UserIsAdmin() ) { $result .= &GetAdminBar($id, ""); }
< 	$result .= "</div>";
< 		
< 	return $result;
< }
< 
< sub getFooterNote {
< 	my $html;
< 	my $userid = &GetParam("username", "");
< 	my $access = "Guest ";
< 	my $username = "Anonymous";
< 
< 	if (UserIsAdmin()){
< 		$access = "Admin ";
< 	}
< 	elsif (UserIsEditor()){
< 		$access = "Editor ";
< 	}
< 	
< 	if ($userid ne ""){
< 		$username = $userid;
< 	}
< 	
< 	if ($FooterNote ne ""){
< 		$html = $FooterNote;
< 		$html =~ s/access/$access/;
< 		$html =~ s/username/$userid/;
< 	}
< 	
< 	return $html;
< }
< 
< sub GetCommonFooter {
< 	my ($html);
< 	my $id = &GetParam( "id",     "" );
< 	
< 	$html = $WikiLineFooter;
< 	$html .= "\n<div class='wikifooter'>";
< 	$html .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	$html .= &GetGotoBar("");
< 	$html .= &GetSearchForm();
< 	$html .= "</form>";	
< 	$html .= &getFooterNote();
< 	
< 	if ( $AdminBar && &UserIsAdmin() ) { $html .= &GetAdminBar($id, "class='wikirevision'"); }
< 	$html .= "\n<div>"; ## ??NEEDED ??
< 	
< 	return $html;
< }
< 
< sub GetGotoBar {
< 	my ($id) = @_;
< 	my ( $main, $bartext );
< 	
< 	$bartext = "\n<div class='wikigotobar'>";
< 	$bartext .= &GetPageLink($HomePage);
< 	
< 	if ( $id =~ m|/| ) {
< 		$main = $id;
< 		$main =~ s|/.*||;    # Only the main page name (remove subpage)
< 		
< 		unless ($main eq $HomePage){
< 			$bartext .= " | " . &GetPageLink($main);
< 		}
< 	}
< 	
< 	$bartext .= " | " . &GetPageLink($RCName);
< 	$bartext .= " | " . &GetPrefsLink();
< 	
< 	if ( $UseUpload && &UserCanUpload() ) { $bartext .= " | " . &GetUploadLink(); }
< 	
< 	$bartext .= " | " . &ScriptLink( "action=listfiles&filter=sample", "List Assets" );
< 	
< 	if ( &GetParam( "linkrandom", 0 ) ) { $bartext .= " | " . &GetRandomLink(); }
< 	if ( $UserGotoBar ne "" ) { $bartext .= " | " . $UserGotoBar; }
< 	
< 	$bartext .= "</div>";
< 	
< 	return $bartext;
< }
< 
< sub GetSearchForm {
< 	my ($html);
< 	
< 	$html =  "\n<div class='wikisearch'>";
< 	$html .= "\n<div class='wikisearchlabel'>Search:</div>";
< 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";
< 		
< 	if ($SearchButton) { $html .= " " . $q->submit( 'dosearch', "Go!" ); }
< 	else { $html .= &GetHiddenValue( "dosearch", 1 ); }
< 	
< 	$html .= "</div>";
< 	
< 	return $html;
< }
< 
< sub GetRedirectPage {
< 	my ( $newid, $name, $isEdit ) = @_;
< 	my ( $url, $html );
< 	my ($nameLink);
< 
< 	# Normally get URL from script, but allow override.
< 	$FullUrl  = $q->url( -full => 1 ) if ( $FullUrl eq "" );
< 	$url      = $FullUrl . &ScriptLinkChar() . $newid;
< 	$nameLink = "<a href='$url' class='wikiredirect'>$name</a>";
< 	
< 	if ( $RedirType < 3 ) {
< 		if ( $RedirType == 1 ) {    # Use CGI.pm
< 			 # NOTE: do NOT use -method (does not work with old CGI.pm versions)
< 			 # Thanks to Daniel Neri for fixing this problem.
< 			$html = $q->redirect( -uri => $url );
< 		}
< 		else {    # Minimal header
< 			$html = "Status: 302 Moved\n";
< 			$html .= "Location: $url\n";
< 			$html .= "Content-Type: text/html\n";   # Needed for browser failure
< 		}
< 		$html .= " Your browser should go to the $newid page.";
< 		$html .= " If it does not, click $nameLink to continue.";
< 	}
< 	else {
< 		if ($isEdit) {
< 			$html  = &GetHeader( "", "Thanks for editing...", "" );
< 			$html .= &GetLeftNav("");
< 			$html .= "\n<div class='wikiadmin'>";
<  			$html .= "Thank you for editing $nameLink ";
< 		}
< 		else {
< 			$html = &GetHeader( "", "Link to another page...", "" );
< 			$html .= &GetLeftNav("");
< 			$html .= "\n<div class='wikiadmin'>";
< 		}
< 		
< 		$html .= "Follow the $nameLink link to continue.";
< 		$html .= "</div>";
< 		$html .= "</div></div></body></html>";	
< 	}
< 	
< 	return $html;
< }
< 
< # ==== Common wiki markup ====
< sub RestoreSavedText {
< 	my ($text) = @_;
< 	
< 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
< 	
< 	return $text;
< }
< 
< sub RemoveFS {
< 	my ($text) = @_;
< 
< 	# Note: must remove all $FS, and $FS may be multi-byte/char separator
< 	$text =~ s/($FS)+(\d)/$2/g;
< 	
< 	return $text;
< }
< 
< sub WikiToHTML {
< 	my ($pageText) = @_;
< 	$TableMode       = 0;
< 	%SaveUrl         = ();
< 	%SaveNumUrl      = ();
< 	$SaveUrlIndex    = 0;
< 	$SaveNumUrlIndex = 0;
< 	$pageText        = &RemoveFS($pageText);
< 	
< 	if ($RawHtml) { $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige; }
< 	
< 	$pageText = &QuoteHtml($pageText);
< 	$pageText =~ s/\\ *\r?\n/ /g;    # Join lines with backslash at end
< 		
< 	if ($ParseParas) {
< 
< 		# Note: The following 3 rules may span paragraphs, so they are
< 		#       copied from CommonMarkup
< 		$pageText =~ s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
< 		$pageText =~ s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
< 		$pageText =~ s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
< 		$pageText =~ s/\{{template:(\w+\s*.*?)}}/&StoreTemplate($1)/iges;
< 		$pageText =~ s/\{{flash:\s*(.*?)}}/&StoreRaw(&GetFlash($1))/iges;
< 		$pageText =~ s/\{{gallery:\s*(.*?)}}/&StoreRaw(&GetGallery($1))/iges;
< 		
< 		$pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
< 		$pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
< 		
< 	}
< 	else {
< 		$pageText = &WikiLinesToHtml($pageText);         # Line-oriented markup
< 		$pageText = &CommonMarkup( $pageText, 1, 0 );    # Multi-line markup
< 	}
< 	
< 	while (@HeadingNumbers) {
< 		pop @HeadingNumbers;
< 		$TableOfContents .= "</dd></dl>";
< 	}
< 	
< 	$pageText =~ s/&lt;toc&gt;/<div class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
< 	$pageText =~ s/&lt;toc ((\d)+)?&gt;/<div style='width: $1;' class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
< 	$pageText =~ s/\#SUBPAGES\s+(\w+.*?)/&StoreRaw("\n<h6>" . Ts('Subpages of: %s', &QuoteHtml($1)) . "<\/h6>" . &GetPageList(&GetSubpages($1)))/ige;
< 	$pageText =~ s/\#SUBPAGES/&StoreRaw("\n<h6>" . Ts('Subpages for %s', $MainPage) . "<\/h6>" . &GetPageList(&GetSubpages($MainPage)))/ige;
< 	
< 	if ( $LateRules ne "" ) { $pageText = &EvalLocalRules( $LateRules, $pageText, 0 ); }
< 	
< 	return &RestoreSavedText($pageText);
< }
< 
< sub CommonMarkup {
< 	my ( $text, $useImage, $doLines ) = @_;
< 	local $_ = $text;
< 	
< 	if ( $doLines < 2 ) {    # 2 = do line-oriented only
< 		
< 		while ( m!\#INCLUDE\s*((\w+\.?\w*|/)+)!gi and $AllowInclusion ) {		
< 			my $FileName = $1;
< 			
< 			open FILE, "$InclusionDir/$FileName"
< 			or &ReportError("Cannot open $FileName: $!");
< 			
< 			local $/;			
< 			my $FileContent = <FILE>;
< 			
< 			close FILE
< 			or &ReportError("Cannot close $FileName: $!");
< 			s!\#INCLUDE\s*$FileName!$FileContent!i unless $FileName !~ /(html?|txt)$/i;
< 		}
<   
< 		# The <nowiki> tag stores text with no markup (except quoting HTML)
< 		s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
< 
< 		# The <pre> tag wraps the stored text with the HTML <pre> tag
< 		s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
< 		s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
< 		
< 		if ( $EarlyRules ne "" ) {
< 			$_ = &EvalLocalRules( $EarlyRules, $_, !$useImage );
< 		}
< 		
< 		s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
< 		
< 		if ($HtmlTags) {
< 			my ($t);
< 			foreach $t (@HtmlPairs) {
< 				s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
< 			}
< 			foreach $t (@HtmlSingle) {
< 				s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
< 			}
< 		}
< 		else {
< 
< 			# Note that these tags are restricted to a single line
< 			s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
< 			s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
< 			s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
< 			s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
< 		}
< 
< 		# Auto signature if use ~~~~ ; useful for quick comments
< 	    my $id = &GetParam("username", "");
< 		my $idLink = "$HomePagePrefix/$id";
< 		my $timestamp = &TimeToText($Now);
< 		my $finalText = "";
< 		
< 		$id =~ s/ /_/g;
< 
< 		if ($id){
< 			$finalText = &StorePageOrEditLink($idLink, $id);
< 			s/\~\~\~\~/<i>\[$finalText]<\/i>/gi;
< 			s/\$\$\$\$/<i>\[$finalText at $timestamp]<\/i>/gi;
< 		}
< 		else {
< 			$id = "Guest";			
< 			s/\~\~\~\~/<i>\[$id at $timestamp]<\/i>/gi;
< 			s/\$\$\$\$/<i>\[$id at $timestamp]<\/i>/gi;
< 		}
< 		
< 		s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;    # <tt> (MeatBall)
< 		s/\&lt;br\&gt;/<br>/gi;    # Allow simple line break anywhere
< 		
< 		if ($HtmlLinks) {
< 			s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
< 		}
< 		
< 		if ($FreeLinks) {
< 
< 			# Consider: should local free-link descriptions be conditional?
< 			# Also, consider that one could write [[Bad Page|Good Page]]?
< 			s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
< 			s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
< 		}
< 		
< 		if ($BracketText) {        
< 			# Links like [URL text of link]
< 			s/\[$UrlPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketUrl($1, $2, $useImage, $3)/geos;
< 			s/\[$InterLinkPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketInterPage($1, $2, $useImage, $3)/geos;
< 			
< 			if ( $WikiLinks && $BracketWiki ) {    # Local bracket-links
< 				s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
< 				s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1, $2, $3)/geos if $NamedAnchors;
< 			}
< 		}
< 		
< 		s/\[$UrlPattern(\|(.*))?\]/&StoreBracketUrl($1, "", 0, "")/geo;
< 		s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0, "")/geo;
< 		s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
< 		s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
< 		
< 		if ($WikiLinks) {
< 			s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1, $2, ""))/geo if $NamedAnchors;
< 
< 			# CAA: Putting \b in front of $LinkPattern breaks /SubPage links
< 			#      (subpage links without the main page)
< 			s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
< 		}
< 		s/\b$RFCPattern/&StoreRFC($1)/geo;
< 		s/\b$ISBNPattern/&StoreISBN($1)/geo;
< 		
< 		if ($UseUpload) {
< 			s/$UploadPattern/&StoreUpload($1)/geo;
< 		}
< 		
< 		if ($ThinLine) {
< 			if ($OldThinLine) {   
< 				# Backwards compatible, conflicts with headers
< 				s/====+/$WikiLine2/g;
< 			}
< 			else {                
< 				# New behavior--no conflict
< 				s/------+/$WikiLine2/g;
< 			}
< 			s/----+/$WikiLine1/g;
< 		}
< 		else {
< 			s/----+/$WikiLine/g;
< 		}
< 		
< 		if ($AutoMailto) {
< 			s/([A-z0-9-_]+(?:\.[A-z0-9-_]+)*)\@([A-z0-9-_]+(?:\.[A-z0-9-_]+)*(?:\.[A-z]{2,})+)/<a href="mailto:$1\@$2">$1\@$2<\/a>/g;
< 		}
< 	}
< 	
< 	if ($doLines) {    
< 		# 0 = no line-oriented, 1 or 2 = do line-oriented
< 	    # The quote markup patterns avoid overlapping tags (with 5 quotes)
< 	    # by matching the inner quotes for the strong pattern.
< 		s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g; #'REMARK
< 		s/''(.*?)''/<em>$1<\/em>/g;
< 		
< 		if ($UseHeadings) {
< 			s/(^|\n)\s*(\=+)\s*(#)?\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $4, $3)/geo;
< 		}
< 		
< 		if ($TableMode == 1) {
< 			my @cells = split(/\|\|/);
< 			my $cellIndex = 0;
< 			
< 			while (/(\|\|)+([^\|<]+)/) {	
< 				my $switches = @cells->[++$cellIndex];
< 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
< 				my $cellOptions = "$class $style $width $align";
< 				
< 				s/((\|\|)+)/"<\/td><td $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;
< 			} 
< 			s/(\|\w*=\w*)+([^\|<]+)//g;   
< 		}
< 		elsif  ($TableMode == 2) {
< 			my @cells = split(/\!\!/);
< 			my $cellIndex = 0;
< 			
< 			while (/(\!\!)+([^\!<]+)/) {			
< 				my $switches = @cells->[++$cellIndex];
< 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
< 				my $cellOptions = "$class $style $width $align";
< 				
< 				s/((\!\!)+)/"<\/th><th $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;				
< 			}
< 			s/(\|\w*=\w*)+([^\!<]+)//g;
< 		}
< 	}
< 	
< 	return $_;
< }
< 
< sub GetTableCellModifiers {
< 	my ($given, $initialCell, $cellIndex) = @_;	
< 	my ($options) = $given;
< 
< 	/^(\s*(\w+)\s*)\|/;
< 	my $align = $2;
< 	if ($initialCell ne ""){ $align = $initialCell; }
< 		
< 	$align = $align =~ /^  / ? ($align =~ /  $/ ? 'center' : 'right') : 'left';
< 	$align = "align='$align'";
< 	
< 	my ($options) = $options =~ /(\|\S*=\S*)+/g;
< 	my %options = &GetOptions($options);
< 
< 	my $class;
< 	my $style;
< 	my $width;	
< 	my $rowclass;
< 	my $rowstyle;
< 	my $rowalign;
< 	my $tablewidth;
< 	my $tableclass;
< 	my $tablestyle;
< 		
< 	if ($TableCellDefaults{"rowclass"} =~ /clear/){ $TableCellDefaults{"rowclass"} = ""; }
< 	if ($TableCellDefaults{"rowstyle"} =~ /clear/){ $TableCellDefaults{"rowstyle"} = ""; }
< 	if ($TableCellDefaults{"rowalign"} =~ /clear/){ $TableCellDefaults{"rowalign"} = ""; }
< 				
< 	if ($TableCellDefaults{"rowclass"}){ $rowclass = $TableCellDefaults{"rowclass"}; }
< 	if ($TableCellDefaults{"rowstyle"}){ $rowstyle = $TableCellDefaults{"rowstyle"}; }
< 	if ($TableCellDefaults{"rowalign"}){ $rowalign = $TableCellDefaults{"rowalign"}; }
< 		
< 	if ($options{'rowclass'}){ $rowclass = "class='" . $options{'rowclass'} . "'"; $TableCellDefaults{"rowclass"} = $rowclass; }
< 	if ($options{'rowstyle'}){ $rowstyle = "style='" . $options{'rowstyle'} . "'"; $TableCellDefaults{"rowstyle"} = $rowstyle; }
< 	if ($options{'rowalign'}){ $rowalign = "align='" . $options{'rowalign'} . "'"; $TableCellDefaults{"rowalign"} = $rowalign; }
< 	
< 	if ($rowclass){ $class = $rowclass; }
< 	if ($rowstyle){ $style = $rowstyle; }
< 	if ($rowalign){ $align = $rowalign; }
< 
< 	if ($TableCellDefaults{"class$cellIndex"} =~ /clear/){ $TableCellDefaults{"class$cellIndex"} = ""; }
< 	if ($TableCellDefaults{"style$cellIndex"} =~ /clear/){ $TableCellDefaults{"style$cellIndex"} = ""; }
< 	if ($TableCellDefaults{"align$cellIndex"} =~ /clear/){ $TableCellDefaults{"align$cellIndex"} = ""; }
< 			
< 	if ($TableCellDefaults{"class$cellIndex"}){ $class = $TableCellDefaults{"class$cellIndex"}; }
< 	if ($TableCellDefaults{"style$cellIndex"}){ $style = $TableCellDefaults{"style$cellIndex"}; }
< 	if ($TableCellDefaults{"align$cellIndex"}){ $align = $TableCellDefaults{"align$cellIndex"}; }
< 
< 	if ($options{'class'}){ $class = "class='" . $options{'class'} . "'"; $TableCellDefaults{"class$cellIndex"} = $class; }
< 	if ($options{'style'}){ $style = "style='" . $options{'style'} . "'"; $TableCellDefaults{"style$cellIndex"} = $style; }
< 	if ($options{'align'}){ $align = "align='" . $options{'align'} . "'"; $TableCellDefaults{"align$cellIndex"} = $align; }
< 	if ($options{'width'}){ $width = "width='" . $options{'width'} . "'"; }
< 	if ($options{'tablewidth'}){ $tablewidth = "width='" . $options{'tablewidth'} . "'"; }
< 	if ($options{'tablestyle'}){ $tablestyle = "style='" . $options{'tablestyle'} . "'"; }
< 	if ($options{'tableclass'}){ $tableclass = "class='" . $options{'tableclass'} . "'"; } else { $tableclass = "class='wikilargelist'"; }
< 					
< 	return ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass);				
< }
< 
< sub WikiLinesToHtml {
< 	my ($pageText) = @_;
< 	my ( $pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode );
< 	
< 	@htmlStack = ();
< 	$depth     = 0;
< 	$pageHtml  = "";
< 	
< 	foreach ( split( /\r?\n/, $pageText ) ) {    # Process lines one-at-a-time
< 		$code           = "";
< 		$codeAttributes = "";
< 		$TableMode      = 0;
< 		$_ .= "\n";
< 		
< 		if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
< 			$code  = "dl";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\:+)/<dt><dd>/) {
< 			$code  = "dl";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\*+)/<li>/) {
< 			$code  = "ul";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\#+)/<li>/) {
< 			$code  = "ol";
< 			$depth = length $1;
< 		}
< 		elsif ($TableSyntax && /^(\!\!)+.*\!\!\s*$/) {
< 			/^(\!\!)+([^\!]+)/;
< 			
< 			%TableCellDefaults = {};
< 			
< 			my $switches = $2;
< 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, "", 0);
< 			my $cellOptions = "$class $style $width $align";
< 			
< 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/th><\/tr>\n"/e;
< 			
< 			$code = "table";
< 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
< 			$TableMode = 2;
< 			$depth = 1;
< 		}
< 		elsif ($TableSyntax && /^(\|\|)+.*\|\|\s*$/) {
< 			/^((\|\|)+)(.*?)\|\|/;	
< 	
< 			my ($alignInitial) = $3;
< 			my $switches = $3;
< 			($alignInitial) = $alignInitial =~ /(.*)\|/;	
< 
< 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, $alignInitial, 0);
< 			my $cellOptions = "$class $style $width $align";
< 			
< 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/td><\/tr>\n"/e;
< 			
< 			$code = "table";
< 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
< 			$TableMode = 1;
< 			$depth = 1;
< 		}
< 		elsif (/^[ \t].*\S/) {
< 			$code  = "pre";
< 			$depth = 1;
< 		}
< 		else {
< 			$depth = 0;
< 		}
< 		
< 		while ( @htmlStack > $depth ) {    
< 			# Close tags as needed
< 			$pageHtml .= "</" . pop(@htmlStack) . ">";
< 		}
< 		
< 		if ( $depth > 0 ) {
< 			$depth = $IndentLimit if ( $depth > $IndentLimit );
< 			if (@htmlStack) {              
< 				# Non-empty stack
< 				$oldCode = pop(@htmlStack);
< 				
< 				if ( $oldCode ne $code ) {
< 					$pageHtml .= "</$oldCode><$code>";
< 				}
< 				push( @htmlStack, $code );
< 			}
< 			
< 			while ( @htmlStack < $depth ) {
< 				push( @htmlStack, $code );
< 				$pageHtml .= "\n<$code $codeAttributes>";
< 			}
< 		}
< 		
< 		if ( !$ParseParas ) {
< 			s/^\s*$/<p>\n/;    # Blank lines become <p> tags
< 		}
< 		$pageHtml .= &CommonMarkup( $_, 1, 2 );    # Line-oriented common markup
< 	}
< 	
< 	while ( @htmlStack > 0 ) {                     
< 		# Clear stack
< 		$pageHtml .= "</" . pop(@htmlStack) . ">";
< 	}
< 	
< 	return $pageHtml;
< }
< 
< sub EvalLocalRules {
< 	my ( $rules, $origText, $isDiff ) = @_;
< 	my ( $text, $reportError, $errorText );
< 	
< 	$text        = $origText;
< 	$reportError = 1;
< 
< 	# Basic idea: the $rules should change $text, possibly with different
< 	# behavior if $isDiff is true (no images or color changes?)
< 	# Note: for fun, the $rules could also change $reportError and $origText
< 	if ( !eval $rules ) {
< 		$errorText = $@;
< 		
< 		if ( $errorText eq "" ) {
< 
< 		  # Search for "Unknown Error" for the reason the next line is commented
< 		  #     $errorText = "Unknown Error (no error text)";
< 		}
< 		if ( $errorText ne "" ) {
< 			$text = $origText;    # Consider: should partial results be kept?
< 			
< 			if ($reportError) {
< 				$text .= "\n<hr>";
< 				$text .= "<b>";
< 				$text .= "Local rule error:";
< 				$text .= "</b><br>";
< 				$text .= &QuoteHtml($errorText);
< 			}
< 		}
< 	}
< 	
< 	return $text;
< }
< 
< sub QuoteHtml {
< 	my ($html) = @_;
< 	
< 	$html =~ s/&/&amp;/g;
< 	$html =~ s/</&lt;/g;
< 	$html =~ s/>/&gt;/g;
< 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
< 	
< 	return $html;
< }
< 
< sub ParseParagraph {
< 	my ($text) = @_;
< 	
< 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
< 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
< 	
< 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
< 	
< 	return "\n<p>$text</p>";
< }
< 
< sub StoreInterPage {
< 	my ( $id, $useImage ) = @_;
< 	my ( $link, $extra );
< 	
< 	( $link, $extra ) = &InterPageLink( $id, $useImage );
< 
< 	# Next line ensures no empty links are stored
< 	$link = &StoreRaw($link) if ( $link ne "" );
< 	
< 	return $link . $extra;
< }
< 
< sub InterPageLink {
< 	my ( $id, $useImage ) = @_;
< 	my ( $name, $site, $remotePage, $url, $punct );
< 	
< 	( $id, $punct ) = &SplitUrlPunct($id);
< 	$name = $id;
< 	( $site, $remotePage ) = split( /:/, $id, 2 );
< 	$url = &GetSiteUrl($site);
< 	
< 	return ( "", $id . $punct ) if ( $url eq "" );
< 	
< 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
< 	$url .= $remotePage;
< 	
< 	return ( &UrlLinkOrImage( $url, $name, $useImage ), $punct );
< }
< 
< sub StoreBracketInterPage {
< 	my ( $id, $text, $useImage, $options ) = @_;
< 	my ( $site, $remotePage, $url, $index );
< 	
< 	( $site, $remotePage ) = split( /:/, $id, 2 );
< 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
< 	$url = &GetSiteUrl($site);
< 	
< 	if ( $text ne "" ) {
< 		return "[$id $text]" if ( $url eq "" );
< 	}
< 	else {
< 		return "[$id]" if ( $url eq "" );
< 		$text = &GetBracketUrlIndex($id);
< 	}
< 	
< 	$url .= $remotePage;
< 	
< 	$text = StoreBracketUrl( $url, $text, $useImage, $options);
< 	
< 	return $text;
< }
< 
< sub GetBracketUrlIndex {
< 	my ($id) = @_;
< 	my ( $index, $key );
< 
< 	# Consider plain array?
< 	if ( $SaveNumUrl{$id} > 0 ) { return $SaveNumUrl{$id}; }
< 	
< 	$SaveNumUrlIndex++;    # Start with 1
< 	$SaveNumUrl{$id} = $SaveNumUrlIndex;
< 	
< 	return $SaveNumUrlIndex;
< }
< 
< sub GetSiteUrl {
< 	my ($site) = @_;
< 	my ( $data, $status );
< 	
< 	if ( !$InterSiteInit ) {
< 		( $status, $data ) = &ReadFile($InterFile);
< 		
< 		if ($status) {
< 			%InterSite = split( /\s+/, $data );    # Consider defensive code
< 		}
< 
< 		# Check for definitions to allow file to override automatic settings
< 		if ( !defined( $InterSite{'LocalWiki'} ) ) {
< 			$InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
< 		}
< 		
< 		if ( !defined( $InterSite{'Local'} ) ) {
< 			$InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
< 		}
< 		
< 		$InterSiteInit = 1;                        # Init only once per request
< 	}
< 	
< 	return $InterSite{$site} if ( defined( $InterSite{$site} ) );
< 	return "";
< }
< 
< sub StoreRaw {
< 	my ($html) = @_;
< 	
< 	$SaveUrl{$SaveUrlIndex} = $html;
< 	
< 	return $FS . $SaveUrlIndex++ . $FS;
< }
< 
< sub StorePre {
< 	my ( $html, $tag ) = @_;
< 	
< 	return &StoreRaw( "<$tag>" . $html . "</$tag>" );
< }
< 
< sub ReadWikiFile {
< 	my ($fileName) = @_;
< 	my ($fileData, %tempPage, %tempSection, %tempText);
< 	
< 	return unless -f $fileName;
< 	
< 	$fileData = &ReadFileOrDie($fileName);
< 	%tempPage = split(/$FS1/, $fileData, -1);
< 	%tempSection = split(/$FS2/, $tempPage{'text_default'}, -1);
< 	%tempText = split(/$FS3/, $tempSection{'data'}, -1);
< 	
< 	return $tempText{'text'};
< }
< 
< sub WikiFileToHTML {
< 	my ($text) = @_;
< 	my ($output);
< 	my ($mySaveUrlIndex, $mySaveNumUrlIndex, $myTableMode, %mySaveUrl, %mySaveNumUrl);
< 	
< 	return unless $text;
< 	
< 	# Global variables do not help this code. Nasty, but easiest solution.
< 	%mySaveUrl= %SaveUrl;
< 	%mySaveNumUrl= %SaveNumUrl;
< 	$mySaveUrlIndex= $SaveUrlIndex;
< 	$mySaveNumUrlIndex = $SaveNumUrlIndex;
< 	$myTableMode= $TableMode;
< 	
< 	$output = &WikiToHTML($text);
< 	
< 	%SaveUrl = %mySaveUrl;
< 	%SaveNumUrl = %mySaveNumUrl;
< 	$SaveUrlIndex = $mySaveUrlIndex;
< 	$SaveNumUrlIndex = $mySaveNumUrlIndex;
< 	$TableMode = $myTableMode;
< 	
< 	return $output;
< }
< 
< sub StoreTemplate {
< 	my ($params) = @_;
< 	my ($templateId, $templateFile, $templateText, $output, %substitutes);
< 	
< 	$params =~ s/^\s*(\S+)\s*/$templateId=$1,''/e;
< 	return &StoreRaw('No template name') unless $templateId;
< 	
< 	$templateFile = &GetPageFile($templateId);
< 	return &StoreRaw(Ts('Template %s not found', $templateId)) unless -f $templateFile;
< 	
< 	while ($params =~ /^(\S+)\s*=(.*)$/gm) {
< 		$substitutes{$1} = $2;
< 	}
< 	
< 	$templateText = &ReadWikiFile($templateFile);
< 	$templateText =~ s/\$(\S+)\$/$substitutes{$1}/gi;
< 	$templateText =~ s/{{//g; # Avoid nesting.
< 	$output = &WikiFileToHTML($templateText);
< 	
< 	return &StoreRaw($output);
< }
< 
< sub StoreHref {
< 	my ( $anchor, $text ) = @_;
< 	
< 	return "<a" . &StoreRaw($anchor) . ">$text</a>";
< }
< 
< sub StoreUrl {
< 	my ( $name, $useImage ) = @_;
< 	my ( $link, $extra );
< 	
< 	( $link, $extra ) = &UrlLink( $name, $useImage );
< 
< 	# Next line ensures no empty links are stored
< 	$link = &StoreRaw($link) if ( $link ne "" );
< 	
< 	return $link . $extra;
< }
< 
< sub UrlLink {
< 	my ( $rawname, $useImage ) = @_;
< 	my ( $name, $punct );
< 	
< 	( $name, $punct ) = &SplitUrlPunct($rawname);
< 	
< 	if ( $LimitFileUrl && ( $NetworkFile && $name =~ m|^file:| ) ) {
< 
< 		# Only do remote file:// links. No file:///c|/windows.
< 		if ( $name =~ m|^file://[^/]| ) {
< 			return ( "<a href='$name' class='wikiurllink'>$name</a>", $punct );
< 		}
< 		
< 		return ( $rawname, "" );
< 	}
< 	
< 	return ( &UrlLinkOrImage( $name, $name, $useImage ), $punct );
< }
< 
< sub UrlLinkOrImage {
< 	my ( $url, $name, $useImage ) = @_;
< 	
< 	# Restricted image URLs so that mailto:foo@bar.gif is not an image
< 	if ( $useImage && &ImageAllowed($url) ) {
< 		return "<a href='$url' class='wikiurlorimage' target='_blank'><img class='wikiurlorimage' src='$url'></a>";
< 	}
< 	
< 	return "<a href='$url' class='wikiurlorimage'>$name</a>";
< }
< 
< sub ImageAllowed {
< 	my ($url) = @_;
< 	my ( $site, $imagePrefixes );
< 	
< 	$imagePrefixes = 'http:|https:|ftp:|upload:';
< 	$imagePrefixes .= '|file:' if ( !$LimitFileUrl );
< 	
< 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
< 	return 0 if ( $url =~ /"/ );    #" No HTML-breaking quotes allowed
< 	return 1 if ( @ImageSites < 1 );    # Most common case: () means all allowed
< 	return 0 if ( $ImageSites[0] eq 'none' );    # Special case: none allowed
< 
< 	foreach $site (@ImageSites) {
< 		return 1
< 		  if ( $site eq substr( $url, 0, length($site) ) );    # Match prefix
< 	}
< 	
< 	return 0;
< }
< 
< sub ExtensionAllowed {
< 	my ($file) = @_;
< 	
< 	return 1 if ( $file =~ m/\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
< 	
< 	return 0;	
< }
< 
< sub GetUploadUrl {
< 	my ($url) = @_;
< 	
< 	&StoreRaw($url);
< }
< 
< sub GetOptions {
< 	my ($text) = @_;
< 	my %options;
< 	
< 	foreach my $pair (split(/\|/, $text)){
< 		my @keyvalues = split (/=/, $pair);
< 		$options{$keyvalues[0]} = $keyvalues[1];
< 	}
< 	
< 	return %options;	
< }
< 
< sub ComputeImageRatio {
< 	my ($imageName, $desiredWidth, $desiredHeight, $okayLarger) = @_;
< 	my $filepath = "$UploadDir/$imageName";
< 	my ($imageWidth, $imageHeight) = Image::Size::imgsize($filepath);
< 	
< 	my $ratioWidth = 1;
< 	my $ratioHeight = 1;
< 	my $ratioFinal = 1;
< 	
< 	if ($desiredWidth){ $ratioWidth = $desiredWidth/$imageWidth; }
< 	if ($desiredHeight){ $ratioHeight = $desiredHeight/$imageHeight; }
< 	
< 	if ($okayLarger){
< 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioWidth; }
< 		else { $ratioFinal = $ratioHeight; }
< 	}
< 	else {
< 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioHeight; }
< 		else { $ratioFinal = $ratioWidth; }
< 	
< 	}
< 	
< 	my $finalWidth = int($ratioFinal * $imageWidth);
< 	my $finalHeight = int($ratioFinal * $imageHeight);
< 	
< 	return ($finalWidth, $finalHeight);
< }
< 
< sub StoreBracketUrl {
< 	my ( $url, $text, $useImage, $options ) = @_;
< 	my %options = &GetOptions($options);
< 	my $imageFloat;
< 	my $imageClear = "\n<br class='clear$options{clear}'/>";
< 	my $boxFloat = " float" . $options{'boxfloat'};
< 	my $boxClear = "\n<br class='clear$options{boxclear}'/>";
< 	my $width;
< 	my $height;
< 	my $title;
< 	my $caption;
< 	my $description;
< 	my $imageLink;
< 	my $boxWidth = "style='width: 300px !important;'";
< 
< 	if ( $text eq "" ) { $text = &GetBracketUrlIndex($url); }
< 
< 	if ($options{'float'}){ $imageFloat = "float" . $options{'float'}; }
< 	if ($options{'clear'}){ $imageClear = "\n<br class='clear$options{clear}'/>"; }
< 	if ($options{'title'}){ $title = $options{title}; } else { $title = $text; }
< 	if ($options{'width'}){ $width = $options{'width'}; }
< 	if ($options{'height'}){ $height = $options{'height'}; }
< 			
< 	if ($options{'boxfloat'}){ $boxFloat = "float" . $options{'boxfloat'}; }
< 	if ($options{'boxclear'}){ $boxClear = "\n<br class='clear$options{boxclear}'/>"; }
< 	if ($options{'boxwidth'}){ $boxWidth = "style='width: $options{boxwidth} !important;'"; }
< 	if ($options{'caption'}){ 
< 		if ($options{'description'}){ $description = $options{description}; } 
< 		else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
< 		
< 		$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div><div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
< 	}
< 	
< 	if ($url =~ /$UploadPattern/){ $url = "$UploadUrl/$1"; }	
< 	if ( $BracketImg && $useImage && &ImageAllowed($text) ) {		
< 		if ($text =~ /$UploadPattern/){
< 			my $imageName = $1;
< 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($imageName, $width, $height, "");
< 			my $imageStyle = "style='width: $imageWidth; height: $imageHeight;'";
< 			
< 			$imageLink = "$UploadUrl/" . &GetUploadUrl($1);			
< 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' $imageStyle src='$imageLink'></a>";
< 		}
< 		else {
< 			$imageLink = $text;
< 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' src='$imageLink'></a>";
< 		}
< 		my $expandlink =  "<a target='_blank' class='wikiexpandimageicon' href='$imageLink' title='View source image'>&nbsp;</a>";
< 		
< 		if ($options{'caption'}){ 
< 			if ($options{'description'}){ $description = $options{description}; } 
< 			else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
< 			
< 			$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div>$expandlink<div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
< 		}
< 			
< 		if ($imageClear){ $text .= $imageClear; }		
< 					
< 		if ($caption){
< 			$text = "\n<div title='$title' class='wikibracketbox $boxFloat' $boxWidth>$text$caption</div>";		
< 		}
< 		else {
< 			$text = "\n<div title='$title' class='$boxFloat'>$text</div>";	
< 		}
< 		
< 		if ($boxClear){ $text .= $boxClear; }
< 	}
< 	else {
< 		$text = "<a href='$url' title='$title' class='wikibracketurl'>[$text]</a>";
< 	}
< 	
< 	return &StoreRaw($text);
< }
< 
< sub StoreBracketLink {
< 	my ( $name, $text ) = @_;
< 	
< 	return &StoreRaw( &GetPageLinkText( $name, "[$text]" ) );
< }
< 
< sub StoreBracketAnchoredLink {
< 	my ( $name, $anchor, $text ) = @_;
< 	
< 	return &StoreRaw( &GetPageLinkText( "$name#$anchor", "[$text]" ) );
< }
< 
< sub StorePageOrEditLink {
< 	my ( $page, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$page =~ s/^\s+//;        # Trim extra spaces
< 		$page =~ s/\s+$//;
< 		$page =~ s|\s*/\s*|/|;    # ...also before/after subpages
< 	}
< 	$name =~ s/^\s+//;
< 	$name =~ s/\s+$//;
< 	
< 	return &StoreRaw( &GetPageOrEditLink( $page, $name ) );
< }
< 
< sub StoreRFC {
< 	my ($num) = @_;
< 	
< 	return &StoreRaw( &RFCLink($num) );
< }
< 
< sub RFCLink {
< 	my ($num) = @_;
< 	
< 	return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\" class='wikirfclink'>RFC $num</a>";
< }
< 
< sub StoreUpload {
< 	my ($url) = @_;
< 	
< 	return &StoreRaw( &UploadLink($url) );
< }
< 
< sub UploadLink {
< 	my ($filename) = @_;
< 	my ( $html, $url );
< 	
< 	return $filename if ( $UploadUrl eq "" );    # No bad links if misconfigured
< 	
< 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
< 	$url  = $UploadUrl . $filename;
< 	$html = "<a href='$url' class='wikiuploadlink' target='_blank'>";
< 	
< 	if ( &ImageAllowed($url) ) {
< 		$html .= "<img class='wikiuploadlink' src='$url' alt='upload:$filename'>";
< 	}
< 	else {
< 		$html .= "upload:$filename";
< 	}
< 	$html .= "</a>";
< 	
< 	return $html;
< }
< 
< sub StoreISBN {
< 	my ($num) = @_;
< 	
< 	return &StoreRaw( &ISBNLink($num) );
< }
< 
< sub ISBNALink {
< 	my ( $num, $pre, $post, $text ) = @_;
< 	
< 	return "<a href='$pre$num$post' class='wikiisbnalink'>$text</a>";
< }
< 
< sub ISBNLink {
< 	my ($rawnum) = @_;
< 	my ( $rawprint, $html, $num, $numSites, $i );
< 	
< 	$num      = $rawnum;
< 	$rawprint = $rawnum;
< 	$rawprint =~ s/ +$//;
< 	$num      =~ s/[- ]//g;
< 	$numSites = scalar @IsbnNames;    # Number of entries
< 	
< 	if ( ( length($num) != 10 ) || ( $numSites < 1 ) ) {
< 		return "ISBN $rawnum";
< 	}
< 	
< 	$html = &ISBNALink( $num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint );
< 	
< 	if ( $numSites > 1 ) {
< 		$html .= " (";
< 		$i = 1;
< 		while ( $i < $numSites ) {
< 			$html .=
< 			  &ISBNALink( $num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i] );
< 			if ( $i < ( $numSites - 1 ) ) {    # Not the last site
< 				$html .= ", ";
< 			}
< 			$i++;
< 		}
< 		$html .= ")";
< 	}
< 	
< 	$html .= " " if ( $rawnum =~ / $/ );    # Add space if old ISBN had space.
< 	
< 	return $html;
< }
< 
< sub SplitUrlPunct {
< 	my ($url) = @_;
< 	my ($punct);
< 	
< 	if ( $url =~ s/\"\"$// ) {  #"REMARK
< 		return ( $url, "" );    # Delete double-quote delimiters here
< 	}
< 	
< 	$punct = "";
< 	if ($NewFS) {
< 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/ );
< 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
< 	}
< 	else {
< 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/ );
< 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
< 	}
< 	
< 	return ( $url, $punct );
< }
< 
< sub StripUrlPunct {
< 	my ($url) = @_;
< 	my ($junk);
< 	
< 	( $url, $junk ) = &SplitUrlPunct($url);
< 	
< 	return $url;
< }
< 
< sub WikiHeadingNumber {
< 	my ( $depth, $text, $useNumber) = @_;
< 	my ( $anchor, $number );
< 	
< 	return "" unless --$depth > 0;
< 		
< 	while ( scalar @HeadingNumbers < ( $depth - 1 ) ) {
< 		push @HeadingNumbers, 1;
< 		$TableOfContents .= "<dl><dt></dt><dd>";
< 	}
< 	
< 	if ( scalar @HeadingNumbers < $depth ) {
< 		push @HeadingNumbers, 0;
< 		$TableOfContents .= "<dl><dt></dt><dd>";
< 	}
< 	
< 	while ( scalar @HeadingNumbers > $depth ) {
< 		pop @HeadingNumbers;
< 		$TableOfContents .= "</dd></dl>";
< 	}
< 	
< 	$HeadingNumbers[$#HeadingNumbers]++;
< 	$number = ( join '.', @HeadingNumbers ) . '. ';
< 
< 	# Remove embedded links. THIS IS FRAGILE!
< 	$text = &RestoreSavedText($text);
< 	$text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si;        # No such page syntax
< 	$text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
< 
< 	# Cook anchor by canonicalizing $text.
< 	$anchor = $text;
< 	$anchor =~ s/\<.*?\>//g;
< 	$anchor =~ s/\W/_/g;
< 	$anchor =~ s/__+/_/g;
< 	$anchor =~ s/^_//;
< 	$anchor =~ s/_$//;
< 
< 	# Last ditch effort
< 	$anchor = "_" . ( join '_', @HeadingNumbers ) unless $anchor;
< 	$TableOfContents .= ('&nbsp;' x (2 * $depth)) . $number;
< 	$TableOfContents .= &ScriptLink( "$OpenPageName#$anchor", $text );
< 	$TableOfContents .= "</dd><dt>";
< 	$TableOfContents .= "</dt><dd>";
< 	  
< 	## return &StoreHref(" name='$anchor'") . $number;
< 	if ($useNumber) {
< 		return &StoreHref(" name='$anchor'") . $number;
< 	} else {
< 		return &StoreHref(" name='$anchor'");
< 	}
< }
< 
< sub WikiHeading {
< 	## my ( $pre, $depth, $text ) = @_;
< 	my ($pre, $depth, $text, $useNumber) = @_;
< 	
< 	$depth = length($depth);
< 	$depth = 6 if ( $depth > 6 );
< 		
< 	if ($useNumber) {
< 		$text = &WikiHeadingNumber($depth,$text, 1) . $text;
< 	} else {
< 		$text = &WikiHeadingNumber($depth,$text, 0) . $text;
< 	}	
< 	
< 	return $pre . "<H$depth>$text</H$depth>";
< }
< 
< # ==== Difference markup and HTML ====
< sub GetDiffHTML {
< 	my ( $diffType, $id, $revOld, $revNew, $newText ) = @_;
< 	my ( $html, $diffText, $diffTextTwo, $priorName, $links, $usecomma );
< 	my ( $major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName );
< 	
< 	$links     = " (";
< 	$usecomma  = 0;
< 	$major     = &ScriptLinkDiff( 1, $id, "major diff", "" );
< 	$minor     = &ScriptLinkDiff( 2, $id, "minor diff", "" );
< 	$author    = &ScriptLinkDiff( 3, $id, "author diff", "" );
< 	$useMajor  = 1;
< 	$useMinor  = 1;
< 	$useAuthor = 1;
< 	$diffType  = &GetParam( "defaultdiff", 1 ) if ( $diffType == 4 );
< 	
< 	if ( $diffType == 1 ) {
< 		$priorName = "major";
< 		$cacheName = "major";
< 		$useMajor  = 0;
< 	}
< 	elsif ( $diffType == 2 ) {
< 		$priorName = "minor";
< 		$cacheName = "minor";
< 		$useMinor  = 0;
< 	}
< 	elsif ( $diffType == 3 ) {
< 		$priorName = "author";
< 		$cacheName = "author";
< 		$useAuthor = 0;
< 	}
< 	
< 	if ( $revOld ne "" ) {
< 
< 		# Note: OpenKeptRevisions must have been done by caller.
< 		# Eventually optimize if same as cached revision
< 		$diffText = &GetKeptDiff( $newText, $revOld, 1 );    # 1 = get lock
< 		if ( $diffText eq "" ) {
< 			$diffText = "(The revisions are identical or unavailable.)";
< 		}
< 	}
< 	else {
< 		$diffText = &GetCacheDiff($cacheName);
< 	}
< 	
< 	$useMajor = 0 if ( $useMajor && ( $diffText eq &GetCacheDiff("major") ) );
< 	$useMinor = 0 if ( $useMinor && ( $diffText eq &GetCacheDiff("minor") ) );
< 	$useAuthor = 0 if ( $useAuthor && ( $diffText eq &GetCacheDiff("author") ) );
< 	$useMajor = 0 if ( ( !defined( &GetPageCache('oldmajor') ) ) || ( &GetPageCache("oldmajor") < 1 ) );
< 	$useAuthor = 0 if ( ( !defined( &GetPageCache('oldauthor') ) ) || ( &GetPageCache("oldauthor") < 1 ) );
< 	
< 	if ($useMajor) {
< 		$links .= $major;
< 		$usecomma = 1;
< 	}
< 	
< 	if ($useMinor) {
< 		$links .= ", " if ($usecomma);
< 		$links .= $minor;
< 		$usecomma = 1;
< 	}
< 	
< 	if ($useAuthor) {
< 		$links .= ", " if ($usecomma);
< 		$links .= $author;
< 	}
< 	
< 	if ( !( $useMajor || $useMinor || $useAuthor ) ) {
< 		$links .= "no other diffs";
< 	}
< 	$links .= ")";
< 	
< 	if ( ( !defined($diffText) ) || ( $diffText eq "" ) ) {
< 		$diffText = "No diff available.";
< 	}
< 	
< 	if ( $revOld ne "" ) {
< 		my $currentRevision = "current revision";
< 		
< 		$currentRevision = "revision $revNew " if $revNew;
< 		$html .= "<h4>Difference (from revision $revOld to $currentRevision)</h4>";
< 		$html .= "$links<br><br>";
< 		$html .= &DiffToHTML($diffText);
< 	}
< 	else {
< 		if (
< 			( $diffType != 2 )
< 			&& (   ( !defined( &GetPageCache("old$cacheName") ) )
< 				|| ( &GetPageCache("old$cacheName") < 1 ) )
< 		  )
< 		{
< 			$html .= "<h4>No diff available -- this is the first $priorName revision.</h4>";
< 			$html .= "$links<br><br>";
< 		}
< 		else {
< 			$html .= "<h4>Difference from prior $priorName revision</h4>";
< 			$html .= "$links<br><br>";
< 			$html .= &DiffToHTML($diffText);
< 		}
< 	}
< 	@HeadingNumbers  = ();
< 	$TableOfContents = "";
< 		
< 	return $html;
< }
< 
< sub GetCacheDiff {
< 	my ($type) = @_;
< 	my ($diffText);
< 	
< 	$diffText = &GetPageCache("diff_default_$type");
< 	$diffText = &GetCacheDiff('minor') if ( $diffText eq "1" );
< 	$diffText = &GetCacheDiff('major') if ( $diffText eq "2" );
< 	
< 	return $diffText;
< }
< 
< # Must be done after minor diff is set and OpenKeptRevisions called
< sub GetKeptDiff {
< 	my ( $newText, $oldRevision, $lock ) = @_;
< 	my ( %sect, %data, $oldText );
< 	
< 	$oldText = "";
< 	if ( defined( $KeptRevisions{$oldRevision} ) ) {
< 		%sect = split( /$FS2/, $KeptRevisions{$oldRevision}, -1 );
< 		%data = split( /$FS3/, $sect{'data'}, -1 );
< 		$oldText = $data{'text'};
< 	}
< 	
< 	return "" if ( $oldText eq "" );    # Old revision not found
< 	return &GetDiff( $oldText, $newText, $lock );
< }
< 
< sub GetDiff {
<   my $textOld = shift;
<   my $textNew = shift;
< 
<   my %format = (
<     paraIdent     => '<tr valign=top><td class="diff-para-ident">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident">%text%</td></tr>',
<     paraAdded     => '<tr valign=top><td class="diff-para-ident"></td><td class="diff-vertical"></td><td class="diff-para-added">%text%</td></tr>',
<     paraDeleted   => '<tr valign=top><td class="diff-para-deleted">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident"></td></tr>',
<     paraChanged   => '<tr valign=top><td class="diff-para-changed-old">%text%</td><td class="diff-vertical"></td><td class="diff-para-changed-new">%text%</td></tr>',
<     paraReplaced  => '<tr valign=top><td class="diff-para-deleted">%textDeleted%</td><td class="diff-vertical"></td><td class="diff-para-added">%textAdded%</td></tr>',
<   
<     changeContext => 1,
<     changeHeader  => '<tr valign=top><td class="diff-header">Paragraph %oldFrom%</td><td class="diff-vertical">&nbsp;</td><td class="diff-header">Paragraph %newFrom%</td></tr>',
<   
<     spanIdent     => '<span class="diff-span-ident">%text%</span>',
<     spanAdded     => '<span class="diff-span-added">%text%</span>',
<     spanDeleted   => '<span class="diff-span-deleted">%text%</span>',
< 
<     processText => sub {
< 
<       my $text = shift;
< 
<       $text =~ s[&]               [&amp;]g;
<       $text =~ s[<]               [&lt;]g;
<       $text =~ s[>]               [&gt;]g;
<       $text =~ s[\n]              [<br>\n]g;
<       $text =~ s[\r]              []g;
<       $text =~ s[([\t ]+)([\t ])] [('&nbsp;' x length($1)) . $2]ge;
<       $text =~ s[^[\t ]]          [&nbsp;];
< 
<       return $text;
<     }
<   );
< 
<   my $diff = Diff::diffText($textOld, $textNew, %format);
<   
<   if ($diff ne "") {
<     $diff =~ s[<td class="diff-para-changed-old">(.*?)</td>] [
<       my $textChanged = $1;
<       $textChanged =~ s[<span class="diff-span-added">.*?</span>] []gs;
<       qq[<td class="diff-para-changed">$textChanged</td>];
<     ]ges;
<     
<     $diff =~ s[<td class="diff-para-changed-new">(.*?)</td>] [
<       my $textChanged = $1;
<       $textChanged =~ s[<span class="diff-span-deleted">.*?</span>] []gs;
<       qq[<td class="diff-para-changed">$textChanged</td>];
<     ]ges;
<   
<     $diff = qq[<div id=wikidiffdiv><table id=wikidifftable>$diff</table></div>];
<   }
< 
<   return $diff;
< }
< 
< sub DiffToHTML { shift }
< 
< # ==== Database (Page, Section, Text, Kept, User) functions ====
< sub OpenNewPage {
< 	my ($id) = @_;
< 	
< 	%Page             = ();
< 	$Page{'version'}  = 3;       # Data format version
< 	$Page{'revision'} = 0;       # Number of edited times
< 	$Page{'tscreate'} = $Now;    # Set once at creation
< 	$Page{'ts'}       = $Now;    # Updated every edit
< 	$Page{'authorcreate'} = GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
< }
< 
< sub OpenNewSection {
< 	my ( $name, $data ) = @_;
< 	
< 	%Section             = ();
< 	$Section{'name'}     = $name;
< 	$Section{'version'}  = 1;                   # Data format version
< 	$Section{'revision'} = 0;                   # Number of edited times
< 	$Section{'tscreate'} = $Now;                # Set once at creation
< 	$Section{'ts'}       = $Now;                # Updated every edit
< 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
< 	$Section{'host'} 	 = "";        # Updated only for real edits (can be slow)
< 	$Section{'id'}   	 = $UserID;
< 	$Section{'username'} = &GetParam( "username", "" );
< 	$Section{'data'}     = $data;
< 	$Page{$name} 		 = join( $FS2, %Section );    # Replace with save?
< 	$Page{'authorcreate'}= GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
< }
< 
< sub OpenNewText {
< 	my ($name) = @_;                          # Name of text (usually "default")
< 	
< 	%Text = ();
< 	
< 	if ( $NewText ne "" ) { $Text{'text'} = $NewText; }
< 	else { $Text{'text'} = "Describe the new page here."; }
< 	
< 	$Text{'text'} .= "\n" if ( substr( $Text{'text'}, -1, 1 ) ne "\n" );
< 	$Text{'minor'}     = 0;                   # Default as major edit
< 	$Text{'newauthor'} = 1;                   # Default as new author
< 	$Text{'summary'}   = "";
< 	
< 	&OpenNewSection( "text_$name", join( $FS3, %Text ) );
< }
< 
< sub GetPageFile {
< 	my ($id) = @_;
< 	
< 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
< }
< 
< sub OpenPage {
< 	my ($id) = @_;
< 	my ( $fname, $data );
< 	
< 	if (!CheckIsAuthUser($id)) { $id = "AuthError"; } #auth patch
< 	if ( $OpenPageName eq $id ) { return; }
< 	if ( $id eq ""){ return; }
< 		
< 	%Section = ();
< 	%Text    = ();
< 	$fname   = &GetPageFile($id);
< 	
< 	if ( -f $fname ) {
< 		$data = &ReadFileOrDie($fname);
< 		%Page = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	}
< 	else {
< 		&OpenNewPage($id);
< 	}
< 	
< 	if ( $Page{'version'} != 3 ) { &UpdatePageVersion(); }
< 	
< 	$OpenPageName = $id;
< }
< 
< sub OpenSection {
< 	my ($name) = @_;
< 	
< 	if ( !defined( $Page{$name} ) ) { &OpenNewSection( $name, "" ); }
< 	else { %Section = split( /$FS2/, $Page{$name}, -1 ); }
< }
< 
< sub OpenText {
< 	my ($name) = @_;
< 	
< 	if ( !defined( $Page{"text_$name"} ) ) {
< 		&OpenNewText($name);
< 	}
< 	else {
< 		&OpenSection("text_$name");
< 		%Text = split( /$FS3/, $Section{'data'}, -1 );
< 	}
< }
< 
< sub OpenDefaultText {
< 	&OpenText('default');
< }
< 
< # Called after OpenKeptRevisions
< sub OpenKeptRevision {
< 	my ($revision) = @_;
< 	
< 	%Section = split( /$FS2/, $KeptRevisions{$revision}, -1 );
< 	%Text = split( /$FS3/, $Section{'data'}, -1 );
< }
< 
< sub GetPageCache {
< 	my ($name) = @_;
< 	
< 	return $Page{"cache_$name"};
< }
< 
< # Always call SavePage within a lock.
< sub SavePage {
< 	my $file = &GetPageFile($OpenPageName);
< 	
< 	$Page{'revision'} += 1;    # Number of edited times
< 	$Page{'ts'} = $Now;        # Updated every edit
< 	&CreatePageDir( $PageDir, $OpenPageName );
< 	&WriteStringToFile( $file, join( $FS1, %Page ) );
< }
< 
< sub SaveSection {
< 	my ( $name, $data ) = @_;
< 	
< 	$Section{'revision'} += 1;    # Number of edited times
< 	$Section{'ts'}       = $Now;                          # Updated every edit
< 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
< 	$Section{'id'}       = $UserID;
< 	$Section{'username'} = &GetParam( "username", "" );
< 	$Section{'data'}     = $data;
< 	$Page{$name} = join( $FS2, %Section );
< }
< 
< sub SaveText {
< 	my ($name) = @_;
< 	
< 	&SaveSection( "text_$name", join( $FS3, %Text ) );
< }
< 
< sub SaveDefaultText {
< 	&SaveText('default');
< }
< 
< sub SetPageCache {
< 	my ( $name, $data ) = @_;
< 	
< 	$Page{"cache_$name"} = $data;
< }
< 
< sub UpdatePageVersion {
< 	&ReportError( "Bad page version (or corrupt page)." );
< }
< 
< sub KeepFileName {
< 	return $KeepDir . "/"
< 	  . &GetPageDirectory($OpenPageName)
< 	  . "/$OpenPageName.kp";
< }
< 
< sub SaveKeepSection {
< 	my $file = &KeepFileName();
< 	my $data;
< 	
< 	return if ( $Section{'revision'} < 1 );    # Don't keep "empty" revision
< 	
< 	$Section{'keepts'} = $Now;
< 	$data = $FS1 . join( $FS2, %Section );
< 	&CreatePageDir( $KeepDir, $OpenPageName );
< 	&AppendStringToFileLimited( $file, $data, $KeepSize );
< }
< 
< sub ExpireKeepFile {
< 	my ( $fname, $data, @kplist, %tempSection, $expirets );
< 	my ( $anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev );
< 	my ( $oldMajor, $oldAuthor );
< 	
< 	$fname = &KeepFileName();
< 	return if ( !( -f $fname ) );
< 	
< 	$data = &ReadFileOrDie($fname);
< 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	return if ( length(@kplist) < 1 );    # Also empty
< 	
< 	shift(@kplist) if ( $kplist[0] eq "" );    # First can be empty
< 	return if ( length(@kplist) < 1 );         # Also empty
< 	
< 	%tempSection = split( /$FS2/, $kplist[0], -1 );
< 
< 	if ( !defined( $tempSection{'keepts'} ) ) {
< 		return;                                # Bad keep file
< 	}
< 	
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 	return if ( $tempSection{'keepts'} >= $expirets );    # Nothing old enough
< 	
< 	$anyExpire = 0;
< 	$anyKeep   = 0;
< 	%keepFlag  = ();
< 	$oldMajor  = &GetPageCache('oldmajor');
< 	$oldAuthor = &GetPageCache('oldauthor');
< 	
< 	foreach ( reverse @kplist ) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName    = $tempSection{'name'};
< 		$sectRev     = $tempSection{'revision'};
< 		$expire      = 0;
< 		
< 		if ( $sectName eq "text_default" ) {
< 			if (   ( $KeepMajor && ( $sectRev == $oldMajor ) )
< 				|| ( $KeepAuthor && ( $sectRev == $oldAuthor ) ) )
< 			{
< 				$expire = 0;
< 			}
< 			elsif ( $tempSection{'keepts'} < $expirets ) {
< 				$expire = 1;
< 			}
< 		}
< 		else {
< 			if ( $tempSection{'keepts'} < $expirets ) {
< 				$expire = 1;
< 			}
< 		}
< 		if ( !$expire ) {
< 			$keepFlag{ $sectRev . "," . $sectName } = 1;
< 			$anyKeep = 1;
< 		}
< 		else {
< 			$anyExpire = 1;
< 		}
< 	}
< 	if ( !$anyKeep ) {    # Empty, so remove file
< 		unlink($fname);
< 		return;
< 	}
< 	return if ( !$anyExpire );    # No sections expired
< 	
< 	open( OUT, ">$fname" ) or die( Ts( 'cant write %s', $fname ) . ": $!" );
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName    = $tempSection{'name'};
< 		$sectRev     = $tempSection{'revision'};
< 		
< 		if ( $keepFlag{ $sectRev . "," . $sectName } ) {
< 			print OUT $FS1, $_;
< 		}
< 	}
< 	close(OUT);
< }
< 
< sub OpenKeptList {
< 	my ( $fname, $data );
< 	
< 	@KeptList = ();
< 	$fname    = &KeepFileName();
< 	return if ( !( -f $fname ) );
< 	
< 	$data = &ReadFileOrDie($fname);
< 	@KeptList = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< }
< 
< sub OpenKeptRevisions {
< 	my ($name) = @_;    # Name of section
< 	my ( $fname, $data, %tempSection );
< 	
< 	%KeptRevisions = ();
< 	&OpenKeptList();
< 	
< 	foreach (@KeptList) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		next if ( $tempSection{'name'} ne $name );
< 		$KeptRevisions{ $tempSection{'revision'} } = $_;
< 	}
< }
< 
< sub LoadUserData {
< 	my ( $data, $status );
< 	
< 	%UserData = ();
< 	( $status, $data ) = &ReadFile( &UserDataFilename($UserID) );
< 	
< 	if ( !$status ) {
< 		$UserID = 112;    # Could not open file.  Consider warning message?
< 		return;
< 	}
< 	
< 	%UserData = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< }
< 
< sub UserDataFilename {
< 	my ($id) = @_;
< 	
< 	if ($id =~ /(\d+)/){
< 		$id = $1;
< 	}
< 	else { die "The userid must be a positive integer"; }
< 	
< 	return "" if ( $id < 1 );
< 	return $UserDir . "/" . ( $id % 10 ) . "/$id.db";
< }
< 
< # ==== Misc. functions ====
< sub ReportError {
< 	my ($errmsg) = @_;
< 	
< 	print &GetHeader( "", "ERROR!", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>$errmsg</h2>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub ValidId {
< 	my ($id) = @_;
< 	
< 	if ( length($id) > 120 ) {
< 		return Ts( 'Page name is too long: %s', $id );
< 	}
< 	
< 	if ( $id =~ m| | ) {
< 		return Ts( 'Page name may not contain space characters: %s', $id );
< 	}
< 	
< 	if ($UseSubpage) {
< 		if ( $id =~ m|.*/.*/| ) {
< 			return Ts( 'Too many / characters in page %s', $id );
< 		}
< 		if ( $id =~ /^\// ) {
< 			return Ts( 'Invalid Page %s (subpage without main page)', $id );
< 		}
< 		if ( $id =~ /\/$/ ) {
< 			return Ts( 'Invalid Page %s (missing subpage name)', $id );
< 		}
< 	}
< 	
< 	if ($FreeLinks) {
< 		$id =~ s/ /_/g;
< 		if ( !$UseSubpage ) {
< 			if ( $id =~ /\// ) {
< 				return Ts( 'Invalid Page %s (/ not allowed)', $id );
< 			}
< 		}
< 		if ( !( $id =~ m|^$FreeLinkPattern$| ) ) {
< 			return Ts( 'Invalid Page %s', $id );
< 		}
< 		if ( $id =~ m|\.db$| ) {
< 			return Ts( 'Invalid Page %s (must not end with .db)', $id );
< 		}
< 		if ( $id =~ m|\.lck$| ) {
< 			return Ts( 'Invalid Page %s (must not end with .lck)', $id );
< 		}
< 		return "";
< 	}
< 	else {
< 		if ( !( $id =~ /^$LinkPattern$/ ) ) {
< 			return Ts( 'Invalid Page %s', $id );
< 		}
< 	}
< 	
< 	return "";
< }
< 
< sub ValidIdOrDie {
< 	my ($id) = @_;
< 	my $error;
< 	
< 	$error = &ValidId($id);
< 	
< 	if ( $error ne "" ) {
< 		&ReportError($error);
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub UserCanEdit {
< 	my ( $id, $deepCheck ) = @_;
< 	my $authtype = &CheckIsAuthUser($id);
< 	
< 	# Optimized for the "everyone can edit" case (don't check passwords)
< 	if ( ( $id ne "" ) && ( -f &GetLockedPageFile($id) ) ) {
< 		return 1 if ( &UserIsAdmin() );    # Requires more privledges
< 		     # Consider option for editor-level to edit these pages?
< 		return 0;
< 	}
< 	if ( !$EditAllowed ) {
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0;
< 	}
< 	if ( -f "$DataDir/noedit" ) {
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0;
< 	}
< 	if ($deepCheck) {    # Deeper but slower checks (not every page)
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0 if ( &UserIsBanned() );
< 	}
< 	
< 	return 1;
< }
< 
< sub UserIsBanned {
< 	my ( $host, $ip, $data, $status );
< 	( $status, $data ) = &ReadFile("$DataDir/banlist");
< 	
< 	return 0 if ( !$status );    # No file exists, so no ban
< 	$data =~ s/\r//g;
< 	$ip   = $ENV{'REMOTE_ADDR'};
< 	$host = &GetRemoteHost(0);
< 	
< 	foreach ( split( /\n/, $data ) ) {
< 		next if ( (/^\s*$/) || (/^#/) );    # Skip empty, spaces, or comments
< 		return 1 if ( $ip   =~ /$_/i );
< 		return 1 if ( $host =~ /$_/i );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsAdmin {
< 	my ( @pwlist, $userPassword );
< 	
< 	return 0 if ( $AdminPass eq "" );
< 	$userPassword = &GetParam( "adminpw", "" );
< 	return 0 if ( $userPassword eq "" );
< 	
< 	foreach ( split( /\s+/, $AdminPass ) ) {
< 		next     if ( $_            eq "" );
< 		return 1 if ( $userPassword eq $_ );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsEditor {
< 	my ( @pwlist, $userPassword );
< 	
< 	return 1 if ( &UserIsAdmin() );    # Admin includes editor
< 	return 0 if ( $EditPass eq "" );
< 	$userPassword = &GetParam( "password", "" );    # Used for both
< 	return 0 if ( $userPassword eq "" );
< 	
< 	foreach ( split( /\s+/, $EditPass ) ) {
< 		next     if ( $_            eq "" );
< 		return 1 if ( $userPassword eq $_ );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsEditorOrAdmin {
< 	return (UserIsEditor || UserIsAdmin);	
< }
< 
< sub UserCanUpload {
< 	return 1 if ( &UserIsEditor() );
< 	return $AllUpload;
< }
< 
< sub GetLockedPageFile {
< 	my ($id) = @_;
< 	
< 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
< }
< 
< sub RequestLockDir {
< 	my ( $name, $tries, $wait, $errorDie ) = @_;
< 	my ( $lockName, $n );
< 	
< 	&CreateDir($TempDir);
< 	$lockName = $LockDir . $name;
< 	$n        = 0;
< 	
< 	while ( mkdir( $lockName, 0555 ) == 0 ) {
< 		if ( $! != 17 ) {
< 			die( Ts( 'can not make %s', $LockDir ) . ": $!\n" ) if $errorDie;
< 			return 0;
< 		}
< 		return 0 if ( $n++ >= $tries );
< 		sleep($wait);
< 	}
< 	
< 	return 1;
< }
< 
< sub ReleaseLockDir {
< 	my ($name) = @_;
< 	
< 	rmdir( $LockDir . $name );
< }
< 
< sub RequestLock {
< 	# 10 tries, 3 second wait, possibly die on error
< 	return &RequestLockDir( "main", 10, 3, $LockCrash );
< }
< 
< sub ReleaseLock {
< 	&ReleaseLockDir('main');
< }
< 
< sub ForceReleaseLock {
< 	my ($name) = @_;
< 	my $forced;
< 
< 	# First try to obtain lock (in case of normal edit lock)
< 	# 5 tries, 3 second wait, do not die on error
< 	$forced = !&RequestLockDir( $name, 5, 3, 0 );
< 	&ReleaseLockDir($name);    # Release the lock, even if we didn't get it.
< 	
< 	return $forced;
< }
< 
< sub RequestCacheLock {
< 	# 4 tries, 2 second wait, do not die on error
< 	return &RequestLockDir( 'cache', 4, 2, 0 );
< }
< 
< sub ReleaseCacheLock {
< 	&ReleaseLockDir('cache');
< }
< 
< sub RequestDiffLock {
< 	# 4 tries, 2 second wait, do not die on error
< 	return &RequestLockDir( 'diff', 4, 2, 0 );
< }
< 
< sub ReleaseDiffLock {
< 	&ReleaseLockDir('diff');
< }
< 
< # Index lock is not very important--just return error if not available
< sub RequestIndexLock {
< 	# 1 try, 2 second wait, do not die on error
< 	return &RequestLockDir( 'index', 1, 2, 0 );
< }
< 
< sub ReleaseIndexLock {
< 	&ReleaseLockDir('index');
< }
< 
< sub ReadFile {
< 	my ($fileName) = @_;
< 	my ($data);
< 	
< 	local $/ = undef;    # Read complete files
< 	if ( open( IN, "<$fileName" ) ) {
< 		$data = <IN>;
< 		close IN;
< 		return ( 1, $data );
< 	}
< 	
< 	return ( 0, "" );
< }
< 
< sub ReadFileOrDie {
< 	my ($fileName) = @_;
< 	my ( $status, $data );
< 	
< 	( $status, $data ) = &ReadFile($fileName);
< 	if ( !$status ) {
< 		die( Ts( 'Can not open %s', $fileName ) . ": $!" );
< 	}
< 	
< 	return $data;
< }
< 
< sub WriteStringToFile {
< 	my ( $file, $string ) = @_;
< 	
< 	open( OUT, ">$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
< 	print OUT $string;
< 	close(OUT);
< }
< 
< sub AppendStringToFile {
< 	my ( $file, $string ) = @_;
< 	
< 	open( OUT, ">>$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
< 	print OUT $string;
< 	close(OUT);
< }
< 
< sub AppendStringToFileLimited {
< 	my ( $file, $string, $limit ) = @_;
< 	
< 	if ( ( $limit < 1 ) || ( ( ( -s $file ) + length($string) ) <= $limit ) ) {
< 		&AppendStringToFile( $file, $string );
< 	}
< }
< 
< sub CreateDir {
< 	my ($newdir) = @_;
< 	
< 	mkdir( $newdir, 0775 ) if ( !( -d $newdir ) );
< }
< 
< sub CreatePageDir {
< 	my ( $dir, $id ) = @_;
< 	my $subdir;
< 	
< 	&CreateDir($dir);    # Make sure main page exists
< 	$subdir = $dir . "/" . &GetPageDirectory($id);
< 	&CreateDir($subdir);
< 	
< 	if ( $id =~ m|([^/]+)/| ) {
< 		$subdir = $subdir . "/" . $1;
< 		&CreateDir($subdir);
< 	}
< }
< 
< sub UpdateHtmlCache {
< 	my ( $id, $html ) = @_;
< 	my $idFile;
< 	
< 	$idFile = &GetHtmlCacheFile($id);
< 	&CreatePageDir( $HtmlDir, $id );
< 	if ( &RequestCacheLock() ) {
< 		&WriteStringToFile( $idFile, $html );
< 		&ReleaseCacheLock();
< 	}
< }
< 
< sub GenerateAllPagesList {
< 	my ( @pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId );
< 	
< 	@pages = ();
< 	if ($FastGlob) {
< 		# The following was inspired by the FastGlob code by Marc W. Mengel.
< 		# Thanks to Bob Showalter for pointing out the improvement.
< 		opendir( PAGELIST, $PageDir );
< 		@dirs = readdir(PAGELIST);
< 		closedir(PAGELIST);
< 		@dirs = sort(@dirs);
< 		foreach $dir (@dirs) {
< 			next
< 			  if ( substr( $dir, 0, 1 ) eq '.' );  # No ., .., or .dirs or files
< 			opendir( PAGELIST, "$PageDir/$dir" );
< 			@pageFiles = readdir(PAGELIST);
< 			closedir(PAGELIST);
< 			foreach $id (@pageFiles) {
< 				next if ( ( $id eq '.' ) || ( $id eq '..' ) );
< 				if ( substr( $id, -3 ) eq '.db' ) {
< 					push( @pages, substr( $id, 0, -3 ) );
< 				}
< 				elsif ( substr( $id, -4 ) ne '.lck' ) {
< 					opendir( PAGELIST, "$PageDir/$dir/$id" );
< 					@subpageFiles = readdir(PAGELIST);
< 					closedir(PAGELIST);
< 					foreach $subId (@subpageFiles) {
< 						if ( substr( $subId, -3 ) eq '.db' ) {
< 							push( @pages, "$id/" . substr( $subId, 0, -3 ) );
< 						}
< 					}
< 				}
< 			}
< 		}
< 	}
< 	else {
< 		# Old slow/compatible method.
< 		@dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
< 		
< 		foreach $dir (@dirs) {
< 			if ( -e "$PageDir/$dir" ) {    # Thanks to Tim Holt
< 				while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
< 					s|^$PageDir/||;
< 					m|^[^/]+/(\S*).db|;
< 					$id = $1;
< 					push( @pages, $id );
< 				}
< 			}
< 		}
< 	}
< 	
< 	return sort(@pages);
< }
< 
< sub AllPagesList {
< 	my ( $rawIndex, $refresh, $status );
< 	
< 	if ( !$UseIndex ) {
< 		return &GenerateAllPagesList();
< 	}
< 	
< 	$refresh = &GetParam( "refresh", 0 );
< 	if ( $IndexInit && !$refresh ) {
< 
< 		# Note for mod_perl: $IndexInit is reset for each query
< 		# Eventually consider some timestamp-solution to keep cache?
< 		return @IndexList;
< 	}
< 	
< 	if ( ( !$refresh ) && ( -f $IndexFile ) ) {
< 		( $status, $rawIndex ) = &ReadFile($IndexFile);
< 		
< 		if ($status) {
< 			%IndexHash = split( /\s+/, $rawIndex );
< 			@IndexList = sort( keys %IndexHash );
< 			$IndexInit = 1;
< 			
< 			return @IndexList;
< 		}
< 
< 		# If open fails just refresh the index
< 	}
< 	
< 	@IndexList = ();
< 	%IndexHash = ();
< 	@IndexList = &GenerateAllPagesList();
< 	
< 	foreach (@IndexList) {
< 		$IndexHash{$_} = 1;
< 	}
< 	
< 	$IndexInit = 1;    # Initialized for this run of the script
< 	                   # Try to write out the list for future runs
< 	&RequestIndexLock() or return @IndexList;
< 	&WriteStringToFile( $IndexFile, join( " ", %IndexHash ) );
< 	&ReleaseIndexLock();
< 	
< 	return @IndexList;
< }
< 
< sub AllSubPagesList {
< 	my $GivenPage = shift;
< 	my @PageList = &AllPagesList();
< 	my @Results;
< 	
< 	foreach (@PageList){
< 		if (/^$GivenPage\//i){
< 			push @Results, $_;	
< 		}
< 	}
< 	
< 	return @Results;
< }
< 
< sub CalcDay {
< 	my ($ts) = @_;
< 	
< 	$ts += $TimeZoneOffset;
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
< 	
< 	if ($NumberDates) {
< 		$year = $year + 1900;
< 		$mon = $mon + 1;
< 		if ($mon < 10){ $mon = "0$mon"; }
< 		if ($mday < 10){ $mday = "0$mday"; }
< 		
< 		return "$year$NumberDatesDelim$mon$NumberDatesDelim$mday";
< 	}
< 	
< 	return (
< 		"January",   "February", "March",    "April",
< 		"May",       "June",     "July",     "August",
< 		"September", "October",  "November", "December"
< 	  )[$mon]
< 	  . " "
< 	  . $mday . ", "
< 	  . ( $year + 1900 );
< }
< 
< sub CalcTime {
< 	my ($ts) = @_;
< 	my ( $ampm, $mytz );
< 	
< 	$ts += $TimeZoneOffset;
< 	
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
< 	$mytz = "";
< 	
< 	if ( ( $TimeZoneOffset == 0 ) && ( $ScriptTZ ne "" ) ) {
< 		$mytz = " " . $ScriptTZ;
< 	}
< 	$ampm = "";
< 	
< 	if ($UseAmPm) {
< 		$ampm = " am";
< 		if ( $hour > 11 ) {
< 			$ampm = " pm";
< 			$hour = $hour - 12;
< 		}
< 		$hour = 12 if ( $hour == 0 );
< 	}
< 	
< 	$min = "0" . $min if ( $min < 10 );
< 	
< 	return $hour . ":" . $min . $ampm . $mytz;
< }
< 
< sub TimeToText {
< 	my ($t) = @_;
< 	
< 	return &CalcDay($t) . " " . &CalcTime($t);
< }
< 
< sub GetParam {
< 	my ( $name, $default ) = @_;
< 	my $result;
< 	
< 	$result = $q->param($name);
< 	
< 	if ( !defined($result) ) {
< 		if ( defined( $UserData{$name} ) ) {
< 			$result = $UserData{$name};
< 		}
< 		else {
< 			$result = $default;
< 		}
< 	}
< 	
< 	return $result;
< }
< 
< sub GetHiddenValue {
< 	my ( $name, $value ) = @_;
< 	
< 	$q->param( $name, $value );
< 	
< 	return $q->hidden($name);
< }
< 
< sub GetRemoteHost {
< 	my ($doMask) = @_;
< 	my ( $rhost, $iaddr );
< 	
< 	$rhost = $ENV{REMOTE_HOST};
< 	
< 	if ( $UseLookup && ( $rhost eq "" ) ) {
< 
< 		# Catch errors (including bad input) without aborting the script
< 		eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
< 		  . '$rhost = gethostbyaddr($iaddr, AF_INET)';
< 	}
< 	
< 	if ( $rhost eq "" ) {
< 		$rhost = $ENV{REMOTE_ADDR};
< 	}
< 	
< 	$rhost = &GetMaskedHost($rhost) if ($doMask);
< 	
< 	return $rhost;
< }
< 
< sub FreeToNormal {
< 	my ($id) = @_;
< 	
< 	$id =~ s/ /_/g;
< 	$id = ucfirst($id) if ( $UpperFirst || $FreeUpper );
< 	
< 	if ( index( $id, '_' ) > -1 ) {    # Quick check for any space/underscores
< 		$id =~ s/__+/_/g;
< 		$id =~ s/^_//;
< 		$id =~ s/_$//;
< 		
< 		if ($UseSubpage) {
< 			$id =~ s|_/|/|g;
< 			$id =~ s|/_|/|g;
< 		}
< 	}
< 	
< 	if ($FreeUpper) {
< 
< 		# Note that letters after ' are *not* capitalized
< 		if ( $id =~ m|[-_.,\(\)/][a-z]| ) { # Quick check for non-canonical case
< 			$id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
< 		}
< 	}
< 	
< 	return $id;
< }
< 
< #END_OF_BROWSE_CODE
< # == Page-editing and other special-action code ========================
< $OtherCode = "";    # Comment next line to always compile (slower)
< 
< #$OtherCode = <<'#END_OF_OTHER_CODE';
< sub DoOtherRequest {
< 	my ( $id, $action, $filter, $text, $search );
< 	
< 	$action = &GetParam( "action", "" );
< 	$id     = &GetParam( "id",     "" );
< 	$filter = &GetParam( "filter", "" );
< 	
< 	if ( $action ne "" ) {
< 		$action = lc($action);
< 		
< 		if ( $action eq "edit" ) {
< 			&DoEdit( $id, 0, 0, "", 0 ) if &ValidIdOrDie($id);
< 		}
< 		elsif ( $action eq "unlock" ) {
< 			&DoUnlock();
< 		}
< 		elsif ( $action eq "index" ) {
< 			&DoIndex();
< 		}
< 		elsif ( $action eq "links" ) {
< 			&DoLinks();
< 		}
< 		elsif ( $action eq "maintain" ) {
< 			&DoMaintain();
< 		}
< 		elsif ( $action eq "pagelock" ) {
< 			&DoPageLock();
< 		}
< 		elsif ( $action eq "editlock" ) {
< 			&DoEditLock();
< 		}
< 		elsif ( $action eq "editprefs" ) {
< 			&DoEditPrefs();
< 		}
< 		elsif ( $action eq "editbanned" ) {
< 			&DoEditBanned();
< 		}
< 		elsif ( $action eq "editlinks" ) {
< 			&DoEditLinks();
< 		}
< 		elsif ( $action eq "login" ) {
< 			&DoEnterLogin();
< 		}
< 		elsif ( $action eq "newlogin" ) {
< 			$UserID = 0;
< 			&DoEditPrefs();    # Also creates new ID
< 		}
< 		elsif ( $action eq "version" ) {
< 			&DoShowVersion();
< 		}
< 		elsif ( $action eq "rss" ) {
< 			&DoRss();
< 		}
< 		elsif ( $action eq "delete" ) {
< 			&DoDeletePage($id);
< 		}
< 		elsif ( $UseUpload && ( $action eq "upload" ) ) {
< 			&DoUpload();
< 		}
< 		elsif ( $action eq "maintainrc" ) {
< 			&DoMaintainRc();
< 		}
< 		elsif ( $action eq "convert" ) {
< 			&DoConvert();
< 		}
< 		elsif ( $action eq "trimusers" ) {
< 			&DoTrimUsers();
< 		}
< 		elsif ( $action eq "listfiles" ) {
< 			&DoListFiles($id, $filter, 0);	
< 		}
< 		elsif ( $action eq "listdisabled" ) {
< 			&DoListFiles($id, $filter, 1);	
< 		}
< 		else {
< 			&ReportError( Ts( 'Invalid action parameter %s', $action ) );
< 		}
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_prefs", 0 ) ) {
< 		&DoUpdatePrefs();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_ban", 0 ) ) {
< 		&DoUpdateBanned();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "enter_login", 0 ) ) {
< 		&DoLogin();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_links", 0 ) ) {
< 		&DoUpdateLinks();
< 		return;
< 	}
< 	
< 	if ( $UseUpload && ( &GetParam( "upload", 0 ) ) ) {
< 		&SaveUpload();
< 		return;
< 	}
< 	
< 	$search = &GetParam( "search", "" );
< 	
< 	if ( ( $search ne "" ) || ( &GetParam( "dosearch", "" ) ne "" ) ) {
< 		&DoSearch($search, $filter);
< 		return;
< 	}
< 	else {
< 		$search = &GetParam( "back", "" );
< 		if ( $search ne "" ) {
< 			&DoBackLinks($search, $filter);
< 			
< 			return;
< 		}
< 	}
< 
< 	# Handle posted pages
< 	if ( &GetParam( "oldtime", "" ) ne "" ) {
< 		$id = &GetParam( "title", "" );
< 		&DoPost() if &ValidIdOrDie($id);
< 		
< 		return;
< 	}
< 	
< 	&ReportError( "Invalid URL." );
< }
< 
< sub PageIsLocked {
< 	my ($id, $deepedit) = @_;
< 	my ($result) = 0;
< 	
< 	if ( !&UserCanEdit( $id, $deepedit ) ) {
< 			$result = 1;
< 		if ( &UserIsBanned() ) {
< 			$result = 2;
< 		}
< 		else {
< 			$result = 3;
< 		}
< 	}
< 	
< 	return $result;
< }
< 
< sub DoEdit {
< 	my ( $id, $isConflict, $oldTime, $newText, $preview ) = @_;
< 	my ( $header, $editRows, $editCols, $userName, $revision, $oldText );
< 	my ( $summary, $isEdit, $pageTime, $isLocked );
< 	
< 	my $authtype = &CheckIsAuthUser($id);
< 	if (!$authtype) { $id = "AuthError"; } #auth patch	
< 	if ($FreeLinks) { $id = &FreeToNormal($id); }   # Take care of users like Markus Lude :-)	
< 	
< 	$isLocked = &PageIsLocked( $id, 1 );
< 	
< 	if ( $isLocked > 0 or $authtype eq "" || $authtype eq "1") {
< 		print &GetHeader( "", "Editing Denied", "" );
< 		print &GetLeftNav("");
< 		print "\n<div class='wikiadmin'>";
< 		
< 		if ( $isLocked == 2 ) {
< 			print "\n<h2>Editing not allowed: user, ip, or network is blocked.</h2>";
< 			print "\nContact the wiki administrator for more information.";
< 		}
< 		else {
< 			print "\n<h2>Editing not allowed: $id is read-only.</h2>";
< 		}
< 		
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></body></html>";
< 			
< 		return;
< 	}
< 
< 	# Consider sending a new user-ID cookie if user does not have one
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$pageTime = $Section{'ts'};
< 	$header   = Ts( 'Editing %s', $id );
< 
< 	# Old revision handling
< 	$revision = &GetParam( 'revision', "" );
< 	$revision =~ s/\D//g;    # Remove non-numeric chars
< 	
< 	if ( $revision ne "" ) {
< 		&OpenKeptRevisions('text_default');
< 		
< 		if ( !defined( $KeptRevisions{$revision} ) ) {
< 			$revision = "";
< 
< 			# Consider better solution like error message?
< 		}
< 		else {
< 			&OpenKeptRevision($revision);
< 			$header = Ts( 'Editing revision %s of ', $revision ) . $id;
< 		}
< 	}
< 	
< 	$oldText = $Text{'text'};
< 	
< 	if ( $preview && !$isConflict ) { $oldText = $newText; }
< 	
< 	$editRows = &GetParam( "editrows", 20 );
< 	$editCols = &GetParam( "editcols", 65 );
< 	
< 	print &GetHeader( "", &QuoteHtml($header), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $revision ne "" ) {
< 		print "\n<b>Editing old revision $revision. Saving this page will replace the latest revision with this text.</b><br>";
< 	}
< 	
< 	if ($isConflict) {
< 		$editRows -= 10 if ( $editRows > 19 );
< 		print "\n<H1>Edit Conflict!</H1>";
< 		
< 		if ( $isConflict > 1 ) {
< 
< 			# The main purpose of a new warning is to display more text
< 			# and move the save button down from its old location.
< 			print "\n<h2>(This is a new conflict)</h2>";
< 		}
< 		
< 		print "\n<p><strong>";
< 		print "\nSomeone saved this page after you started editing. ";
< 		print "\nThe top textbox contains the saved text. ";
< 		print "\nOnly the text in the top textbox will be saved.";
< 		print "\n</strong></p><br>";
< 		print "\nScroll down to see your edited text.";
< 		print "\n<br>";
< 		print "\nLast save time: ";
< 		print &TimeToText($oldTime);
< 		print "\n(Current time is: ";
< 		print &TimeToText($Now);
< 		print "\n)<br>";
< 	}
< 	
< 	print "\n<div id='wikieditbar'>";
< 	print "<a href='$ScriptName?WikiStyleGuide'>WikiStyleGuide</a> | ";
< 	print "<a href='$ScriptName?WikiHeadings'>WikiHeadings</a> | ";
< 	print "<a href='$ScriptName?WikiGallery'>WikiGallery</a>| ";
< 	print "<a href='$ScriptName?WikiFlash'>WikiFlash</a>| ";
< 	print "<a href='$ScriptName?WikiTOCs'>WikiTOCs</a> | ";
< 	print "<a href='$ScriptName?WikiURLs'>WikiURLs</a> | ";
< 	print "<a href='$ScriptName?WikiImages'>WikiImages</a> | ";
< 	print "<a href='$ScriptName?WikiTables'>WikiTables</a> | ";
< 	print "<a href='$ScriptName?WikiLists'>WikiLists</a> | ";
< 	print "<a href='$ScriptName?WikiMarkup'>WikiMarkup</a>";
< 	print "\n</div>";
< 	
< 	print "\n<br>";
< 	print "\n<form id='wikiform' action='$ScriptName#preview-anchor' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( "title",   $id );
< 	print &GetHiddenValue( "oldtime",     $pageTime );
< 	print &GetHiddenValue( "oldconflict", $isConflict );
< 	  
< 	if ( $revision ne "" ) { print &GetHiddenValue( "revision", $revision ); }
< 	
< 	print &GetTextArea( 'text', $oldText, $editRows, $editCols );
< 	$summary = &GetParam( "summary", "*" );
< 	
< 	print "\n<br><br><div id='wikisaveedit'>Summary:";
< 	print
< 	  $q->textfield(
< 		-name      => 'summary',
< 		-id		   => 'summarytext',
< 		-default   => $summary,
< 		-override  => 1,
< 		-size      => 60,
< 		-maxlength => 200
< 	  );
< 	  
< 	if ( &GetParam("recent_edit") eq "on" ) {
< 		print "\n<br>",
< 		  $q->checkbox(
< 			-name    => 'recent_edit',
< 			-checked => 1,
< 			-label   => "This change is a minor edit."
< 		  );
< 		print "\n<br>";
< 	}
< 	else {
< 		print "\n<br>",
< 		  $q->checkbox(
< 			-name  => 'recent_edit',
< 			-checked => 0,
< 			-label => "This change is a minor edit."
< 		  );
< 		print "\n<br>";
< 	}
< 	
< 	if ($EmailNotify) {
< 		print "\n&nbsp;&nbsp;&nbsp;"
< 		  . $q->checkbox(
< 			-name  => 'do_email_notify',
< 			-label =>
< 			  Ts( 'Send email notification that %s has been changed.', $id )
< 		  );
< 	}
< 	
< 	print "\n<br>";
< 	
< 	if ( $EditNote ne "" ) { print $EditNote . '<br>'; }
< 	
< 	$userName = &GetParam( "username", "" );
< 	print $q->submit( -name => 'Preview', -value => 'Preview' );
< 	print $q->button( -name => 'Cancel', -value => 'Cancel', -onclick => 'window.location="' . $ScriptName . '?' . $id . '";' );
< 	print $q->submit( -name => 'Save', -value => "Save" );	
< 	
< 	if ( $userName ne "" ) {
< 		print "\n (Your user name is ";
< 		print &GetPageLinkText($HomePagePrefix . '/' . $userName, $userName);
< 		print "\n )";
< 	}
< 	else {
< 		print ' (', Ts( 'Visit %s to set your user name.', &GetPrefsLink() ), ') ';
< 	}
< 
< 	if ($isConflict) {
< 		print "\n<br><hr><p><strong>";
< 		print "\nThis is the text you submitted:";
< 		print  "</strong><p>";
< 		print &GetTextArea( 'newtext', $newText, $editRows, $editCols );
< 	}
< 	
< 	print "\n</div>";
< 	print "\n</form>";
< 	print "<a name='preview-anchor'></a>";
< 	print "\n</div>";			
< 	print "\n$WikiLineFooter";
< 	
< 	if ($preview) {
< 		
< 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
< 		print $WikiLineHeaderPreview;
< 		print "\n<div id='wikipreview' class='wikipreview'>";
< 					
< 		if ($isConflict) {
< 			print "\n<b>NOTE: This preview shows the revision of the other author.</b><hr>";
< 		}
< 		
< 		$MainPage = $id;
< 		$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
< 		
< 		print &WikiToHTML($oldText);
< 		print "\n</div>";
< 		print "\n$WikiLineFooter";
< 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
< 		print "\n<div id='wikibar'>&nbsp</div>";
< 	}
< 
< 	print "\n<div class='wikifooter'>";	
< 	print "<div class='wikirevision'>";
< 	print &GetHistoryLink( $id, "View other revisions<br>", "Click to view revision history");
< 	print "</div>";
< 	print &GetGotoBar($id);
< 	print &getFooterNote();
< 	
< 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
< 			
< 	print "\n</div></div></body></html>";	
< }
< 
< sub GetTextArea {
< 	my ( $name, $text, $rows, $cols ) = @_;
< 	my ( $html );
< 	
< 	$html = "\n<div style='width: 100%;'>";
< 	if ( &GetParam( "editwide", 1 ) ) {
< 		$html .= $q->textarea(
< 			-name     => $name,
< 			-default  => $text,
< 			-id       => 'wikitextarea' . $name,
< 			-rows     => $rows,
< 			-columns  => $cols,
< 			-override => 1,
< 			-style    => 'width:100%',
< 			-wrap     => 'virtual'
< 		);
< 	}
< 	else {
< 		$html .= $q->textarea(
< 			-name     => $name,
< 			-default  => $text,
< 			-id       => 'wikitextarea' . $name,
< 			-rows     => $rows,
< 			-columns  => $cols,
< 			-override => 1,
< 			-wrap     => 'virtual'
< 		);
< 	}
< 	
< 	$html .= "</div>";
< 	
< 	return $html;
< }
< 
< sub DoEditPrefs {
< 	my ( $check, $recentName, %labels );
< 	
< 	$recentName = $RCName;
< 	$recentName =~ s/_/ /g;
< 	
< 	&DoNewLogin() if ( $UserID < 400 );
< 	
< 	print &GetHeader( "", "Editing Preferences", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikidiff'>";
< 	print "\n<h2>Access Controls</h2>";
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( "edit_prefs", 1 );
< 	print "\n<table class='wikilargelist'>";
< 	print "\n<tr><th colspan='2'><b>User Information </b></th></tr>";
< 	print "\n<tr><td>Your User ID number </td><td>$UserID</td></tr>";
< 	print "\n<tr><td>UserName</td>";
< 	print "\n<td>" . &GetFormText( 'username', "", 30, 50 );
< 	print "\n<br>(blank to remove, or valid page name)</td></tr>";
< 	print "\n<tr><td>Set Password </td>";
< 	print "\n<td>";
< 	print
< 	  $q->password_field(
< 		-name      => 'p_password',
< 		-value     => '*',
< 		-size      => 30,
< 		-maxlength => 50
< 	  );
< 	 print "\n<br>(blank to remove password)";
< 	 print "\n<br>Passwords allow sharing preferences between multiple systems. Passwords are completely optional. ";
< 	 print "\n</td></tr>";
< 
< 
< 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
< 		print "\n<tr><td>Administrator Password </td>";
< 		print "\n<td>";
< 		print
< 		  $q->password_field(
< 			-name      => 'p_adminpw',
< 			-value     => '*',
< 			-size      => 30,
< 			-maxlength => 50
< 		  );
< 		print "\n<br>(blank to remove password)";
< 		print "\n<br>(Administrator passwords are used for special maintenance.)";
< 		print "\n</td></tr>";
< 	}
< 	
< 	if ($EmailNotify) {
< 		print "\n<tr><td>Email Address</td>";
< 		print "\n<td>" . &GetFormText( 'email', "", 30, 60 );
< 		print "\n<br>" . &GetFormCheck( 'notify', 1, "Include this address in the site email list." );
< 		print "\n<br>(Uncheck the box to remove the address.) ";
< 		
< 		print "\n</td></tr>";
< 	}
< 	
< 	print "\n</table>";
< 	
< 	print "\n$WikiLinePref<b>$recentName:</b>";
< 	print "\n<br>Default days to display: ";
< 	print &GetFormText( 'rcdays', $RcDefault, 4, 9 );
< 	print "\n<br>", &GetFormCheck( 'rcnewtop', $RecentTop, "Most recent changes on top" );
< 	print "\n<br>", &GetFormCheck( 'rcall', 0, "Show all changes (not just most recent)" );
< 	
< 	%labels = (
< 		0 => "Hide minor edits",
< 		1 => "Show minor edits",
< 		2 => "Show only minor edits"
< 	);
< 	
< 	print "\n<br>Minor edit display: ";
< 	print $q->popup_menu(
< 		-name   => 'p_rcshowedit',
< 		-values => [ 0, 1, 2 ],
< 		-labels => \%labels,
< 		-default => &GetParam( "rcshowedit", $ShowEdits )
< 	);
< 	
< 	print "\n<br>", &GetFormCheck( 'rcchangehist', 1, "Use 'changes' as link to history" );
< 
< 	if ($UseDiff) {
< 		print "\n$WikiLinePref<b>Differences:</b>";
< 		print "\n<br>", &GetFormCheck( 'diffrclink', 1, "Show (diff) links on $recentName " );
< 		print "\n<br>", &GetFormCheck( 'alldiff', 0, "Show differences on all pages" );
< 		print "\n  (", &GetFormCheck( 'norcdiff', 1, "No differences on $recentName " ), ")";
< 		%labels = ( 1 => "Major", 2 => "Minor", 3 => "Author" );
< 		print "\n<br>Default difference type: ";
< 		print $q->popup_menu(
< 			-name   => 'p_defaultdiff',
< 			-values => [ 1, 2, 3 ],
< 			-labels => \%labels,
< 			-default => &GetParam( "defaultdiff", 1 )
< 		);
< 	}
< 	
< 	print "\n$WikiLinePref<b>Misc:</b>";
< 
< 	# Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
< 	print "\n<br>";
< 	print "\nServer time: ";
< 	print &TimeToText( $Now - $TimeZoneOffset );
< 	print &GetFormText( 'tzoffset', 0, 4, 9 );
< 	print "\n<br>";
< 	print &GetFormCheck( 'editwide', 1, "Use 100% wide edit area (if supported)" );
< 	print "\n<br>";
< 	print "\nEdit area rows: ";
< 	print &GetFormText( 'editrows', 20, 4, 4 );
< 	print "\n columns: ";
< 	print &GetFormText( 'editcols', 65, 4, 4 );
< 	print "\n<br>";
< 	print &GetFormCheck( 'toplinkbar', 1, "Show link bar on top" );
< 	print "\n<br>";
< 	print &GetFormCheck( 'linkrandom', 0, "Add 'Random Page' link to link bar" );
< 	print "\n<br>";
< 	print "\nStyleSheet URL: ";
< 	print &GetFormText( 'stylesheet', "", 30, 150 );
< 	print "\n<br><br>";
< 	print "\n<input type='button' name='Cancel' value='Cancel' onclick='history.go(-1);' style='margin-right: 20px;'>";
< 	print "\n<input type='reset' name='Reset'> ";
< 	print $q->submit( -name => 'Save', -value => "Save" );
< 	print "\n</form>";
< 	print "\n</div>";
< 	print "\n$WikiLineFooter";
< 	print "\n<div class='wikifooter'>";
< 	print &GetGotoBar("");
< 
< 	print &getFooterNote();
< 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
< 	print "\n</div></div></body></html>";	
< }
< 
< sub GetFormText {
< 	my ( $name, $default, $size, $max ) = @_;
< 	my $text = &GetParam( $name, $default );
< 	
< 	return $q->textfield(
< 		-name      => "p_$name",
< 		-default   => $text,
< 		-override  => 1,
< 		-size      => $size,
< 		-maxlength => $max
< 	);
< }
< 
< sub GetFormCheck {
< 	my ( $name, $default, $label ) = @_;
< 	my $checked = ( &GetParam( $name, $default ) > 0 );
< 	
< 	return $q->checkbox(
< 		-name     => "p_$name",
< 		-override => 1,
< 		-checked  => $checked,
< 		-label    => $label
< 	);
< }
< 
< sub DoUpdatePrefs {
< 	my ( $username, $password, $stylesheet );
< 
< 	# All link bar settings should be updated before printing the header
< 	&UpdatePrefCheckbox("toplinkbar");
< 	&UpdatePrefCheckbox("linkrandom");
< 	
< 	print &GetHeader( "", "Saving Preferences" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $UserID < 1001 ) {
< 		print "\n<h2>Invalid UserID $UserID, preferences not saved.</h2>";
< 		
< 		if ( $UserID == 111 ) {
< 			print "\n<br>(Preferences require cookies, but no cookie was sent.)";
< 		}
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></body></html>";
< 		
< 		return;
< 	}
< 	
< 	$username = &GetParam( "p_username", "" );
< 	
< 	if ($FreeLinks) {
< 		$username =~ s/^\[\[(.+)\]\]/$1/;    # Remove [[ and ]] if added
< 		$username = &FreeToNormal($username);
< 		$username =~ s/_/ /g;
< 	}
< 	
< 	if ( $username eq "" ) {
< 		print "\n<h2>UserName removed.</h2>";
< 		undef $UserData{'username'};
< 	}
< 	elsif ( ( !$FreeLinks ) && ( !( $username =~ /^$LinkPattern$/ ) ) ) {
< 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
< 	}
< 	elsif ( $FreeLinks && ( !( $username =~ /^$FreeLinkPattern$/ ) ) ) {
< 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
< 	}
< 	elsif ( length($username) > 50 ) {    # Too long
< 		print "\n<h2>UserName must be 50 characters or less. (not saved)</h2>";
< 	}
< 	else {
< 		print "\n<h2>UserName $username saved.</h2>";
< 		$UserData{'username'} = $username;
< 	}
< 	
< 	$password = &GetParam( "p_password", "" );
< 	
< 	if ( $password eq "" ) {
< 		print "\nPassword removed.<br>";
< 		undef $UserData{'password'};
< 	}
< 	elsif ( $password ne "*" ) {
< 		print "\nPassword changed.<br>";
< 		$UserData{'password'} = $password;
< 	}
< 	
< 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
< 		$password = &GetParam( "p_adminpw", "" );
< 		if ( $password eq "" ) {
< 			print "\nAdministrator password removed.<br>";
< 			undef $UserData{'adminpw'};
< 		}
< 		elsif ( $password ne "*" ) {
< 			print "\nAdministrator password changed.<br>";
< 			$UserData{'adminpw'} = $password;
< 			
< 			if ( &UserIsAdmin() ) {
< 				print "\nUser has administrative abilities.<br>";
< 			}
< 			elsif ( &UserIsEditor() ) {
< 				print "\nUser has editor abilities.<br>";
< 			}
< 			else {
< 				print "\nUser does not have administrative abilities. (Password does not match administrative password(s).) <br>";
< 			}
< 		}
< 	}
< 	
< 	if ($EmailNotify) {
< 		&UpdatePrefCheckbox("notify");
< 		&UpdateEmailList();
< 	}
< 	
< 	&UpdatePrefNumber( "rcdays", 0, 0, 999999 );
< 	&UpdatePrefCheckbox("rcnewtop");
< 	&UpdatePrefCheckbox("rcall");
< 	&UpdatePrefCheckbox("rcchangehist");
< 	&UpdatePrefCheckbox("editwide");
< 	
< 	if ($UseDiff) {
< 		&UpdatePrefCheckbox("norcdiff");
< 		&UpdatePrefCheckbox("diffrclink");
< 		&UpdatePrefCheckbox("alldiff");
< 		&UpdatePrefNumber( "defaultdiff", 1, 1, 3 );
< 	}
< 	
< 	&UpdatePrefNumber( "rcshowedit", 1, 0,    2 );
< 	&UpdatePrefNumber( "tzoffset",   0, -999, 999 );
< 	&UpdatePrefNumber( "editrows",   1, 1,    999 );
< 	&UpdatePrefNumber( "editcols",   1, 1,    999 );
< 	
< 	print "\n<br>Server time: ";
< 	print &TimeToText( $Now - $TimeZoneOffset );
< 	print "\n<br>";
< 	$TimeZoneOffset = &GetParam( "tzoffset", 0 ) * ( 60 * 60 );
< 	
< 	print"Local time: ";
< 	print &TimeToText($Now);
< 	print "\n<br>";
< 	$stylesheet = &GetParam( 'p_stylesheet', "" );
< 
< 	if ( $stylesheet eq "" ) {
< 		if ( &GetParam( 'stylesheet', "" ) ne "" ) {
< 			print "\nStyleSheet URL removed.<br>";
< 		}
< 		undef $UserData{'stylesheet'};
< 	}
< 	else {
< 		$stylesheet =~ s/[">]//g;  # Remove characters that would cause problems"
< 		$UserData{'stylesheet'} = $stylesheet;
< 		print "\nStyleSheet setting saved.<br>";
< 	}
< 	
< 	&SaveUserData();
< 	
< 	print "\n<br><b>Preferences saved.</b>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # add or remove email address from preferences to $EmailFile
< sub UpdateEmailList {
< 	my (@old_emails);
< 	local $/ = "\n";               # don't slurp whole files in this sub.
< 	
< 	if ( my $new_email = $UserData{'email'} = &GetParam( "p_email", "" ) ) {
< 		my $notify = $UserData{'notify'};
< 		if ( -f $EmailFile ) {
< 			open( NOTIFY, $EmailFile ) or die( Ts( 'Could not read from %s:', $EmailFile ) . " $!\n" );
< 			@old_emails = <NOTIFY>;
< 			close(NOTIFY);
< 		}
< 		else {
< 			@old_emails = ();
< 		}
< 		
< 		my $already_in_list = grep /$new_email/, @old_emails;
< 		
< 		if ( $notify and ( not $already_in_list ) ) {
< 			&RequestLock() or die( "Could not get mail lock" );
< 			if ( !open( NOTIFY, ">>$EmailFile" ) ) {
< 				&ReleaseLock();    # Don't leave hangling locks
< 				die( "Could not append to $EmailFile : $!\n" );
< 			}
< 			
< 			print NOTIFY $new_email, "\n";
< 			close(NOTIFY);
< 			&ReleaseLock();
< 		}
< 		elsif ( ( not $notify ) and $already_in_list ) {
< 			&RequestLock() or die( "Could not get mail lock" );
< 			if ( !open( NOTIFY, ">$EmailFile" ) ) {
< 				&ReleaseLock();
< 				die( "Could not overwrite $EmailFile : $!\n" );
< 			}
< 			foreach (@old_emails) {
< 				print NOTIFY "$_" unless /$new_email/;
< 			}
< 			
< 			close(NOTIFY);
< 			&ReleaseLock();
< 		}
< 	}
< }
< 
< sub UpdatePrefCheckbox {
< 	my ($param) = @_;
< 	my $temp = &GetParam( "p_$param", "*" );
< 	
< 	$UserData{$param} = 1 if ( $temp eq "on" );
< 	$UserData{$param} = 0 if ( $temp eq "*" );
< 
< 	# It is possible to skip updating by using another value, like "2"
< }
< 
< sub UpdatePrefNumber {
< 	my ( $param, $integer, $min, $max ) = @_;
< 	my $temp = &GetParam( "p_$param", "*" );
< 	
< 	return if ( $temp eq "*" );
< 	
< 	$temp =~ s/[^-\d\.]//g;
< 	$temp =~ s/\..*// if ($integer);
< 	
< 	return if ( $temp eq "" );
< 	return if ( ( $temp < $min ) || ( $temp > $max ) );
< 	
< 	$UserData{$param} = $temp;
< }
< 
< sub DoIndex {
< 	print &GetHeader( "", "Index of all pages", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print PrintPageList( "", &AllPagesList() );
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Create a new user file/cookie pair
< sub DoNewLogin {
< 	# Consider warning if cookie already exists
< 	# (maybe use "replace=1" parameter)
< 	&CreateUserDir();
< 	$SetCookie{'id'}      = &GetNewUserId();
< 	$SetCookie{'randkey'} = int( rand(1000000000) );
< 	$SetCookie{'rev'}     = 1;
< 	%UserCookie           = %SetCookie;
< 	$UserID               = $SetCookie{'id'};
< 
< 	# The cookie will be transmitted in the next header
< 	%UserData               = %UserCookie;
< 	$UserData{'createtime'} = $Now;
< 	$UserData{'createip'}   = $ENV{REMOTE_ADDR};
< 	&SaveUserData();
< }
< 
< sub DoEnterLogin {
< 	print &GetHeader( "", "Login", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>Enter UserID</h2>";
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( 'enter_login', 1 );
< 	print "\n<table><tr>";
< 	print "\n<td>User ID number &nbsp;</td>";
< 	print "\n<td>";
< 	print
< 	  $q->textfield(
< 		-name      => 'p_userid',
< 		-value     => "",
< 		-size      => 15,
< 		-maxlength => 50
< 	  );
< 	print "\n</td>";
< 	print "\n<tr>";
< 	print "\n<td>Password  &nbsp;</td>";
< 	print "\n<td>";
< 	print
< 	  $q->password_field(
< 		-name      => 'p_password',
< 		-value     => "",
< 		-size      => 15,
< 		-maxlength => 50
< 	  );
< 	print "\n</td>";
< 	print "\n</tr></table><br>";
< 	print $q->submit( -name => 'Login', -value => 'Login' );
< 	print "\n<br></form></div>";
< 	print &GetCommonFooter();
< 	print "\n</div></body></html>";	
< }
< 
< sub DoLogin {
< 	my ( $uid, $password, $success );
< 	
< 	$success = 0;
< 	$uid = &GetParam( "p_userid", "" );
< 	$uid =~ s/\D//g;
< 	$password = &GetParam( "p_password", "" );
< 	
< 	print &GetHeader( "", "Login Results", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( ( $uid > 199 ) && ( $password ne "" ) && ( $password ne "*" ) ) {
< 		$UserID = $uid;
< 		&LoadUserData();
< 		if ( $UserID > 199 ) {
< 			if ( defined( $UserData{'password'} ) && ( $UserData{'password'} eq $password ) ) {
< 				$SetCookie{'id'}      = $uid;
< 				$SetCookie{'randkey'} = $UserData{'randkey'};
< 				$SetCookie{'rev'}     = 1;
< 				$success              = 1;
< 			}
< 			else {
< 				print "\nUserID Account Undefined<br>";
< 			}
< 		}
< 		else {
< 			print "\nUserID must be above 199<br>";
< 		}
< 	}
< 	
< 	
< 	if ($success) { print "\n<h2>Login for user ID $uid complete.</h2>"; }
< 	else { print "\n<h2>Login for user ID $uid failed.</h2>"; }
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter;
< 	print "\n</div></body></html>";	
< }
< 
< sub GetNewUserId {
< 	my ($id);
< 	
< 	$id = $StartUID;
< 	
< 	while ( -f &UserDataFilename( $id + 1000 ) ) { $id += 1000; }
< 	while ( -f &UserDataFilename( $id + 100 ) ) { $id += 100; }
< 	while ( -f &UserDataFilename( $id + 10 ) ) { $id += 10; }
< 	
< 	&RequestLock() or die( "Could not get user-ID lock" );
< 
< 	while ( -f &UserDataFilename($id) ) { $id++; }
< 	
< 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
< 	&ReleaseLock();
< 	
< 	return $id;
< }
< 
< # Consider user-level lock?
< sub SaveUserData {
< 	my ( $userFile, $data );
< 	
< 	&CreateUserDir();
< 	$userFile = &UserDataFilename($UserID);
< 	$data = join( $FS1, %UserData );
< 	&WriteStringToFile( $userFile, $data );
< }
< 
< sub CreateUserDir {
< 	my ( $n, $subdir );
< 	
< 	if ( !( -d "$UserDir/0" ) ) {
< 		&CreateDir($UserDir);
< 		foreach $n ( 0 .. 9 ) {
< 			$subdir = "$UserDir/$n";
< 			&CreateDir($subdir);
< 		}
< 	}
< }
< 
< sub DoSearch {
< 	my ($string, $filter) = @_;
< 	my ( $title );
< 	
< 	if ( $string eq "" ) {
< 		&DoIndex();
< 		return;
< 	}
< 	
< 	print &GetHeader( "", &QuoteHtml( Ts( "Search for: $title %s", $string ) ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print PrintPageList( $filter, &SearchTitleAndBody($string, $filter) );
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
< 	print "\n<input type='hidden' name='search' value='$string'>";
< 	print "\n<input type='hidden' name='dosearch' value='1'>";	
< 	print "\n<input type='submit' value='Apply Filter'>";	
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoBackLinks {
< 	my ($string, $filter) = @_;
< 	my ($title);
< 	
< 	$title = $string;
< 	
< 	print &GetHeader( "", &QuoteHtml( Ts( 'Backlinks for: %s', $string ) ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	# At this time the backlinks are mostly a renamed search.
< 	# An initial attempt to match links only failed on subpages and free links.
< 	# Escape some possibly problematic characters:
< 	
< 	$string =~ s/([_ ])/( |_)/g;
< 	$string =~ s/([-'(),])/\\$1/g; #'REMARK
< 	$string =~ m,/, ? "\\b$string\\b" : "$string\\b";
< 	
< 	print PrintPageList( grep($_ !~ $title, $filter, &SearchTitleAndBody($string, $filter, "")) );
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
< 	print "\n<input type='hidden' name='back' value='$string'>";
< 	print "\n<input type='submit' value='Apply Filter'>";	
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub PrintPageList {
< 	my ($filter, @results) = @_;
< 	my $term;
<     my $pagename;
<     my $html = "";
<     my $pagecount = scalar(@results);
<     my $currentInitial = "";
<     my $thisInitial;
<     my $lastInitial;
<     my $letterGrouping = ($pagecount > 25);
<     my $currentParent = "";
<     my $linktext = "";
<     my $notFirst;
< 
< 	if ($filter ne ""){ $term = " using filter '<em>$filter</em>'"; }
< 	$html .= "<h2>" . ( scalar(@results) ) . " pages found: $term</h2>";
<     #$html .= "<ol>\n" if ($letterGrouping ne 1); # commented to keep a 'original' usemod look
<     
<     if ($letterGrouping) {
<         $html .= "<h3 class='lettergroup'>";
<         foreach $pagename (@results) {
<             $thisInitial = substr($pagename,0,1);
<             if ($thisInitial ne $lastInitial) {
<                     $html .= "<a href=\"#letter".$thisInitial."\">".$thisInitial."</a> ";
<                     $lastInitial = $thisInitial;
<             }
<         }
<         $html .= "</h3>";
<     }
<     
<     foreach $pagename (@results) {
<         if ($letterGrouping) {
<             $thisInitial = substr($pagename,0,1);
<             if ($currentInitial ne $thisInitial) {
<                 #$html .= "</ol>" if ($currentInitial ne ""); # commented to keep a 'original' usemod look
<                 $html .= "\n<br><br><h3 class='lettergroup'><a name=\"letter$thisInitial\"> $thisInitial </h3>\n$WikiLine\n";
<                 #$html .= "<ol>\n"; # commented to keep a 'original' usemod look
<                 $currentInitial = $thisInitial; 
<                 $notFirst = 0;
<             }
<         }
<         #$html .= "<li>"; # commented to keep a 'original' usemod look
<         $html .= "   ";
<         if (not($pagename =~ m|(.*)/(.*)|)) {
<             $currentParent = $pagename;
<             $linktext = $pagename;
<         } 
<         else {
<             if ($1 eq $currentParent) {
<                 if ($letterGrouping){  $linktext = "$currentParent/$2";}
<                 else { $html .= "... "; $linktext = "/$2";}                
<             } 
<             else {
<                 $linktext = $pagename;
<             }
<         }
<         if ($notFirst){ $notFirst = 1; $linktext = ", $linktext"; }
<         $html .= &GetPageLinkText($pagename,$linktext);
< 
<         if ($letterGrouping){ if ($notFirst){ $html .= ", "; }}
<         else { $html .= "\n<br>"; }
<     }
<     #$html .= "</ol>\n"; # commented to keep a 'original' usemod look
<     $html .= "\n<br>";
<     
<     return $html;
< }
< 
< sub DoLinks {	
< 	print &GetHeader( "", &QuoteHtml( "Full Link List" ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<hr><pre>\n\n\n\n";    # Extra lines to get below the logo
< 
< 	print &PrintLinkList(&GetFullLinkList(
< 		&GetParam("unique", 1),
< 		&GetParam("sort", 1),
< 		&GetParam("page", 1),
< 		&GetParam("inter", 0),
< 		&GetParam("url", 0),
< 		&GetParam("exists", 2),
< 		&GetParam("empty", 0),
< 		&GetParam("search", "")
< 	));
< 	
< 	print "\n</pre>";
< 	print "\n</div>";
< 	print "\n</div></div></body></html>";	
< }
< 
< sub PrintLinkList {
< 	my ( $pagelines, $page,  $names, $editlink );
< 	my ( $link, $text, $extra, @links, %pgExists );
< 	
< 	%pgExists = ();
< 	
< 	foreach $page ( &AllPagesList() ) {
< 		$pgExists{$page} = 1;
< 	}
< 	
< 	$names    = &GetParam( "names",    1 );
< 	$editlink = &GetParam( "editlink", 0 );
< 	
< 	foreach $pagelines (@_) {
< 		@links = ();
< 		
< 		foreach $page ( split( ' ', $pagelines ) ) {
< 			if ( $page =~ /\:/ ) {    # URL or InterWiki form
< 				if ( $page =~ /$UrlPattern/ ) {
< 					( $link, $extra ) = &UrlLink( $page, 0 );    # No images
< 				}
< 				else {
< 					( $link, $extra ) = &InterPageLink( $page, 0 );  # No images
< 				}
< 			}
< 			else {
< 				if ( $pgExists{$page} ) {
< 					$link = &GetPageLink($page);
< 				}
< 				else {
< 					$link = $page;
< 					if ($editlink) {
< 						$link .= &GetEditLink( $page, "?" );
< 					}
< 				}
< 			}
< 			
< 			push( @links, $link );
< 		}
< 		if ( !$names ) {
< 			shift(@links);
< 		}
< 		
< 		$text .= join(' ', @links) . "\n";
< 	}
< 	
< 	return $text;
< }
< 
< sub GetFullLinkList {
< 	my ($unique, $sort, $pagelink, $interlink, $urllink, $exists, $empty, $search, $listWantedPages )= @_ ;
< 	my ($name, $link ); # foreach iterators (though why not use $_ ?)
< 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
< 
< 	#my ($name, $unique, $sort, $exists, $empty, $link, $search);
< 	#my ($pagelink, $interlink, $urllink);	
< 	#$unique = &GetParam("unique", 1);
< 	#$sort = &GetParam("sort", 1);
< 	#$pagelink = &GetParam("page", 1);
< 	#$interlink = &GetParam("inter", 0);
< 	#$urllink = &GetParam("url", 0);
< 	#$exists = &GetParam("exists", 2);
< 	#$empty = &GetParam("empty", 0);
< 	#$search = &GetParam("search", "");
< 	
< 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) {
< 		$pagelink = 0;
< 	}
< 	%pgExists = ();
< 	@pglist   = &AllPagesList();
< 	
< 	foreach $name (@pglist) {
< 		$pgExists{$name} = 1;
< 	}
< 	%seen = ();
< 	
< 	foreach $name (@pglist) {
< 		@newlinks = ();
< 		if ( $unique != 2 ) {
< 			%seen = ();
< 		}
< 		
< 		@links = &GetPageLinks($name, $pagelink, $interlink, $urllink, $listWantedPages);
< 	
< 	    foreach $link (@links) {
< 			if ($link =~ m/^\//){
< 				$name =~ m/(.*)\//;
< 				
< 				if ($1){ $link = $1 . $link; }
< 				else { $link = $name . $link; }
< 			}
< 			
< 			$seen{$link}++;
< 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) {
< 				next;
< 			}
< 			
< 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) {
< 				next;
< 			}
< 			
< 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) {
< 				next;
< 			}
< 			
< 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) {
< 				next;
< 			}
< 			push( @newlinks, $link );
< 		}
< 		
< 		@links = @newlinks;
< 		if ($sort) {
< 			@links = sort(@links);
< 		}
< 		unshift( @links, $name );
< 		
< 		if ( $empty || ( $#links > 0 ) ) {    # If only one item, list is empty.
< 			push( @found, join( ' ', @links ) );
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub GetSubpages {
< 	my ($parentPage) = @_;
< 	my ($dir, @subpageFiles, @pages, $subId);
< 	
< 	return "" unless $parentPage;
< 	$dir = GetPageDirectory($parentPage);
< 	
< 	opendir(PAGELIST, "$PageDir/$dir/$parentPage") or return "";
< 	@subpageFiles = readdir(PAGELIST);
< 	closedir(PAGELIST);
< 	
< 	foreach $subId (@subpageFiles) {
< 		if (substr($subId, -3) eq '.db') {
< 		  push(@pages, "$parentPage/" . substr($subId, 0, -3));
< 		}
< 	}
< 	
< 	return @pages;
< }
< 
< sub GetPageList {
< 	my ($pagename, $retval);
< 	my (@list) = @_;
< 
< 	foreach $pagename (@list) {
< 	##	$retval .= ".... " if ($pagename =~ m|/|);
< 		$retval .= "&nbsp;" . &GetPageLink($pagename) . "<br>";
< 	}
< 
< 	return $retval;
< }
< 
< sub GetPageLinks {
< 	my ( $name, $pagelink, $interlink, $urllink, $listWantedPages ) = @_;
< 	my ( $text, @links );
< 	
< 	@links = ();
< 	&OpenPage($name);
< 	&OpenDefaultText();
< 	
< 	$text = $Text{'text'};
< 	$text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
< 	$text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
< 	$text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
< 	$text =~ s/<tt>(.|\n)*?\<\/tt>/ /ig;
< 	
< 	if ($interlink) {
< 		$text =~ s/''+/ /g;    # Quotes can adjacent to inter-site links
< 		$text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 	}
< 	else {
< 		$text =~ s/$InterLinkPattern/ /g;
< 	}
< 	
< 	if ($urllink) {
< 		$text =~ s/''+/ /g;    # Quotes can adjacent to URLs
< 		$text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 	}
< 	else {
< 		$text =~ s/$UrlPattern/ /g;
< 	}
< 	
< 	if ($pagelink) {
< 		if ($FreeLinks) {
< 			my $f2 = $FreeLinkPattern;
< 			
< 			$text =~ s/\[\[$f2\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
< 			$text =~ s/\[\[$f2\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
< 		}
< 		
< 		if ($listWantedPages){ $text =~ s/\[((.|\n)*?)\]/ /ig; }
< 			
< 		if ($WikiLinks) {
< 			$text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 		}
< 	}
< 	
< 	return @links;
< }
< 
< sub DoPost {
< 	my ( $editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user );
< 	my $string      = &GetParam( "text",        undef );
< 	my $id          = &GetParam( "title",       "" );
< 	my $summary     = &GetParam( "summary",     "" );
< 	my $oldtime     = &GetParam( "oldtime",     "" );
< 	my $oldconflict = &GetParam( "oldconflict", "" );
< 	my $isEdit      = 0;
< 	my $editTime    = $Now;
< 	my $authorAddr  = $ENV{REMOTE_ADDR};
< 	
< 	if ($id =~ /()/){
< 		$id = $1;
< 	}
< 	else {
< 		die "The page name $id is not valid";
< 	}
< 	
< 	if ($FreeLinks){
< 		$id = &FreeToNormal($id);
< 	}
< 	
< 	if ( !&UserCanEdit( $id, 1 ) ) {
< 		# This is an internal interface--we don't need to explain
< 		&ReportError( Ts( 'Editing not allowed for %s.', $id ) );
< 		return;
< 	}
< 	
< 	if (   ( $id eq 'SampleUndefinedPage' )
< 		|| ( $id eq 'SampleUndefinedPage' )
< 		|| ( $id eq 'Sample_Undefined_Page' )
< 		|| ( $id eq 'Sample_Undefined_Page' ) )
< 	{
< 		&ReportError( " $id cannot be defined." );
< 		return;
< 	}
< 	
< 	$string  = &RemoveFS($string);
< 	$summary = &RemoveFS($summary);
< 	$summary =~ s/[\r\n]//g;
< 	
< 	if ( length($summary) > 300 ) {    # Too long (longer than form allows)
< 		$summary = substr( $summary, 0, 300 );
< 	}
< 
< 	# Add a newline to the end of the string (if it doesn't have one)
< 	$string .= "\n" if ( !( $string =~ /\n$/ ) );
< 
< 
< 	# Lock before getting old page to prevent races
< 	# Consider extracting lock section into sub, and eval-wrap it?
< 	# (A few called routines can die, leaving locks.)
< 	if ($LockCrash) {
< 		&RequestLock() or die( "Could not get editing lock" );
< 	}
< 	else {
< 		if ( !&RequestLock() ) {
< 			&ForceReleaseLock('main');
< 		}
< 
< 		# Clear all other locks.
< 		&ForceReleaseLock('cache');
< 		&ForceReleaseLock('diff');
< 		&ForceReleaseLock('index');
< 	}
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$old     = $Text{'text'};
< 	$oldrev  = $Section{'revision'};
< 	$pgtime  = $Section{'ts'};
< 	$preview = 0;
< 	$preview = 1 if ( &GetParam( "Preview", "" ) ne "" );
< 	
< 	if ( !$preview && ( $old eq $string ) ) {    # No changes (ok for preview)
< 		&ReleaseLock();
< 		&ReBrowsePage( $id, "", 1 );
< 		return;
< 	}
< 	
< 	if ( ( $UserID > 399 ) || ( $Section{'id'} > 399 ) ) {
< 		$newAuthor = ( $UserID ne $Section{'id'} );    # known user(s)
< 	}
< 	else {
< 		$newAuthor = ( $Section{'ip'} ne $authorAddr );    # hostname fallback
< 	}
< 	
< 	$newAuthor = 1 if ( $oldrev == 0 );    # New page
< 	$newAuthor = 0 if ( !$newAuthor );     # Standard flag form, not empty
< 	                                       # Detect editing conflicts and resubmit edit
< 	                                       
< 	if ( ( $oldrev > 0 ) && ( $newAuthor && ( $oldtime != $pgtime ) ) ) {
< 		&ReleaseLock();
< 		if ( $oldconflict > 0 ) {    # Conflict again...
< 			&DoEdit( $id, 2, $pgtime, $string, $preview );
< 		}
< 		else {
< 			&DoEdit( $id, 1, $pgtime, $string, $preview );
< 		}
< 		return;
< 	}
< 	
< 	if ($preview) {
< 		&ReleaseLock();
< 		&DoEdit( $id, 0, $pgtime, $string, 1 );
< 		return;
< 	}
< 	
< 	$user = &GetParam( "username", "" );
< 
< 	# If the person doing editing chooses, send out email notification
< 	if ($EmailNotify) {
< 		&EmailNotify( $id, $user )
< 		  if &GetParam( "do_email_notify", "" ) eq 'on';
< 	}
< 	
< 	if ( &GetParam( "recent_edit", "" ) eq 'on' ) {
< 		$isEdit = 1;
< 	}
< 	
< 	if ( !$isEdit ) {
< 		&SetPageCache( 'oldmajor', $Section{'revision'} );
< 	}
< 	
< 	if ($newAuthor) {
< 		&SetPageCache( 'oldauthor', $Section{'revision'} );
< 	}
< 	
< 	&SaveKeepSection();
< 	&ExpireKeepFile();
< 	
< 	if ($UseDiff) {
< 		&UpdateDiffs( $id, $editTime, $old, $string, $isEdit, $newAuthor );
< 	}
< 	
< 	$Text{'text'}      = $string;
< 	$Text{'minor'}     = $isEdit;
< 	$Text{'newauthor'} = $newAuthor;
< 	$Text{'summary'}   = $summary;
< 	$Section{'host'}   = &GetRemoteHost(1);
< 	
< 	&SaveDefaultText();
< 	&SavePage();
< 	&WriteRcLog( $id, $summary, $isEdit, $editTime, $Section{'revision'}, $user,
< 		$Section{'host'} );
< 
< 	if ($UseCache) {
< 		&UnlinkHtmlCache($id);    # Old cached copy is invalid
< 		if ( $Page{'revision'} < 2 ) {    # If this is a new page...
< 			&NewPageCacheClear($id);      # ...uncache pages linked to this one.
< 		}
< 	}
< 	
< 	if ( $UseIndex && ( $Page{'revision'} == 1 ) ) {
< 		unlink($IndexFile);               # Regenerate index on next request
< 	}
< 	
< 	&ReleaseLock();
< 	&ReBrowsePage( $id, "", 1 );
< }
< 
< sub UpdateDiffs {
< 	my ( $id, $editTime, $old, $new, $isEdit, $newAuthor ) = @_;
< 	my ( $editDiff, $oldMajor, $oldAuthor );
< 	
< 	$editDiff  = &GetDiff( $old, $new, 0 );    # 0 = already in lock
< 	$oldMajor  = &GetPageCache('oldmajor');
< 	$oldAuthor = &GetPageCache('oldauthor');
< 	
< 	if ($UseDiffLog) {
<   		my $editDiff = Diff::diffClassic($old, $new);  # add this line
<   		&WriteDiff($id, $editTime, $editDiff);
< 	}
< 	
< 	&SetPageCache( 'diff_default_minor', $editDiff );
< 	if ( $isEdit || !$newAuthor ) {
< 		&OpenKeptRevisions('text_default');
< 	}
< 	
< 	if ( !$isEdit ) {
< 		&SetPageCache( 'diff_default_major', "1" );
< 	}	
< 	else {
< 		&SetPageCache( 'diff_default_major',
< 			&GetKeptDiff( $new, $oldMajor, 0 ) );
< 	}
< 	
< 	if ($newAuthor) {
< 		&SetPageCache( 'diff_default_author', "1" );
< 	}	
< 	elsif ( $oldMajor == $oldAuthor ) {
< 		&SetPageCache( 'diff_default_author', "2" );
< 	}
< 	else {
< 		&SetPageCache( 'diff_default_author',
< 			&GetKeptDiff( $new, $oldAuthor, 0 ) );
< 	}
< }
< 
< # Translation note: the email messages are still sent in English
< # Send an email message.
< sub SendEmail {
< 	my ( $to, $from, $reply, $subject, $message ) = @_;
< 
< 	# sendmail options:
< 	#    -odq : send mail to queue (i.e. later when convenient)
< 	#    -oi  : do not wait for "." line to exit
< 	#    -t   : headers determine recipient.
< 	open( SENDMAIL, "| $SendMail -oi -t " ) or die "Can't send email: $!\n";
< 	print SENDMAIL "From: $from\n";
< 	print SENDMAIL "To: $to\n";
< 	print SENDMAIL "Reply-to: $reply\n";
< 	print SENDMAIL "Subject: $subject\n";
< 	print SENDMAIL "$message\n";
< 	close(SENDMAIL) or warn "sendmail didn't close nicely";
< }
< ## Email folks who want to know a note that a page has been modified. - JimM.
< sub EmailNotify {
< 	local $/ = "\n";    # don't slurp whole files in this sub.
< 	
< 	if ($EmailNotify) {
< 		my ( $id, $user ) = @_;
< 		
< 		if ($user) {
< 			$user = " by $user";
< 		}
< 		
< 		my $address;
< 		
< 		return if ( !-f $EmailFile );    # No notifications yet
< 		
< 		open( EMAIL, $EmailFile )
< 		  or die "Can't open $EmailFile: $!\n";
< 		$address = join ",", <EMAIL>;
< 		$address =~ s/\n//g;
< 		close(EMAIL);
< 		
< 		my $home_url        = $q->url();
< 		my $page_url        = $home_url . "?$id";
< 		my $editors_summary = $q->param("summary");
< 
< 		if ( ( $editors_summary eq "*" ) or ( $editors_summary eq "" ) ) {
< 			$editors_summary = "";
< 		}
< 		else {
< 			$editors_summary = " Summary: $editors_summary";
< 		}
< 		
< 		my $content = <<"END_MAIL_CONTENT";
< 
<  The $SiteName page $id at
<    $page_url
<  has been changed$user to revision $Page{revision}. $editors_summary
< 
<  (Replying to this notification will
<   send email to the entire mailing list,
<   so only do that if you mean to.
< 
<   To remove yourself from this list, visit
<   ${home_url}?action=editprefs .)
< END_MAIL_CONTENT
< 		my $subject = "The $id page at $SiteName has been changed.";
< 
< 		# I'm setting the "reply-to" field to be the same as the "to:" field
< 		# which seems appropriate for a mailing list, especially since the
< 		# $EmailFrom string needn't be a real email address.
< 		&SendEmail( $address, $EmailFrom, $address, $subject, $content );
< 	}
< }
< 
< sub SearchTitleAndBody {
< 	my ($term, $filter) = @_;
< 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
< 	
< 	#If the search term has a !preceding it, strip it and set the exclusion flag
< 	if ($term =~ m/^\!/){ 
< 		$excludeTerm = 1;
< 		$term = substr($term, 1);	
< 	}
< 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
< 	if ($filter =~ m/^\!/){ 
< 		$excludeFilter = 1;
< 		$filter = substr($filter, 1);	
< 	}
< 
< 	foreach $name ( &AllPagesList() ) {
< 		if ($excludeFilter){
< 			if ($filter) { next if ($name =~ m/$filter/); }
< 		}
< 		else {
< 			if ($filter) { next unless ($name =~ m/$filter/); }
< 
< 		}
< 		
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if (!$excludeTerm){  
< 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( $freeName =~ /$term/i ) {
< 					push( @found, $name );
< 				}
< 			}
< 		}
< 		else { 
< 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( ! ($freeName =~ /$term/i) ) {
< 					push( @found, $name );
< 				}
< 			}			
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub SearchBody {
< 	my ($string) = @_;
< 	my ( $name, @found );
< 	
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if ( $Text{'text'} =~ /$string/i ) {
< 			push( @found, $name );
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub UnlinkHtmlCache {
< 	my ($id) = @_;
< 	my $idFile;
< 	
< 	$idFile = &GetHtmlCacheFile($id);
< 	
< 	if ( -f $idFile ) {
< 		unlink($idFile);
< 	}
< }
< 
< sub NewPageCacheClear {
< 	my ($id) = @_;
< 	my $name;
< 	
< 	return if ( !$UseCache );
< 	
< 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
< 	                    # The following code used to search the body for the $id
< 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
< 		&UnlinkHtmlCache($name);
< 	}
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub DoUnlock {
< 	my $LockMessage = "Normal Unlock.";
< 	
< 	print &GetHeader( "", "Removing edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>This operation may take several seconds...</h2>\n";
< 	
< 	if ( &ForceReleaseLock('main') ) {
< 		$LockMessage = "Forced Unlock.";
< 	}
< 	
< 	&ForceReleaseLock('cache');
< 	&ForceReleaseLock('diff');
< 	&ForceReleaseLock('index');
< 	
< 	print "\n<br><h2>$LockMessage</h2>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub WriteRcLog {
< 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
< 	my ( $extraTemp, %extra );
< 	
< 	%extra = ();
< 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
< 	$extra{'name'}     = $name     if ( $name ne "" );
< 	$extra{'revision'} = $revision if ( $revision ne "" );
< 	$extraTemp = join( $FS2, %extra );
< 
< 	# The two fields at the end of a line are kind and extension-hash
< 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
< 	
< 	if ( !open( OUT, ">>$RcFile" ) ) {
< 		die( Ts( '%s log error:', $RCName ) . " $!" );
< 	}
< 	
< 	print OUT $rc_line . "\n";
< 	close(OUT);
< }
< 
< sub WriteDiff {
< 	my ( $id, $editTime, $diffString ) = @_;
< 	
< 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
< 	print OUT "------\n" . $id . "|" . $editTime . "\n";
< 	print OUT $diffString;
< 	close(OUT);
< }
< 
< # Actions are vetoable if someone edits the page before
< # the keep expiry time. For example, page deletion. If
< # no one edits the page by the time the keep expiry time
< # elapses, then no one has vetoed the last action, and the
< # action is accepted.
< # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
< sub ProcessVetos {
< 	my ($expirets);
< 	
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 	
< 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
< 	
< 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
< 		&DeletePage( $OpenPageName, 1, 1 );
< 		return ( 1, "(deleted)" );
< 	}
< 	
< 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
< 		my $fname = $1;
< 
< 		# Only replace an allowed, existing file.
< 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
< 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
< 				my $string = $1;
< 				
< 				$string =~ s/\r\n/\n/gms;
< 				open( OUT, ">$fname" ) or return 0;
< 				print OUT $string;
< 				close OUT;
< 				
< 				return ( 0, "(replaced)" );
< 			}
< 		}
< 	}
< 	return ( 0, "(done)" );
< }
< 
< sub DoMaintain {
< 	my ( $name, $fname, $data, $message, $status );
< 	
< 	print &GetHeader( "", "Maintenance on all pages", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	$fname = "$DataDir/maintain";
< 	
< 	if ( !&UserIsAdmin() ) {
< 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
< 			print "\nMaintenance not done. ";
< 			print "\n(Maintenance can only be done once every 12 hours.)";
< 			print "\nRemove the 'maintain' file or wait.";
< 			print "\n</div>";
< 			print &GetCommonFooter();
< 			print "\n</div></div></body></html>";
< 			
< 			return;
< 		}
< 	}
< 	
< 	&RequestLock() or die( "Could not get maintain-lock" );
< 
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		( $status, $message ) = &ProcessVetos();
< 		&ExpireKeepFile() unless $status;
< 		
< 		print "\n.... " if ( $name =~ m|/| );
< 		print &GetPageLink($name);
< 		print "\n $message<br>";
< 	}
< 
< 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
< 	&ReleaseLock();
< 
< 	# Do any rename/deletion commands
< 	# (Must be outside lock because it will grab its own lock)
< 	$fname = "$DataDir/editlinks";
< 	
< 	if ( -f $fname ) {
< 		$data = &ReadFileOrDie($fname);
< 		print "\n<hr>Processing rename/delete commands:<br>";
< 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
< 		unlink("$fname.old");
< 		rename( $fname, "$fname.old" );
< 	}
< 	
< 	if ($MaintTrimRc) {
< 		&RequestLock() or die( "Could not get lock for RC maintenance" );
< 		$status = &TrimRc();                # Consider error messages?
< 		&ReleaseLock();
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Must be called within a lock.
< # Thanks to Alex Schroeder for original code
< sub TrimRc {
< 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
< 
< 	# Determine the number of days to go back
< 	$days = 0;
< 	
< 	foreach (@RcDays) {
< 		$days = $_ if $_ > $days;
< 	}
< 	$starttime = $Now - $days * 24 * 60 * 60;
< 	return 1 if ( !-f $RcFile );    # No work if no file exists
< 	( $status, $data ) = &ReadFile($RcFile);
< 	
< 	if ( !$status ) {
< 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
< 		
< 		return 0;
< 	}
< 
< 	# Move the old stuff from rc to temp
< 	@rc = split( /\n/, $data );
< 	
< 	for ( $i = 0 ; $i < @rc ; $i++ ) {
< 		($ts) = split( /$FS3/, $rc[$i] );
< 		last if ( $ts >= $starttime );
< 	}
< 	
< 	return 1 if ( $i < 1 );    # No lines to move from new to old
< 	
< 	@temp = splice( @rc, 0, $i );
< 
< 	# Write new files and backups
< 	if ( !open( OUT, ">>$RcOldFile" ) ) {
< 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
< 		return 0;
< 	}
< 	print OUT join( "\n", @temp ) . "\n";
< 	close(OUT);
< 	
< 	&WriteStringToFile( $RcFile . '.old', $data );
< 	$data = join( "\n", @rc );
< 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
< 	&WriteStringToFile( $RcFile, $data );
< 	
< 	return 1;
< }
< 
< sub DoMaintainRc {
< 	print &GetHeader( "", "Maintaining RC log", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	return if ( !&UserIsAdminOrError() );
< 	&RequestLock() or die( "Could not get lock for RC maintenance" );
< 	
< 	if ( &TrimRc() ) {
< 		print "\n<br>RC maintenance done.<br>";
< 	}
< 	else {
< 		print "\n<br>RC maintenance not done.<br>";
< 	}
< 	&ReleaseLock();
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub UserIsEditorOrError {
< 	if ( !&UserIsEditor() ) {
< 		print "\n<h2>This operation is restricted to site editors only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></body></html>";
< 			
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub UserIsAdminOrError {
< 	if ( !&UserIsAdmin() ) {
< 		print "\n<h2>This operation is restricted to administrators only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></body></html>";	
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub CheckIsAuthUser {
< 	my ($id) = @_;
< 	my $auth = ""; 
< 	my $found = 0;
< 	my $authtype;
< 	my $authname; 
< 	my $aname;
< 	my $afname;
< 	my $linecount = 0;
< 
< 	if (!(&UserIsAdmin())) {
< 		$aname = $id;
< 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
< 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
< 		
< 		if (-r $afname) {			
< 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
< 			
< 			open (AFN,"<$afname");
< 			while (<AFN>) {
< 				if (/$FS1/) { next; }       	# skip header and footer
< 				if (/^>\s[^\w]/) { next; }  	# skip comments	
< 				if (/diff-/){ next; }		
< 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
< 					$authtype = $1;
< 					$authname = $2; 
< 					
< 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
< 					elsif ($authtype eq "r"){ $authtype = "1"; }
< 					else { $authtype = "1"; }
< 					
< 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
< 				}
< 			}
< 			close AFN;
< 			if ($linecount == 0){ $auth = "3"; }
< 			elsif ($found == 0) { $auth = ""; }
< 		}
< 		else {
< 			$auth = "3";
< 		}
< 	}
< 	else {
< 		$auth = "3";
< 	}
< 	return $auth;
< }
< 
< sub DoEditLock {
< 	my ($fname);
< 	
< 	print &GetHeader( "", "Set or Remove global edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	return if ( !&UserIsAdminOrError() );
< 	$fname = "$DataDir/noedit";
< 
< 	if ( &GetParam( "set", 1 ) ) {
< 		&WriteStringToFile( $fname, "editing locked." );
< 	}
< 	else {
< 		unlink($fname);
< 	}
< 	
< 	if ( -f $fname ) {
< 		print "\n<h2>Edit lock created.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Edit lock removed.</h2>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoPageLock {
< 	my ( $fname, $id );
< 	
< 	print &GetHeader( "", "Set or Remove page edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	# Consider allowing page lock/unlock at editor level?
< 	return if ( !&UserIsAdminOrError() );
< 		
< 	$id = &GetParam( "id", "" );
< 	if ( $id eq "" ) {
< 		print "\n<p>Missing page id to lock/unlock...</p>";
< 		
< 		return;
< 	}
< 	
< 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
< 	$fname = &GetLockedPageFile($id);
< 	
< 	if ( &GetParam( "set", 1 ) ) {
< 		&WriteStringToFile( $fname, "editing locked." );
< 	}
< 	else {
< 		unlink($fname);
< 	}
< 
< 	if ( -f $fname ) {
< 		print "\n<h2>Lock for '$id' created.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Lock for '$id' removed.</h2>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoEditBanned {
< 	my ( $banList, $status );
< 	
< 	print &GetHeader( "", "Editing Banned list", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	return if ( !&UserIsAdminOrError() );
< 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
< 	$banList = "" if ( !$status );
< 	
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print GetHiddenValue( "edit_ban", 1 );
< 	print "\n<h2> Banned IP/network/host list:</h2>";
< 	print "\nEach entry is either a commented line (starting with #), ";
< 	print "\nor a Perl regular expression (matching either an IP address or ";
< 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
< 	print "\ngive up your admin access (remove password in Preferences).";
< 	print "\n<p><br><b>Example:</b><br><br>";
< 	print "\n# blocks hosts ending with .foocorp.com<br>";
< 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
< 	print "\n# blocks exact IP address<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
< 	print "\n# blocks whole 123.21.3.* IP network<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
< 	print &GetTextArea( 'banlist', $banList, 12, 50 );
< 	print "\n<br><br>";
< 	print $q->submit( -name => 'Save' );
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	;
< }
< 
< sub DoUpdateBanned {
< 	my ( $newList, $fname );
< 	
< 	print &GetHeader( "", "Updating Banned list", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	$fname = "$DataDir/banlist";
< 	$newList = &GetParam( "banlist", "#Empty file" );
< 	
< 	if ( $newList eq "" ) {
< 		print "\n<p>Empty banned list or error.</p>";
< 		print "\n<p>Resubmit with at least one space character to remove.</p>";
< 	}
< 	elsif ( $newList =~ /^\s*$/s ) {
< 		unlink($fname);
< 		print "\n<p>Removed banned list</p>";
< 	}
< 	else {
< 		&WriteStringToFile( $fname, $newList );
< 		print "\n<p>Updated banned list</p>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # ==== Editing/Deleting pages and links ====
< sub DoEditLinks {
< 	print &GetHeader( "", "Editing Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
< 	}
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print GetHiddenValue( "edit_links", 1 );
< 	print "\n<h2>Editing/Deleting page titles:</h2>";
< 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
< 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
< 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
< 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
< 	print &GetTextArea( 'commandlist', "", 12, 50 );
< 	print "\n<br><br>";
< 	print $q->checkbox(
< 		-name     => "p_changerc",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Edit $RCName"
< 	);
< 	print "\n<br>";
< 	print $q->checkbox(
< 		-name     => "p_changetext",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Substitute text for rename"
< 	);
< 	print "\n<br><br>";
< 	print $q->submit( -name => 'Process Command' );
< 	print "\n</form>";
< 	print "\n</div>";
< 	
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub UpdateLinksList {
< 	my ( $commandList, $doRC, $doText ) = @_;
< 	
< 	if ($doText) {
< 		&BuildLinkIndex();
< 	}
< 	&RequestLock() or die "UpdateLinksList could not get main lock";
< 	unlink($IndexFile) if ($UseIndex);
< 	
< 	foreach ( split( /\n/, $commandList ) ) {
< 		s/\s+$//g;
< 		
< 		next if ( !(/^[=!|?]/) );    # Only valid commands.
< 		print "\nProcessing $_<br>\n";
< 		
< 		if (/^\!(.+)/) {
< 			&DeletePage( $1, $doRC, $doText );
< 		}
< 		elsif (/^\?(.+)/){
< 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
< 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
< 			print "\n<br><br>";
< 		}
< 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
<       		my $GivenPage = $1;
<       		my $GivenNewName = $2;
<       
<       		if ($GivenPage =~ s[\/\*][]) {
<        			print "\nRenaming subpages of $GivenPage too...<br>";
<         
<         		foreach (&AllSubPagesList($GivenPage)) {
< 					my $NewSubName = $_;
< 					
< 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
< 					print "\nrenaming $_ to $NewSubName<br>";
< 					&RenamePage($_, $NewSubName, $doRC, $doText);
< 		        }
<       		}
< 		      # rename the page itself
< 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
< 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
< 		}
< 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
< 			&RenameTextLinks( $1, $2 );
< 		}
< 	}
< 	
< 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
< 	unlink($IndexFile) if ($UseIndex);
< 	&ReleaseLock();
< }
< 
< sub BuildLinkIndex {
< 	my ( @pglist, $page, @links, $link, %seen );
< 	
< 	@pglist    = &AllPagesList();
< 	%LinkIndex = ();
< 	
< 	foreach $page (@pglist) {
< 		&BuildLinkIndexPage($page);
< 	}
< }
< 
< sub BuildLinkIndexPage {
< 	my ($page) = @_;
< 	my ( @links, $link, %seen );
< 	
< 	@links = &GetPageLinks( $page, 1, 0, 0 );
< 	%seen = ();
< 	
< 	foreach $link (@links) {
< 		if ( defined( $LinkIndex{$link} ) ) {
< 			if ( !$seen{$link} ) {
< 				$LinkIndex{$link} .= " " . $page;
< 			}
< 		}
< 		else {
< 			$LinkIndex{$link} .= " " . $page;
< 		}
< 		$seen{$link} = 1;
< 	}
< }
< 
< sub DoUpdateLinks {
< 	my ( $commandList, $doRC, $doText );
< 	
< 	print &GetHeader( "", "Updating Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
< 	}
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	$commandList = &GetParam( "commandlist", "" );
< 	$doRC        = &GetParam( "p_changerc",  "0" );
< 	$doRC = 1 if ( $doRC eq "on" );
< 	$doText = &GetParam( "p_changetext", "0" );
< 	$doText = 1 if ( $doText eq "on" );
< 	
< 	if ( $commandList eq "" ) {
< 		print "\n<p>Empty command list or error.</p>";
< 	}
< 	else {
< 		&UpdateLinksList( $commandList, $doRC, $doText );
< 		print "\n<p>Finished command list.</p>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub EditRecentChanges {
< 	my ( $action, $old, $new ) = @_;
< 	
< 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
< 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
< }
< 
< sub EditRecentChangesFile {
< 	my ( $fname, $action, $old, $new, $printError ) = @_;
< 	my ( $status, $fileData, $errorText, $rcline, @rclist );
< 	my ( $outrc, $ts, $page, $junk );
< 	
< 	( $status, $fileData ) = &ReadFile($fname);
< 	
< 	if ( !$status ) {
< 
< 		# Save error text if needed.
< 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
< 		print $errorText if ($printError);
< 		
< 		return;
< 	}
< 	
< 	$outrc = "";
< 	@rclist = split( /\n/, $fileData );
< 	
< 	foreach $rcline (@rclist) {
< 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
< 		if ( $page eq $old ) {
< 			if ( $action == 1 ) {    # Delete
< 				;                    # Do nothing (don't add line to new RC)
< 			}
< 			elsif ( $action == 2 ) {
< 				$junk = $rcline;
< 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
< 				$outrc .= $junk . "\n";
< 			}
< 		}
< 		else {
< 			$outrc .= $rcline . "\n";
< 		}
< 	}
< 	
< 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
< 	&WriteStringToFile( $fname, $outrc );
< }
< 
< # Delete and rename must be done inside locks.
< sub DeletePage {
< 	my ( $page, $doRC, $doText ) = @_;
< 	my ( $fname, $status );
< 	
< 	$page =~ s/ /_/g;
< 	$page =~ s/\[+//;
< 	$page =~ s/\]+//;
< 	$status = &ValidId($page);
< 	
< 	if ( $status ne "" ) {
< 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
< 		return;
< 	}
< 	
< 	$fname = &GetPageFile($page);
< 	unlink($fname) if ( -f $fname );
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	unlink($fname)     if ( -f $fname );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
< 	       # Currently don't do anything with page text
< }
< 
< # Given text, returns substituted text
< sub SubstituteTextLinks {
< 	my ( $old, $new, $text ) = @_;
< 
< 	# Much of this is taken from the common markup
< 	%SaveUrl      = ();
< 	$SaveUrlIndex = 0;
< 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
< 	
< 	if ($RawHtml) {
< 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
< 	}
< 	
< 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
< 	
< 	if ($FreeLinks) {
< 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
< 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
< 	}
< 	
< 	if ($BracketText) {         # Links like [URL text of link]
< 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
< 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
< 	}
< 	
< 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
< 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
< 	
< 	if ($WikiLinks) {
< 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
< 	}
< 
< 	# Thanks to David Claughton for the following fix
< 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
< 	
< 	return $text;
< }
< 
< sub SubFreeLink {
< 	my ( $link, $name, $old, $new ) = @_;
< 	my ($oldlink);
< 	
< 	$oldlink = $link;
< 	$link =~ s/^\s+//;
< 	$link =~ s/\s+$//;
< 	
< 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
< 	{
< 		$link = $new;
< 	}
< 	
< 	else {
< 		$link = $oldlink;    # Preserve spaces if no match
< 	}
< 	
< 	$link = "[[$link";
< 	
< 	if ( $name ne "" ) {
< 		$link .= "|$name";
< 	}
< 	
< 	$link .= "]]";
< 	
< 	return &StoreRaw($link);
< }
< 
< sub SubWikiLink {
< 	my ( $link, $old, $new ) = @_;
< 	my ($newBracket);
< 	
< 	$newBracket = 0;
< 	
< 	if ( $link eq $old ) {
< 		$link = $new;
< 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
< 			$link = "[[$link]]";
< 		}
< 	}
< 	
< 	return &StoreRaw($link);
< }
< 
< # Rename is mostly copied from expire
< sub RenameKeepText {
< 	my ( $page, $old, $new ) = @_;
< 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
< 	my ( $sectName, $newText );
< 	
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	return if ( !( -f $fname ) );
< 	( $status, $data ) = &ReadFile($fname);
< 	return if ( !$status );
< 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	%tempSection = split( /$FS2/, $kplist[0], -1 );
< 
< 	if ( !defined( $tempSection{'keepts'} ) ) {
< 		return;
< 	}
< 
< 	# First pass: optimize for nothing changed
< 	$changed = 0;
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$changed = 1 if ( $Text{'text'} ne $newText );
< 		}
< 	}
< 	
< 	return if ( !$changed );    # No sections changed
< 	open( OUT, ">$fname" ) or return;
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$Text{'text'} = $newText;
< 			$tempSection{'data'} = join( $FS3, %Text );
< 			print OUT $FS1, join( $FS2, %tempSection );
< 		}
< 		else {
< 			print OUT $FS1, $_;
< 		}
< 	}
< 	close(OUT);
< }
< 
< sub RenameTextLinks {
< 	my ( $old, $new ) = @_;
< 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
< 	my ( $oldCanonical, @pageList );
< 	
< 	$old =~ s/ /_/g;
< 	$oldCanonical = &FreeToNormal($old);
< 	$new =~ s/ /_/g;
< 	$status = &ValidId($old);
< 	
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
< 	
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$old =~ s/_/ /g;
< 	$new =~ s/_/ /g;
< 
< 	# Note: the LinkIndex must be built prior to this routine
< 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
< 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
< 	foreach $page (@pageList) {
< 		$changed = 0;
< 		&OpenPage($page);
< 		foreach $section ( keys %Page ) {
< 			if ( $section =~ /^text_/ ) {
< 				&OpenSection($section);
< 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
< 				$oldText = $Text{'text'};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Text{'text'} = $newText;
< 					$Section{'data'} = join( $FS3, %Text );
< 					$Page{$section} = join( $FS2, %Section );
< 					$changed = 1;
< 				}
< 			}
< 			elsif ( $section =~ /^cache_diff/ ) {
< 				$oldText = $Page{$section};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Page{$section} = $newText;
< 					$changed = 1;
< 				}
< 			}
< 
< 			# Add other text-sections (categories) here
< 		}
< 		if ($changed) {
< 			$file = &GetPageFile($page);
< 			&WriteStringToFile( $file, join( $FS1, %Page ) );
< 		}
< 		&RenameKeepText( $page, $old, $new );
< 	}
< }
< 
< sub RenamePage {
< 	my ( $old, $new, $doRC, $doText ) = @_;
< 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
< 	
< 	$old =~ s/ /_/g;
< 	$new    = &FreeToNormal($new);
< 	$status = &ValidId($old);
< 	
< 	if ( $status ne "" ) {
< 		print "\nRename: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename: new page $new is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$newfname = &GetPageFile($new);
< 	if ( -f $newfname ) {
< 		print "\nRename: new page $new already exists--not renamed.<br>";
< 		return;
< 	}
< 	$oldfname = &GetPageFile($old);
< 	if ( !( -f $oldfname ) ) {
< 		print "\nRename: old page $old does not exist--nothing done.<br>";
< 		return;
< 	}
< 	
< 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
< 	rename( $oldfname, $newfname );
< 	&CreatePageDir( $KeepDir, $new );
< 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
< 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
< 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
< 	rename( $oldkeep, $newkeep );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
< 
< 	if ($doText) {
< 		&BuildLinkIndexPage($new);          # Keep index up-to-date
< 		&RenameTextLinks( $old, $new );
< 	}
< }
< 
< sub DoShowVersion {
< 	print &GetHeader( "", "Displaying Wiki Version", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>NobleWiki</h2>";
< 	print "\n<p>derived from UseModWiki version 1.0</p>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Admin bar contributed by ElMoro (with some changes)
< sub GetPageLockLink {
< 	my ( $id, $status, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 	}
< 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
< }
< sub GetGallery {
< 	my ($params) = @_;
< 	my @lines = split(/\r?\n/, $params);
< 	my $lineNum = 0;
< 	my $imageNum = 0;
< 	my %options;
< 	my $images = "";
< 	my $text = "";
< 	
< 	my $defaultImage = "image1.jpg";
< 	my $defaultThumb = "thumb_image1.jpg";
< 	my $image;
< 	my $thumb;
< 	my $title;
< 	my $header;
< 	my $caption;
< 	my $description;
< 	my $thumbWidth = 100;
< 	
< 	$GLOBAL_galleryCount++;
< 		
< 	foreach my $line (@lines){
< 		%options = &GetOptions($line);
< 		
< 		if ($lineNum == 0){
< 			$lineNum++;
< 			
< 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
< 			if ($options{'description'}){ $description = $options{'description'}; }
< 			if ($options{'header'}){ $header = $options{'header'}; }
< 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
< 			
< 			next;	
< 		}
< 		else {		
< 			if ($options{'image'}){ $image = $options{'image'}; }
< 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
< 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
< 			
< 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
< 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
< 			
< 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
< 				
< 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
< 		}
< 	}
< 	
< 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
< 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
< 	
< 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
< 	
< 	$text .= "\n	    <ul>";	
< 	$text .= $images;
< 	$text .= "\n	    </ul>";
< 	
< 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
< 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
< 	
< 	$text .= "\n	</div>";		
< 	
< 	return $text;
< }
< 
< sub GetFlash {
< 	my ($options) = @_;
< 	my %options = &GetOptions($options);	
< 	my $fpath = "$UploadUrl/";
< 	my $defaultSWF = 'ufo.swf';
< 	my $maxWidth = 400;
< 	my $maxHeight = 300;
< 	my $ratio = 1;
< 	
< 	my $text = "";
< 	
< 	my $fname;
< 	my $fwidth;
< 	my $fheight;
< 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
< 	my $idFO = "FO_$GLOBAL_flashCount";
< 
< 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
< 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
< 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
< 	
< 	if ($fwidth > $maxWidth){
< 		$ratio = $maxWidth / $fwidth;
< 		$fwidth = $maxWidth;
< 		$fheight = int ($ratio * $fheight);
< 	}
< 	elsif ($fheight > $maxHeight){
< 		$ratio = $maxHeight / $fheight;
< 		$fheight = $maxHeight;
< 		$fwidth = int ($ratio * $fwidth);
< 	}
< 			
< 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
< 	
< 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
< 	$text .= "\n<script type='text/javascript'>";
< 	$text .= "\n			var fpath = '$fpath';";
< 	$text .= "\n			var fname = '$fname';";
< 	$text .= "\n			var fwidth = $fwidth;";
< 	$text .= "\n			var fheight = $fheight;";
< 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
< 	$text .= "\n			\$(window).load(function () {";
< 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
< 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
< 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
< 	$text .= "\n		    });";
< 	$text .= "\n		</script>";		
< 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
< 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
< 	$text .= "\n		<p style='clear: both;'></p>";
< 	$text .= "\n	</div>";
< 
< 	$GLOBAL_flashCount++;
< 	
< 	return $text;		
< }
< sub GetAdminBar {
< 	my ($id, $cssClass) = @_;
< 	my ($result);
< 
< 	$result .= "\n<div $cssClass>";
< 	$result .= "Administration: ";
< 	
< 	my ($notValid) = $id =~ /^\d*$/;
< 	
< 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
< 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
< 	} 
< 		
< 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
< 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
< 	
< 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
< 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
< 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
< 	$result .= " | " . &ScriptLink("action=orphans", "List Orphans" );
< 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
< 			
< 	if ( -f "$DataDir/noedit" ) {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
< 	}
< 	else {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
< 	}
< 	
< 	$result .= "</div>";
< 	
< 	return $result;
< }
< 
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
< 	my ($id) = @_;
< 	
< 	return if ( !&ValidIdOrDie($id) );
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
< 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
< 		print &GetLeftNav("");
< 		print "\n<div class='wikiadmin'>";
< 		print "\n<h2>Delete Page?</h2>";
< 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
< 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></body></html>";	
< 		
< 		return;
< 	}
< 	
< 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
< 	print &GetLeftNav("");	
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $id eq $HomePage ) {
< 		print Ts( '%s can not be deleted.', $HomePage );
< 	}
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) {
< 			print Ts( '%s can not be deleted because it is locked.', $id );
< 		}
< 		else {
< 
< 			# Must lock because of RC-editing
< 			&RequestLock() or die( "Could not get editing lock" );
< 			DeletePage( $id, 1, 1 );
< 			&ReleaseLock();
< 			print Ts( '%s has been deleted.', $id );
< 		}
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
< 	print &GetHeader( "", "File Upload Page", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	print "\n<h2>Select File</h2>";
< 	print "\nThe current upload size limit is $MaxPost.<br>";
< 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
< 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
< 	print "\n<input type='hidden' name='upload' value='1' />";
< 	print "\nFile to Upload: ";
< 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
< 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub SaveUpload {
< 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
< 	print &GetHeader( "", "Upload Finished", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
< 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
< 	$filename = $q->param('file');
< 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
< 	
< 	$uploadFilehandle = $filename;
< 	open UPLOADFILE, ">$UploadDir$filename";
< 	binmode(UPLOADFILE);	
< 	while (<$uploadFilehandle>) { print UPLOADFILE; }
< 	close UPLOADFILE;
< 	
< 	print "\n<h2>Upload Completed</h2>";
< 	print "\nThe wiki link to your file is:<br><br>";
< 	
< 	$printFilename = $filename;
< 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
< 	$fileUrl = $UploadUrl . $printFilename;
< 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
< 
< 	if ( $filename =~ /${ImageExtensions}$/ ) {
< 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub ConvertFsFile {
< 	my ( $oldFS, $newFS, $fname ) = @_;
< 	my ( $oldData, $newData, $status );
< 	
< 	return if ( !-f $fname );           # Convert only existing regular files
< 	( $status, $oldData ) = &ReadFile($fname);
< 	
< 	if ( !$status ) {
< 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
< 		
< 		return;
< 	}
< 	
< 	$newData = $oldData;
< 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
< 	
< 	return if ( $oldData eq $newData );    # Do not write if the same
< 	&WriteStringToFile( $fname, $newData );
< 
< 	# print $fname . '<br>';    # progress report
< }
< 
< # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
< # Note that top level directory (page/keep/user) contains only dirs
< sub ConvertFsDir {
< 	my ( $oldFS, $newFS, $topDir ) = @_;
< 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
< 	
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	@dirs = sort(@dirs);
< 	
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$topDir/$dir" );             # Top level directories only
< 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
< 		
< 		opendir( DIRLIST, "$topDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
< 		
< 		foreach $file (@files) {
< 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
< 			$fname = "$topDir/$dir/$file";
< 			if ( -f $fname ) {
< 				# print $fname . '<br>';   # progress
< 				&ConvertFsFile( $oldFS, $newFS, $fname );
< 			}
< 			elsif ( -d $fname ) {
< 				opendir( DIRLIST, $fname );
< 				@subFiles = readdir(DIRLIST);
< 				closedir(DIRLIST);
< 				
< 				foreach $subFile (@subFiles) {
< 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
< 					$subFname = "$fname/$subFile";
< 					if ( -f $subFname ) {
< 						# print $subFname . '<br>';   # progress
< 						&ConvertFsFile( $oldFS, $newFS, $subFname );
< 					}
< 				}
< 			}
< 		}
< 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
< 	}
< }
< 
< sub ConvertFsCleanup {
< 	my ($topDir) = @_;
< 	my ( @dirs, $dir );
< 	
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-f "$topDir/$dir" );             # Remove only files...
< 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
< 		unlink "$topDir/$dir";
< 	}
< }
< 
< sub DoConvert {
< 	my $oldFS = "\xb3";
< 	my $newFS = "\x1e\xff\xfe\x1e";
< 	
< 	print &GetHeader( "", "Convert wiki DB", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";	
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	if ( $FS ne $newFS ) {
< 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
< 		return;
< 	}
< 	
< 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
< 	print "\nWiki DB locked for conversion.<br>";
< 	print "\nConverting Wiki DB...<br>";
< 	
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
< 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
< 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
< 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
< 	&ConvertFsCleanup($PageDir);
< 	&ConvertFsCleanup($KeepDir);
< 	&ConvertFsCleanup($UserDir);
< 	
< 	print "\nFinished converting wiki DB.<br>";
< 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< # Remove user-id files if no useful preferences set
< sub DoTrimUsers {
< 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
< 	my ( @dirs, @files, $dir, $file, $item );
< 	
< 	print &GetHeader( "", "Trim wiki users", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	$removed = 0;
< 	$maxID   = 1001;
< 	opendir( DIRLIST, $UserDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
< 		
< 		opendir( DIRLIST, "$UserDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
< 		
< 		foreach $file (@files) {
< 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
< 				$id    = $1;
< 				$maxID = $id if ( $id > $maxID );
< 				%Data  = ();
< 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
< 				
< 				if ($status) {
< 					%Data =
< 					  split( /$FS1/, $data, -1 )
< 					  ;    # -1 keeps trailing null fields
< 					$keep = 0;
< 					
< 					foreach $item (qw(username password adminpw stylesheet)) {
< 						$keep = 1
< 						  if ( defined( $Data{$item} )
< 							&& ( $Data{$item} ne "" ) );
< 					}
< 					
< 					if ( !$keep ) {
< 						unlink "$UserDir/$dir/$file";
< 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
< 						$removed += 1;
< 					}
< 				}
< 			}
< 		}
< 	}
< 	print Ts( 'Removed %s files.', $removed ) . '<br>';
< 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";	
< }
< 
< sub DoAssetsToc {
< 	## Check $DataDir and see if assets-toc exists
< 	## -- if not, then build TOC
< 	## -- if does, but is older than 1 minute, rebuild TOC
< 	## Return TOC	
< }
< sub DoFilterToc {
< 	## Given @filters, pageIndex, pageSize
< 	## Get TOC from DoAssetsTOC
< 	## Apply @filters; sort, apply pageIndex * pageSize as offset
< 	## Return FilteredTOC	
< }
< sub DoListFiles {
< 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
< 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
< 	my ( $id, $filter, $managedisabled ) = @_;
< 
< 	if ($managedisabled){ 
< 		$targetDir = "$DisabledDir";
< 	}
< 	else {
< 		$targetDir = "$UploadDir";
< 	}
< 
< 	# CREATE array of filters
< 	$filter = lc($filter);
< 	$filter =~ s/\s//go;
< 	if ($filter ne ""){ 
< 		if ($filter =~ m/,/){
< 			@filters = split(',', $filter);
< 			
< 		}
< 		else {
< 			push (@filters, $filter);
< 		}
< 		$term = "using '<em>$filter</em>'";
< 	}
< 		
< 	# READ DIRECTORY	
< 	opendir( DIRLIST, $targetDir );
< 	@list = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	
< 	# RUN INCLUSIVE FILTERS
< 	foreach $file (@list){		
< 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
< 		
< 		if ($filter eq ""){  push @includes, $file; next; }
< 		
< 		$qualifies = 0;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;
< 			$include = $item;
< 					
< 			if ($item =~ m/^\!/){ next; }
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
< 		}
< 		
< 		if ($qualifies){ push @includes, $file; }
< 	}
< 
< 	# RUN EXCLUSIVE FILTERS
< 	foreach $file (@includes){
< 		if ($filter eq ""){  push @files, $file; next; }
< 				
< 		$qualifies = 1;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;					
< 			unless ($item =~ m/^\!/){ next; }
< 			$include = substr($item, 1);
< 
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
< 		}
< 		
< 		if ($qualifies){ push @files, $file; }
< 	}
< 	
< 	print &GetHeader( "", "Manage Assets", "" );
< 	print &GetLeftNav($id);
< 	print "\n<div class='wikidiff'>";
< 	
< 	#return if ( !&UserIsEditorOrError() );
< 		
< 	if ($managedisabled){
< 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
< 		
< 		# MOVE file to disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $keeppath){
< 				if (-w $UploadDir){
< 					if (rename($keeppath, $uploadpath)){
< 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 	else {
< 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
< 		
< 		# MOVE file from disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $uploadpath){
< 				if (-w $DisabledDir){
< 					if (rename($uploadpath, $keeppath)){
< 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 
< 	print "\n<table class='wikilargelist'>";
< 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
< 	
< 	foreach $file (@files) {
< 		$filecount++;
< 		$linkname = "upload:$file";
< 		
< 		@links = SearchTitleAndBody($file, "", "");
< 		$numlinks = scalar(@links);
< 
< 		$title = "";
< 		$action = "";
< 			
< 		if ($managedisabled){			
< 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td>$file</td>";
< 			print "\n<td align='right'>$size</td>";			
< 			
< 			if ( &UserIsEditorOrAdmin() ){
< 				$title = "Click to re-enable file.";
< 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
< 			}
< 		}
< 		else {		
< 			$uploadpath = "$UploadUrl/$file";
< 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
< 			print "\n<td align='right'>$size</td>";
< 			
< 			if ($numlinks > 0){
< 				$title = "Click to see what pages link to this file.";
< 				$action = "href='$ScriptName?back=$file'";
< 			}
< 			elsif ( &UserIsEditorOrAdmin() ){
< 				$numlinks = "0";
< 				$title = "Click to disable file.";
< 				$action = "href='$ScriptName?action=listfiles&id=$file'";
< 			}		
< 		}
< 
< 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
< 		print "\n</tr>";
< 	}
< 	
< 	if (scalar(@files) == 0){
< 		print "\n<td colspan='4'>No files available</td></tr>";
< 	}
< 	print "\n</table>";
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
< 	print "\n<input type='submit' value='Apply Filter'>";
< 	
< 	
< 	if ($managedisabled){
< 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
< 	}
< 	else {
< 		print "\n<input type='hidden' name='action' value='listfiles'>";
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
< 	}
< 	print "\nUse ! to exclude a term, separate terms with a comma";
< 	print "\n</form>";
< 	print "\n</div>";
< 
< 	print &GetCommonFooter();
< 	print "\n</div></div></body></html>";				
< }
< 
< 
< #END_OF_OTHER_CODE
< &DoWikiRequest() if ( $RunCGI && ( $_ ne 'nocgi' ) );    # Do everything.
< 1;    # In case we are loaded from elsewhere
< 
< # == End of UseModWiki script. ===========================================
< </nowiki></pre>
7404a2
> 
------
ImageGallery/ExampleGallery|1195777174
7a8,21
> thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip5
> thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip6
> thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip7
> thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip8
> thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip9
> thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip10
> thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip11
> thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip12
> thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip13
> thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip14
> thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip15
> thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip16
> thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip17
> thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip18
------
SandBox|1195861097
0a1,5177
> <pre>
> 
> #!perl
> # UseModWiki version 1.0.3 (September 12, 2007)
> # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
> # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
> # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
> #    <marcus@ira.uka.de>
> # ...which was based on
> #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
> #    and The Original WikiWikiWeb  (C) Ward Cunningham
> #        <ward@c2.com> (code reused with permission)
> # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
> #
> # This program is free software; you can redistribute it and/or modify
> # it under the terms of the GNU General Public License as published by
> # the Free Software Foundation; either version 2 of the License, or
> # (at your option) any later version.
> #
> # This program is distributed in the hope that it will be useful,
> # but WITHOUT ANY WARRANTY; without even the implied warranty of
> # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> # GNU General Public License for more details.
> #
> # You should have received a copy of the GNU General Public License
> # along with this program; if not, write to the
> #    Free Software Foundation, Inc.
> #    59 Temple Place, Suite 330
> #    Boston, MA 02111-1307 USA
> 
> package UseModWiki;
> use strict;
> local $| = 1;  # Do not buffer output (localized for mod_perl)
> 
> # Configuration/constant variables:
> use vars qw(@RcDays @HtmlPairs @HtmlSingle
>   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
>   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
>   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
>   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
>   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
>   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
>   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
>   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
>   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
>   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
>   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
>   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
>   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
>   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
>   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
>   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
>   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
>   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine 
>   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
>   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
>   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton 
>   $EditNameLink $UseMetaWiki @ImageSites $BracketImg );
> # Note: $NotifyDefault is kept because it was a config variable in 0.90
> # Other global variables:
> use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
>   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
>   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
>   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
>   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
>   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
>   $ConfigError $UploadPattern );
> 
> # == Configuration =====================================================
> $DataDir     = "C:/wikidb"; # Main wiki directory
> $UseConfig   = 1;       # 1 = use config file,    0 = do not look for config
> $ConfigFile  = "$DataDir/config";   # Configuration file
> 
> # Default configuration (used if UseConfig is 0)
> $CookieName  = "Wiki";          # Name for this wiki (for multi-wiki sites)
> $SiteName    = "Wiki";          # Name of site (used for titles)
> $HomePage    = "HomePage";      # Home page (change space to _)
> $RCName      = "RecentChanges"; # Name of changes page (change space to _)
> $LogoUrl     = "/wiki.gif";     # URL for site logo ("" for no logo)
> $ENV{PATH}   = "/usr/bin/";     # Path used to find "diff"
> $ScriptTZ    = "";              # Local time zone ("" means do not print)
> $RcDefault   = 30;              # Default number of RecentChanges days
> @RcDays      = qw(1 3 7 30 90); # Days for links on RecentChanges
> $KeepDays    = 14;              # Days to keep old revisions
> $SiteBase    = "";              # Full URL for <BASE> header
> $FullUrl     = "";              # Set if the auto-detected URL is wrong
> $RedirType   = 1;               # 1 = CGI.pm, 2 = script, 3 = no redirect
> $AdminPass   = "";              # Set to non-blank to enable password(s)
> $EditPass    = "";              # Like AdminPass, but for editing only
> $StyleSheet  = "";              # URL for CSS stylesheet (like "/wiki.css")
> $NotFoundPg  = "";              # Page for not-found links ("" for blank pg)
> $EmailFrom   = "Wiki";          # Text for "From: " field of email notes.
> $SendMail    = "/usr/sbin/sendmail";  # Full path to sendmail executable
> $FooterNote  = "";              # HTML for bottom of every page
> $EditNote    = "";              # HTML notice above buttons on edit page
> $MaxPost     = 1024 * 210;      # Maximum 210K posts (about 200K for pages)
> $NewText     = "";              # New page text ("" for default message)
> $HttpCharset = "";              # Charset for pages, like "iso-8859-2"
> $UserGotoBar = "";              # HTML added to end of goto bar
> $InterWikiMoniker = '';         # InterWiki moniker for this wiki. (for RSS)
> $SiteDescription  = $SiteName;  # Description of this wiki. (for RSS)
> $RssLogoUrl  = '';              # Optional image for RSS feed
> $EarlyRules  = '';              # Local syntax rules for wiki->html (evaled)
> $LateRules   = '';              # Local syntax rules for wiki->html (evaled)
> $KeepSize    = 0;               # If non-zero, maximum size of keep file
> $BGColor     = 'white';         # Background color ('' to disable)
> $DiffColor1  = '#ffffaf';       # Background color of old/deleted text
> $DiffColor2  = '#cfffcf';       # Background color of new/added text
> $FavIcon     = '';              # URL of bookmark/favorites icon, or ''
> $RssDays     = 7;               # Default number of days in RSS feed
> $UserHeader  = '';              # Optional HTML header additional content
> $UserBody    = '';              # Optional <BODY> tag additional content
> $StartUID    = 1001;            # Starting number for user IDs
> $UploadDir   = '';              # Full path (like /foo/www/uploads) for files
> $UploadUrl   = '';              # Full URL (like http://foo.com/uploads)
> @ImageSites  = qw();            # Url prefixes of good image sites: ()=all
> 
> # Major options:
> $UseSubpage  = 1;           # 1 = use subpages,       0 = do not use subpages
> $UseCache    = 0;           # 1 = cache HTML pages,   0 = generate every page
> $EditAllowed = 1;           # 1 = editing allowed,    0 = read-only
> $RawHtml     = 0;           # 1 = allow <HTML> tag,   0 = no raw HTML in pages
> $HtmlTags    = 0;           # 1 = "unsafe" HTML tags, 0 = only minimal tags
> $UseDiff     = 0;           # 1 = use diff features,  0 = do not use diff
> $FreeLinks   = 1;           # 1 = use [[word]] links, 0 = LinkPattern only
> $WikiLinks   = 1;           # 1 = use LinkPattern,    0 = use [[word]] only
> $AdminDelete = 1;           # 1 = Admin only deletes, 0 = Editor can delete
> $RunCGI      = 1;           # 1 = Run script as CGI,  0 = Load but do not run
> $EmailNotify = 0;           # 1 = use email notices,  0 = no email on changes
> $EmbedWiki   = 0;           # 1 = no headers/footers, 0 = normal wiki pages
> $DeletedPage = 'DeletedPage';   # 0 = disable, 'PageName' = tag to delete page
> $ReplaceFile = 'ReplaceFile';   # 0 = disable, 'PageName' = indicator tag
> @ReplaceableFiles = ();     # List of allowed server files to replace
> $TableSyntax = 1;           # 1 = wiki syntax tables, 0 = no table syntax
> $NewFS       = 0;           # 1 = new multibyte $FS,  0 = old $FS
> $UseUpload   = 0;           # 1 = allow uploads,      0 = no uploads
> 
> # Minor options:
> $LogoLeft     = 0;      # 1 = logo on left,       0 = logo on right
> $RecentTop    = 1;      # 1 = recent on top,      0 = recent on bottom
> $UseDiffLog   = 1;      # 1 = save diffs to log,  0 = do not save diffs
> $KeepMajor    = 1;      # 1 = keep major rev,     0 = expire all revisions
> $KeepAuthor   = 1;      # 1 = keep author rev,    0 = expire all revisions
> $ShowEdits    = 0;      # 1 = show minor edits,   0 = hide edits by default
> $HtmlLinks    = 0;      # 1 = allow A HREF links, 0 = no raw HTML links
> $SimpleLinks  = 0;      # 1 = only letters,       0 = allow _ and numbers
> $NonEnglish   = 0;      # 1 = extra link chars,   0 = only A-Za-z chars
> $ThinLine     = 0;      # 1 = fancy <hr> tags,    0 = classic wiki <hr>
> $BracketText  = 1;      # 1 = allow [URL text],   0 = no link descriptions
> $UseAmPm      = 1;      # 1 = use am/pm in times, 0 = use 24-hour times
> $UseIndex     = 0;      # 1 = use index file,     0 = slow/reliable method
> $UseHeadings  = 1;      # 1 = allow = h1 text =,  0 = no header formatting
> $NetworkFile  = 1;      # 1 = allow remote file:, 0 = no file:// links
> $BracketWiki  = 0;      # 1 = [WikiLnk txt] link, 0 = no local descriptions
> $UseLookup    = 1;      # 1 = lookup host names,  0 = skip lookup (IP only)
> $FreeUpper    = 1;      # 1 = force upper case,   0 = do not force case
> $FastGlob     = 1;      # 1 = new faster code,    0 = old compatible code
> $MetaKeywords = 1;      # 1 = Google-friendly,    0 = search-engine averse
> $NamedAnchors = 1;      # 0 = no anchors, 1 = enable anchors,
>                         # 2 = enable but suppress display
> $SlashLinks   = 0;      # 1 = use script/action links, 0 = script?action
> $UpperFirst   = 1;      # 1 = free links start uppercase, 0 = no ucfirst
> $AdminBar     = 1;      # 1 = admins see admin links, 0 = no admin bar
> $RepInterMap  = 0;      # 1 = intermap is replacable, 0 = not replacable
> $ConfirmDel   = 1;      # 1 = delete link confirm page, 0 = immediate delete
> $MaskHosts    = 0;      # 1 = mask hosts/IPs,      0 = no masking
> $LockCrash    = 0;      # 1 = crash if lock stuck, 0 = auto clear locks
> $HistoryEdit  = 0;      # 1 = edit links on history page, 0 = no edit links
> $OldThinLine  = 0;      # 1 = old ==== thick line, 0 = ------ for thick line
> $NumberDates  = 0;      # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
> $ParseParas   = 0;      # 1 = new paragraph markup, 0 = old markup
> $AuthorFooter = 1;      # 1 = show last author in footer, 0 = do not show
> $AllUpload    = 0;      # 1 = anyone can upload,   0 = only editor/admins
> $LimitFileUrl = 1;      # 1 = limited use of file: URLs, 0 = no limits
> $MaintTrimRc  = 0;      # 1 = maintain action trims RC, 0 = only maintainrc
> $SearchButton = 0;      # 1 = search button on page, 0 = old behavior
> $EditNameLink = 0;      # 1 = edit links use name (CSS), 0 = '?' links
> $UseMetaWiki  = 0;      # 1 = add MetaWiki search links, 0 = no MW links
> $BracketImg   = 1;      # 1 = [url url.gif] becomes image link, 0 = no img
> 
> # Names of sites.  (The first entry is used for the number link.)
> @IsbnNames = ('bn.com', 'amazon.com', 'search');
> # Full URL of each site before the ISBN
> @IsbnPre = ('http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=',
>             'http://www.amazon.com/exec/obidos/ISBN=',
>             'http://www.pricescan.com/books/BookDetail.asp?isbn=');
> # Rest of URL of each site after the ISBN (usually '')
> @IsbnPost = ('', '', '');
> 
> # HTML tag lists, enabled if $HtmlTags is set.
> # Scripting is currently possible with these tags,
> # so they are *not* particularly "safe".
> # Tags that must be in <tag> ... </tag> pairs:
> @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
>   em s strike strong tt var div center blockquote ol ul dl table caption);
> # Single tags (that do not require a closing /tag)
> @HtmlSingle = qw(br p hr li dt dd tr td th);
> @HtmlPairs = (@HtmlPairs, @HtmlSingle);  # All singles can also be pairs
> 
> # == You should not have to change anything below this line. =============
> $IndentLimit = 20;                  # Maximum depth of nested lists
> $PageDir     = "$DataDir/page";     # Stores page data
> $HtmlDir     = "$DataDir/html";     # Stores HTML versions
> $UserDir     = "$DataDir/user";     # Stores user data
> $KeepDir     = "$DataDir/keep";     # Stores kept (old) page data
> $TempDir     = "$DataDir/temp";     # Temporary files and locks
> $LockDir     = "$TempDir/lock";     # DB is locked if this exists
> $InterFile   = "$DataDir/intermap"; # Interwiki site->url map
> $RcFile      = "$DataDir/rclog";    # New RecentChanges logfile
> $RcOldFile   = "$DataDir/oldrclog"; # Old RecentChanges logfile
> $IndexFile   = "$DataDir/pageidx";  # List of all pages
> $EmailFile   = "$DataDir/emails";   # Email notification lists
> 
> if ($RepInterMap) {
>   push @ReplaceableFiles, $InterFile;
> }
> 
> # The "main" program, called at the end of this script file.
> sub DoWikiRequest {
>   if ($UseConfig && (-f $ConfigFile)) {
>     $ConfigError = '';
>     if (!do $ConfigFile) {   # Some error occurred
>       $ConfigError = $@;
>       if ($ConfigError eq '') {
>         # Unfortunately, if the last expr returns 0, one will get a false
>         # error above.  To remain compatible with existing installs the
>         # wiki must not report an error unless there is error text in $@.
>         # (Errors in "use strict" may not have error text.)
>         # Uncomment the line below if you want to catch use strict errors.
> #       $ConfigError = T('Unknown Error (no error text)');
>       }
>     }
>   }
>   &InitLinkPatterns();
>   if (!&DoCacheBrowse()) {
>     eval $BrowseCode;
>     &InitRequest() or return;
>     if (!&DoBrowseRequest()) {
>       eval $OtherCode;
>       &DoOtherRequest();
>     }
>   }
> }
> 
> # == Common and cache-browsing code ====================================
> sub InitLinkPatterns {
>   my ($UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim);
> 
>   # Field separators are used in the URL-style patterns below.
>   if ($NewFS) {
>     $FS  = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
>   } else {
>     $FS  = "\xb3";    # The FS character is a superscript "3"
>   }
>   $FS1 = $FS . "1";   # The FS values are used to separate fields
>   $FS2 = $FS . "2";   # in stored hashtables and other data structures.
>   $FS3 = $FS . "3";   # The FS character is not allowed in user data.
>   $UpperLetter = "[A-Z";
>   $LowerLetter = "[a-z";
>   $AnyLetter   = "[A-Za-z";
>   if ($NonEnglish) {
>     $UpperLetter .= "\xc0-\xde";
>     $LowerLetter .= "\xdf-\xff";
>     if ($NewFS) {
>       $AnyLetter   .= "\x80-\xff";
>     } else {
>       $AnyLetter   .= "\xc0-\xff";
>     }
>   }
>   if (!$SimpleLinks) {
>     $AnyLetter .= "_0-9";
>   }
>   $UpperLetter .= "]"; $LowerLetter .= "]"; $AnyLetter .= "]";
>   # Main link pattern: lowercase between uppercase, then anything
>   $LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter
>          . $AnyLetter . "*";
>   # Optional subpage link pattern: uppercase, lowercase, then anything
>   $LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
>   if ($UseSubpage) {
>     # Loose pattern: If subpage is used, subpage may be simple name
>     $LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
>     # Strict pattern: both sides must be the main LinkPattern
>     # $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
>   } else {
>     $LinkPattern = "($LpA)";
>   }
>   $QDelim = '(?:"")?';     # Optional quote delimiter (not in output)
>   $AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
>   $LinkPattern .= $QDelim;
>   # Inter-site convention: sites must start with uppercase letter
>   # (Uppercase letter avoids confusion with URLs)
>   $InterSitePattern = $UpperLetter . $AnyLetter . "+";
>   $InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
>   if ($FreeLinks) {
>     # Note: the - character must be first in $AnyLetter definition
>     if ($NonEnglish) {
>       if ($NewFS) {
>         $AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
>       } else {
>         $AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
>       }
>     } else {
>       $AnyLetter = "[-,.()' _0-9A-Za-z]";
>     }
>   }
>   $FreeLinkPattern = "($AnyLetter+)";
>   if ($UseSubpage) {
>     $FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+)";
>   }
>   $FreeLinkPattern .= $QDelim;
>   # Url-style links are delimited by one of:
>   #   1.  Whitespace                           (kept in output)
>   #   2.  Left or right angle-bracket (< or >) (kept in output)
>   #   3.  Right square-bracket (])             (kept in output)
>   #   4.  A single double-quote (")            (kept in output)
>   #   5.  A $FS (field separator) character    (kept in output)
>   #   6.  A double double-quote ("")           (removed from output)
>   $UrlProtocols = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|"
>                   . "prospero|telnet|gopher";
>   $UrlProtocols .= '|file'  if ($NetworkFile || !$LimitFileUrl);
>   $UrlPattern = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
>   $ImageExtensions = "(gif|jpg|png|bmp|jpeg|ico|tiff?)";
>   $RFCPattern = "RFC\\s?(\\d+)";
>   $ISBNPattern = "ISBN:?([0-9- xX]{10,})";
>   $UploadPattern = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
> }
> 
> # Simple HTML cache
> sub DoCacheBrowse {
>   my ($query, $idFile, $text);
> 
>   return 0  if (!$UseCache);
>   $query = $ENV{'QUERY_STRING'};
>   if (($query eq "") && ($ENV{'REQUEST_METHOD'} eq "GET")) {
>     $query = $HomePage;  # Allow caching of home page.
>   }
>   if (!($query =~ /^$LinkPattern$/)) {
>     if (!($FreeLinks && ($query =~ /^$FreeLinkPattern$/))) {
>       return 0;  # Only use cache for simple links
>     }
>   }
>   $idFile = &GetHtmlCacheFile($query);
>   if (-f $idFile) {
>     local $/ = undef;   # Read complete files
>     open(INFILE, "<$idFile") or return 0;
>     $text = <INFILE>;
>     close INFILE;
>     print $text;
>     return 1;
>   }
>   return 0;
> }
> 
> sub GetHtmlCacheFile {
>   my ($id) = @_;
> 
>   return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
> }
> 
> sub GetPageDirectory {
>   my ($id) = @_;
> 
>   if ($id =~ /^([a-zA-Z])/) {
>     return uc($1);
>   }
>   return "other";
> }
> 
> sub T {
>   my ($text) = @_;
> 
>   if (defined($Translate{$text}) && ($Translate{$text} ne ''))  {
>     return $Translate{$text};
>   }
>   return $text;
> }
> 
> sub Ts {
>   my ($text, $string, $noquote) = @_;
> 
>   $string = &QuoteHtml($string) unless $noquote;
>   $text = T($text);
>   $text =~ s/\%s/$string/;
>   return $text;
> }
> 
> sub Tss {
>   my $text = $_[0];
>   my @args = @_;
> 
>   @args = map {
>     $_ = &QuoteHtml($_);
>   } @args;
>   $text = T($text);
>   $text =~ s/\%([1-9])/$args[$1]/ge;
>   return $text;
> }
> 
> # == Normal page-browsing and RecentChanges code =======================
> $BrowseCode = ""; # Comment next line to always compile (slower)
> #$BrowseCode = <<'#END_OF_BROWSE_CODE';
> use CGI;
> use CGI::Carp qw(fatalsToBrowser);
> 
> sub InitRequest {
>   my @ScriptPath = split('/', "$ENV{SCRIPT_NAME}");
> 
>   $CGI::POST_MAX = $MaxPost;
>   if ($UseUpload) {
>     $CGI::DISABLE_UPLOADS = 0;  # allow uploads
>   } else {
>     $CGI::DISABLE_UPLOADS = 1;  # no uploads
>   }
>   $q = new CGI;
>   # Fix some issues with editing UTF8 pages (if charset specified)
>   if ($HttpCharset ne '') {
>     $q->charset($HttpCharset);
>   }
>   $Now = time;                     # Reset in case script is persistent
>   $ScriptName = pop(@ScriptPath);  # Name used in links
>   $IndexInit = 0;                  # Must be reset for each request
>   $InterSiteInit = 0;
>   %InterSite = ();
>   $MainPage = ".";       # For subpages only, the name of the top-level page
>   $OpenPageName = "";    # Currently open page
>   &CreateDir($DataDir);  # Create directory if it doesn't exist
>   if (!-d $DataDir) {
>     &ReportError(Ts('Could not create %s', $DataDir) . ": $!");
>     return 0;
>   }
>   &InitCookie();         # Reads in user data
>   return 1;
> }
> 
> sub InitCookie {
>   %SetCookie = ();
>   $TimeZoneOffset = 0;
>   undef $q->{'.cookies'};  # Clear cache if it exists (for SpeedyCGI)
>   %UserData = ();          # Fix for persistent environments.
>   %UserCookie = $q->cookie($CookieName);
>   $UserID = $UserCookie{'id'};
>   $UserID =~ s/\D//g;  # Numeric only
>   if ($UserID < 200) {
>     $UserID = 111;
>   } else {
>     &LoadUserData($UserID);
>   }
>   if ($UserID > 199) {
>     if (($UserData{'id'}       != $UserCookie{'id'})      ||
>         ($UserData{'randkey'}  != $UserCookie{'randkey'})) {
>       $UserID = 113;
>       %UserData = ();   # Invalid.  Consider warning message.
>     }
>   }
>   if ($UserData{'tzoffset'} != 0) {
>     $TimeZoneOffset = $UserData{'tzoffset'} * (60 * 60);
>   }
> }
> 
> sub DoBrowseRequest {
>   my ($id, $action, $text);
> 
>   if (!$q->param) {             # No parameter
>     &BrowsePage($HomePage);
>     return 1;
>   }
>   $id = &GetParam('keywords', '');
>   if ($id) {                    # Just script?PageName
>     if ($FreeLinks && (!-f &GetPageFile($id))) {
>       $id = &FreeToNormal($id);
>     }
>     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
>       $id = $NotFoundPg;
>     }
>     &BrowsePage($id)  if &ValidIdOrDie($id);
>     return 1;
>   }
>   $action = lc(&GetParam('action', ''));
>   $id = &GetParam('id', '');
>   if ($action eq 'browse') {
>     if ($FreeLinks && (!-f &GetPageFile($id))) {
>       $id = &FreeToNormal($id);
>     }
>     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
>       $id = $NotFoundPg;
>     }
>     &BrowsePage($id)  if &ValidIdOrDie($id);
>     return 1;
>   } elsif ($action eq 'rc') {
>     &BrowsePage($RCName);
>     return 1;
>   } elsif ($action eq 'random') {
>     &DoRandom();
>     return 1;
>   } elsif ($action eq 'history') {
>     &DoHistory($id)   if &ValidIdOrDie($id);
>     return 1;
>   }
>   return 0;  # Request not handled
> }
> 
> sub BrowsePage {
>   my ($id) = @_;
>   my ($fullHtml, $oldId, $allDiff, $showDiff, $openKept);
>   my ($revision, $goodRevision, $diffRevision, $newText);
> 
>   &OpenPage($id);
>   &OpenDefaultText();
>   $openKept = 0;
>   $revision = &GetParam('revision', '');
>   $revision =~ s/\D//g;           # Remove non-numeric chars
>   $goodRevision = $revision;      # Non-blank only if exists
>   if ($revision ne '') {
>     &OpenKeptRevisions('text_default');
>     $openKept = 1;
>     if (!defined($KeptRevisions{$revision})) {
>       $goodRevision = '';
>     } else {
>       &OpenKeptRevision($revision);
>     }
>   }
>   # Raw mode: just untranslated wiki text
>   if (&GetParam('raw', 0)) {
>      print &GetHttpHeader('text/plain');
>      print $Text{'text'};
>      return;
>   }
>   $newText = $Text{'text'};     # For differences
>   # Handle a single-level redirect
>   $oldId = &GetParam('oldid', '');
>   if (($oldId eq '') && (substr($Text{'text'}, 0, 10) eq '#REDIRECT ')) {
>     $oldId = $id;
>     if (($FreeLinks) && ($Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/)) {
>       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/);
>       $id = &FreeToNormal($id);
>     } else {
>       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+(\S+)/);
>     }
>     if (&ValidId($id) eq '') {
>       # Consider revision in rebrowse?
>       &ReBrowsePage($id, $oldId, 0);
>       return;
>     } else {  # Not a valid target, so continue as normal page
>       $id = $oldId;
>       $oldId = '';
>     }
>   }
>   $MainPage = $id;
>   $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
>   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId);
>   if ($revision ne '') {
>     if (($revision eq $Page{'revision'}) || ($goodRevision ne '')) {
>       $fullHtml .= '<b>' . Ts('Showing revision %s', $revision) . "</b><br>";
>     } else {
>       $fullHtml .= '<b>' . Ts('Revision %s not available', $revision)
>                    . ' (' . T('showing current revision instead')
>                    . ')</b><br>';
>     }
>   }
>   $allDiff  = &GetParam('alldiff', 0);
>   if ($allDiff != 0) {
>     $allDiff = &GetParam('defaultdiff', 1);
>   }
>   if ((($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName))
>       && &GetParam('norcdiff', 1)) {
>     $allDiff = 0;  # Only show if specifically requested
>   }
>   $showDiff = &GetParam('diff', $allDiff);
>   if ($UseDiff && $showDiff) {
>     $diffRevision = $goodRevision;
>     $diffRevision = &GetParam('diffrevision', $diffRevision);
>     # Eventually try to avoid the following keep-loading if possible?
>     &OpenKeptRevisions('text_default')  if (!$openKept);
>     $fullHtml .= &GetDiffHTML($showDiff, $id, $diffRevision,
>                               $revision, $newText);
>     $fullHtml .= "<hr class=wikilinediff>\n";
>   }
>   $fullHtml .= '<div class=wikitext>';
>   $fullHtml .= &WikiToHTML($Text{'text'});
>   $fullHtml .= '</div>';
>   if (($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName)) {
>     print $fullHtml;
>     print "<hr class=wikilinerc>\n";
>     print '<div class=wikirc>';
>     &DoRc(1);
>     print '</div>';
>     print &GetFooterText($id, $goodRevision);
>     return;
>   }
>   $fullHtml .= &GetFooterText($id, $goodRevision);
>   print $fullHtml;
>   return  if ($showDiff || ($revision ne ''));  # Don't cache special version
>   &UpdateHtmlCache($id, $fullHtml)  if ($UseCache && ($oldId eq ''));
> }
> 
> sub ReBrowsePage {
>   my ($id, $oldId, $isEdit) = @_;
> 
>   if ($oldId ne "") {   # Target of #REDIRECT (loop breaking)
>     print &GetRedirectPage("action=browse&id=$id&oldid=$oldId",
>                            $id, $isEdit);
>   } else {
>     print &GetRedirectPage($id, $id, $isEdit);
>   }
> }
> 
> sub DoRc {
>   my ($rcType) = @_;   # 0 = RSS, 1 = HTML
>   my ($fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly);
>   my (@fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML);
>   my $starttime = 0;
>   my $showbar = 0;
> 
>   if (0 == $rcType) {
>     $showHTML = 0;
>   } else {
>     $showHTML = 1;
>   }
>   if (&GetParam("from", 0)) {
>     $starttime = &GetParam("from", 0);
>     if ($showHTML) {
>       print "<h2>" . Ts('Updates since %s', &TimeToText($starttime))
>             . "</h2>\n";
>     }
>   } else {
>     $daysago = &GetParam("days", 0);
>     $daysago = &GetParam("rcdays", 0)  if ($daysago == 0);
>     if ($daysago) {
>       $starttime = $Now - ((24*60*60)*$daysago);
>       if ($showHTML) {
>         print "<h2>" . Ts('Updates in the last %s day'
>                           . (($daysago != 1)?"s":""), $daysago) . "</h2>\n";
>       }
>       # Note: must have two translations (for "day" and "days")
>       # Following comment line is for translation helper script
>       # Ts('Updates in the last %s days', '');
>     }
>   }
>   if ($starttime == 0) {
>     if (0 == $rcType) {
>       $starttime = $Now - ((24*60*60)*$RssDays);
>     } else {
>       $starttime = $Now - ((24*60*60)*$RcDefault);
>     }
>     if ($showHTML) {
>       print "<h2>" . Ts('Updates in the last %s day'
>                         . (($RcDefault != 1)?"s":""), $RcDefault) . "</h2>\n";
>     }
>     # Translation of above line is identical to previous version
>   }
>   # Read rclog data (and oldrclog data if needed)
>   ($status, $fileData) = &ReadFile($RcFile);
>   $errorText = "";
>   if (!$status) {
>     # Save error text if needed.
>     $errorText = '<p><strong>' . Ts('Could not open %s log file', $RCName)
>                  . ":</strong> $RcFile<p>"
>                  . T('Error was') . ":\n<pre>$!</pre>\n" . '<p>'
>     . T('Note: This error is normal if no changes have been made.') . "\n";
>   }
>   @fullrc = split(/\n/, $fileData);
>   $firstTs = 0;
>   if (@fullrc > 0) {  # Only false if no lines in file
>     ($firstTs) = split(/$FS3/, $fullrc[0]);
>   }
>   if (($firstTs == 0) || ($starttime <= $firstTs)) {
>     ($status, $oldFileData) = &ReadFile($RcOldFile);
>     if ($status) {
>       @fullrc = split(/\n/, $oldFileData . $fileData);
>     } else {
>       if ($errorText ne "") {  # could not open either rclog file
>         print $errorText;
>         print "<p><strong>"
>               . Ts('Could not open old %s log file', $RCName)
>               . ":</strong> $RcOldFile<p>"
>               . T('Error was') . ":\n<pre>$!</pre>\n";
>         return;
>       }
>     }
>   }
>   $lastTs = 0;
>   if (@fullrc > 0) {  # Only false if no lines in file
>     ($lastTs) = split(/$FS3/, $fullrc[$#fullrc]);
>   }
>   $lastTs++  if (($Now - $lastTs) > 5);  # Skip last unless very recent
> 
>   $idOnly = &GetParam("rcidonly", "");
>   if ($idOnly && $showHTML) {
>     print '<b>(' . Ts('for %s only', &ScriptLink($idOnly, &QuoteHtml($idOnly)), 1)
>           . ')</b><br>';
>   }
>   if ($showHTML) {
>     foreach $i (@RcDays) {
>       print " | "  if $showbar;
>       $showbar = 1;
>       print &ScriptLink("action=rc&days=$i",
>                         Ts('%s day' . (($i != 1)?'s':''), $i));
>         # Note: must have two translations (for "day" and "days")
>         # Following comment line is for translation helper script
>         # Ts('%s days', '');
>     }
>     print "<br>" . &ScriptLink("action=rc&from=$lastTs",
>                                T('List new changes starting from'));
>     print " " . &TimeToText($lastTs) . "<br>\n";
>   }
>   $i = 0;
>   while ($i < @fullrc) {  # Optimization: skip old entries quickly
>     ($ts) = split(/$FS3/, $fullrc[$i]);
>     if ($ts >= $starttime) {
>       $i -= 1000  if ($i > 0);
>       last;
>     }
>     $i += 1000;
>   }
>   $i -= 1000  if (($i > 0) && ($i >= @fullrc));
>   for (; $i < @fullrc ; $i++) {
>     ($ts) = split(/$FS3/, $fullrc[$i]);
>     last if ($ts >= $starttime);
>   }
>   if ($i == @fullrc && $showHTML) {
>     print '<br><strong>' . Ts('No updates since %s',
>                               &TimeToText($starttime)) . "</strong><br>\n";
>   } else {
>     splice(@fullrc, 0, $i);  # Remove items before index $i
>     # Consider an end-time limit (items older than X)
>     if (0 == $rcType) {
>       print &GetRcRss(@fullrc);
>     } else {
>       print &GetRcHtml(@fullrc);
>     }
>   }
>   if ($showHTML) {
>     print '<p>' . Ts('Page generated %s', &TimeToText($Now)), "<br>\n";
>   }
> }
> 
> sub GetRc {
>   my $rcType = shift;
>   my @outrc = @_;
>   my ($rcline, $date, $newtop, $author, $inlist, $result);
>   my ($showedit, $link, $all, $idOnly, $headItem, $item);
>   my ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp);
>   my ($rcchangehist, $tEdit, $tChanges, $tDiff);
>   my ($headList, $historyPrefix, $diffPrefix);
>   my %extra = ();
>   my %changetime = ();
>   my %pagecount = ();
> 
>   # Slice minor edits
>   $showedit = &GetParam("rcshowedit", $ShowEdits);
>   $showedit = &GetParam("showedit", $showedit);
>   if ($showedit != 1) {
>     my @temprc = ();
>     foreach $rcline (@outrc) {
>       ($ts, $pagename, $summary, $isEdit, $host) = split(/$FS3/, $rcline);
>       if ($showedit == 0) {  # 0 = No edits
>         push(@temprc, $rcline)  if (!$isEdit);
>       } else {               # 2 = Only edits
>         push(@temprc, $rcline)  if ($isEdit);
>       }
>     }
>     @outrc = @temprc;
>   }
>   # Optimize param fetches out of main loop
>   $rcchangehist = &GetParam("rcchangehist", 1);
>   # Optimize translations out of main loop
>   $tEdit    = T('(edit)');
>   $tDiff    = T('(diff)');
>   $tChanges = T('changes');
>   $diffPrefix = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
>   $historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
>   foreach $rcline (@outrc) {
>     ($ts, $pagename) = split(/$FS3/, $rcline);
>     $pagecount{$pagename}++;
>     $changetime{$pagename} = $ts;
>   }
>   $date = "";
>   $all = &GetParam("rcall", 0);
>   $all = &GetParam("all", $all);
>   $newtop = &GetParam("rcnewtop", $RecentTop);
>   $newtop = &GetParam("newtop", $newtop);
>   $idOnly = &GetParam("rcidonly", "");
>   $inlist = 0;
>   $headList = '';
>   $result = '';
>   @outrc = reverse @outrc if ($newtop);
>   foreach $rcline (@outrc) {
>     ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp)
>       = split(/$FS3/, $rcline);
>     next  if ((!$all) && ($ts < $changetime{$pagename}));
>     next  if (($idOnly ne "") && ($idOnly ne $pagename));
>     %extra = split(/$FS2/, $extraTemp, -1);
>     if ($date ne &CalcDay($ts)) {
>       $date = &CalcDay($ts);
>       if (1 == $rcType) {  # HTML
>         # add date, properly closing lists first
>         if ($inlist) {
>           $result .= "</UL>\n";
>           $inlist = 0;
>         }
>         $result .= "<p><strong>" . $date . "</strong></p>\n";
>         if (!$inlist) {
>           $result .= "<UL>\n";
>           $inlist = 1;
>         }
>       }
>     }
>     if (0 == $rcType) {  # RSS
>       ($headItem, $item) = &GetRssRcLine($pagename, $ts, $host,
>                               $extra{'name'}, $extra{'id'}, $summary, $isEdit,
>                               $pagecount{$pagename}, $extra{'revision'},
>                               $diffPrefix, $historyPrefix);
>       $headList .= $headItem;
>       $result   .= $item;
>     } else {  # HTML
>       $result .= &GetHtmlRcLine($pagename, $ts, $host, $extra{'name'},
>                          $extra{'id'}, $summary, $isEdit,
>                          $pagecount{$pagename}, $extra{'revision'},
>                          $tEdit, $tDiff, $tChanges, $all, $rcchangehist);
>     }
>   }
>   if (1 == $rcType) {
>     $result .= "</UL>\n"  if ($inlist);  # Close final tag
>   }
>   return ($headList, $result);  # Just ignore headList for HTML
> }
> 
> sub GetRcHtml {
>   my ($html, $extra);
> 
>   ($extra, $html) = &GetRc(1, @_);
>   return $html;
> }
> 
> sub GetHtmlRcLine {
>   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
>       $isEdit, $pagecount, $revision, $tEdit, $tDiff, $tChanges, $all,
>       $rcchangehist) = @_;
>   my ($author, $sum, $edit, $count, $link, $html);
> 
>   $html = '';
>   $host = &QuoteHtml($host);
>   if (defined($userName) && defined($userID)) {
>     $author = &GetAuthorLink($host, $userName, $userID);
>   } else {
>     $author = &GetAuthorLink($host, "", 0);
>   }
>   $sum = "";
>   if (($summary ne "") && ($summary ne "*")) {
>     $summary = &QuoteHtml($summary);
>     $sum = "<strong>[$summary]</strong> ";
>   }
>   $edit = "";
>   $edit = "<em>$tEdit</em> "  if ($isEdit);
>   $count = "";
>   if ((!$all) && ($pagecount > 1)) {
>     $count = "($pagecount ";
>     if ($rcchangehist) {
>       $count .= &GetHistoryLink($pagename, $tChanges);
>     } else {
>       $count .= $tChanges;
>     }
>     $count .= ") ";
>   }
>   $link = "";
>   if ($UseDiff && &GetParam("diffrclink", 1)) {
>     $link .= &ScriptLinkDiff(4, $pagename, $tDiff, "") . "  ";
>   }
>   $link .= &GetPageLink($pagename);
>   $html .= "<li>$link ";
>   $html .=  &CalcTime($timestamp) . " $count$edit" . " $sum";
>   $html .= ". . . . . $author\n";
>   return $html;
> }
> 
> sub GetRcRss {
>   my ($rssHeader, $headList, $items);
> 
>   # Normally get URL from script, but allow override
>   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
>   $QuotedFullUrl = &QuoteHtml($FullUrl);
>   $SiteDescription = &QuoteHtml($SiteDescription);
> 
>   my $ChannelAbout = &QuoteHtml($FullUrl . &ScriptLinkChar()
>                                 . $ENV{QUERY_STRING});
>   $rssHeader = <<RSS ;
> <?xml version="1.0" encoding="ISO-8859-1"?>
> <rdf:RDF
>     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
>     xmlns="http://purl.org/rss/1.0/"
>     xmlns:dc="http://purl.org/dc/elements/1.1/"
>     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
> >
>     <channel rdf:about="$ChannelAbout">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
>         <description>${\(&QuoteHtml($SiteDescription))}</description>
>         <wiki:interwiki>
>             <rdf:Description link="$QuotedFullUrl">
>                 <rdf:value>$InterWikiMoniker</rdf:value>
>             </rdf:Description>
>         </wiki:interwiki>
>         <items>
>             <rdf:Seq>
> RSS
>   ($headList, $items) = &GetRc(0, @_);
>   $rssHeader .= $headList;
>   return <<RSS ;
> $rssHeader
>             </rdf:Seq>
>         </items>
>     </channel>
>     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <url>$RssLogoUrl</url>
>         <link>$QuotedFullUrl</link>
>     </image>
> $items
> </rdf:RDF>
> RSS
> }
> 
> sub GetRssRcLine{
>   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
>       $isEdit, $pagecount, $revision, $diffPrefix, $historyPrefix) = @_;
>   my ($pagenameEsc, $itemID, $description, $authorLink, $author, $status,
>       $importance, $date, $item, $headItem);
> 
>   $pagenameEsc = CGI::escape($pagename);
>   # Add to list of items in the <channel/>
>   $itemID = $FullUrl . &ScriptLinkChar()
>             . &GetOldPageParameters('browse', $pagenameEsc, $revision);
>   $itemID = &QuoteHtml($itemID);
>   $headItem = "                <rdf:li rdf:resource=\"$itemID\"/>\n";
>   # Add to list of items proper.
>   if (($summary ne "") && ($summary ne "*")) {
>     $description = &QuoteHtml($summary);
>   }
>   $host = &QuoteHtml($host);
>   if ($userName) {
>     $author = &QuoteHtml($userName);
>     $authorLink = "link=\"$QuotedFullUrl?$author\"";
>   } else {
>     $author = $host;
>   }
>   $status = (1 == $revision) ? 'new' : 'updated';
>   $importance = $isEdit ? 'minor' : 'major';
>   $timestamp += $TimeZoneOffset;
>   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($timestamp);
>   $year += 1900;
>   $date = sprintf("%4d-%02d-%02dT%02d:%02d:%02d+%02d:00",
>     $year, $mon+1, $mday, $hour, $min, $sec, $TimeZoneOffset/(60*60));
>   $pagename = &QuoteHtml($pagename);
>   # Write it out longhand
>   $item = <<RSS ;
>     <item rdf:about="$itemID">
>         <title>$pagename</title>
>         <link>$QuotedFullUrl?$pagenameEsc</link>
>         <description>$description</description>
>         <dc:date>$date</dc:date>
>         <dc:contributor>
>             <rdf:Description wiki:host="$host" $authorLink>
>                 <rdf:value>$author</rdf:value>
>             </rdf:Description>
>         </dc:contributor>
>         <wiki:status>$status</wiki:status>
>         <wiki:importance>$importance</wiki:importance>
>         <wiki:diff>$diffPrefix$pagenameEsc</wiki:diff>
>         <wiki:version>$revision</wiki:version>
>         <wiki:history>$historyPrefix$pagenameEsc</wiki:history>
>     </item>
> RSS
>   return ($headItem, $item);
> }
> 
> sub DoRss {
>   print "Content-type: text/xml\n\n";
>   &DoRc(0);
> }
> 
> sub DoRandom {
>   my ($id, @pageList);
> 
>   @pageList = &AllPagesList();  # Optimize?
>   $id = $pageList[int(rand($#pageList + 1))];
>   &ReBrowsePage($id, "", 0);
> }
> 
> sub DoHistory {
>   my ($id) = @_;
>   my ($html, $canEdit, $row, $newText);
> 
>   print &GetHeader('', Ts('History of %s', $id), '') . '<br>';
>   &OpenPage($id);
>   &OpenDefaultText();
>   $newText = $Text{'text'};
>   $canEdit = 0;
>   $canEdit = &UserCanEdit($id)  if ($HistoryEdit);
>   if ($UseDiff) {
>     print <<EOF ;
>       <form action="$ScriptName" METHOD="GET">
>           <input type="hidden" name="action" value="browse"/>
>           <input type="hidden" name="diff" value="1"/>
>           <input type="hidden" name="id" value="$id"/>
>       <table border="0" width="100%"><tr>
> EOF
>   }
>   $html = &GetHistoryLine($id, $Page{'text_default'}, $canEdit, $row++);
>   &OpenKeptRevisions('text_default');
>   foreach (reverse sort {$a <=> $b} keys %KeptRevisions) {
>     next  if ($_ eq "");  # (needed?)
>     $html .= &GetHistoryLine($id, $KeptRevisions{$_}, $canEdit, $row++);
>   }
>   print $html;
>   if ($UseDiff) {
>     my $label = T('Compare');
>     print "<tr><td align='center'><input type='submit' "
>           . "value='$label'/>&nbsp;&nbsp;</td></table></form>\n";
>     print "<hr class=wikilinediff>\n";
>     print &GetDiffHTML(&GetParam('defaultdiff', 1), $id, '', '', $newText);
>   }
>   print &GetCommonFooter();
> }
> 
> sub GetMaskedHost {
>   my ($text) = @_;
>   my ($logText);
> 
>   if (!$MaskHosts) {
>     return $text;
>   }
>   $logText = T('(logged)');
>   if (!($text =~ s/\d+$/$logText/)) { # IP address (ending numbers masked)
>     $text =~ s/^[^\.\(]+/$logText/;   # Host name: mask until first .
>   }
>   return $text;
> }
> 
> sub GetHistoryLine {
>   my ($id, $section, $canEdit, $row) = @_;
>   my ($html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor);
>   my (%sect, %revtext);
> 
>   %sect = split(/$FS2/, $section, -1);
>   %revtext = split(/$FS3/, $sect{'data'});
>   $rev = $sect{'revision'};
>   $summary = $revtext{'summary'};
>   if ((defined($sect{'host'})) && ($sect{'host'} ne '')) {
>     $host = $sect{'host'};
>   } else {
>     $host = $sect{'ip'};
>   }
>   $host = &GetMaskedHost($host);
>   $user = $sect{'username'};
>   $uid = $sect{'id'};
>   $ts = $sect{'ts'};
>   $minor = '';
>   $minor = '<i>' . T('(edit)') . '</i> '  if ($revtext{'minor'});
>   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
>   if ($UseDiff) {
>     my ($c1, $c2);
>     $c1 = 'checked="checked"' if 1 == $row;
>     $c2 = 'checked="checked"' if 0 == $row;
>     $html .= "<tr><td align='center'><input type='radio' "
>              . "name='diffrevision' value='$rev' $c1/> ";
>     $html .= "<input type='radio' name='revision' value='$rev' $c2/></td><td>";
>   }
>   if (0 == $row) { # current revision
>     $html .= &GetPageLinkText($id, Ts('Revision %s', $rev)) . ' ';
>     if ($canEdit) {
>       $html .= &GetEditLink($id, T('Edit')) . ' ';
>     }
>   } else {
>     $html .= &GetOldPageLink('browse', $id, $rev,
>                              Ts('Revision %s', $rev)) . ' ';
>     if ($canEdit) {
>       $html .= &GetOldPageLink('edit',   $id, $rev, T('Edit')) . ' ';
>     }
>   }
>   $html .= ". . " . $minor . &TimeToText($ts) . " ";
>   $html .= T('by') . ' ' . &GetAuthorLink($host, $user, $uid) . " ";
>   if (defined($summary) && ($summary ne "") && ($summary ne "*")) {
>     $summary = &QuoteHtml($summary);   # Thanks Sunir! :-)
>     $html .= "<b>[$summary]</b> ";
>   }
>   $html .= $UseDiff ? "</tr>\n" : "<br>\n";
>   return $html;
> }
> 
> # ==== HTML and page-oriented functions ====
> sub ScriptLinkChar {
>   if ($SlashLinks) {
>     return '/';
>   }
>   return '?';
> }
> 
> sub ScriptLink {
>   my ($action, $text) = @_;
> 
>   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
>          . "\">$text</a>";
> }
> 
> sub ScriptLinkClass {
>   my ($action, $text, $class) = @_;
> 
>   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
>          . '" class="' . $class . "\">$text</a>";
> }
> 
> sub GetPageLinkText {
>   my ($id, $name) = @_;
> 
>   $id =~ s|^/|$MainPage/|;
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>     $name =~ s/_/ /g;
>   }
>   return &ScriptLinkClass($id, $name, 'wikipagelink');
> }
> 
> sub GetPageLink {
>   my ($id) = @_;
> 
>   return &GetPageLinkText($id, $id);
> }
> 
> sub GetEditLink {
>   my ($id, $name) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>     $name =~ s/_/ /g;
>   }
>   return &ScriptLinkClass("action=edit&id=$id", $name, 'wikipageedit');
> }
> 
> sub GetDeleteLink {
>   my ($id, $name, $confirm) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>     $name =~ s/_/ /g;
>   }
>   return &ScriptLink("action=delete&id=$id&confirm=$confirm", $name);
> }
> 
> sub GetOldPageParameters {
>   my ($kind, $id, $revision) = @_;
> 
>   $id = &FreeToNormal($id) if $FreeLinks;
>   return "action=$kind&id=$id&revision=$revision";
> }
> 
> sub GetOldPageLink {
>   my ($kind, $id, $revision, $name) = @_;
> 
>   $name =~ s/_/ /g if $FreeLinks;
>   return &ScriptLink(&GetOldPageParameters($kind, $id, $revision), $name);
> }
> 
> sub GetPageOrEditAnchoredLink {
>   my ($id, $anchor, $name) = @_;
>   my (@temp, $exists);
> 
>   if ($name eq "") {
>     $name = $id;
>     if ($FreeLinks) {
>       $name =~ s/_/ /g;
>     }
>   }
>   $id =~ s|^/|$MainPage/|;
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   $exists = 0;
>   if ($UseIndex) {
>     if (!$IndexInit) {
>       @temp = &AllPagesList();          # Also initializes hash
>     }
>     $exists = 1  if ($IndexHash{$id});
>   } elsif (-f &GetPageFile($id)) {      # Page file exists
>     $exists = 1;
>   }
>   if ($exists) {
>     $id = "$id#$anchor"  if $anchor;
>     $name = "$name#$anchor"  if $anchor && $NamedAnchors != 2;
>     return &GetPageLinkText($id, $name);
>   }
>   if ($FreeLinks && !$EditNameLink) {
>     if ($name =~ m| |) {  # Not a single word
>       $name = "[$name]";  # Add brackets so boundaries are obvious
>     }
>   }
>   if ($EditNameLink) {
>     return &GetEditLink($id, $name);
>   } else {
>     return $name . &GetEditLink($id, '?');
>   }
> }
> 
> sub GetPageOrEditLink {
>     my ($id, $name) = @_;
>     return &GetPageOrEditAnchoredLink($id, "", $name);
> }
> 
> sub GetBackLinksSearchLink {
>   my ($id) = @_;
>   my $name = $id;
> 
>   $id =~ s|.+/|/|;   # Subpage match: search for just /SubName
>   if ($FreeLinks) {
>     $name =~ s/_/ /g;  # Display with spaces
>     $id =~ s/_/+/g;    # Search for url-escaped spaces
>   }
>   return &ScriptLink("back=$id", $name);
> }
> 
> sub GetPrefsLink {
>   return &ScriptLink("action=editprefs", T('Preferences'));
> }
> 
> sub GetRandomLink {
>   return &ScriptLink("action=random", T('Random Page'));
> }
> 
> sub ScriptLinkDiff {
>   my ($diff, $id, $text, $rev) = @_;
> 
>   $rev = "&revision=$rev"  if ($rev ne "");
>   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
>   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
> }
> 
> sub ScriptLinkDiffRevision {
>   my ($diff, $id, $rev, $text) = @_;
> 
>   $rev = "&diffrevision=$rev"  if ($rev ne "");
>   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
>   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
> }
> 
> sub GetUploadLink {
>   return &ScriptLink('action=upload', T('Upload'));
> }
> 
> sub ScriptLinkTitle {
>   my ($action, $text, $title) = @_;
> 
>   if ($FreeLinks) {
>     $action =~ s/ /_/g;
>   }
>   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
>          . "\" title=\"$title\">$text</a>";
> }
> 
> sub GetAuthorLink {
>   my ($host, $userName, $uid) = @_;
>   my ($html, $title, $userNameShow);
> 
>   $userNameShow = $userName;
>   if ($FreeLinks) {
>     $userName     =~ s/ /_/g;
>     $userNameShow =~ s/_/ /g;
>   }
>   if (&ValidId($userName) ne "") {  # Invalid under current rules
>     $userName = "";  # Just pretend it isn't there.
>   }
>   if (($uid > 0) && ($userName ne "")) {
>     $html = &ScriptLinkTitle($userName, $userNameShow,
>             Ts('ID %s', $uid) . ' ' . Ts('from %s', $host));
>   } else {
>     $html = $host;
>   }
>   return $html;
> }
> 
> sub GetHistoryLink {
>   my ($id, $text) = @_;
> 
>   if ($FreeLinks) {
>     $id =~ s/ /_/g;
>   }
>   return &ScriptLink("action=history&id=$id", $text);
> }
> 
> sub GetHeader {
>   my ($id, $title, $oldId) = @_;
>   my $header = "";
>   my $logoImage = "";
>   my $result = "";
>   my $embed = &GetParam('embed', $EmbedWiki);
>   my $altText = T('[Home]');
> 
>   $result = &GetHttpHeader('');
>   if ($FreeLinks) {
>     $title =~ s/_/ /g;   # Display as spaces
>   }
>   $result .= &GetHtmlHeader("$SiteName: $title");
>   return $result  if ($embed);
> 
>   $result .= '<div class=wikiheader>';
>   if ($oldId ne '') {
>     $result .= $q->h3('(' . Ts('redirected from %s', 
>                                &GetEditLink($oldId, &QuoteHtml($oldId)), 1) . ')');
>   }
>   if ((!$embed) && ($LogoUrl ne "")) {
>     $logoImage = "img src=\"$LogoUrl\" alt=\"$altText\" border=0";
>     if (!$LogoLeft) {
>       $logoImage .= " align=\"right\"";
>     }
>     $header = &ScriptLink($HomePage, "<$logoImage>");
>   }
>   if ($id ne '') {
>     $result .= $q->h1($header . &GetBackLinksSearchLink($id));
>   } else {
>     $result .= $q->h1($header . $title);
>   }
>   if (&GetParam("toplinkbar", 1)) {
>     $result .= &GetGotoBar($id) . "<hr class=wikilineheader>";
>   }
>   $result .= '</div>';
>   return $result;
> }
> 
> sub GetHttpHeader {
>   my ($type) = @_;
>   my $cookie;
> 
>   $type = 'text/html'  if ($type eq '');
>   if (defined($SetCookie{'id'})) {
>     $cookie = "$CookieName="
>             . "rev&" . $SetCookie{'rev'}
>             . "&id&" . $SetCookie{'id'}
>             . "&randkey&" . $SetCookie{'randkey'};
>     $cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
>     if ($HttpCharset ne '') {
>       return $q->header(-cookie=>$cookie,
>                         -type=>"$type; charset=$HttpCharset");
>     }
>     return $q->header(-cookie=>$cookie);
>   }
>   if ($HttpCharset ne '') {
>     return $q->header(-type=>"$type; charset=$HttpCharset");
>   }
>   return $q->header(-type=>$type);
> }
> 
> sub GetHtmlHeader {
>   my ($title) = @_;
>   my ($dtd, $html, $bodyExtra, $stylesheet);
> 
>   $html = '';
>   $dtd = '-//IETF//DTD HTML//EN';
>   $html = qq(<!DOCTYPE HTML PUBLIC "$dtd">\n);
>   $title = $q->escapeHTML($title);
>   $html .= "<HTML><HEAD><TITLE>$title</TITLE>\n";
>   if ($FavIcon ne '') {
>     $html .= '<LINK REL="SHORTCUT ICON" HREF="' . $FavIcon . '">' 
>   }
>   if ($MetaKeywords) {
>       my $keywords = $OpenPageName;
>       $keywords =~ s/([a-z])([A-Z])/$1, $2/g;
>       $html .= "<META NAME='KEYWORDS' CONTENT='$keywords'/>\n" if $keywords;
>   }
>   # we don't want robots indexing our history or other admin pages
>   my $action = lc(&GetParam('action', ''));
>   unless (!$action or $action eq "rc" or $action eq "index") {
>     $html .= "<META NAME='robots' CONTENT='noindex,nofollow'>\n";
>   }
>   if ($SiteBase ne "") {
>     $html .= qq(<BASE HREF="$SiteBase">\n);
>   }
>   $stylesheet = &GetParam('stylesheet', $StyleSheet);
>   $stylesheet = $StyleSheet  if ($stylesheet eq '');
>   $stylesheet = ''  if ($stylesheet eq '*');  # Allow removing override
>   if ($stylesheet ne '') {
>     $html .= qq(<LINK REL="stylesheet" HREF="$stylesheet">\n);
>   }
>   $html .= $UserHeader;
>   $bodyExtra = '';
>   if ($UserBody ne '') {
>     $bodyExtra = ' ' . $UserBody;
>   }
>   if ($BGColor ne '') {
>     $bodyExtra .= qq( BGCOLOR="$BGColor");
>   }
>   $html .= "</HEAD><BODY$bodyExtra>\n";
>   return $html;
> }
> 
> sub GetFooterText {
>   my ($id, $rev) = @_;
>   my $result;
> 
>   if (&GetParam('embed', $EmbedWiki)) {
>     return $q->end_html;
>   }
>   $result = '<div class=wikifooter>';
>   $result .= "<hr class=wikilinefooter>\n";
>   $result .= &GetFormStart();
>   $result .= &GetGotoBar($id);
>   if (&UserCanEdit($id, 0)) {
>     if ($rev ne '') {
>       $result .= &GetOldPageLink('edit',   $id, $rev,
>                                  Ts('Edit revision %s of this page', $rev));
>     } else {
>       $result .= &GetEditLink($id, T('Edit text of this page'));
>     }
>   } else {
>     $result .= T('This page is read-only');
>   }
>   $result .= ' | ';
>   $result .= &GetHistoryLink($id, T('View other revisions'));
>   if ($rev ne '') {
>     $result .= ' | ';
>     $result .= &GetPageLinkText($id, T('View current revision'));
>   }
>   if ($UseMetaWiki) {
>     $result .= ' | <a href="http://sunir.org/apps/meta.pl?' . &UriEscape($id) . '">'
>                . T('Search MetaWiki') . '</a>';
>   }
>   if ($Section{'revision'} > 0) {
>     $result .= '<br>';
>     if ($rev eq '') {  # Only for most current rev
>       $result .= T('Last edited');
>     } else {
>       $result .= T('Edited');
>     }
>     $result .= ' ' . &TimeToText($Section{ts});
>     if ($AuthorFooter) {
>       $result .= ' ' . Ts('by %s', &GetAuthorLink($Section{'host'},
>                                      $Section{'username'}, $Section{'id'}), 1);
>     }
>   }
>   if ($UseDiff) {
>     $result .= ' ' . &ScriptLinkDiff(4, $id, T('(diff)'), $rev);
>   }
>   $result .= '<br>' . &GetSearchForm();
>   if ($AdminBar && &UserIsAdmin()) {
>     $result .= '<br>' . &GetAdminBar($id);
>   }
>   if ($DataDir =~ m|/tmp/|) {
>     $result .= '<br><b>' . T('Warning') . ':</b> '
>                . Ts('Database is stored in temporary directory %s',
>                     $DataDir) . '<br>';
>   }
>   if ($ConfigError ne '') {
>     $result .= '<br><b>' . T('Config file error:') . '</b> '
>                . $ConfigError . '<br>';
>   }
>   $result .= $q->endform;
>   if ($FooterNote ne '') {
>     $result .= T($FooterNote);
>   }
>   $result .= '</div>';
>   $result .= &GetMinimumFooter();
>   return $result;
> }
> 
> sub GetCommonFooter {
>   my ($html);
> 
>   $html = '<div class=wikifooter>' . '<hr class=wikilinefooter>'
>           . &GetFormStart() . &GetGotoBar('')
>           . &GetSearchForm() . $q->endform;
>   if ($FooterNote ne '') {
>     $html .= T($FooterNote);
>   }
>   $html .= '</div>' . $q->end_html;
>   return $html;
> }
> 
> sub GetMinimumFooter {
>   return $q->end_html;
> }
> 
> sub GetFormStart {
>   return $q->startform("POST", "$ScriptName",
>                        "application/x-www-form-urlencoded");
> }
> 
> sub GetGotoBar {
>   my ($id) = @_;
>   my ($main, $bartext);
> 
>   $bartext  = &GetPageLink($HomePage);
>   if ($id =~ m|/|) {
>     $main = $id;
>     $main =~ s|/.*||;  # Only the main page name (remove subpage)
>     $bartext .= " | " . &GetPageLink($main);
>   }
>   $bartext .= " | " . &GetPageLink($RCName);
>   $bartext .= " | " . &GetPrefsLink();
>   if ($UseUpload && &UserCanUpload()) {
>     $bartext .= " | " . &GetUploadLink();
>   }
>   if (&GetParam("linkrandom", 0)) {
>     $bartext .= " | " . &GetRandomLink();
>   }
>   if ($UserGotoBar ne '') {
>     $bartext .= " | " . $UserGotoBar;
>   }
>   $bartext .= "<br>\n";
>   return $bartext;
> }
> 
> sub GetSearchForm {
>   my ($result);
> 
>   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
>   if ($SearchButton) {
>     $result .= $q->submit('dosearch', T('Go!'));
>   } else {  
>     $result .= &GetHiddenValue("dosearch", 1);
>   }
>   return $result;
> }
> 
> sub GetRedirectPage {
>   my ($newid, $name, $isEdit) = @_;
>   my ($url, $html);
>   my ($nameLink);
> 
>   # Normally get URL from script, but allow override.
>   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
>   $url = $FullUrl . &ScriptLinkChar() . &UriEscape($newid);
>   $nameLink = "<a href=\"$url\">$name</a>";
>   if ($RedirType < 3) {
>     if ($RedirType == 1) {             # Use CGI.pm
>       # NOTE: do NOT use -method (does not work with old CGI.pm versions)
>       # Thanks to Daniel Neri for fixing this problem.
>       $html = $q->redirect(-uri=>$url);
>     } else {                           # Minimal header
>       $html  = "Status: 302 Moved\n";
>       $html .= "Location: $url\n";
>       $html .= "Content-Type: text/html\n";  # Needed for browser failure
>       $html .= "\n";
>     }
>     $html .= "\n" . Ts('Your browser should go to the %s page.', $newid);
>     $html .= ' ' . Ts('If it does not, click %s to continue.', $nameLink);
>   } else {
>     if ($isEdit) {
>       $html  = &GetHeader('', T('Thanks for editing...'), '');
>       $html .= Ts('Thank you for editing %s.', $nameLink);
>     } else {
>       $html  = &GetHeader('', T('Link to another page...'), '');
>     }
>     $html .= "\n<p>";
>     $html .= Ts('Follow the %s link to continue.', $nameLink);
>     $html .= &GetMinimumFooter();
>   }
>   return $html;
> }
> 
> # ==== Common wiki markup ====
> sub RestoreSavedText {
>   my ($text) = @_;
> 
>   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
>   return $text;
> }
> 
> sub RemoveFS {
>   my ($text) = @_;
> 
>   # Note: must remove all $FS, and $FS may be multi-byte/char separator
>   $text =~ s/($FS)+(\d)/$2/g;
>   return $text;
> }
> 
> sub WikiToHTML {
>   my ($pageText) = @_;
>   $TableMode = 0;
> 
>   %SaveUrl = ();
>   %SaveNumUrl = ();
>   $SaveUrlIndex = 0;
>   $SaveNumUrlIndex = 0;
>   $pageText = &RemoveFS($pageText);
>   if ($RawHtml) {
>     $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
>   }
>   $pageText = &QuoteHtml($pageText);
>   $pageText =~ s/\\ *\r?\n/ /g;          # Join lines with backslash at end
>   if ($ParseParas) {
>     # Note: The following 3 rules may span paragraphs, so they are
>     #       copied from CommonMarkup
>     $pageText =~
>         s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
>     $pageText =~
>         s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
>     $pageText =~
>         s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
>     $pageText =~ s/((.|\n)+?\n)\s*(\n|$)/&ParseParagraph($1)/geo;
>     $pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
>   } else {
>     $pageText = &CommonMarkup($pageText, 1, 0);   # Multi-line markup
>     $pageText = &WikiLinesToHtml($pageText);      # Line-oriented markup
>   }
>   while (@HeadingNumbers) {
>     pop @HeadingNumbers;
>     $TableOfContents .= "</dd></dl>\n\n";
>   }
>   $pageText =~ s/&lt;toc&gt;/$TableOfContents/gi;
>   if ($LateRules ne '') {
>     $pageText = &EvalLocalRules($LateRules, $pageText, 0);
>   }
>   return &RestoreSavedText($pageText);
> }
> 
> sub CommonMarkup {
>   my ($text, $useImage, $doLines) = @_;
>   local $_ = $text;
> 
>   if ($doLines < 2) { # 2 = do line-oriented only
>     # The <nowiki> tag stores text with no markup (except quoting HTML)
>     s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
>     # The <pre> tag wraps the stored text with the HTML <pre> tag
>     s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
>     s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
>     if ($EarlyRules ne '') {
>       $_ = &EvalLocalRules($EarlyRules, $_, !$useImage);
>     }
>     s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
>     if ($HtmlTags) {
>       my ($t);
>       foreach $t (@HtmlPairs) {
>         s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
>       }
>       foreach $t (@HtmlSingle) {
>         s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
>       }
>     } else {
>       # Note that these tags are restricted to a single line
>       s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
>       s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
>       s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
>       s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
>     }
>     s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;  # <tt> (MeatBall)
>     s/\&lt;br\&gt;/<br>/gi;  # Allow simple line break anywhere
>     if ($HtmlLinks) {
>       s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
>     }
>     if ($FreeLinks) {
>       # Consider: should local free-link descriptions be conditional?
>       # Also, consider that one could write [[Bad Page|Good Page]]?
>       s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
>       s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
>     }
>     if ($BracketText) {  # Links like [URL text of link]
>       s/\[$UrlPattern\s+([^\]]+?)\]/&StoreBracketUrl($1, $2, $useImage)/geos;
>       s/\[$InterLinkPattern\s+([^\]]+?)\]/&StoreBracketInterPage($1, $2,
>                                                              $useImage)/geos;
>       if ($WikiLinks && $BracketWiki) {  # Local bracket-links
>         s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
>         s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1,
>                                                $2, $3)/geos if $NamedAnchors;
>       }
>     }
>     s/\[$UrlPattern\]/&StoreBracketUrl($1, "", 0)/geo;
>     s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0)/geo;
>     s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
>     s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
>     if ($UseUpload) {
>       s/$UploadPattern/&StoreUpload($1)/geo;
>     }
>     if ($WikiLinks) {
>       s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1,
>                              $2, ""))/geo if $NamedAnchors;
>       # CAA: Putting \b in front of $LinkPattern breaks /SubPage links
>       #      (subpage links without the main page)
>       s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
>     }
>     s/\b$RFCPattern/&StoreRFC($1)/geo;
>     s/\b$ISBNPattern/&StoreISBN($1)/geo;
>     if ($ThinLine) {
>       if ($OldThinLine) {  # Backwards compatible, conflicts with headers
>         s/====+/<hr noshade class=wikiline size=2>/g;
>       } else {             # New behavior--no conflict
>         s/------+/<hr noshade class=wikiline size=2>/g;
>       }
>       s/----+/<hr noshade class=wikiline size=1>/g;
>     } else {
>       s/----+/<hr class=wikiline>/g;
>     }
>   }
>   if ($doLines) { # 0 = no line-oriented, 1 or 2 = do line-oriented
>     # The quote markup patterns avoid overlapping tags (with 5 quotes)
>     # by matching the inner quotes for the strong pattern.
>     s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g;
>     s/''(.*?)''/<em>$1<\/em>/g;
>     if ($UseHeadings) {
>       s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
>     }
>     if ($TableMode) {
>       s/((\|\|)+)/"<\/TD><TD COLSPAN=\"" . (length($1)\/2) . "\">"/ge;
>     }
>   }
>   return $_;
> }
> 
> sub EmptyCellsToNbsp {
>   my ($row) = @_;
> 
>   $row =~ s/(?<=\|\|)\s+(?=\|\|)/&nbsp;/g;
>   $row =~ s/^\s+(?=\|\|)/&nbsp;/;
>   $row =~ s/(?<=\|\|)\s+$/&nbsp;/;
>   return $row;
> }
> 
> sub WikiLinesToHtml {
>   my ($pageText) = @_;
>   my ($pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode);
> 
>   @htmlStack = ();
>   $depth = 0;
>   $pageHtml = "";
>   foreach (split(/\n/, $pageText)) {  # Process lines one-at-a-time
>     $code = '';
>     $codeAttributes = '';
>     $TableMode = 0;
>     $_ .= "\n";
>     if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
>       $code = "DL";
>       $depth = length $1;
>     } elsif (s/^(\:+)/<dt><dd>/) {
>       $code = "DL";
>       $depth = length $1;
>     } elsif (s/^(\*+)/<li>/) {
>       $code = "UL";
>       $depth = length $1;
>     } elsif (s/^(\#+)/<li>/) {
>       $code = "OL";
>       $depth = length $1;
>     } elsif ($TableSyntax &&
>              s/^((\|\|)+)(.*)\|\|\s*$/"<TR VALIGN='CENTER' "
>                                       . "ALIGN='CENTER'><TD colspan='"
>                                . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/TD><\/TR>\n"/e) {
>       $code = 'TABLE';
>       $codeAttributes = "BORDER='1'";
>       $TableMode = 1;
>       $depth = 1;
>     } elsif (/^[ \t].*\S/) {
>       $code = "PRE";
>       $depth = 1;
>     } else {
>       $depth = 0;
>     }
>     while (@htmlStack > $depth) {   # Close tags as needed
>       $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
>     }
>     if ($depth > 0) {
>       $depth = $IndentLimit  if ($depth > $IndentLimit);
>       if (@htmlStack) {  # Non-empty stack
>         $oldCode = pop(@htmlStack);
>         if ($oldCode ne $code) {
>           $pageHtml .= "</$oldCode><$code>\n";
>         }
>         push(@htmlStack, $code);
>       }
>       while (@htmlStack < $depth) {
>         push(@htmlStack, $code);
>         $pageHtml .= "<$code $codeAttributes>\n";
>       }
>     }
>     if (!$ParseParas) {
>       s/^\s*$/<p>\n/;                      # Blank lines become <p> tags
>     }
>     $pageHtml .= &CommonMarkup($_, 1, 2);  # Line-oriented common markup
>   }
>   while (@htmlStack > 0) {       # Clear stack
>     $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
>   }
>   return $pageHtml;
> }
> 
> sub EvalLocalRules {
>   my ($rules, $origText, $isDiff) = @_;
>   my ($text, $reportError, $errorText);
> 
>   $text = $origText;
>   $reportError = 1;
>   # Basic idea: the $rules should change $text, possibly with different
>   # behavior if $isDiff is true (no images or color changes?)
>   # Note: for fun, the $rules could also change $reportError and $origText
>   if (!eval $rules) {
>     $errorText = $@;
>     if ($errorText eq '') {
>       # Search for "Unknown Error" for the reason the next line is commented
> #     $errorText = T('Unknown Error (no error text)');
>     }
>     if ($errorText ne '') {
>       $text = $origText;    # Consider: should partial results be kept?
>       if ($reportError) {
>         $text .= '<hr><b>' . T('Local rule error:') . '</b><br>'
>                  . &QuoteHtml($errorText);
>       }
>     }
>   }
>   return $text;
> }
>  
> sub UriEscape {
>   my ($uri) = @_;
>   $uri =~ s/([\x00-\x1f\x7f-\xff])/sprintf("%%%02X", ord($1))/ge;
>   $uri =~ s/\&/\&amp;/g;
>   return $uri;
> }
> 
> sub QuoteHtml {
>   my ($html) = @_;
> 
>   $html =~ s/&/&amp;/g;
>   $html =~ s/</&lt;/g;
>   $html =~ s/>/&gt;/g;
>   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
>   return $html;
> }
> 
> sub ParseParagraph {
>   my ($text) = @_;
> 
>   $text = &CommonMarkup($text, 1, 0);   # Multi-line markup
>   $text = &WikiLinesToHtml($text);      # Line-oriented markup
>   return "<p>$text</p>\n";
> }
> 
> sub StoreInterPage {
>   my ($id, $useImage) = @_;
>   my ($link, $extra);
> 
>   ($link, $extra) = &InterPageLink($id, $useImage);
>   # Next line ensures no empty links are stored
>   $link = &StoreRaw($link)  if ($link ne "");
>   return $link . $extra;
> }
> 
> sub InterPageLink {
>   my ($id, $useImage) = @_;
>   my ($name, $site, $remotePage, $url, $punct);
> 
>   ($id, $punct) = &SplitUrlPunct($id);
>   $name = $id;
>   ($site, $remotePage) = split(/:/, $id, 2);
>   $url = &GetSiteUrl($site);
>   return ("", $id . $punct)  if ($url eq "");
>   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
>   $url .= $remotePage;
>   return (&UrlLinkOrImage($url, $name, $useImage), $punct);
> }
> 
> sub StoreBracketInterPage {
>   my ($id, $text, $useImage) = @_;
>   my ($site, $remotePage, $url, $index);
> 
>   ($site, $remotePage) = split(/:/, $id, 2);
>   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
>   $url = &GetSiteUrl($site);
>   if ($text ne "") {
>     return "[$id $text]"  if ($url eq "");
>   } else {
>     return "[$id]"  if ($url eq "");
>     $text = &GetBracketUrlIndex($id);
>   }
>   $url .= $remotePage;
>   if ($BracketImg && $useImage && &ImageAllowed($text)) {
>     $text = "<img src=\"$text\">";
>   } else {
>     $text = "[$text]";
>   }
>   return &StoreRaw("<a href=\"$url\">$text</a>");
> }
> 
> sub GetBracketUrlIndex {
>   my ($id) = @_;
>   my ($index, $key);
> 
>   # Consider plain array?
>   if ($SaveNumUrl{$id} > 0) {
>     return $SaveNumUrl{$id};
>   }
>   $SaveNumUrlIndex++;  # Start with 1
>   $SaveNumUrl{$id} = $SaveNumUrlIndex;
>   return $SaveNumUrlIndex;
> }
> 
> sub GetSiteUrl {
>   my ($site) = @_;
>   my ($data, $status);
> 
>   if (!$InterSiteInit) {
>     ($status, $data) = &ReadFile($InterFile);
>     if ($status) {
>       %InterSite = split(/\s+/, $data);  # Consider defensive code
>     }
>     # Check for definitions to allow file to override automatic settings
>     if (!defined($InterSite{'LocalWiki'})) {
>       $InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
>     }
>     if (!defined($InterSite{'Local'})) {
>       $InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
>     }
>     $InterSiteInit = 1;  # Init only once per request
>   }
>   return $InterSite{$site}  if (defined($InterSite{$site}));
>   return '';
> }
> 
> sub StoreRaw {
>   my ($html) = @_;
> 
>   $SaveUrl{$SaveUrlIndex} = $html;
>   return $FS . $SaveUrlIndex++ . $FS;
> }
> 
> sub StorePre {
>   my ($html, $tag) = @_;
> 
>   return &StoreRaw("<$tag>" . $html . "</$tag>");
> }
> 
> sub StoreHref {
>   my ($anchor, $text) = @_;
> 
>   return "<a" . &StoreRaw($anchor) . ">$text</a>";
> }
> 
> sub StoreUrl {
>   my ($name, $useImage) = @_;
>   my ($link, $extra);
> 
>   ($link, $extra) = &UrlLink($name, $useImage);
>   # Next line ensures no empty links are stored
>   $link = &StoreRaw($link)  if ($link ne "");
>   return $link . $extra;
> }
> 
> sub UrlLink {
>   my ($rawname, $useImage) = @_;
>   my ($name, $punct);
> 
>   ($name, $punct) = &SplitUrlPunct($rawname);
>   if ($LimitFileUrl && ($NetworkFile && $name =~ m|^file:|)) {
>     # Only do remote file:// links. No file:///c|/windows.
>     if ($name =~ m|^file://[^/]|) {
>       return ("<a href=\"$name\">$name</a>", $punct);
>     }
>     return ($rawname, '');
>   }
>   return (&UrlLinkOrImage($name, $name, $useImage), $punct);
> }
> 
> sub UrlLinkOrImage {
>   my ($url, $name, $useImage) = @_;
> 
>   # Restricted image URLs so that mailto:foo@bar.gif is not an image
>   if ($useImage && &ImageAllowed($url)) {
>     return "<img src=\"$url\">";
>   }
>   return "<a href=\"$url\">$name</a>";
> }
> 
> sub ImageAllowed {
>   my ($url) = @_;
>   my ($site, $imagePrefixes);
> 
>   $imagePrefixes = 'http:|https:|ftp:';
>   $imagePrefixes .= '|file:'  if (!$LimitFileUrl);
>   return 0  unless ($url =~ /^($imagePrefixes).+\.$ImageExtensions$/i);
>   return 0  if ($url =~ /"/);      # No HTML-breaking quotes allowed
>   return 1  if (@ImageSites < 1);  # Most common case: () means all allowed
>   return 0  if ($ImageSites[0] eq 'none');  # Special case: none allowed
>   foreach $site (@ImageSites) {
>     return 1  if ($site eq substr($url, 0, length($site)));  # Match prefix
>   }
>   return 0;
> }
> 
> sub StoreBracketUrl {
>   my ($url, $text, $useImage) = @_;
> 
>   if ($text eq "") {
>     $text = &GetBracketUrlIndex($url);
>   } elsif ($text =~ /^$InterLinkPattern$/) {
>     my @interlink = split(/:/, $text, 2);
>     $text = &GetSiteUrl($interlink[0]) . $interlink[1];
>   }
>   if ($BracketImg && $useImage && &ImageAllowed($text)) {
>     $text = "<img src=\"$text\">";
>   } else {
>     $text = "[$text]";
>   }
>   return &StoreRaw("<a href=\"$url\">$text</a>");
> }
> 
> sub StoreBracketLink {
>   my ($name, $text) = @_;
> 
>   return &StoreRaw(&GetPageLinkText($name, "[$text]"));
> }
> 
> sub StoreBracketAnchoredLink {
>   my ($name, $anchor, $text) = @_;
> 
>   return &StoreRaw(&GetPageLinkText("$name#$anchor", "[$text]"));
> }
> 
> sub StorePageOrEditLink {
>   my ($page, $name) = @_;
> 
>   if ($FreeLinks) {
>     $page =~ s/^\s+//;      # Trim extra spaces
>     $page =~ s/\s+$//;
>     $page =~ s|\s*/\s*|/|;  # ...also before/after subpages
>   }
>   $name =~ s/^\s+//;
>   $name =~ s/\s+$//;
>   return &StoreRaw(&GetPageOrEditLink($page, $name));
> }
> 
> sub StoreRFC {
>   my ($num) = @_;
> 
>   return &StoreRaw(&RFCLink($num));
> }
> 
> sub RFCLink {
>   my ($num) = @_;
> 
>   return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\">RFC $num</a>";
> }
> 
> sub StoreUpload {
>   my ($url) = @_;
> 
>   return &StoreRaw(&UploadLink($url));
> }
> 
> sub UploadLink {
>   my ($filename) = @_;
>   my ($html, $url);
>  
>   return $filename  if ($UploadUrl eq '');  # No bad links if misconfigured
>   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
>   $url = $UploadUrl . $filename;
>   $html = '<a href="' . $url . '">';
>   if (&ImageAllowed($url)) {
>     $html .= '<img src="' . $url . '" alt="upload:' . $filename . '">';
>   } else {
>     $html .= 'upload:' . $filename;
>   }
>   $html .= '</a>';
>   return $html;
> }
> 
> sub StoreISBN {
>   my ($num) = @_;
> 
>   return &StoreRaw(&ISBNLink($num));
> }
> 
> sub ISBNALink {
>   my ($num, $pre, $post, $text) = @_;
> 
>   return '<a href="' . $pre . $num . $post . '">' . $text . '</a>';
> }
> 
> sub ISBNLink {
>   my ($rawnum) = @_;
>   my ($rawprint, $html, $num, $numSites, $i);
> 
>   $num = $rawnum;
>   $rawprint = $rawnum;
>   $rawprint =~ s/ +$//;
>   $num =~ s/[- ]//g;
>   $numSites = scalar @IsbnNames;  # Number of entries
>   if ((length($num) != 10) || ($numSites < 1)) {
>     return "ISBN $rawnum";
>   }
>   $html = &ISBNALink($num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint);
>   if ($numSites > 1) {
>     $html .= ' (';
>     $i = 1;
>     while ($i < $numSites) {
>       $html .= &ISBNALink($num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i]);
>       if ($i < ($numSites - 1)) {  # Not the last site
>         $html .= ', ';
>       }
>       $i++;
>     }
>     $html .= ')';
>   }
>   $html .= " "  if ($rawnum =~ / $/);  # Add space if old ISBN had space.
>   return $html;
> }
> 
> sub SplitUrlPunct {
>   my ($url) = @_;
>   my ($punct);
> 
>   if ($url =~ s/\"\"$//) {
>     return ($url, "");   # Delete double-quote delimiters here
>   }
>   $punct = "";
>   if ($NewFS) {
>     ($punct) = ($url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/);
>     $url =~ s/([^a-zA-Z0-9\/\x80-\xff]+)$//;
>   } else {
>     ($punct) = ($url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/);
>     $url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
>   }
>   return ($url, $punct);
> }
> 
> sub StripUrlPunct {
>   my ($url) = @_;
>   my ($junk);
> 
>   ($url, $junk) = &SplitUrlPunct($url);
>   return $url;
> }
> 
> sub WikiHeadingNumber {
>     my ($depth, $text) = @_;
>     my ($anchor, $number);
> 
>     return '' unless --$depth > 0;  # Don't number H1s because it looks stupid
>     while (scalar @HeadingNumbers < ($depth-1)) {
>         push @HeadingNumbers, 1;
>         $TableOfContents .= '<dl><dt> </dt><dd>';
>     }
>     if (scalar @HeadingNumbers < $depth) {
>         push @HeadingNumbers, 0;
>         $TableOfContents .= '<dl><dt> </dt><dd>';
>     }
>     while (scalar @HeadingNumbers > $depth) {
>         pop @HeadingNumbers;
>         $TableOfContents .= "</dd></dl>\n\n";
>     }
>     $HeadingNumbers[$#HeadingNumbers]++;
>     $number = (join '.', @HeadingNumbers) . '. ';
>     # Remove embedded links. THIS IS FRAGILE!
>     $text = &RestoreSavedText($text);
>     $text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si; # No such page syntax
>     $text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
>     # Cook anchor by canonicalizing $text.
>     $anchor = $text;
>     $anchor =~ s/\<.*?\>//g; 
>     $anchor =~ s/\W/_/g;   
>     $anchor =~ s/__+/_/g;
>     $anchor =~ s/^_//;
>     $anchor =~ s/_$//;
>     # Last ditch effort
>     $anchor = '_' . (join '_', @HeadingNumbers) unless $anchor;
>     $TableOfContents .= $number . &ScriptLink("$OpenPageName#$anchor",$text)
>                         . "</dd>\n<dt> </dt><dd>";
>     return &StoreHref(" name=\"$anchor\"") . $number;
> }
> 
> sub WikiHeading {
>   my ($pre, $depth, $text) = @_;
> 
>   $depth = length($depth);
>   $depth = 6  if ($depth > 6);
>   $text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e; # $' == $POSTMATCH
>   return $pre . "<H$depth>$text</H$depth>\n";
> }
> 
> # ==== Difference markup and HTML ====
> sub GetDiffHTML {
>   my ($diffType, $id, $revOld, $revNew, $newText) = @_;
>   my ($html, $diffText, $diffTextTwo, $priorName, $links, $usecomma);
>   my ($major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName);
> 
>   $links = "(";
>   $usecomma = 0;
>   $major  = &ScriptLinkDiff(1, $id, T('major diff'), "");
>   $minor  = &ScriptLinkDiff(2, $id, T('minor diff'), "");
>   $author = &ScriptLinkDiff(3, $id, T('author diff'), "");
>   $useMajor  = 1;
>   $useMinor  = 1;
>   $useAuthor = 1;
>   $diffType = &GetParam("defaultdiff", 1)  if ($diffType == 4);
>   if ($diffType == 1) {
>     $priorName = T('major');
>     $cacheName = 'major';
>     $useMajor  = 0;
>   } elsif ($diffType == 2) {
>     $priorName = T('minor');
>     $cacheName = 'minor';
>     $useMinor  = 0;
>   } elsif ($diffType == 3) {
>     $priorName = T('author');
>     $cacheName = 'author';
>     $useAuthor = 0;
>   }
>   if ($revOld ne "") {
>     # Note: OpenKeptRevisions must have been done by caller.
>     # Eventually optimize if same as cached revision
>     $diffText = &GetKeptDiff($newText, $revOld, 1);  # 1 = get lock
>     if ($diffText eq "") {
>       $diffText = T('(The revisions are identical or unavailable.)');
>     }
>   } else {
>     $diffText  = &GetCacheDiff($cacheName);
>   }
>   $useMajor  = 0  if ($useMajor  && ($diffText eq &GetCacheDiff("major")));
>   $useMinor  = 0  if ($useMinor  && ($diffText eq &GetCacheDiff("minor")));
>   $useAuthor = 0  if ($useAuthor && ($diffText eq &GetCacheDiff("author")));
>   $useMajor  = 0  if ((!defined(&GetPageCache('oldmajor'))) ||
>                       (&GetPageCache("oldmajor") < 1));
>   $useAuthor = 0  if ((!defined(&GetPageCache('oldauthor'))) ||
>                       (&GetPageCache("oldauthor") < 1));
>   if ($useMajor) {
>     $links .= $major;
>     $usecomma = 1;
>   }
>   if ($useMinor) {
>     $links .= ", "  if ($usecomma);
>     $links .= $minor;
>     $usecomma = 1;
>   }
>   if ($useAuthor) {
>     $links .= ", "  if ($usecomma);
>     $links .= $author;
>   }
>   if (!($useMajor || $useMinor || $useAuthor)) {
>     $links .= T('no other diffs');
>   }
>   $links .= ")";
>   if ((!defined($diffText)) || ($diffText eq "")) {
>     $diffText = T('No diff available.');
>   }
>   if ($revOld ne "") {
>     my $currentRevision = T('current revision');
>     $currentRevision = Ts('revision %s', $revNew) if $revNew;
>     $html = '<b>'
>       . Tss("Difference (from revision %1 to %2)", $revOld, $currentRevision)
>       . "</b>\n" . "$links<br>" . &DiffToHTML($diffText);
>   } else {
>     if (($diffType != 2) &&
>         ((!defined(&GetPageCache("old$cacheName"))) ||
>          (&GetPageCache("old$cacheName") < 1))) {
>       $html = '<b>'
>               . Ts('No diff available--this is the first %s revision.',
>                    $priorName) . "</b>\n$links";
>     } else {
>       $html = '<b>'
>               . Ts('Difference (from prior %s revision)', $priorName)
>               . "</b>\n$links<br>" . &DiffToHTML($diffText);
>     }
>   }
>   @HeadingNumbers = ();
>   $TableOfContents = '';
>   return $html;
> }
> 
> sub GetCacheDiff {
>   my ($type) = @_;
>   my ($diffText);
> 
>   $diffText = &GetPageCache("diff_default_$type");
>   $diffText = &GetCacheDiff('minor')  if ($diffText eq "1");
>   $diffText = &GetCacheDiff('major')  if ($diffText eq "2");
>   return $diffText;
> }
> 
> # Must be done after minor diff is set and OpenKeptRevisions called
> sub GetKeptDiff {
>   my ($newText, $oldRevision, $lock) = @_;
>   my (%sect, %data, $oldText);
> 
>   $oldText = "";
>   if (defined($KeptRevisions{$oldRevision})) {
>     %sect = split(/$FS2/, $KeptRevisions{$oldRevision}, -1);
>     %data = split(/$FS3/, $sect{'data'}, -1);
>     $oldText = $data{'text'};
>   }
>   return ""  if ($oldText eq "");  # Old revision not found
>   return &GetDiff($oldText, $newText, $lock);
> }
> 
> sub GetDiff {
>   my ($old, $new, $lock) = @_;
>   my ($diff_out, $oldName, $newName);
> 
>   &CreateDir($TempDir);
>   $oldName = "$TempDir/old_diff";
>   $newName = "$TempDir/new_diff";
>   if ($lock) {
>     &RequestDiffLock() or return "";
>     $oldName .= "_locked";
>     $newName .= "_locked";
>   }
>   &WriteStringToFile($oldName, $old);
>   &WriteStringToFile($newName, $new);
>   $diff_out = `diff $oldName $newName`;
>   &ReleaseDiffLock()  if ($lock);
>   $diff_out =~ s/\\ No newline.*\n//g;   # Get rid of common complaint.
>   # No need to unlink temp files--next diff will just overwrite.
>   return $diff_out;
> }
> 
> sub DiffToHTML {
>   my ($html) = @_;
>   my ($tChanged, $tRemoved, $tAdded);
> 
>   $tChanged = T('Changed:');
>   $tRemoved = T('Removed:');
>   $tAdded   = T('Added:');
>   $html =~ s/\n--+//g;
>   # Note: Need spaces before <br> to be different from diff section.
>   $html =~ s/(^|\n)(\d+.*c.*)/$1 <br><strong>$tChanged $2<\/strong><br>/g;
>   $html =~ s/(^|\n)(\d+.*d.*)/$1 <br><strong>$tRemoved $2<\/strong><br>/g;
>   $html =~ s/(^|\n)(\d+.*a.*)/$1 <br><strong>$tAdded $2<\/strong><br>/g;
>   $html =~ s/\n((<.*\n)+)/&ColorDiff($1, $DiffColor1, 0)/ge;
>   $html =~ s/\n((>.*\n)+)/&ColorDiff($1, $DiffColor2, 1)/ge;
>   return $html;
> }
> 
> sub ColorDiff {
>   my ($diff, $color, $type) = @_;
>   my ($colorHtml, $classHtml);
> 
>   $diff =~ s/(^|\n)[<>]/$1/g;
>   $diff = &QuoteHtml($diff);
>   # Do some of the Wiki markup rules:
>   %SaveUrl = ();
>   %SaveNumUrl = ();
>   $SaveUrlIndex = 0;
>   $SaveNumUrlIndex = 0;
>   $diff = &RemoveFS($diff);
>   $diff = &CommonMarkup($diff, 0, 1);      # No images, all patterns
>   if ($LateRules ne '') {
>     $diff = &EvalLocalRules($LateRules, $diff, 1);
>   }
>   1 while $diff =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
>   $diff =~ s/\r?\n/<br>/g;
>   $colorHtml = '';
>   if ($color ne '') {
>     $colorHtml = " bgcolor=$color";
>   }
>   if ($type) {
>     $classHtml = ' class=wikidiffnew';
>   } else {
>     $classHtml = ' class=wikidiffold';
>   }
>   return "<table width=\"95\%\"$colorHtml$classHtml><tr><td>\n" . $diff
>          . "</td></tr></table>\n";
> }
> 
> # ==== Database (Page, Section, Text, Kept, User) functions ====
> sub OpenNewPage {
>   my ($id) = @_;
> 
>   %Page = ();
>   $Page{'version'} = 3;      # Data format version
>   $Page{'revision'} = 0;     # Number of edited times
>   $Page{'tscreate'} = $Now;  # Set once at creation
>   $Page{'ts'} = $Now;        # Updated every edit
> }
> 
> sub OpenNewSection {
>   my ($name, $data) = @_;
> 
>   %Section = ();
>   $Section{'name'} = $name;
>   $Section{'version'} = 1;      # Data format version
>   $Section{'revision'} = 0;     # Number of edited times
>   $Section{'tscreate'} = $Now;  # Set once at creation
>   $Section{'ts'} = $Now;        # Updated every edit
>   $Section{'ip'} = $ENV{REMOTE_ADDR};
>   $Section{'host'} = '';        # Updated only for real edits (can be slow)
>   $Section{'id'} = $UserID;
>   $Section{'username'} = &GetParam("username", "");
>   $Section{'data'} = $data;
>   $Page{$name} = join($FS2, %Section);  # Replace with save?
> }
> 
> sub OpenNewText {
>   my ($name) = @_;  # Name of text (usually "default")
>   %Text = ();
>   if ($NewText ne '') {
>     $Text{'text'} = T($NewText);
>   } else {
>     $Text{'text'} = T('Describe the new page here.') . "\n";
>   }
>   $Text{'text'} .= "\n"  if (substr($Text{'text'}, -1, 1) ne "\n");
>   $Text{'minor'} = 0;      # Default as major edit
>   $Text{'newauthor'} = 1;  # Default as new author
>   $Text{'summary'} = '';
>   &OpenNewSection("text_$name", join($FS3, %Text));
> }
> 
> sub GetPageFile {
>   my ($id) = @_;
> 
>   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
> }
> 
> sub OpenPage {
>   my ($id) = @_;
>   my ($fname, $data);
> 
>   if ($OpenPageName eq $id) {
>     return;
>   }
>   %Section = ();
>   %Text = ();
>   $fname = &GetPageFile($id);
>   if (-f $fname) {
>     $data = &ReadFileOrDie($fname);
>     %Page = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>   } else {
>     &OpenNewPage($id);
>   }
>   if ($Page{'version'} != 3) {
>     &UpdatePageVersion();
>   }
>   $OpenPageName = $id;
> }
> 
> sub OpenSection {
>   my ($name) = @_;
> 
>   if (!defined($Page{$name})) {
>     &OpenNewSection($name, "");
>   } else {
>     %Section = split(/$FS2/, $Page{$name}, -1);
>   }
> }
> 
> sub OpenText {
>   my ($name) = @_;
> 
>   if (!defined($Page{"text_$name"})) {
>     &OpenNewText($name);
>   } else {
>     &OpenSection("text_$name");
>     %Text = split(/$FS3/, $Section{'data'}, -1);
>   }
> }
> 
> sub OpenDefaultText {
>   &OpenText('default');
> }
> 
> # Called after OpenKeptRevisions
> sub OpenKeptRevision {
>   my ($revision) = @_;
> 
>   %Section = split(/$FS2/, $KeptRevisions{$revision}, -1);
>   %Text = split(/$FS3/, $Section{'data'}, -1);
> }
> 
> sub GetPageCache {
>   my ($name) = @_;
> 
>   return $Page{"cache_$name"};
> }
> 
> # Always call SavePage within a lock.
> sub SavePage {
>   my $file = &GetPageFile($OpenPageName);
> 
>   $Page{'revision'} += 1;    # Number of edited times
>   $Page{'ts'} = $Now;        # Updated every edit
>   &CreatePageDir($PageDir, $OpenPageName);
>   &WriteStringToFile($file, join($FS1, %Page));
> }
> 
> sub SaveSection {
>   my ($name, $data) = @_;
> 
>   $Section{'revision'} += 1;   # Number of edited times
>   $Section{'ts'} = $Now;       # Updated every edit
>   $Section{'ip'} = $ENV{REMOTE_ADDR};
>   $Section{'id'} = $UserID;
>   $Section{'username'} = &GetParam("username", "");
>   $Section{'data'} = $data;
>   $Page{$name} = join($FS2, %Section);
> }
> 
> sub SaveText {
>   my ($name) = @_;
> 
>   &SaveSection("text_$name", join($FS3, %Text));
> }
> 
> sub SaveDefaultText {
>   &SaveText('default');
> }
> 
> sub SetPageCache {
>   my ($name, $data) = @_;
> 
>   $Page{"cache_$name"} = $data;
> }
> 
> sub UpdatePageVersion {
>   &ReportError(T('Bad page version (or corrupt page).'));
> }
> 
> sub KeepFileName {
>   return $KeepDir . "/" . &GetPageDirectory($OpenPageName)
>          . "/$OpenPageName.kp";
> }
> 
> sub SaveKeepSection {
>   my $file = &KeepFileName();
>   my $data;
> 
>   return  if ($Section{'revision'} < 1);  # Don't keep "empty" revision
>   $Section{'keepts'} = $Now;
>   $data = $FS1 . join($FS2, %Section);
>   &CreatePageDir($KeepDir, $OpenPageName);
>   &AppendStringToFileLimited($file, $data, $KeepSize);
> }
> 
> sub ExpireKeepFile {
>   my ($fname, $data, @kplist, %tempSection, $expirets);
>   my ($anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev);
>   my ($oldMajor, $oldAuthor);
> 
>   $fname = &KeepFileName();
>   return  if (!(-f $fname));
>   $data = &ReadFileOrDie($fname);
>   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>   return  if (length(@kplist) < 1);  # Also empty
>   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
>   return  if (length(@kplist) < 1);  # Also empty
>   %tempSection = split(/$FS2/, $kplist[0], -1);
>   if (!defined($tempSection{'keepts'})) {
>     return;  # Bad keep file
>   }
>   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
>   return  if ($tempSection{'keepts'} >= $expirets);  # Nothing old enough
>   $anyExpire = 0;
>   $anyKeep   = 0;
>   %keepFlag  = ();
>   $oldMajor  = &GetPageCache('oldmajor');
>   $oldAuthor = &GetPageCache('oldauthor');
>   foreach (reverse @kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     $sectRev = $tempSection{'revision'};
>     $expire = 0;
>     if ($sectName eq "text_default") {
>       if (($KeepMajor  && ($sectRev == $oldMajor)) ||
>           ($KeepAuthor && ($sectRev == $oldAuthor))) {
>         $expire = 0;
>       } elsif ($tempSection{'keepts'} < $expirets) {
>         $expire = 1;
>       }
>     } else {
>       if ($tempSection{'keepts'} < $expirets) {
>         $expire = 1;
>       }
>     }
>     if (!$expire) {
>       $keepFlag{$sectRev . "," . $sectName} = 1;
>       $anyKeep = 1;
>     } else {
>       $anyExpire = 1;
>     }
>   }
>   if (!$anyKeep) {  # Empty, so remove file
>     unlink($fname);
>     return;
>   }
>   return  if (!$anyExpire);  # No sections expired
>   open (OUT, ">$fname") or die (Ts('cant write %s', $fname) . ": $!");
>   foreach (@kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     $sectRev = $tempSection{'revision'};
>     if ($keepFlag{$sectRev . "," . $sectName}) {
>       print OUT $FS1, $_;
>     }
>   }
>   close(OUT);
> }
> 
> sub OpenKeptList {
>   my ($fname, $data);
> 
>   @KeptList = ();
>   $fname = &KeepFileName();
>   return  if (!(-f $fname));
>   $data = &ReadFileOrDie($fname);
>   @KeptList = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
> }
> 
> sub OpenKeptRevisions {
>   my ($name) = @_;  # Name of section
>   my ($fname, $data, %tempSection);
> 
>   %KeptRevisions = ();
>   &OpenKeptList();
>   foreach (@KeptList) {
>     %tempSection = split(/$FS2/, $_, -1);
>     next  if ($tempSection{'name'} ne $name);
>     $KeptRevisions{$tempSection{'revision'}} = $_;
>   }
> }
> 
> sub LoadUserData {
>   my ($data, $status);
> 
>   %UserData = ();
>   ($status, $data) = &ReadFile(&UserDataFilename($UserID));
>   if (!$status) {
>     $UserID = 112;  # Could not open file.  Consider warning message?
>     return;
>   }
>   %UserData = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
> }
> 
> sub UserDataFilename {
>   my ($id) = @_;
> 
>   return ""  if ($id < 1);
>   return $UserDir . "/" . ($id % 10) . "/$id.db";
> }
> 
> # ==== Misc. functions ====
> sub ReportError {
>   my ($errmsg) = @_;
> 
>   print $q->header, $q->start_html, "<H2>", &QuoteHtml($errmsg), "</H2>", $q->end_html;
> }
> 
> sub ValidId {
>   my ($id) = @_;
> 
>   if (length($id) > 120) {
>     return Ts('Page name is too long: %s', $id);
>   }
>   if ($id =~ m| |) {
>     return Ts('Page name may not contain space characters: %s', $id);
>   }
>   if ($UseSubpage) {
>     if ($id =~ m|.*/.*/|) {
>       return Ts('Too many / characters in page %s', $id);
>     }
>     if ($id =~ /^\//) {
>       return Ts('Invalid Page %s (subpage without main page)', $id);
>     }
>     if ($id =~ /\/$/) {
>       return Ts('Invalid Page %s (missing subpage name)', $id);
>     }
>   }
>   if ($FreeLinks) {
>     $id =~ s/ /_/g;
>     if (!$UseSubpage) {
>       if ($id =~ /\//) {
>         return Ts('Invalid Page %s (/ not allowed)', $id);
>       }
>     }
>     if (!($id =~ m|^$FreeLinkPattern$|)) {
>       return Ts('Invalid Page %s', $id);
>     }
>     if ($id =~ m|\.db$|) {
>       return Ts('Invalid Page %s (must not end with .db)', $id);
>     }
>     if ($id =~ m|\.lck$|) {
>       return Ts('Invalid Page %s (must not end with .lck)', $id);
>     }
>     return "";
>   } else {
>     if (!($id =~ /^$LinkPattern$/)) {
>       return Ts('Invalid Page %s', $id);
>     }
>   }
>   return "";
> }
> 
> sub ValidIdOrDie {
>   my ($id) = @_;
>   my $error;
> 
>   $error = &ValidId($id);
>   if ($error ne "") {
>     &ReportError($error);
>     return 0;
>   }
>   return 1;
> }
> 
> sub UserCanEdit {
>   my ($id, $deepCheck) = @_;
> 
>   # Optimized for the "everyone can edit" case (don't check passwords)
>   if (($id ne "") && (-f &GetLockedPageFile($id))) {
>     return 1  if (&UserIsAdmin());  # Requires more privledges
>     # Consider option for editor-level to edit these pages?
>     return 0;
>   }
>   if (!$EditAllowed) {
>     return 1  if (&UserIsEditor());
>     return 0;
>   }
>   if (-f "$DataDir/noedit") {
>     return 1  if (&UserIsEditor());
>     return 0;
>   }
>   if ($deepCheck) {   # Deeper but slower checks (not every page)
>     return 1  if (&UserIsEditor());
>     return 0  if (&UserIsBanned());
>   }
>   return 1;
> }
> 
> sub UserIsBanned {
>   my ($host, $ip, $data, $status);
> 
>   ($status, $data) = &ReadFile("$DataDir/banlist");
>   return 0  if (!$status);  # No file exists, so no ban
>   $data =~ s/\r//g;
>   $ip = $ENV{'REMOTE_ADDR'};
>   $host = &GetRemoteHost(0);
>   foreach (split(/\n/, $data)) {
>     next  if ((/^\s*$/) || (/^#/));  # Skip empty, spaces, or comments
>     return 1  if ($ip   =~ /$_/i);
>     return 1  if ($host =~ /$_/i);
>   }
>   return 0;
> }
> 
> sub UserIsAdmin {
>   my (@pwlist, $userPassword);
> 
>   return 0  if ($AdminPass eq "");
>   $userPassword = &GetParam("adminpw", "");
>   return 0  if ($userPassword eq "");
>   foreach (split(/\s+/, $AdminPass)) {
>     next  if ($_ eq "");
>     return 1  if ($userPassword eq $_);
>   }
>   return 0;
> }
> 
> sub UserIsEditor {
>   my (@pwlist, $userPassword);
> 
>   return 1  if (&UserIsAdmin());             # Admin includes editor
>   return 0  if ($EditPass eq "");
>   $userPassword = &GetParam("adminpw", "");  # Used for both
>   return 0  if ($userPassword eq "");
>   foreach (split(/\s+/, $EditPass)) {
>     next  if ($_ eq "");
>     return 1  if ($userPassword eq $_);
>   }
>   return 0;
> }
> 
> sub UserCanUpload {
>   return 1  if (&UserIsEditor());
>   return $AllUpload;
> }
> 
> sub GetLockedPageFile {
>   my ($id) = @_;
> 
>   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
> }
> 
> sub RequestLockDir {
>   my ($name, $tries, $wait, $errorDie) = @_;
>   my ($lockName, $n);
> 
>   &CreateDir($TempDir);
>   $lockName = $LockDir . $name;
>   $n = 0;
>   while (mkdir($lockName, 0555) == 0) {
>     if ($! != 17) {
>       die(Ts('can not make %s', $LockDir) . ": $!\n")  if $errorDie;
>       return 0;
>     }
>     return 0  if ($n++ >= $tries); 
>     sleep($wait);
>   }
>   return 1;
> }
> 
> sub ReleaseLockDir {
>   my ($name) = @_;
> 
>   rmdir($LockDir . $name);
> }
> 
> sub RequestLock {
>   # 10 tries, 3 second wait, possibly die on error
>   return &RequestLockDir("main", 10, 3, $LockCrash);
> }
> 
> sub ReleaseLock {
>   &ReleaseLockDir('main');
> }
> 
> sub ForceReleaseLock {
>   my ($name) = @_;
>   my $forced;
> 
>   # First try to obtain lock (in case of normal edit lock)
>   # 5 tries, 3 second wait, do not die on error
>   $forced = !&RequestLockDir($name, 5, 3, 0);
>   &ReleaseLockDir($name);  # Release the lock, even if we didn't get it.
>   return $forced;
> }
> 
> sub RequestCacheLock {
>   # 4 tries, 2 second wait, do not die on error
>   return &RequestLockDir('cache', 4, 2, 0);
> }
> 
> sub ReleaseCacheLock {
>   &ReleaseLockDir('cache');
> }
> 
> sub RequestDiffLock {
>   # 4 tries, 2 second wait, do not die on error
>   return &RequestLockDir('diff', 4, 2, 0);
> }
> 
> sub ReleaseDiffLock {
>   &ReleaseLockDir('diff');
> }
> 
> # Index lock is not very important--just return error if not available
> sub RequestIndexLock {
>   # 1 try, 2 second wait, do not die on error
>   return &RequestLockDir('index', 1, 2, 0);
> }
> 
> sub ReleaseIndexLock {
>   &ReleaseLockDir('index');
> }
> 
> sub ReadFile {
>   my ($fileName) = @_;
>   my ($data);
>   local $/ = undef;   # Read complete files
> 
>   if (open(IN, "<$fileName")) {
>     $data=<IN>;
>     close IN;
>     return (1, $data);
>   }
>   return (0, "");
> }
> 
> sub ReadFileOrDie {
>   my ($fileName) = @_;
>   my ($status, $data);
> 
>   ($status, $data) = &ReadFile($fileName);
>   if (!$status) {
>     die(Ts('Can not open %s', $fileName) . ": $!");
>   }
>   return $data;
> }
> 
> sub WriteStringToFile {
>   my ($file, $string) = @_;
> 
>   open (OUT, ">$file") or die(Ts('cant write %s', $file) . ": $!");
>   print OUT  $string;
>   close(OUT);
> }
> 
> sub AppendStringToFile {
>   my ($file, $string) = @_;
> 
>   open (OUT, ">>$file") or die(Ts('cant write %s', $file) . ": $!");
>   print OUT  $string;
>   close(OUT);
> }
> 
> sub AppendStringToFileLimited {
>   my ($file, $string, $limit) = @_;
> 
>   if (($limit < 1) || (((-s $file) + length($string)) <= $limit)) {
>     &AppendStringToFile($file, $string);
>   }
> }
> 
> sub CreateDir {
>   my ($newdir) = @_;
> 
>   mkdir($newdir, 0775)  if (!(-d $newdir));
> }
> 
> sub CreatePageDir {
>   my ($dir, $id) = @_;
>   my $subdir;
> 
>   &CreateDir($dir);  # Make sure main page exists
>   $subdir = $dir . "/" . &GetPageDirectory($id);
>   &CreateDir($subdir);
>   if ($id =~ m|([^/]+)/|) {
>     $subdir = $subdir . "/" . $1;
>     &CreateDir($subdir);
>   }
> }
> 
> sub UpdateHtmlCache {
>   my ($id, $html) = @_;
>   my $idFile;
> 
>   $idFile = &GetHtmlCacheFile($id);
>   &CreatePageDir($HtmlDir, $id);
>   if (&RequestCacheLock()) {
>     &WriteStringToFile($idFile, $html);
>     &ReleaseCacheLock();
>   }
> }
> 
> sub GenerateAllPagesList {
>   my (@pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId);
> 
>   @pages = ();
>   if ($FastGlob) {
>     # The following was inspired by the FastGlob code by Marc W. Mengel.
>     # Thanks to Bob Showalter for pointing out the improvement.
>     opendir(PAGELIST, $PageDir);
>     @dirs = readdir(PAGELIST);
>     closedir(PAGELIST);
>     @dirs = sort(@dirs);
>     foreach $dir (@dirs) {
>       next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs or files
>       opendir(PAGELIST, "$PageDir/$dir");
>       @pageFiles = readdir(PAGELIST);
>       closedir(PAGELIST);
>       foreach $id (@pageFiles) {
>         next  if (($id eq '.') || ($id eq '..'));
>         if (substr($id, -3) eq '.db') {
>           push(@pages, substr($id, 0, -3));
>         } elsif (substr($id, -4) ne '.lck') {
>           opendir(PAGELIST, "$PageDir/$dir/$id");
>           @subpageFiles = readdir(PAGELIST);
>           closedir(PAGELIST);
>           foreach $subId (@subpageFiles) {
>             if (substr($subId, -3) eq '.db') {
>               push(@pages, "$id/" . substr($subId, 0, -3));
>             }
>           }
>         }
>       }
>     }
>   } else {
>     # Old slow/compatible method.
>     @dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
>     foreach $dir (@dirs) {
>       if (-e "$PageDir/$dir") {  # Thanks to Tim Holt
>         while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
>           s|^$PageDir/||;
>           m|^[^/]+/(\S*).db|;
>           $id = $1;
>           push(@pages, $id);
>         }
>       }
>     }
>   }
>   return sort(@pages);
> }
> 
> sub AllPagesList {
>   my ($rawIndex, $refresh, $status);
> 
>   if (!$UseIndex) {
>     return &GenerateAllPagesList();
>   }
>   $refresh = &GetParam("refresh", 0);
>   if ($IndexInit && !$refresh) {
>     # Note for mod_perl: $IndexInit is reset for each query
>     # Eventually consider some timestamp-solution to keep cache?
>     return @IndexList;
>   }
>   if ((!$refresh) && (-f $IndexFile)) {
>     ($status, $rawIndex) = &ReadFile($IndexFile);
>     if ($status) {
>       %IndexHash = split(/\s+/, $rawIndex);
>       @IndexList = sort(keys %IndexHash);
>       $IndexInit = 1;
>       return @IndexList;
>     }
>     # If open fails just refresh the index
>   }
>   @IndexList = ();
>   %IndexHash = ();
>   @IndexList = &GenerateAllPagesList();
>   foreach (@IndexList) {
>     $IndexHash{$_} = 1;
>   }
>   $IndexInit = 1;  # Initialized for this run of the script
>   # Try to write out the list for future runs
>   &RequestIndexLock() or return @IndexList;
>   &WriteStringToFile($IndexFile, join(" ", %IndexHash));
>   &ReleaseIndexLock();
>   return @IndexList;
> }
> 
> sub CalcDay {
>   my ($ts) = @_;
> 
>   $ts += $TimeZoneOffset;
>   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
>   if ($NumberDates) {
>     return ($year + 1900) . '-' . ($mon+1) . '-' . $mday;
>   }
>   return ("January", "February", "March", "April", "May", "June",
>           "July", "August", "September", "October", "November",
>           "December")[$mon]. " " . $mday . ", " . ($year+1900);
> }
> 
> sub CalcTime {
>   my ($ts) = @_;
>   my ($ampm, $mytz);
> 
>   $ts += $TimeZoneOffset;
>   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
>   $mytz = "";
>   if (($TimeZoneOffset == 0) && ($ScriptTZ ne "")) {
>     $mytz = " " . $ScriptTZ;
>   }
>   $ampm = "";
>   if ($UseAmPm) {
>     $ampm = " am";
>     if ($hour > 11) {
>       $ampm = " pm";
>       $hour = $hour - 12;
>     }
>     $hour = 12   if ($hour == 0);
>   }
>   $min = "0" . $min   if ($min<10);
>   return $hour . ":" . $min . $ampm . $mytz;
> }
> 
> sub TimeToText {
>   my ($t) = @_;
> 
>   return &CalcDay($t) . " " . &CalcTime($t);
> }
> 
> sub GetParam {
>   my ($name, $default) = @_;
>   my $result;
> 
>   $result = $q->param($name);
>   if (!defined($result)) {
>     if (defined($UserData{$name})) {
>       $result = $UserData{$name};
>     } else {
>       $result = $default;
>     }
>   }
>   return $result;
> }
> 
> sub GetHiddenValue {
>   my ($name, $value) = @_;
> 
>   $q->param($name, $value);
>   return $q->hidden($name);
> }
> 
> sub GetRemoteHost {
>   my ($doMask) = @_;
>   my ($rhost, $iaddr);
> 
>   $rhost = $ENV{REMOTE_HOST};
>   if ($UseLookup && ($rhost eq "")) {
>     # Catch errors (including bad input) without aborting the script
>     eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
>          . '$rhost = gethostbyaddr($iaddr, AF_INET)';
>   }
>   if ($rhost eq "") {
>     $rhost = $ENV{REMOTE_ADDR};
>   }
>   $rhost = &GetMaskedHost($rhost)  if ($doMask);
>   return $rhost;
> }
> 
> sub FreeToNormal {
>   my ($id) = @_;
> 
>   $id =~ s/ /_/g;
>   $id = ucfirst($id)  if ($UpperFirst || $FreeUpper);
>   if (index($id, '_') > -1) {  # Quick check for any space/underscores
>     $id =~ s/__+/_/g;
>     $id =~ s/^_//;
>     $id =~ s/_$//;
>     if ($UseSubpage) {
>       $id =~ s|_/|/|g;
>       $id =~ s|/_|/|g;
>     }
>   }
>   if ($FreeUpper) {
>     # Note that letters after ' are *not* capitalized
>     if ($id =~ m|[-_.,\(\)/][a-z]|) {    # Quick check for non-canonical case
>       $id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
>     }
>   }
>   return $id;
> }
> #END_OF_BROWSE_CODE
> 
> # == Page-editing and other special-action code ========================
> $OtherCode = ""; # Comment next line to always compile (slower)
> #$OtherCode = <<'#END_OF_OTHER_CODE';
> 
> sub DoOtherRequest {
>   my ($id, $action, $text, $search);
> 
>   $action = &GetParam("action", "");
>   $id = &GetParam("id", "");
>   if ($action ne "") {
>     $action = lc($action);
>     if      ($action eq "edit") {
>       &DoEdit($id, 0, 0, "", 0)  if &ValidIdOrDie($id);
>     } elsif ($action eq "unlock") {
>       &DoUnlock();
>     } elsif ($action eq "index") {
>       &DoIndex();
>     } elsif ($action eq "links") {
>       &DoLinks();
>     } elsif ($action eq "maintain") {
>       &DoMaintain();
>     } elsif ($action eq "pagelock") {
>       &DoPageLock();
>     } elsif ($action eq "editlock") {
>       &DoEditLock();
>     } elsif ($action eq "editprefs") {
>       &DoEditPrefs();
>     } elsif ($action eq "editbanned") {
>       &DoEditBanned();
>     } elsif ($action eq "editlinks") {
>       &DoEditLinks();
>     } elsif ($action eq "login") {
>       &DoEnterLogin();
>     } elsif ($action eq "newlogin") {
>       $UserID = 0;
>       &DoEditPrefs();  # Also creates new ID
>     } elsif ($action eq "version") {
>       &DoShowVersion();
>     } elsif ($action eq "rss") {
>       &DoRss();
>     } elsif ($action eq "delete") {
>       &DoDeletePage($id);
>     } elsif ($UseUpload && ($action eq "upload")) {
>       &DoUpload();
>     } elsif ($action eq "maintainrc") {
>       &DoMaintainRc();
>     } elsif ($action eq "convert") {
>       &DoConvert();
>     } elsif ($action eq "trimusers") {
>       &DoTrimUsers();
>     } else {
>       &ReportError(Ts('Invalid action parameter %s', $action));
>     }
>     return;
>   }
>   if (&GetParam("edit_prefs", 0)) {
>     &DoUpdatePrefs();
>     return;
>   }
>   if (&GetParam("edit_ban", 0)) {
>     &DoUpdateBanned();
>     return;
>   }
>   if (&GetParam("enter_login", 0)) {
>     &DoLogin();
>     return;
>   }
>   if (&GetParam("edit_links", 0)) {
>     &DoUpdateLinks();
>     return;
>   }
>   if ($UseUpload && (&GetParam("upload", 0))) {
>     &SaveUpload();
>     return;
>   }
>   $search = &GetParam("search", "");
>   if (($search ne "") || (&GetParam("dosearch", "") ne "")) {
>     &DoSearch($search);
>     return;
>   } else {
>     $search = &GetParam("back","");
>     if ($search ne "") {
>       &DoBackLinks($search);
>       return;
>     }
>   }
>   # Handle posted pages
>   if (&GetParam("oldtime", "") ne "") {
>     $id = &GetParam("title", "");
>     &DoPost()  if &ValidIdOrDie($id);
>     return;
>   }
>   &ReportError(T('Invalid URL.'));
> }
> 
> sub DoEdit {
>   my ($id, $isConflict, $oldTime, $newText, $preview) = @_;
>   my ($header, $editRows, $editCols, $userName, $revision, $oldText);
>   my ($summary, $isEdit, $pageTime);
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);  # Take care of users like Markus Lude :-)
>   }
>   if (!&UserCanEdit($id, 1)) {
>     print &GetHeader('', T('Editing Denied'), '');
>     if (&UserIsBanned()) {
>       print T('Editing not allowed: user, ip, or network is blocked.');
>       print "<p>";
>       print T('Contact the wiki administrator for more information.');
>     } else {
>       print Ts('Editing not allowed: %s is read-only.', $SiteName);
>     }
>     print &GetCommonFooter();
>     return;
>   }
>   # Consider sending a new user-ID cookie if user does not have one
>   &OpenPage($id);
>   &OpenDefaultText();
>   $pageTime = $Section{'ts'};
>   $header = Ts('Editing %s', $id);
>   # Old revision handling
>   $revision = &GetParam('revision', '');
>   $revision =~ s/\D//g;  # Remove non-numeric chars
>   if ($revision ne '') {
>     &OpenKeptRevisions('text_default');
>     if (!defined($KeptRevisions{$revision})) {
>       $revision = '';
>       # Consider better solution like error message?
>     } else {
>       &OpenKeptRevision($revision);
>       $header = Ts('Editing revision %s of ', $revision ) . $id;
>     }
>   }
>   $oldText = $Text{'text'};
>   if ($preview && !$isConflict) {
>     $oldText = $newText;
>   }
>   $editRows = &GetParam("editrows", 20);
>   $editCols = &GetParam("editcols", 65);
>   print &GetHeader('', &QuoteHtml($header), '');
>   if ($revision ne '') {
>     print "\n<b>"
>           . Ts('Editing old revision %s.', $revision) . "  "
>     . T('Saving this page will replace the latest revision with this text.')
>           . '</b><br>'
>   }
>   if ($isConflict) {
>     $editRows -= 10  if ($editRows > 19);
>     print "\n<H1>" . T('Edit Conflict!') . "</H1>\n";
>     if ($isConflict>1) {
>       # The main purpose of a new warning is to display more text
>       # and move the save button down from its old location.
>       print "\n<H2>" . T('(This is a new conflict)') . "</H2>\n";
>     }
>     print "<p><strong>",
>           T('Someone saved this page after you started editing.'), " ",
>           T('The top textbox contains the saved text.'), " ",
>           T('Only the text in the top textbox will be saved.'),
>           "</strong><br>\n",
>           T('Scroll down to see your edited text.'), "<br>\n";
>     print T('Last save time:'), ' ', &TimeToText($oldTime),
>           " (", T('Current time is:'), ' ', &TimeToText($Now), ")<br>\n";
>   }
>   print &GetFormStart();
>   print &GetHiddenValue("title", $id), "\n",
>         &GetHiddenValue("oldtime", $pageTime), "\n",
>         &GetHiddenValue("oldconflict", $isConflict), "\n";
>   if ($revision ne "") {
>     print &GetHiddenValue("revision", $revision), "\n";
>   }
>   print &GetTextArea('text', $oldText, $editRows, $editCols);
>   $summary = &GetParam("summary", "*");
>   print "<p>", T('Summary:'),
>         $q->textfield(-name=>'summary',
>                       -default=>$summary, -override=>1,
>                       -size=>60, -maxlength=>200);
>   if (&GetParam("recent_edit") eq "on") {
>     print "<br>", $q->checkbox(-name=>'recent_edit', -checked=>1,
>                                -label=>T('This change is a minor edit.'));
>   } else {
>     print "<br>", $q->checkbox(-name=>'recent_edit',
>                                -label=>T('This change is a minor edit.'));
>   }
>   if ($EmailNotify) {
>     print "&nbsp;&nbsp;&nbsp;" .
>            $q->checkbox(-name=> 'do_email_notify',
>       -label=>Ts('Send email notification that %s has been changed.', $id));
>   }
>   print "<br>";
>   if ($EditNote ne '') {
>     print T($EditNote) . '<br>';  # Allow translation
>   }
>   print $q->submit(-name=>'Save', -value=>T('Save')), "\n";
>   $userName = &GetParam("username", "");
>   if ($userName ne "") {
>     print ' (', T('Your user name is'), ' ',
>           &GetPageLink($userName) . ') ';
>   } else {
>     print ' (', Ts('Visit %s to set your user name.', &GetPrefsLink(), 1), ') ';
>   }
>   print $q->submit(-name=>'Preview', -value=>T('Preview')), "\n";
>   if ($isConflict) {
>     print "\n<br><hr><p><strong>", T('This is the text you submitted:'),
>           "</strong><p>",
>           &GetTextArea('newtext', $newText, $editRows, $editCols),
>           "<p>\n";
>   }
>   if ($preview) {
>     print '<div class=wikipreview>';
>     print "<hr class=wikilinepreview>\n";
>     print "<h2>", T('Preview:'), "</h2>\n";
>     if ($isConflict) {
>       print "<b>",
>             T('NOTE: This preview shows the revision of the other author.'),
>             "</b><hr>\n";
>     }
>     $MainPage = $id;
>     $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
>     print &WikiToHTML($oldText) . "<hr class=wikilinepreview>\n";
>     print "<h2>", T('Preview only, not yet saved'), "</h2>\n";
>     print '</div>';
>   }
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetHistoryLink($id, T('View other revisions')) . "<br>\n";
>     print &GetGotoBar($id);
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub GetTextArea {
>   my ($name, $text, $rows, $cols) = @_;
> 
>   if (&GetParam("editwide", 1)) {
>     return $q->textarea(-name=>$name, -default=>$text,
>                         -rows=>$rows, -columns=>$cols, -override=>1,
>                         -style=>'width:100%', -wrap=>'virtual');
>   }
>   return $q->textarea(-name=>$name, -default=>$text,
>                       -rows=>$rows, -columns=>$cols, -override=>1,
>                       -wrap=>'virtual');
> }
> 
> sub DoEditPrefs {
>   my ($check, $recentName, %labels);
> 
>   $recentName = $RCName;
>   $recentName =~ s/_/ /g;
>   &DoNewLogin()  if ($UserID < 400);
>   print &GetHeader('', T('Editing Preferences'), '');
>   print '<div class=wikipref>';
>   print &GetFormStart();
>   print GetHiddenValue("edit_prefs", 1), "\n";
>   print '<b>' . T('User Information:') . "</b>\n";
>   print '<br>' . Ts('Your User ID number: %s', $UserID) . "\n";
>   print '<br>' . T('UserName:') . ' ', &GetFormText('username', "", 20, 50);
>   print ' ' . T('(blank to remove, or valid page name)');
>   print '<br>' . T('Set Password:') . ' ',
>         $q->password_field(-name=>'p_password', -value=>'*', 
>                            -size=>15, -maxlength=>50),
>         ' ', T('(blank to remove password)'), '<br>(',
>         T('Passwords allow sharing preferences between multiple systems.'),
>         ' ', T('Passwords are completely optional.'), ')';
>   if (($AdminPass ne '') || ($EditPass ne '')) {
>     print '<br>', T('Administrator Password:'), ' ',
>           $q->password_field(-name=>'p_adminpw', -value=>'*', 
>                              -size=>15, -maxlength=>50),
>           ' ', T('(blank to remove password)'), '<br>',
>           T('(Administrator passwords are used for special maintenance.)');
>   }
>   if ($EmailNotify) {
>     print "<br>";
>     print &GetFormCheck('notify', 1,
>           T('Include this address in the site email list.')), ' ',
>           T('(Uncheck the box to remove the address.)');
>     print '<br>', T('Email Address:'), ' ',
>           &GetFormText('email', "", 30, 60);
>   }
>   print "<hr class=wikilinepref><b>$recentName:</b>\n";
>   print '<br>', T('Default days to display:'), ' ',
>         &GetFormText('rcdays', $RcDefault, 4, 9);
>   print "<br>", &GetFormCheck('rcnewtop', $RecentTop,
>                               T('Most recent changes on top'));
>   print "<br>", &GetFormCheck('rcall', 0,
>                               T('Show all changes (not just most recent)'));
>   %labels = (0=>T('Hide minor edits'), 1=>T('Show minor edits'),
>              2=>T('Show only minor edits'));
>   print '<br>', T('Minor edit display:'), ' ';
>   print $q->popup_menu(-name=>'p_rcshowedit',
>                        -values=>[0,1,2], -labels=>\%labels,
>                        -default=>&GetParam("rcshowedit", $ShowEdits));
>   print "<br>", &GetFormCheck('rcchangehist', 1,
>                               T('Use "changes" as link to history'));
>   if ($UseDiff) {
>     print '<hr class=wikilinepref><b>', T('Differences:'), "</b>\n";
>     print "<br>", &GetFormCheck('diffrclink', 1,
>                                 Ts('Show (diff) links on %s', $recentName));
>     print "<br>", &GetFormCheck('alldiff', 0,
>                                 T('Show differences on all pages'));
>     print "  (",  &GetFormCheck('norcdiff', 1,
>                                 Ts('No differences on %s', $recentName)), ")";
>     %labels = (1=>T('Major'), 2=>T('Minor'), 3=>T('Author'));
>     print '<br>', T('Default difference type:'), ' ';
>     print $q->popup_menu(-name=>'p_defaultdiff',
>                          -values=>[1,2,3], -labels=>\%labels,
>                          -default=>&GetParam("defaultdiff", 1));
>   }
>   print '<hr class=wikilinepref><b>', T('Misc:'), "</b>\n";
>   # Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
>   print '<br>', T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset);
>   print '<br>', T('Time Zone offset (hours):'), ' ',
>         &GetFormText('tzoffset', 0, 4, 9);
>   print '<br>', &GetFormCheck('editwide', 1,
>                               T('Use 100% wide edit area (if supported)'));
>   print '<br>',
>         T('Edit area rows:'), ' ', &GetFormText('editrows', 20, 4, 4),
>         ' ', T('columns:'),   ' ', &GetFormText('editcols', 65, 4, 4);
> 
>   print '<br>', &GetFormCheck('toplinkbar', 1,
>                               T('Show link bar on top'));
>   print '<br>', &GetFormCheck('linkrandom', 0,
>                               T('Add "Random Page" link to link bar'));
>   print '<br>' . T('StyleSheet URL:') . ' ',
>         &GetFormText('stylesheet', "", 30, 150);
>   print '<br>', $q->submit(-name=>'Save', -value=>T('Save')), "\n";
>   print $q->endform;
>   print '</div>';
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub GetFormText {
>   my ($name, $default, $size, $max) = @_;
>   my $text = &GetParam($name, $default);
> 
>   return $q->textfield(-name=>"p_$name", -default=>$text,
>                        -override=>1, -size=>$size, -maxlength=>$max);
> }
> 
> sub GetFormCheck {
>   my ($name, $default, $label) = @_;
>   my $checked = (&GetParam($name, $default) > 0);
> 
>   return $q->checkbox(-name=>"p_$name", -override=>1, -checked=>$checked,
>                       -label=>$label);
> }
> 
> sub DoUpdatePrefs {
>   my ($username, $password, $stylesheet);
> 
>   # All link bar settings should be updated before printing the header
>   &UpdatePrefCheckbox("toplinkbar");
>   &UpdatePrefCheckbox("linkrandom");
>   print &GetHeader('', T('Saving Preferences'), '');
>   print '<br>';
>   if ($UserID < 1001) {
>     print '<b>',
>           Ts('Invalid UserID %s, preferences not saved.', $UserID), '</b>';
>     if ($UserID == 111) {
>       print '<br>',
>             T('(Preferences require cookies, but no cookie was sent.)');
>     }
>     print &GetCommonFooter();
>     return;
>   }
>   $username = &GetParam("p_username",  "");
>   if ($FreeLinks) {
>     $username =~ s/^\[\[(.+)\]\]/$1/;  # Remove [[ and ]] if added
>     $username =  &FreeToNormal($username);
>     $username =~ s/_/ /g;
>   }
>   if ($username eq "") {
>     print T('UserName removed.'), '<br>';
>     undef $UserData{'username'};
>   } elsif ((!$FreeLinks) && (!($username =~ /^$LinkPattern$/))) {
>     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
>   } elsif ($FreeLinks && (!($username =~ /^$FreeLinkPattern$/))) {
>     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
>   } elsif (length($username) > 50) {  # Too long
>     print T('UserName must be 50 characters or less. (not saved)'), "<br>\n";
>   } else {
>     print Ts('UserName %s saved.', $username), '<br>';
>     $UserData{'username'} = $username;
>   }
>   $password = &GetParam("p_password",  "");
>   if ($password eq "") {
>     print T('Password removed.'), '<br>';
>     undef $UserData{'password'};
>   } elsif ($password ne "*") {
>     print T('Password changed.'), '<br>';
>     $UserData{'password'} = $password;
>   }
>   if (($AdminPass ne "") || ($EditPass ne "")) {
>     $password = &GetParam("p_adminpw",  "");
>     if ($password eq "") {
>       print T('Administrator password removed.'), '<br>';
>       undef $UserData{'adminpw'};
>     } elsif ($password ne "*") {
>       print T('Administrator password changed.'), '<br>';
>       $UserData{'adminpw'} = $password;
>       if (&UserIsAdmin()) {
>         print T('User has administrative abilities.'), '<br>';
>       } elsif (&UserIsEditor()) {
>         print T('User has editor abilities.'), '<br>';
>       } else {
>         print T('User does not have administrative abilities.'), ' ',
>               T('(Password does not match administrative password(s).)'),
>               '<br>';
>       }
>     }
>   }
>   if ($EmailNotify) {
>     &UpdatePrefCheckbox("notify");
>     &UpdateEmailList();
>   }
>   &UpdatePrefNumber("rcdays", 0, 0, 999999);
>   &UpdatePrefCheckbox("rcnewtop");
>   &UpdatePrefCheckbox("rcall");
>   &UpdatePrefCheckbox("rcchangehist");
>   &UpdatePrefCheckbox("editwide");
>   if ($UseDiff) {
>     &UpdatePrefCheckbox("norcdiff");
>     &UpdatePrefCheckbox("diffrclink");
>     &UpdatePrefCheckbox("alldiff");
>     &UpdatePrefNumber("defaultdiff", 1, 1, 3);
>   }
>   &UpdatePrefNumber("rcshowedit", 1, 0, 2);
>   &UpdatePrefNumber("tzoffset", 0, -999, 999);
>   &UpdatePrefNumber("editrows", 1, 1, 999);
>   &UpdatePrefNumber("editcols", 1, 1, 999);
>   print T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset), '<br>';
>   $TimeZoneOffset = &GetParam("tzoffset", 0) * (60 * 60);
>   print T('Local time:'), ' ', &TimeToText($Now), '<br>';
>   $stylesheet = &GetParam('p_stylesheet', '');
>   if ($stylesheet eq '') {
>     if (&GetParam('stylesheet', '') ne '') {
>       print T('StyleSheet URL removed.'), '<br>';
>     }
>     undef $UserData{'stylesheet'};
>   } else {
>     $stylesheet =~ s/[">]//g;  # Remove characters that would cause problems
>     $UserData{'stylesheet'} = $stylesheet;
>     print T('StyleSheet setting saved.'), '<br>';
>   }
>   &SaveUserData();
>   print '<b>', T('Preferences saved.'), '</b>';
>   print &GetCommonFooter();
> }
> 
> # add or remove email address from preferences to $EmailFile
> sub UpdateEmailList {
>   my (@old_emails);
> 
>   local $/ = "\n";  # don't slurp whole files in this sub.
>   if (my $new_email = $UserData{'email'} = &GetParam("p_email", "")) {
>     my $notify = $UserData{'notify'};
>     if (-f $EmailFile) {
>       open(NOTIFY, $EmailFile)
>         or die(Ts('Could not read from %s:', $EmailFile) . " $!\n");
>       @old_emails = <NOTIFY>;
>       close(NOTIFY);
>     } else {
>       @old_emails = ();
>     }
>     my $already_in_list = grep /$new_email/, @old_emails;
>     if ($notify and (not $already_in_list)) {
>       &RequestLock() or die(T('Could not get mail lock'));
>       if (!open(NOTIFY, ">>$EmailFile")) {
>         &ReleaseLock();  # Don't leave hangling locks
>         die(Ts('Could not append to %s:', $EmailFile) . " $!\n");
>       }
>       print NOTIFY $new_email, "\n";
>       close(NOTIFY);
>       &ReleaseLock();
>     }
>     elsif ((not $notify) and $already_in_list) {
>       &RequestLock() or die(T('Could not get mail lock'));
>       if (!open(NOTIFY, ">$EmailFile")) {
>         &ReleaseLock();
>         die(Ts('Could not overwrite %s:', "$EmailFile") . " $!\n");
>       }
>       foreach (@old_emails) {
>         print NOTIFY "$_" unless /$new_email/;
>       }
>       close(NOTIFY);
>       &ReleaseLock();
>     }
>   }
> }
> 
> sub UpdatePrefCheckbox {
>   my ($param) = @_;
>   my $temp = &GetParam("p_$param", "*");
> 
>   $UserData{$param} = 1  if ($temp eq "on");
>   $UserData{$param} = 0  if ($temp eq "*");
>   # It is possible to skip updating by using another value, like "2"
> }
> 
> sub UpdatePrefNumber {
>   my ($param, $integer, $min, $max) = @_;
>   my $temp = &GetParam("p_$param", "*");
> 
>   return  if ($temp eq "*");
>   $temp =~ s/[^-\d\.]//g;
>   $temp =~ s/\..*//  if ($integer);
>   return  if ($temp eq "");
>   return  if (($temp < $min) || ($temp > $max));
>   $UserData{$param} = $temp;
> }
> 
> sub DoIndex {
>   print &GetHeader('', T('Index of all pages'), '');
>   print '<br>';
>   &PrintPageList(&AllPagesList());
>   print &GetCommonFooter();
> }
> 
> # Create a new user file/cookie pair
> sub DoNewLogin {
>   # Consider warning if cookie already exists
>   # (maybe use "replace=1" parameter)
>   &CreateUserDir();
>   $SetCookie{'id'} = &GetNewUserId();
>   $SetCookie{'randkey'} = int(rand(1000000000));
>   $SetCookie{'rev'} = 1;
>   %UserCookie = %SetCookie;
>   $UserID = $SetCookie{'id'};
>   # The cookie will be transmitted in the next header
>   %UserData = %UserCookie;
>   $UserData{'createtime'} = $Now;
>   $UserData{'createip'} = $ENV{REMOTE_ADDR};
>   &SaveUserData();
> }
> 
> sub DoEnterLogin {
>   print &GetHeader('', T('Login'), "");
>   print &GetFormStart();
>   print &GetHiddenValue('enter_login', 1), "\n";
>   print '<br>', T('User ID number:'), ' ',
>         $q->textfield(-name=>'p_userid', -value=>'',
>                       -size=>15, -maxlength=>50);
>   print '<br>', T('Password:'), ' ',
>         $q->password_field(-name=>'p_password', -value=>'', 
>                            -size=>15, -maxlength=>50);
>   print '<br>', $q->submit(-name=>'Login', -value=>T('Login')), "\n";
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub DoLogin {
>   my ($uid, $password, $success);
> 
>   $success = 0;
>   $uid = &GetParam("p_userid", "");
>   $uid =~ s/\D//g;
>   $password = &GetParam("p_password",  "");
>   if (($uid > 199) && ($password ne "") && ($password ne "*")) {
>     $UserID = $uid;
>     &LoadUserData();
>     if ($UserID > 199) {
>       if (defined($UserData{'password'}) &&
>           ($UserData{'password'} eq $password)) {
>         $SetCookie{'id'} = $uid;
>         $SetCookie{'randkey'} = $UserData{'randkey'};
>         $SetCookie{'rev'} = 1;
>         $success = 1;
>       }
>     }
>   }
>   print &GetHeader('', T('Login Results'), '');
>   if ($success) {
>     print Ts('Login for user ID %s complete.', $uid);
>   } else {
>     print Ts('Login for user ID %s failed.', $uid);
>   }
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub GetNewUserId {
>   my ($id);
> 
>   $id = $StartUID;
>   while (-f &UserDataFilename($id+1000)) {
>     $id += 1000;
>   }
>   while (-f &UserDataFilename($id+100)) {
>     $id += 100;
>   }
>   while (-f &UserDataFilename($id+10)) {
>     $id += 10;
>   }
>   &RequestLock() or die(T('Could not get user-ID lock'));
>   while (-f &UserDataFilename($id)) {
>     $id++;
>   }
>   &WriteStringToFile(&UserDataFilename($id), "lock");  # reserve the ID
>   &ReleaseLock();
>   return $id;
> }
> 
> # Consider user-level lock?
> sub SaveUserData {
>   my ($userFile, $data);
> 
>   &CreateUserDir();
>   $userFile = &UserDataFilename($UserID);
>   $data = join($FS1, %UserData);
>   &WriteStringToFile($userFile, $data);
> }
> 
> sub CreateUserDir {
>   my ($n, $subdir);
> 
>   if (!(-d "$UserDir/0")) {
>     &CreateDir($UserDir);
> 
>     foreach $n (0..9) {
>       $subdir = "$UserDir/$n";
>       &CreateDir($subdir);
>     }
>   }
> }
> 
> sub DoSearch {
>   my ($string) = @_;
> 
>   if ($string eq '') {
>     &DoIndex();
>     return;
>   }
>   print &GetHeader('', &QuoteHtml(Ts('Search for: %s', $string)), '');
>   print '<br>';
>   &PrintPageList(&SearchTitleAndBody($string));
>   print &GetCommonFooter();
> }
> 
> sub DoBackLinks {
>   my ($string) = @_;
> 
>   print &GetHeader('', &QuoteHtml(Ts('Backlinks for: %s', $string)), '');
>   print '<br>';
>   # At this time the backlinks are mostly a renamed search.
>   # An initial attempt to match links only failed on subpages and free links.
>   # Escape some possibly problematic characters:
>   $string =~ s/([-'().,])/\\$1/g; 
>   &PrintPageList(&SearchTitleAndBody($string));
>   print &GetCommonFooter();
> }
> 
> sub PrintPageList {
>   my $pagename;
> 
>   print "<h2>", Ts('%s pages found:', ($#_ + 1)), "</h2>\n";
>   foreach $pagename (@_) {
>     print ".... "  if ($pagename =~ m|/|);
>     print &GetPageLink($pagename), "<br>\n";
>   }
> }
> 
> sub DoLinks {
>   print &GetHeader('', &QuoteHtml(T('Full Link List')), '');
>   print "<hr><pre>\n\n\n\n\n";  # Extra lines to get below the logo
>   &PrintLinkList(&GetFullLinkList());
>   print "</pre>\n";
>   print &GetMinimumFooter();
> }
> 
> sub PrintLinkList {
>   my ($pagelines, $page, $names, $editlink);
>   my ($link, $extra, @links, %pgExists);
> 
>   %pgExists = ();
>   foreach $page (&AllPagesList()) {
>     $pgExists{$page} = 1;
>   }
>   $names = &GetParam("names", 1);
>   $editlink = &GetParam("editlink", 0);
>   foreach $pagelines (@_) {
>     @links = ();
>     foreach $page (split(' ', $pagelines)) {
>       if ($page =~ /\:/) {  # URL or InterWiki form
>         if ($page =~ /$UrlPattern/) {
>           ($link, $extra) = &UrlLink($page, 0);  # No images
>         } else {
>           ($link, $extra) = &InterPageLink($page, 0);  # No images
>         }
>       } else {
>         if ($pgExists{$page}) {
>           $link = &GetPageLink($page);
>         } else {
>           $link = $page;
>           if ($editlink) {
>             $link .= &GetEditLink($page, "?");
>           }
>         }
>       }
>       push(@links, $link);
>     }
>     if (!$names) {
>       shift(@links);
>     }
>     print join(' ', @links), "\n";
>   }
> }
> 
> sub GetFullLinkList {
>   my ($name, $unique, $sort, $exists, $empty, $link, $search);
>   my ($pagelink, $interlink, $urllink);
>   my (@found, @links, @newlinks, @pglist, %pgExists, %seen, $main);
> 
>   $unique = &GetParam("unique", 1);
>   $sort = &GetParam("sort", 1);
>   $pagelink = &GetParam("page", 1);
>   $interlink = &GetParam("inter", 0);
>   $urllink = &GetParam("url", 0);
>   $exists = &GetParam("exists", 2);
>   $empty = &GetParam("empty", 0);
>   $search = &GetParam("search", "");
>   if (($interlink == 2) || ($urllink == 2)) {
>     $pagelink = 0;
>   }
>   %pgExists = ();
>   @pglist = &AllPagesList();
>   foreach $name (@pglist) {
>     $pgExists{$name} = 1;
>   }
>   %seen = ();
>   foreach $name (@pglist) {
>     @newlinks = ();
>     if ($unique != 2) {
>       %seen = ();
>     }
>     @links = &GetPageLinks($name, $pagelink, $interlink, $urllink);
>     if ($UseSubpage) {
>       $main = $name;
>       $main =~ s/\/.*//;
>     }
>     foreach $link (@links) {
>       if ($UseSubpage && ($link =~ /^\//)) {
>         $link = $main . $link;
>       }
>       $seen{$link}++;
>       if (($unique > 0) && ($seen{$link} != 1)) {
>         next;
>       }
>       if (($exists == 0) && ($pgExists{$link} == 1)) {
>         next;
>       }
>       if (($exists == 1) && ($pgExists{$link} != 1)) {
>         next;
>       }
>       if (($search ne "") && !($link =~ /$search/)) {
>         next;
>       }
>       push(@newlinks, $link);
>     }
>     @links = @newlinks;
>     if ($sort) {
>       @links = sort(@links);
>     }
>     unshift (@links, $name);
>     if ($empty || ($#links > 0)) {  # If only one item, list is empty.
>       push(@found, join(' ', @links));
>     }
>   }
>   return @found;
> }
> 
> sub GetPageLinks {
>   my ($name, $pagelink, $interlink, $urllink) = @_;
>   my ($text, @links);
> 
>   @links = ();
>   &OpenPage($name);
>   &OpenDefaultText();
>   $text = $Text{'text'};
>   $text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
>   $text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
>   $text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
>   $text =~ s/<code>(.|\n)*?\<\/code>/ /ig;
>   if ($interlink) {
>     $text =~ s/''+/ /g;  # Quotes can adjacent to inter-site links
>     $text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
>   } else {
>     $text =~ s/$InterLinkPattern/ /g;
>   }
>   if ($urllink) {
>     $text =~ s/''+/ /g;  # Quotes can adjacent to URLs
>     $text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
>   } else {
>     $text =~ s/$UrlPattern/ /g;
>   }
>   if ($pagelink) {
>     if ($FreeLinks) {
>       my $fl = $FreeLinkPattern;
>       $text =~ s/\[\[$fl\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
>       $text =~ s/\[\[$fl\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
>     }
>     if ($WikiLinks) {
>       $text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
>     }
>   }
>   return @links;
> }
> 
> sub DoPost {
>   my ($editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user);
>   my $string = &GetParam("text", undef);
>   my $id = &GetParam("title", "");
>   my $summary = &GetParam("summary", "");
>   my $oldtime = &GetParam("oldtime", "");
>   my $oldconflict = &GetParam("oldconflict", "");
>   my $isEdit = 0;
>   my $editTime = $Now;
>   my $authorAddr = $ENV{REMOTE_ADDR};
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   if (!&UserCanEdit($id, 1)) {
>     # This is an internal interface--we don't need to explain
>     &ReportError(Ts('Editing not allowed for %s.', $id));
>     return;
>   }
>   if (($id eq   'SampleUndefinedPage')    ||
>       ($id eq T('SampleUndefinedPage'))   ||
>       ($id eq   'Sample_Undefined_Page')  ||
>       ($id eq T('Sample_Undefined_Page'))) {
>     &ReportError(Ts('%s cannot be defined.', $id));
>     return;
>   }
>   $string  = &RemoveFS($string);
>   $summary = &RemoveFS($summary);
>   $summary =~ s/[\r\n]//g;
>   if (length($summary) > 300) {  # Too long (longer than form allows)
>     $summary = substr($summary, 0, 300);
>   }
>   # Add a newline to the end of the string (if it doesn't have one)
>   $string .= "\n"  if (!($string =~ /\n$/));
>   # Lock before getting old page to prevent races
>   # Consider extracting lock section into sub, and eval-wrap it?
>   # (A few called routines can die, leaving locks.)
>   if ($LockCrash) {
>     &RequestLock() or die(T('Could not get editing lock'));
>   } else {
>     if (!&RequestLock()) {
>       &ForceReleaseLock('main');
>     }
>     # Clear all other locks.
>     &ForceReleaseLock('cache');
>     &ForceReleaseLock('diff');
>     &ForceReleaseLock('index');
>   }
>   &OpenPage($id);
>   &OpenDefaultText();
>   $old = $Text{'text'};
>   $oldrev = $Section{'revision'};
>   $pgtime = $Section{'ts'};
>   $preview = 0;
>   $preview = 1  if (&GetParam("Preview", "") ne "");
>   if (!$preview && ($old eq $string)) {  # No changes (ok for preview)
>     &ReleaseLock();
>     &ReBrowsePage($id, "", 1);
>     return;
>   }
>   if (($UserID > 399) || ($Section{'id'} > 399))  {
>     $newAuthor = ($UserID ne $Section{'id'});       # known user(s)
>   } else {
>     $newAuthor = ($Section{'ip'} ne $authorAddr);  # hostname fallback
>   }
>   $newAuthor = 1  if ($oldrev == 0);  # New page
>   $newAuthor = 0  if (!$newAuthor);   # Standard flag form, not empty
>   # Detect editing conflicts and resubmit edit
>   if (($oldrev > 0) && ($newAuthor && ($oldtime != $pgtime))) {
>     &ReleaseLock();
>     if ($oldconflict > 0) {  # Conflict again...
>       &DoEdit($id, 2, $pgtime, $string, $preview);
>     } else {
>       &DoEdit($id, 1, $pgtime, $string, $preview);
>     }
>     return;
>   }
>   if ($preview) {
>     &ReleaseLock();
>     &DoEdit($id, 0, $pgtime, $string, 1);
>     return;
>   }
>   $user = &GetParam("username", "");
>   # If the person doing editing chooses, send out email notification
>   if ($EmailNotify) {
>     &EmailNotify($id, $user) if &GetParam("do_email_notify", "") eq 'on';
>   }
>   if (&GetParam("recent_edit", "") eq 'on') {
>     $isEdit = 1;
>   }
>   if (!$isEdit) {
>     &SetPageCache('oldmajor', $Section{'revision'});
>   }
>   if ($newAuthor) {
>     &SetPageCache('oldauthor', $Section{'revision'});
>   }
>   &SaveKeepSection();
>   &ExpireKeepFile();
>   if ($UseDiff) {
>     &UpdateDiffs($id, $editTime, $old, $string, $isEdit, $newAuthor);
>   }
>   $Text{'text'} = $string;
>   $Text{'minor'} = $isEdit;
>   $Text{'newauthor'} = $newAuthor;
>   $Text{'summary'} = $summary;
>   $Section{'host'} = &GetRemoteHost(1);
>   &SaveDefaultText(); 
>   &SavePage();
>   &WriteRcLog($id, $summary, $isEdit, $editTime, $Section{'revision'},
>               $user, $Section{'host'});
>   if ($UseCache) {
>     &UnlinkHtmlCache($id);         # Old cached copy is invalid
>     if ($Page{'revision'} < 2) {   # If this is a new page...
>       &NewPageCacheClear($id);     # ...uncache pages linked to this one.
>     }
>   }
>   if ($UseIndex && ($Page{'revision'} == 1)) {
>     unlink($IndexFile);  # Regenerate index on next request
>   }
>   &ReleaseLock();
>   &ReBrowsePage($id, "", 1);
> }
> 
> sub UpdateDiffs {
>   my ($id, $editTime, $old, $new, $isEdit, $newAuthor) = @_;
>   my ($editDiff, $oldMajor, $oldAuthor);
> 
>   $editDiff  = &GetDiff($old, $new, 0);     # 0 = already in lock
>   $oldMajor  = &GetPageCache('oldmajor');
>   $oldAuthor = &GetPageCache('oldauthor');
>   if ($UseDiffLog) {
>     &WriteDiff($id, $editTime, $editDiff);
>   }
>   &SetPageCache('diff_default_minor', $editDiff);
>   if ($isEdit || !$newAuthor) {
>     &OpenKeptRevisions('text_default');
>   }
>   if (!$isEdit) {
>     &SetPageCache('diff_default_major', "1");
>   } else {
>     &SetPageCache('diff_default_major', &GetKeptDiff($new, $oldMajor, 0));
>   }
>   if ($newAuthor) {
>     &SetPageCache('diff_default_author', "1");
>   } elsif ($oldMajor == $oldAuthor) {
>     &SetPageCache('diff_default_author', "2");
>   } else {
>     &SetPageCache('diff_default_author', &GetKeptDiff($new, $oldAuthor, 0));
>   }
> }
> 
> # Translation note: the email messages are still sent in English
> # Send an email message.
> sub SendEmail {
>   my ($to, $from, $reply, $subject, $message) = @_;
> 
>   # sendmail options:
>   #    -odq : send mail to queue (i.e. later when convenient)
>   #    -oi  : do not wait for "." line to exit
>   #    -t   : headers determine recipient.
>   open (SENDMAIL, "| $SendMail -oi -t ") or die "Can't send email: $!\n";
>   print SENDMAIL <<"EOF";
> From: $from
> To: $to
> Reply-to: $reply
> Subject: $subject\n
> $message
> EOF
>   close(SENDMAIL) or warn "sendmail didn't close nicely";
> }
> 
> ## Email folks who want to know a note that a page has been modified. - JimM.
> sub EmailNotify {
>   local $/ = "\n";   # don't slurp whole files in this sub.
> 
>   if ($EmailNotify) {
>     my ($id, $user) = @_;
>     if ($user) {
>       $user = " by $user";
>     }
>     my $address;
>     return  if (!-f $EmailFile);  # No notifications yet
>     open(EMAIL, $EmailFile)
>       or die "Can't open $EmailFile: $!\n";
>     $address = join ",", <EMAIL>;
>     $address =~ s/\n//g;
>     close(EMAIL);
>     my $home_url = $q->url();
>     my $page_url = $home_url . &ScriptLinkChar() . &UriEscape($id);
>     my $editors_summary = $q->param("summary");
>     if (($editors_summary eq "*") or ($editors_summary eq "")){
>       $editors_summary = "";
>     }
>     else {
>       $editors_summary = "\n Summary: $editors_summary";
>     }
>     my $content = <<"END_MAIL_CONTENT";
> 
>  The $SiteName page $id at
>    $page_url
>  has been changed$user to revision $Page{revision}. $editors_summary
> 
>  (Replying to this notification will
>   send email to the entire mailing list,
>   so only do that if you mean to.
> 
>   To remove yourself from this list, visit
>   ${home_url}?action=editprefs .)
> END_MAIL_CONTENT
>     my $subject = "The $id page at $SiteName has been changed.";
>     # I'm setting the "reply-to" field to be the same as the "to:" field
>     # which seems appropriate for a mailing list, especially since the
>     # $EmailFrom string needn't be a real email address.
>     &SendEmail($address, $EmailFrom, $address, $subject, $content);
>   }
> }
> 
> sub SearchTitleAndBody {
>   my ($string) = @_;
>   my ($name, $freeName, @found);
> 
>   foreach $name (&AllPagesList()) {
>     &OpenPage($name);
>     &OpenDefaultText();
>     if (($Text{'text'} =~ /$string/i) || ($name =~ /$string/i)) {
>       push(@found, $name);
>     } elsif ($FreeLinks) {
>       if ($name =~ m/_/) {
>         $freeName = $name;
>         $freeName =~ s/_/ /g;
>         if ($freeName =~ /$string/i) {
>           push(@found, $name);
>         }
>       } elsif ($string =~ m/ /) {
>         $freeName = $string;
>         $freeName =~ s/ /_/g;
>         if ($Text{'text'} =~ /$freeName/i) {
>           push(@found, $name);
>         }
>       }
>     }
>   }
>   return @found;
> }
> 
> sub SearchBody {
>   my ($string) = @_;
>   my ($name, @found);
> 
>   foreach $name (&AllPagesList()) {
>     &OpenPage($name);
>     &OpenDefaultText();
>     if ($Text{'text'} =~ /$string/i){
>       push(@found, $name);
>     }
>   }
>   return @found;
> }
> 
> sub UnlinkHtmlCache {
>   my ($id) = @_;
>   my $idFile;
> 
>   $idFile = &GetHtmlCacheFile($id);
>   if (-f $idFile) {
>     unlink($idFile);
>   }
> }
> 
> sub NewPageCacheClear {
>   my ($id) = @_;
>   my $name;
> 
>   return if (!$UseCache);
>   $id =~ s|.+/|/|;  # If subpage, search for just the subpage
>   # The following code used to search the body for the $id
>   foreach $name (&AllPagesList()) {  # Remove all to be safe
>     &UnlinkHtmlCache($name);
>   }
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub DoUnlock {
>   my $LockMessage = T('Normal Unlock.');
> 
>   print &GetHeader('', T('Removing edit lock'), '');
>   print '<p>', T('This operation may take several seconds...'), "\n";
>   if (&ForceReleaseLock('main')) {
>     $LockMessage = T('Forced Unlock.');
>   }
>   &ForceReleaseLock('cache');
>   &ForceReleaseLock('diff');
>   &ForceReleaseLock('index');
>   print "<br><h2>$LockMessage</h2>";
>   print &GetCommonFooter();
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub WriteRcLog {
>   my ($id, $summary, $isEdit, $editTime, $revision, $name, $rhost) = @_;
>   my ($extraTemp, %extra);
> 
>   %extra = ();
>   $extra{'id'} = $UserID          if ($UserID > 0);
>   $extra{'name'} = $name          if ($name ne "");
>   $extra{'revision'} = $revision  if ($revision ne "");
>   $extraTemp = join($FS2, %extra);
>   # The two fields at the end of a line are kind and extension-hash
>   my $rc_line = join($FS3, $editTime, $id, $summary,
>                      $isEdit, $rhost, "0", $extraTemp);
>   if (!open(OUT, ">>$RcFile")) {
>     die(Ts('%s log error:', $RCName) . " $!");
>   }
>   print OUT  $rc_line . "\n";
>   close(OUT);
> }
> 
> sub WriteDiff {
>   my ($id, $editTime, $diffString) = @_;
> 
>   open (OUT, ">>$DataDir/diff_log") or die(T('can not write diff_log'));
>   print OUT  "------\n" . $id . "|" . $editTime . "\n";
>   print OUT  $diffString;
>   close(OUT);
> }
> 
> # Actions are vetoable if someone edits the page before
> # the keep expiry time. For example, page deletion. If
> # no one edits the page by the time the keep expiry time
> # elapses, then no one has vetoed the last action, and the
> # action is accepted.
> # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
> sub ProcessVetos {
>   my ($expirets);
> 
>   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
>   return (0, T('(done)'))  unless $Page{'ts'} < $expirets;
>   if ($DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o) {
>     &DeletePage($OpenPageName, 1, 1);
>     return (1, T('(deleted)'));
>   }
>   if ($ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o) {
>     my $fname = $1;
>     # Only replace an allowed, existing file.
>     if ((grep {$_ eq $fname} @ReplaceableFiles) && -e $fname) {
>        if ($Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims)
>        {
>          my $string = $1;
>          $string =~ s/\r\n/\n/gms;
>          open (OUT, ">$fname") or return 0;
>          print OUT $string;
>          close OUT;
>          return (0, T('(replaced)'));
>       }
>     }
>   }
>   return (0, T('(done)'));
> }
> 
> sub DoMaintain {
>   my ($name, $fname, $data, $message, $status);
>   print &GetHeader('', T('Maintenance on all pages'), '');
>   print "<br>";
>   $fname = "$DataDir/maintain";
>   if (!&UserIsAdmin()) {
>     if ((-f $fname) && ((-M $fname) < 0.5)) {
>       print T('Maintenance not done.'), ' ';
>       print T('(Maintenance can only be done once every 12 hours.)');
>       print ' ', T('Remove the "maintain" file or wait.');
>       print &GetCommonFooter();
>       return;
>     }
>   }
>   &RequestLock() or die(T('Could not get maintain-lock'));
>   foreach $name (&AllPagesList()) {
>     &OpenPage($name);
>     &OpenDefaultText();
>     ($status, $message) = &ProcessVetos();
>     &ExpireKeepFile() unless $status;
>     print ".... "  if ($name =~ m|/|);
>     print &GetPageLink($name);
>     print " $message<br>\n";
>   }
>   &WriteStringToFile($fname, Ts('Maintenance done at %s', &TimeToText($Now)));
>   &ReleaseLock();
>   # Do any rename/deletion commands
>   # (Must be outside lock because it will grab its own lock)
>   $fname = "$DataDir/editlinks";
>   if (-f $fname) {
>     $data = &ReadFileOrDie($fname);
>     print '<hr>', T('Processing rename/delete commands:'), "<br>\n";
>     &UpdateLinksList($data, 1, 1);  # Always update RC and links
>     unlink("$fname.old");
>     rename($fname, "$fname.old");
>   }
>   if ($MaintTrimRc) {
>     &RequestLock() or die(T('Could not get lock for RC maintenance'));
>     $status = &TrimRc();  # Consider error messages?
>     &ReleaseLock();
>   }
>   print &GetCommonFooter();
> }
> 
> # Must be called within a lock.
> # Thanks to Alex Schroeder for original code
> sub TrimRc {
>   my (@rc, @temp, $starttime, $days, $status, $data, $i, $ts);
> 
>   # Determine the number of days to go back
>   $days = 0;
>   foreach (@RcDays) {
>     $days = $_  if $_ > $days;
>   }
>   $starttime = $Now - $days * 24 * 60 * 60;
>   return 1  if (!-f $RcFile);  # No work if no file exists
>   ($status, $data) = &ReadFile($RcFile);
>   if (!$status) {
>     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
>           . ":</strong> $RcFile<p>"
>           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
>     return 0;
>   }
>   # Move the old stuff from rc to temp
>   @rc = split(/\n/, $data);
>   for ($i = 0; $i < @rc; $i++) {
>     ($ts) = split(/$FS3/, $rc[$i]);
>     last  if ($ts >= $starttime);
>   }
>   return 1  if ($i < 1);  # No lines to move from new to old
>   @temp = splice(@rc, 0, $i);
>   # Write new files and backups
>   if (!open(OUT, ">>$RcOldFile")) {
>     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
>           . ":</strong> $RcOldFile<p>"
>           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
>     return 0;
>   }
>   print OUT  join("\n", @temp) . "\n";
>   close(OUT);
>   &WriteStringToFile($RcFile . '.old', $data);
>   $data = join("\n", @rc);
>   $data .= "\n"  if ($data ne '');  # If no entries, don't add blank line
>   &WriteStringToFile($RcFile, $data);
>   return 1;
> }
> 
> sub DoMaintainRc {
>   print &GetHeader('', T('Maintaining RC log'), '');
>   return  if (!&UserIsAdminOrError());
>   &RequestLock() or die(T('Could not get lock for RC maintenance'));
>   if (&TrimRc()) {
>     print '<br>' . T('RC maintenance done.') . '<br>';
>   } else {
>     print '<br>' . T('RC maintenance not done.') . '<br>';
>   }
>   &ReleaseLock();
>   print &GetCommonFooter();
> }
> 
> sub UserIsEditorOrError {
>   if (!&UserIsEditor()) {
>     print '<p>', T('This operation is restricted to site editors only...');
>     print &GetCommonFooter();
>     return 0;
>   }
>   return 1;
> }
> 
> sub UserIsAdminOrError {
>   if (!&UserIsAdmin()) {
>     print '<p>', T('This operation is restricted to administrators only...');
>     print &GetCommonFooter();
>     return 0;
>   }
>   return 1;
> }
> 
> sub DoEditLock {
>   my ($fname);
> 
>   print &GetHeader('', T('Set or Remove global edit lock'), '');
>   return  if (!&UserIsAdminOrError());
>   $fname = "$DataDir/noedit";
>   if (&GetParam("set", 1)) {
>     &WriteStringToFile($fname, "editing locked.");
>   } else {
>     unlink($fname);
>   }
>   if (-f $fname) {
>     print '<p>', T('Edit lock created.'), '<br>';
>   } else {
>     print '<p>', T('Edit lock removed.'), '<br>';
>   }
>   print &GetCommonFooter();
> }
> 
> sub DoPageLock {
>   my ($fname, $id);
> 
>   print &GetHeader('', T('Set or Remove page edit lock'), '');
>   # Consider allowing page lock/unlock at editor level?
>   return  if (!&UserIsAdminOrError());
>   $id = &GetParam("id", "");
>   if ($id eq "") {
>     print '<p>', T('Missing page id to lock/unlock...');
>     return;
>   }
>   return  if (!&ValidIdOrDie($id));       # Consider nicer error?
>   $fname = &GetLockedPageFile($id);
>   if (&GetParam("set", 1)) {
>     &WriteStringToFile($fname, "editing locked.");
>   } else {
>     unlink($fname);
>   }
>   if (-f $fname) {
>     print '<p>', Ts('Lock for %s created.', $id), '<br>';
>   } else {
>     print '<p>', Ts('Lock for %s removed.', $id), '<br>';
>   }
>   print &GetCommonFooter();
> }
> 
> sub DoEditBanned {
>   my ($banList, $status);
> 
>   print &GetHeader('', T('Editing Banned list'), '');
>   return  if (!&UserIsAdminOrError());
>   ($status, $banList) = &ReadFile("$DataDir/banlist");
>   $banList = ""  if (!$status);
>   print &GetFormStart();
>   print GetHiddenValue("edit_ban", 1), "\n";
>   print "<b>Banned IP/network/host list:</b><br>\n";
>   print "<p>Each entry is either a commented line (starting with #), ",
>         "or a Perl regular expression (matching either an IP address or ",
>         "a hostname).  <b>Note:</b> To test the ban on yourself, you must ",
>         "give up your admin access (remove password in Preferences).";
>   print "<p>Example:<br>",
>         "# blocks hosts ending with .foocorp.com<br>",
>         "\\.foocorp\\.com\$<br>",
>         "# blocks exact IP address<br>",
>         "^123\\.21\\.3\\.9\$<br>",
>         "# blocks whole 123.21.3.* IP network<br>",
>         "^123\\.21\\.3\\.\\d+\$<p>";
>   print &GetTextArea('banlist', $banList, 12, 50);
>   print "<br>", $q->submit(-name=>'Save'), "\n";
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub DoUpdateBanned {
>   my ($newList, $fname);
> 
>   print &GetHeader('', T('Updating Banned list'), '');
>   return  if (!&UserIsAdminOrError());
>   $fname = "$DataDir/banlist";
>   $newList = &GetParam("banlist", "#Empty file");
>   if ($newList eq "") {
>     print "<p>", T('Empty banned list or error.');
>     print "<p>", T('Resubmit with at least one space character to remove.');
>   } elsif ($newList =~ /^\s*$/s) {
>     unlink($fname);
>     print "<p>", T('Removed banned list');
>   } else {
>     &WriteStringToFile($fname, $newList);
>     print "<p>", T('Updated banned list');
>   }
>   print &GetCommonFooter();
> }
> 
> # ==== Editing/Deleting pages and links ====
> sub DoEditLinks {
>   print &GetHeader('', T('Editing Links'), '');
>   if ($AdminDelete) {
>     return  if (!&UserIsAdminOrError());
>   } else {
>     return  if (!&UserIsEditorOrError());
>   }
>   print &GetFormStart();
>   print GetHiddenValue("edit_links", 1), "\n";
>   print "<b>Editing/Deleting page titles:</b><br>\n";
>   print "<p>Enter one command on each line.  Commands are:<br>",
>         "<tt>!PageName</tt> -- deletes the page called PageName<br>\n",
>         "<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName ",
>         "to NewPageName and updates links to OldPageName.<br>\n",
>         "<tt>|OldPageName|NewPageName</tt> -- Changes links to OldPageName ",
>         "to NewPageName.",
>         " (Used to rename links to non-existing pages.)<br>\n",
>         "<b>Note: page names are case-sensitive!</b>\n";
>   print &GetTextArea('commandlist', "", 12, 50);
>   print $q->checkbox(-name=>"p_changerc", -override=>1, -checked=>1,
>                       -label=>"Edit $RCName");
>   print "<br>\n";
>   print $q->checkbox(-name=>"p_changetext", -override=>1, -checked=>1,
>                       -label=>"Substitute text for rename");
>   print "<br>", $q->submit(-name=>'Edit'), "\n";
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub UpdateLinksList {
>   my ($commandList, $doRC, $doText) = @_;
> 
>   if ($doText) {
>     &BuildLinkIndex();
>   }
>   &RequestLock() or die T('UpdateLinksList could not get main lock');
>   unlink($IndexFile)  if ($UseIndex);
>   foreach (split(/\n/, $commandList)) {
>     s/\s+$//g;
>     next  if (!(/^[=!|]/));  # Only valid commands.
>     print "Processing $_<br>\n";
>     if (/^\!(.+)/) {
>       &DeletePage($1, $doRC, $doText);
>     } elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
>       &RenamePage($1, $2, $doRC, $doText);
>     } elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
>       &RenameTextLinks($1, $2);
>     }
>   }
>   &NewPageCacheClear(".");  # Clear cache (needs testing?)
>   unlink($IndexFile)  if ($UseIndex);
>   &ReleaseLock();
> }
> 
> sub BuildLinkIndex {
>   my (@pglist, $page, @links, $link, %seen);
> 
>   @pglist = &AllPagesList();
>   %LinkIndex = ();
>   foreach $page (@pglist) {
>     &BuildLinkIndexPage($page);
>   }
> }
> 
> sub BuildLinkIndexPage {
>   my ($page) = @_;
>   my (@links, $link, %seen);
> 
>   @links = &GetPageLinks($page, 1, 0, 0);
>   %seen = ();
>   foreach $link (@links) {
>     if (defined($LinkIndex{$link})) {
>       if (!$seen{$link}) {
>         $LinkIndex{$link} .= " " . $page;
>       }
>     } else {
>       $LinkIndex{$link} .= " " . $page;
>     }
>     $seen{$link} = 1;
>   }
> }
> 
> sub DoUpdateLinks {
>   my ($commandList, $doRC, $doText);
> 
>   print &GetHeader('', T('Updating Links'), '');
>   if ($AdminDelete) {
>     return  if (!&UserIsAdminOrError());
>   } else {
>     return  if (!&UserIsEditorOrError());
>   }
>   $commandList = &GetParam("commandlist", "");
>   $doRC   = &GetParam("p_changerc", "0");
>   $doRC   = 1  if ($doRC eq "on");
>   $doText = &GetParam("p_changetext", "0");
>   $doText = 1  if ($doText eq "on");
>   if ($commandList eq "") {
>     print "<p>", T('Empty command list or error.');
>   } else {
>     &UpdateLinksList($commandList, $doRC, $doText);
>     print "<p>", T('Finished command list.');
>   }
>   print &GetCommonFooter();
> }
> 
> sub EditRecentChanges {
>   my ($action, $old, $new) = @_;
> 
>   &EditRecentChangesFile($RcFile,    $action, $old, $new, 1);
>   &EditRecentChangesFile($RcOldFile, $action, $old, $new, 0);
> }
> 
> sub EditRecentChangesFile {
>   my ($fname, $action, $old, $new, $printError) = @_;
>   my ($status, $fileData, $errorText, $rcline, @rclist);
>   my ($outrc, $ts, $page, $junk);
> 
>   ($status, $fileData) = &ReadFile($fname);
>   if (!$status) {
>     # Save error text if needed.
>     $errorText = "<p><strong>"
>                  . Ts('Could not open %s log file:', $RCName)
>                  . "</strong> $fname"
>                  . "<p>" . T('Error was:') . "\n<pre>$!</pre>\n";
>     print $errorText  if ($printError);
>     return;
>   }
>   $outrc = "";
>   @rclist = split(/\n/, $fileData);
>   foreach $rcline (@rclist) {
>     ($ts, $page, $junk) = split(/$FS3/, $rcline);
>     if ($page eq $old) {
>       if ($action == 1) {  # Delete
>         ; # Do nothing (don't add line to new RC)
>       } elsif ($action == 2) {
>         $junk = $rcline;
>         $junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
>         $outrc .= $junk . "\n";
>       }
>     } else {
>       $outrc .= $rcline . "\n";
>     }
>   }
>   &WriteStringToFile($fname . ".old", $fileData);  # Backup copy
>   &WriteStringToFile($fname, $outrc);
> }
> 
> # Delete and rename must be done inside locks.
> sub DeletePage {
>   my ($page, $doRC, $doText) = @_;
>   my ($fname, $status);
> 
>   $page =~ s/ /_/g;
>   $page =~ s/\[+//;
>   $page =~ s/\]+//;
>   $status = &ValidId($page);
>   if ($status ne "") {
>     print Tss('Delete-Page: page %1 is invalid, error is: %2', $page, $status)
>           . "<br>\n";
>     return;
>   }
>   $fname = &GetPageFile($page);
>   unlink($fname)  if (-f $fname);
>   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
>   unlink($fname)  if (-f $fname);
>   unlink($IndexFile)  if ($UseIndex);
>   &EditRecentChanges(1, $page, "")  if ($doRC);  # Delete page
>   # Currently don't do anything with page text
> }
> 
> # Given text, returns substituted text
> sub SubstituteTextLinks {
>   my ($old, $new, $text) = @_;
> 
>   # Much of this is taken from the common markup
>   %SaveUrl = ();
>   $SaveUrlIndex = 0;
>   $text =~ s/$FS(\d)/$1/g;              # Remove separators (paranoia)
>   if ($RawHtml) {
>     $text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
>   }
>   $text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
>   $text =~ s/(<code>((.|\n)*?)<\/code>)/&StoreRaw($1)/ige;
>   $text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
>   if ($FreeLinks) {
>     $text =~
>      s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
>     $text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
>   }
>   if ($BracketText) {  # Links like [URL text of link]
>     $text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
>     $text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
>   }
>   $text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
>   $text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
>   if ($WikiLinks) {
>     $text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
>   }
>   # Thanks to David Claughton for the following fix
>   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
>   return $text;
> }
> 
> sub SubFreeLink {
>   my ($link, $name, $old, $new) = @_;
>   my ($oldlink);
> 
>   $oldlink = $link;
>   $link =~ s/^\s+//;
>   $link =~ s/\s+$//;
>   if (($link eq $old) || (&FreeToNormal($old) eq &FreeToNormal($link))) {
>     $link = $new;
>   } else {
>     $link = $oldlink;  # Preserve spaces if no match
>   }
>   $link = "[[$link";
>   if ($name ne "") {
>     $link .= "|$name";
>   }
>   $link .= "]]";
>   return &StoreRaw($link);
> }
> 
> sub SubWikiLink {
>   my ($link, $old, $new) = @_;
>   my ($newBracket);
> 
>   $newBracket = 0;
>   if ($link eq $old) {
>     $link = $new;
>     if (!($new =~ /^$LinkPattern$/)) {
>       $link = "[[$link]]";
>     }
>   }
>   return &StoreRaw($link);
> }
> 
> # Rename is mostly copied from expire
> sub RenameKeepText {
>   my ($page, $old, $new) = @_;
>   my ($fname, $status, $data, @kplist, %tempSection, $changed);
>   my ($sectName, $newText);
> 
>   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
>   return  if (!(-f $fname));
>   ($status, $data) = &ReadFile($fname);
>   return  if (!$status);
>   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>   return  if (length(@kplist) < 1);  # Also empty
>   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
>   return  if (length(@kplist) < 1);  # Also empty
>   %tempSection = split(/$FS2/, $kplist[0], -1);
>   if (!defined($tempSection{'keepts'})) {
>     return;
>   }
>   # First pass: optimize for nothing changed
>   $changed = 0;
>   foreach (@kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     if ($sectName =~ /^(text_)/) {
>       %Text = split(/$FS3/, $tempSection{'data'}, -1);
>       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
>       $changed = 1  if ($Text{'text'} ne $newText);
>     }
>   }
>   return  if (!$changed);  # No sections changed
>   open (OUT, ">$fname") or return;
>   foreach (@kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     if ($sectName =~ /^(text_)/) {
>       %Text = split(/$FS3/, $tempSection{'data'}, -1);
>       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
>       $Text{'text'} = $newText;
>       $tempSection{'data'} = join($FS3, %Text);
>       print OUT $FS1, join($FS2, %tempSection);
>     } else {
>       print OUT $FS1, $_;
>     }
>   }
>   close(OUT);
> }
> 
> sub RenameTextLinks {
>   my ($old, $new) = @_;
>   my ($changed, $file, $page, $section, $oldText, $newText, $status);
>   my ($oldCanonical, @pageList);
> 
>   $old =~ s/ /_/g;
>   $oldCanonical = &FreeToNormal($old);
>   $new =~ s/ /_/g;
>   $status = &ValidId($old);
>   if ($status ne "") {
>     print Tss('Rename-Text: old page %1 is invalid, error is: %2', $old, $status)
>           . "<br>\n";
>     return;
>   }
>   $status = &ValidId($new);
>   if ($status ne "") {
>     print Tss('Rename-Text: new page %1 is invalid, error is: %2', $new, $status)
>           . "<br>\n";
>     return;
>   }
>   $old =~ s/_/ /g;
>   $new =~ s/_/ /g;
>   # Note: the LinkIndex must be built prior to this routine
>   return  if (!defined($LinkIndex{$oldCanonical}));
>   @pageList = split(' ', $LinkIndex{$oldCanonical});
>   foreach $page (@pageList) {
>     $changed = 0;
>     &OpenPage($page);
>     foreach $section (keys %Page) {
>       if ($section =~ /^text_/) {
>         &OpenSection($section);
>         %Text = split(/$FS3/, $Section{'data'}, -1);
>         $oldText = $Text{'text'};
>         $newText = &SubstituteTextLinks($old, $new, $oldText);
>         if ($oldText ne $newText) {
>           $Text{'text'} = $newText;
>           $Section{'data'} = join($FS3, %Text);
>           $Page{$section} = join($FS2, %Section);
>           $changed = 1;
>         }
>       } elsif ($section =~ /^cache_diff/) {
>         $oldText = $Page{$section};
>         $newText = &SubstituteTextLinks($old, $new, $oldText);
>         if ($oldText ne $newText) {
>           $Page{$section} = $newText;
>           $changed = 1;
>         }
>       }
>       # Add other text-sections (categories) here
>     }
>     if ($changed) {
>       $file = &GetPageFile($page);
>       &WriteStringToFile($file, join($FS1, %Page));
>     }
>     &RenameKeepText($page, $old, $new);
>   }
> }
> 
> sub RenamePage {
>   my ($old, $new, $doRC, $doText) = @_;
>   my ($oldfname, $newfname, $oldkeep, $newkeep, $status);
> 
>   $old =~ s/ /_/g;
>   $new = &FreeToNormal($new);
>   $status = &ValidId($old);
>   if ($status ne "") {
>     print Tss('Rename: old page %1 is invalid, error is: %2', $old, $status)
>           . "<br>\n";
>     return;
>   }
>   $status = &ValidId($new);
>   if ($status ne "") {
>     print Tss('Rename: new page %1 is invalid, error is: %2', $new, $status)
>           . "<br>\n";
>     return;
>   }
>   $newfname = &GetPageFile($new);
>   if (-f $newfname) {
>     print Ts('Rename: new page %s already exists--not renamed.', $new)
>           . "<br>\n";
>     return;
>   }
>   $oldfname = &GetPageFile($old);
>   if (!(-f $oldfname)) {
>     print Ts('Rename: old page %s does not exist--nothing done.', $old)
>           . "<br>\n";
>     return;
>   }
>   &CreatePageDir($PageDir, $new);  # It might not exist yet
>   rename($oldfname, $newfname);
>   &CreatePageDir($KeepDir, $new);
>   $oldkeep = $KeepDir . "/" . &GetPageDirectory($old) .  "/$old.kp";
>   $newkeep = $KeepDir . "/" . &GetPageDirectory($new) .  "/$new.kp";
>   unlink($newkeep)  if (-f $newkeep);  # Clean up if needed.
>   rename($oldkeep,  $newkeep);
>   unlink($IndexFile)  if ($UseIndex);
>   &EditRecentChanges(2, $old, $new)  if ($doRC);
>   if ($doText) {
>     &BuildLinkIndexPage($new);  # Keep index up-to-date
>     &RenameTextLinks($old, $new);
>   }
> }
> 
> sub DoShowVersion {
>   print &GetHeader('', T('Displaying Wiki Version'), '');
>   print "<p>UseModWiki version 1.0.3</p>\n";
>   print &GetCommonFooter();
> }
> 
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
>   my ($id, $status, $name) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
> }
> 
> sub GetAdminBar {
>   my ($id) = @_;
>   my ($result);
> 
>   $result = T('Administration') . ': ';
>   if (-f &GetLockedPageFile($id))   { 
>     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
>   }
>   else  {
>     $result .= &GetPageLockLink($id, 1, T('Lock page'));
>   }
>   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
>   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
>   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
>   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
>   if (-f "$DataDir/noedit") {
>     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
>   } else {
>     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
>   }
>   return $result;
> }
> 
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
>   my ($id) = @_;
> 
>   return  if (!&ValidIdOrDie($id));
>   print &GetHeader('', Ts('Delete %s', $id), '');
>   return  if (!&UserIsAdminOrError());
>   if ($ConfirmDel && !&GetParam('confirm', 0)) {
>     print '<p>';
>     print Ts('Confirm deletion of %s by following this link:', $id);
>     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
>     print '</p>';
>     print &GetCommonFooter();
>     return;
>   }
>   print '<p>';
>   if ($id eq $HomePage)  {
>     print Ts('%s can not be deleted.', $HomePage);
>   } else {
>     if (-f &GetLockedPageFile($id))   {
>       print Ts('%s can not be deleted because it is locked.', $id);
>     } else {
>       # Must lock because of RC-editing
>       &RequestLock() or die(T('Could not get editing lock'));
>       DeletePage($id, 1, 1);
>       &ReleaseLock();
>       print Ts('%s has been deleted.', $id);
>     }
>   }
>   print '</p>';
>   print &GetCommonFooter();
> }
> 
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
>   print &GetHeader('', T('File Upload Page'), '');
>   if (!$AllUpload) {
>     return if (!&UserIsEditorOrError());
>   }
>   print '<p>' . Ts('The current upload size limit is %s.', $MaxPost) . ' '
>         . Ts('Change the %s variable to increase this limit.', '$MaxPost');
>   print '</p><br>';
>   print '<FORM METHOD="post" ACTION="' . $ScriptName
>         . '" ENCTYPE="multipart/form-data">';
>   print '<input type="hidden" name="upload" value="1" />';
>   print T('File to Upload:'), ' <INPUT TYPE="file" NAME="file"><br><BR>';
>   print '<INPUT TYPE="submit" NAME="Submit" VALUE="', T('Upload'), '">';
>   print '</FORM>';
>   print &GetCommonFooter(); 
> }
> 
> sub SaveUpload {
>   my ($filename, $printFilename, $uploadFilehandle);
>  
>   print &GetHeader('', T('Upload Finished'), '');
>   if (!$AllUpload) {
>     return  if (!&UserIsEditorOrError());
>   }
>   $UploadDir .= '/'  if (substr($UploadDir, -1, 1) ne '/');  # End with /
>   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
>   $filename = $q->param('file');
>   $filename =~ s/.*[\/\\](.*)/$1/;  # Only name after last \ or /
>   $uploadFilehandle = $q->upload('file');
>   open UPLOADFILE, ">$UploadDir$filename";
>   binmode UPLOADFILE;
>   while (<$uploadFilehandle>) { print UPLOADFILE; }
>   close UPLOADFILE;
>   print T('The wiki link to your file is:') . "\n<br><BR>";
>   $printFilename = $filename;
>   $printFilename =~ s/ /\%20/g;  # Replace spaces with escaped spaces
>   print "upload:" . $printFilename . "<BR><BR>\n";
>   if ($filename =~ /$ImageExtensions$/i) {
>     print '<HR><img src="' . $UploadUrl . $filename . '">' . "\n";
>   }
>   print &GetCommonFooter();
> }
> 
> sub ConvertFsFile {
>   my ($oldFS, $newFS, $fname) = @_;
>   my ($oldData, $newData, $status);
> 
>   return  if (!-f $fname);  # Convert only existing regular files
>   ($status, $oldData) = &ReadFile($fname);
>   if (!$status) {
>     print '<br><strong>' . Ts('Could not open file %s', $fname)
>           . ':</strong>' . T('Error was') . ":\n<pre>$!</pre>\n" . '<br>';
>     return;
>   }
>   $newData = $oldData;
>   $newData =~ s/$oldFS(\d)/$newFS . $1/ge;
>   return  if ($oldData eq $newData);  # Do not write if the same
>   &WriteStringToFile($fname, $newData);
> # print $fname . '<br>';    # progress report
> }
> 
> # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
> # Note that top level directory (page/keep/user) contains only dirs
> sub ConvertFsDir {
>   my ($oldFS, $newFS, $topDir) = @_;
>   my (@dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname);
> 
>   opendir(DIRLIST, $topDir);
>   @dirs = readdir(DIRLIST);
>   closedir(DIRLIST);
>   @dirs = sort(@dirs);
>   foreach $dir (@dirs) {
>     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
>     next  if (!-d "$topDir/$dir");          # Top level directories only
>     next  if (-f "$topDir/$dir.cvt");       # Skip if already converted
>     opendir(DIRLIST, "$topDir/$dir");
>     @files = readdir(DIRLIST);
>     closedir(DIRLIST);
>     foreach $file (@files) {
>       next  if (($file eq '.') || ($file eq '..'));
>       $fname = "$topDir/$dir/$file";
>       if (-f $fname) {
> #       print $fname . '<br>';   # progress
>         &ConvertFsFile($oldFS, $newFS, $fname);
>       } elsif (-d $fname) {
>         opendir(DIRLIST, $fname);
>         @subFiles = readdir(DIRLIST);
>         closedir(DIRLIST);
>         foreach $subFile (@subFiles) {
>           next  if (($subFile eq '.') || ($subFile eq '..'));
>           $subFname = "$fname/$subFile";
>           if (-f $subFname) {
> #           print $subFname . '<br>';   # progress
>             &ConvertFsFile($oldFS, $newFS, $subFname);
>           }
>         }
>       }
>     }
>   &WriteStringToFile("$topDir/$dir.cvt", 'converted');
>   }
> }
> 
> sub ConvertFsCleanup {
>   my ($topDir) = @_;
>   my (@dirs, $dir);
> 
>   opendir(DIRLIST, $topDir);
>   @dirs = readdir(DIRLIST);
>   closedir(DIRLIST);
>   foreach $dir (@dirs) {
>     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
>     next  if (!-f "$topDir/$dir");          # Remove only files...
>     next  unless ($dir =~ m/\.cvt$/);       # ...that end with .cvt
>     unlink "$topDir/$dir";
>   }
> }
> 
> sub DoConvert {
>   my $oldFS = "\xb3";
>   my $newFS = "\x1e\xff\xfe\x1e";
> 
>   print &GetHeader('', T('Convert wiki DB'), '');
>   return if (!&UserIsAdminOrError());
>   if ($FS ne $newFS) {
>     print Ts('You must change the %s option before converting the wiki DB.',
>              '$NewFS') . '<br>';
>     return;
>   }
>   &WriteStringToFile("$DataDir/noedit", 'editing locked.');
>   print T('Wiki DB locked for conversion.') . '<br>';
>   print T('Converting Wiki DB...') . '<br>';
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog");
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog.old");
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog");
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog.old");
>   &ConvertFsDir($oldFS, $newFS, $PageDir);
>   &ConvertFsDir($oldFS, $newFS, $KeepDir);
>   &ConvertFsDir($oldFS, $newFS, $UserDir);
>   &ConvertFsCleanup($PageDir);
>   &ConvertFsCleanup($KeepDir);
>   &ConvertFsCleanup($UserDir);
>   print T('Finished converting wiki DB.') . '<br>';
>   print Ts('Remove file %s to unlock wiki for editing.', "$DataDir/noedit")
>         . '<br>';
>   print &GetCommonFooter();
> }
> 
> # Remove user-id files if no useful preferences set
> sub DoTrimUsers {
>   my (%Data, $status, $data, $maxID, $id, $removed, $keep);
>   my (@dirs, @files, $dir, $file, $item);
> 
>   print &GetHeader('', T('Trim wiki users'), '');
>   return if (!&UserIsAdminOrError());
>   $removed = 0;
>   $maxID = 1001;
>   opendir(DIRLIST, $UserDir);
>   @dirs = readdir(DIRLIST);
>   closedir(DIRLIST);
>   foreach $dir (@dirs) {
>     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
>     next  if (!-d "$UserDir/$dir");         # Top level directories only
>     opendir(DIRLIST, "$UserDir/$dir");
>     @files = readdir(DIRLIST);
>     closedir(DIRLIST);
>     foreach $file (@files) {
>       if ($file =~ m/(\d+).db/) {  # Only numeric ID files
>         $id = $1;
>         $maxID = $id  if ($id > $maxID);
>         %Data = ();
>         ($status, $data) = &ReadFile("$UserDir/$dir/$file");
>         if ($status) {
>           %Data = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>           $keep = 0;
>           foreach $item (qw(username password adminpw stylesheet)) {
>             $keep = 1  if (defined($Data{$item}) && ($Data{$item} ne ''));
>           }
>           if (!$keep) {
>             unlink "$UserDir/$dir/$file";
> #           print "$UserDir/$dir/$file" . '<br>';  # progress
>             $removed += 1;
>           }
>         }
>       }
>     }
>   }
>   print Ts('Removed %s files.', $removed) . '<br>';
>   print Ts('Recommended $StartUID setting is %s.', $maxID + 100) . '<br>';
>   print &GetCommonFooter();
> }
> #END_OF_OTHER_CODE
> 
> &DoWikiRequest()  if ($RunCGI && ($_ ne 'nocgi'));   # Do everything.
> 1; # In case we are loaded from elsewhere
> # == End of UseModWiki script. ===========================================
> 
> 
> </pre>
2d5178
< 
------
SandBox|1195861195
2a2,3
> 1.02
> 
4c5
< # UseModWiki version 1.0.3 (September 12, 2007)
---
> # UseModWiki version 1.0.2 (August 26, 2007)
689c690
<     print '<b>(' . Ts('for %s only', &ScriptLink($idOnly, &QuoteHtml($idOnly)), 1)
---
>     print '<b>(' . Ts('for %s only', &ScriptLink($idOnly, $idOnly))
926c927
<   my ($pagenameEsc, $itemID, $description, $authorLink, $author, $status,
---
>   my ($itemID, $description, $authorLink, $author, $status,
929d929
<   $pagenameEsc = CGI::escape($pagename);
932c932
<             . &GetOldPageParameters('browse', $pagenameEsc, $revision);
---
>             . &GetOldPageParameters('browse', $pagename, $revision);
958c958
<         <link>$QuotedFullUrl?$pagenameEsc</link>
---
>         <link>$QuotedFullUrl?$pagename</link>
968c968
<         <wiki:diff>$diffPrefix$pagenameEsc</wiki:diff>
---
>         <wiki:diff>$diffPrefix$pagename</wiki:diff>
970c970
<         <wiki:history>$historyPrefix$pagenameEsc</wiki:history>
---
>         <wiki:history>$historyPrefix$pagename</wiki:history>
1306c1306
<                                &GetEditLink($oldId, &QuoteHtml($oldId)), 1) . ')');
---
>                                &GetEditLink($oldId, $oldId), 1) . ')');
1705,1713d1704
< sub EmptyCellsToNbsp {
<   my ($row) = @_;
< 
<   $row =~ s/(?<=\|\|)\s+(?=\|\|)/&nbsp;/g;
<   $row =~ s/^\s+(?=\|\|)/&nbsp;/;
<   $row =~ s/(?<=\|\|)\s+$/&nbsp;/;
<   return $row;
< }
< 
1741c1732
<                                . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/TD><\/TR>\n"/e) {
---
>                                . (length($1)\/2) . "'>$3<\/TD><\/TR>\n"/e) {
1987,1989d1977
<   } elsif ($text =~ /^$InterLinkPattern$/) {
<     my @interlink = split(/:/, $text, 2);
<     $text = &GetSiteUrl($interlink[0]) . $interlink[1];
3216c3204
<     print &GetHeader('', T('Editing Denied'), '');
---
>     print &GetHeader("", T('Editing Denied'), "");
3364c3352
<   print &GetHeader('', T('Editing Preferences'), '');
---
>   print &GetHeader('', T('Editing Preferences'), "");
3473c3461
<   print &GetHeader('', T('Saving Preferences'), '');
---
>   print &GetHeader('',T('Saving Preferences'), '');
4164,4176c4152,4156
<     } elsif ($FreeLinks) {
<       if ($name =~ m/_/) {
<         $freeName = $name;
<         $freeName =~ s/_/ /g;
<         if ($freeName =~ /$string/i) {
<           push(@found, $name);
<         }
<       } elsif ($string =~ m/ /) {
<         $freeName = $string;
<         $freeName =~ s/ /_/g;
<         if ($Text{'text'} =~ /$freeName/i) {
<           push(@found, $name);
<         }
---
>     } elsif ($FreeLinks && ($name =~ m/_/)) {
>       $freeName = $name;
>       $freeName =~ s/_/ /g;
>       if ($freeName =~ /$string/i) {
>         push(@found, $name);
4463c4443
<   print &GetHeader('', T('Editing Banned list'), '');
---
>   print &GetHeader("", "Editing Banned list", "");
4496c4476
<   print &GetHeader('', T('Updating Banned list'), '');
---
>   print &GetHeader("", "Updating Banned list", "");
4501,4502c4481,4482
<     print "<p>", T('Empty banned list or error.');
<     print "<p>", T('Resubmit with at least one space character to remove.');
---
>     print "<p>Empty banned list or error.";
>     print "<p>Resubmit with at least one space character to remove.";
4505c4485
<     print "<p>", T('Removed banned list');
---
>     print "<p>Removed banned list";
4508c4488
<     print "<p>", T('Updated banned list');
---
>     print "<p>Updated banned list";
4515c4495
<   print &GetHeader('', T('Editing Links'), '');
---
>   print &GetHeader("", "Editing Links", "");
4605c4585
<   print &GetHeader('', T('Updating Links'), '');
---
>   print &GetHeader("", T('Updating Links'), "");
4617c4597
<     print "<p>", T('Empty command list or error.');
---
>     print "<p>Empty command list or error.";
4620c4600
<     print "<p>", T('Finished command list.');
---
>     print "<p>Finished command list.";
4640,4643c4620,4621
<     $errorText = "<p><strong>"
<                  . Ts('Could not open %s log file:', $RCName)
<                  . "</strong> $fname"
<                  . "<p>" . T('Error was:') . "\n<pre>$!</pre>\n";
---
>     $errorText = "<p><strong>Could not open $RCName log file:"
>                  . "</strong> $fname<p>Error was:\n<pre>$!</pre>\n";
4677,4678c4655
<     print Tss('Delete-Page: page %1 is invalid, error is: %2', $page, $status)
<           . "<br>\n";
---
>     print "Delete-Page: page $page is invalid, error is: $status<br>\n";
4814,4815c4791
<     print Tss('Rename-Text: old page %1 is invalid, error is: %2', $old, $status)
<           . "<br>\n";
---
>     print "Rename-Text: old page $old is invalid, error is: $status<br>\n";
4820,4821c4796
<     print Tss('Rename-Text: new page %1 is invalid, error is: %2', $new, $status)
<           . "<br>\n";
---
>     print "Rename-Text: new page $new is invalid, error is: $status<br>\n";
4870,4871c4845
<     print Tss('Rename: old page %1 is invalid, error is: %2', $old, $status)
<           . "<br>\n";
---
>     print "Rename: old page $old is invalid, error is: $status<br>\n";
4876,4877c4850
<     print Tss('Rename: new page %1 is invalid, error is: %2', $new, $status)
<           . "<br>\n";
---
>     print "Rename: new page $new is invalid, error is: $status<br>\n";
4882,4883c4855
<     print Ts('Rename: new page %s already exists--not renamed.', $new)
<           . "<br>\n";
---
>     print "Rename: new page $new already exists--not renamed.<br>\n";
4888,4889c4860
<     print Ts('Rename: old page %s does not exist--nothing done.', $old)
<           . "<br>\n";
---
>     print "Rename: old page $old does not exist--nothing done.<br>\n";
4908,4909c4879,4880
<   print &GetHeader('', T('Displaying Wiki Version'), '');
<   print "<p>UseModWiki version 1.0.3</p>\n";
---
>   print &GetHeader("", "Displaying Wiki Version", "");
>   print "<p>UseModWiki version 1.0.2</p>\n";
4951d4921
<   print &GetHeader('', Ts('Delete %s', $id), '');
4953a4924
>     print &GetHeader('', Ts('Confirm Delete %s', $id), '');
4960a4932
>   print &GetHeader('', Ts('Delete %s', $id), '');
------
WikiBugs|1195887880
11c11,12
< ||2007.11.19||[HomePage/RobertKurcina RobertKurcina]||The various AdminBar links should be enabled or disable to match the left nav.||OPEN||
---
> ||2007.11.19||[HomePage/RobertKurcina RobertKurcina]||The various Admin bar links should be enabled or disable to match the left nav.||OPEN||
> ||2007.11.24||[HomePage/RobertKurcina RobertKurcina]||Table last column; the property seems to be picked up by the previous column.||OPEN||
------
SandBox|1195888681
1,5c1,3
< <pre>
< 1.02
< 
< #!perl
< # UseModWiki version 1.0.2 (August 26, 2007)
---
> <pre><nowiki>
> #!/usr/bin/perl
> # UseModWiki version 1.0 (September 12, 2003)
71c69
< $DataDir     = "C:/wikidb"; # Main wiki directory
---
> $DataDir     = "/tmp/mywikidb"; # Main wiki directory
125c123
< $UseDiff     = 0;           # 1 = use diff features,  0 = do not use diff
---
> $UseDiff     = 1;           # 1 = use diff features,  0 = do not use diff
155c153
< $BracketWiki  = 0;      # 1 = [WikiLnk txt] link, 0 = no local descriptions
---
> $BracketWiki  = 0;	# 1 = [WikiLnk txt] link, 0 = no local descriptions
323c321
<   $ImageExtensions = "(gif|jpg|png|bmp|jpeg|ico|tiff?)";
---
>   $ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
380,382c378,379
<   my ($text, $string, $noquote) = @_;
< 
<   $string = &QuoteHtml($string) unless $noquote;
---
>   my ($text, $string) = @_;
> 
389,394c386,387
<   my $text = $_[0];
<   my @args = @_;
< 
<   @args = map {
<     $_ = &QuoteHtml($_);
<   } @args;
---
>   my $text = @_[0];
> 
396c389
<   $text =~ s/\%([1-9])/$args[$1]/ge;
---
>   $text =~ s/\%([1-9])/$_[$1]/ge;
581a575,577
>   if (!&GetParam('embed', $EmbedWiki)) {
>     $fullHtml .= "<hr class=wikilinefooter>\n";
>   }
584d579
<     print "<hr class=wikilinerc>\n";
587a583
>     print "<hr class=wikilinefooter>\n"  if (!&GetParam('embed', $EmbedWiki));
1001,1005c997,1001
<       <form action="$ScriptName" METHOD="GET">
<           <input type="hidden" name="action" value="browse"/>
<           <input type="hidden" name="diff" value="1"/>
<           <input type="hidden" name="id" value="$id"/>
<       <table border="0" width="100%"><tr>
---
>       <form action='$ScriptName' METHOD='GET'>
>           <input type='hidden' name='action' value='browse'/>
>           <input type='hidden' name='diff' value='1'/>
>           <input type='hidden' name='id' value='$id'/>
>       <table border='0' width='100%'><tr>
1101,1102c1097
<   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
<          . "\">$text</a>";
---
>   return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\">$text</a>";
1108,1109c1103,1104
<   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
<          . '" class="' . $class . "\">$text</a>";
---
>   return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\""
>          . ' class=' . $class . ">$text</a>";
1254,1255c1249,1250
<   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
<          . "\" title=\"$title\">$text</a>";
---
>   return "<a href=\"$ScriptName" . &ScriptLinkChar()
>          . "$action\" title=\"$title\">$text</a>";
1306c1301
<                                &GetEditLink($oldId, $oldId), 1) . ')');
---
>                                &GetEditLink($oldId, $oldId)) . ')');
1367,1371d1361
<   # we don't want robots indexing our history or other admin pages
<   my $action = lc(&GetParam('action', ''));
<   unless (!$action or $action eq "rc" or $action eq "index") {
<     $html .= "<META NAME='robots' CONTENT='noindex,nofollow'>\n";
<   }
1401d1390
<   $result .= "<hr class=wikilinefooter>\n";
1421c1410
<     $result .= ' | <a href="http://sunir.org/apps/meta.pl?' . &UriEscape($id) . '">'
---
>     $result .= ' | <a href="http://sunir.org/apps/meta.pl?' . $id . '">'
1434c1423
<                                      $Section{'username'}, $Section{'id'}), 1);
---
>                                      $Section{'username'}, $Section{'id'}));
1465c1454
<   $html = '<div class=wikifooter>' . '<hr class=wikilinefooter>'
---
>   $html = '<hr class=wikilinefooter>' . '<div class=wikifooter>'
1528c1517
<   $url = $FullUrl . &ScriptLinkChar() . &UriEscape($newid);
---
>   $url = $FullUrl . &ScriptLinkChar() . $newid;
1596c1585
<     $pageText =~ s/((.|\n)+?\n)\s*(\n|$)/&ParseParagraph($1)/geo;
---
>     $pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
1667,1669d1655
<     if ($UseUpload) {
<       s/$UploadPattern/&StoreUpload($1)/geo;
<     }
1678a1665,1667
>     if ($UseUpload) {
>       s/$UploadPattern/&StoreUpload($1)/geo;
>     }
1797,1803d1785
< sub UriEscape {
<   my ($uri) = @_;
<   $uri =~ s/([\x00-\x1f\x7f-\xff])/sprintf("%%%02X", ord($1))/ge;
<   $uri =~ s/\&/\&amp;/g;
<   return $uri;
< }
< 
1963c1945
<   return 0  unless ($url =~ /^($imagePrefixes).+\.$ImageExtensions$/i);
---
>   return 0  unless ($url =~ /^($imagePrefixes).+\.$ImageExtensions$/);
2098c2080
<     $url =~ s/([^a-zA-Z0-9\/\x80-\xff]+)$//;
---
>     $url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
2621c2603
<   print $q->header, $q->start_html, "<H2>", &QuoteHtml($errmsg), "</H2>", $q->end_html;
---
>   print $q->header, "<H2>", $errmsg, "</H2>", $q->end_html;
3298c3280
<     print ' (', Ts('Visit %s to set your user name.', &GetPrefsLink(), 1), ') ';
---
>     print ' (', Ts('Visit %s to set your user name.', &GetPrefsLink()), ') ';
3306a3289
>   print "<hr class=wikilinefooter>\n";
3309d3291
<     print "<hr class=wikilinepreview>\n";
3318c3300
<     print &WikiToHTML($oldText) . "<hr class=wikilinepreview>\n";
---
>     print &WikiToHTML($oldText) . "<hr class=wikilinefooter>\n";
3321a3304,3306
>   print '<div class=wikifooter>';
>   print &GetHistoryLink($id, T('View other revisions')) . "<br>\n";
>   print &GetGotoBar($id);
3323,3329c3308
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetHistoryLink($id, T('View other revisions')) . "<br>\n";
<     print &GetGotoBar($id);
<     print '</div>';
<   }
---
>   print '</div>';
3428d3406
<   print $q->endform;
3430,3435c3408,3412
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
---
>   print "<hr class=wikilinefooter>\n";
>   print '<div class=wikifooter>';
>   print &GetGotoBar('');
>   print $q->endform;
>   print '</div>';
3653a3631,3632
>   print "<hr class=wikilinefooter>\n";
>   print &GetGotoBar('');
3655,3660d3633
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
3690,3695c3663,3665
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
---
>   print "<hr class=wikilinefooter>\n";
>   print &GetGotoBar('');
>   print $q->endform;
3829c3799
<   my (@found, @links, @newlinks, @pglist, %pgExists, %seen, $main);
---
>   my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
3854,3857d3823
<     if ($UseSubpage) {
<       $main = $name;
<       $main =~ s/\/.*//;
<     }
3859,3861d3824
<       if ($UseSubpage && ($link =~ /^\//)) {
<         $link = $main . $link;
<       }
3937,3939d3899
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
4114c4074
<     my $page_url = $home_url . &ScriptLinkChar() . &UriEscape($id);
---
>     my $page_url = $home_url . "?$id";
4462a4423,4424
>   print "<hr class=wikilinefooter>\n";
>   print &GetGotoBar("");
4464,4469d4425
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
4518a4475,4476
>   print "<hr class=wikilinefooter>\n";
>   print &GetGotoBar("");
4520,4525d4477
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
4880c4832
<   print "<p>UseModWiki version 1.0.2</p>\n";
---
>   print "<p>UseModWiki version 1.0</p>\n";
4963,4964c4915,4916
<   print T('File to Upload:'), ' <INPUT TYPE="file" NAME="file"><br><BR>';
<   print '<INPUT TYPE="submit" NAME="Submit" VALUE="', T('Upload'), '">';
---
>   print 'File to Upload: <INPUT TYPE="file" NAME="file"><br><BR>';
>   print '<INPUT TYPE="submit" NAME="Submit" VALUE="Upload">';
4982d4933
<   binmode UPLOADFILE;
4989c4940
<   if ($filename =~ /$ImageExtensions$/i) {
---
>   if ($filename =~ /${ImageExtensions}$/) {
5149c5099
< </pre>
---
> </nowiki></pre>
------
WikiTemplates|1195944637
10a10,11
>  /TemplateCategories
> 
------
WikiTemplates/TemplateCategories|1195944707
1c1,2
< ====== Describe the new page here. =
---
> == Related Entries =
>  $LIST$
------
WikiTemplates/TemplateCategories|1195944769
2c2,13
<  $LIST$
---
>  WikiStyleGuide
>  WikiMarkup
>  WikiTOCs
>  WikiHeadings
>  WikiLists
>  WikiTables
>  WikiImages
>  WikiURLs
>  WikiTemplates
>  WikiGallery
>  WikiFlash
>  WikiTemplates
------
WikiTemplates/TemplateCategories|1195944806
2,10c2,10
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiTemplates
---
>  WikiStyleGuide
>  WikiMarkup
>  WikiTOCs
>  WikiHeadings
>  WikiLists
>  WikiTables
>  WikiImages
>  WikiURLs
>  WikiTemplates
------
WikiTemplates/TemplateCategories|1195944840
1,13c1,3
< == Related Entries =
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiTemplates
<  WikiGallery
<  WikiFlash
<  WikiTemplates
---
> == Related Entries = 
> WikiStyleGuide WikiMarkup WikiTOCs WikiHeadings WikiLists WikiTables WikiImages WikiURLs WikiTemplates WikiGallery WikiFlash
> WikiTemplates
------
WikiStyleGuide|1195945027
31,39c31,32
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/Editing
> }}
------
RelatedEntries|1195945289
1,2c1,12
< ====== Describe the new page here. =
< 
---
> = Related Entries Master Page = 
> 
> Create subpages here for use as Related Entries.  Each subpage should be a mere list or a table of links.  Utilize these as templates in other pages by embedding the template syntax as follows:
> 
> <pre>
> {{template:RelatedEntries/SUBPAGE}}
> </pre>
> 
> Where SUBPAGE is the name of one of the following:
> 
>  #SUBPAGES
> /WikiEditing
------
RelatedEntries/WikiEditing|1195945301
1,2c1,2
< ====== Describe the new page here. =
< 
---
> WikiStyleGuide WikiMarkup WikiTOCs WikiHeadings WikiLists WikiTables WikiImages WikiURLs WikiTemplates WikiGallery WikiFlash
> WikiTemplates
------
RelatedEntries|1195945326
12d11
< /WikiEditing
------
RelatedEntries/WikiEditing|1195945435
1c1,8
< WikiStyleGuide WikiMarkup WikiTOCs WikiHeadings WikiLists WikiTables WikiImages WikiURLs WikiTemplates WikiGallery WikiFlash
---
> WikiStyleGuide
> WikiMarkup
> WikiTOCs
> WikiHeadings
> WikiLists
> WikiTables
> WikiImages
> WikiURLs
2a10,13
> WikiGallery
> WikiFlash
> WikiTemplates
> 
------
WikiStyleGuide|1195945459
31,32c31
< {{template:RelatedEntries/Editing
< }}
---
> {{template:RelatedEntries/WikiEditing}}
------
RelatedEntries|1195945492
6c6
< {{template:RelatedEntries/SUBPAGE}}
---
> {{template:SUBPAGE}
------
WikiEditing|1195945547
63,73c63
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiTemplates
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiFlash|1195945560
35,42c35
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiGallery
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiGallery|1195945576
60,67c60
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiHeadings|1195945590
23,31c23
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiImages|1195945620
92,101c92
<  WikiUploads
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiURLs
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiLists|1195945632
54,62c54
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiMarkup|1195945650
90,98c90
<  WikiStyleGuide
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiTOCs|1195945673
40,48c40
<  WikiStyleGuide
<  WikiMarkup
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiTables|1195945682
75,83c75
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiImages
<  WikiURLs
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiTemplates|1195945697
67,77c67
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiTemplates
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
WikiURLs|1195945708
35,43c35
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiGallery
<  WikiFlash
---
> {{template:RelatedEntries/WikiEditing}}
------
RelatedEntries/WikiAdministration|1195945811
1c1,4
< ====== Describe the new page here. =
---
> AdminFeatures
> WikiAdmin
> AdminActions
> 
------
AdminActions|1195945853
112,114c112
<  AdminFeatures
<  WikiAdmin
<  AdminActions
---
> {{template:RelatedEntries/WikiAdministration}}
------
AdminFeatures|1195945918
64,67c64
<  AdminActions
<  WikiAdmin
<  WikiStyleGuide
<  InterMap
---
> {{template:RelatedEntries/WikiAdministration}}
------
RelatedEntries/WikiAdministration|1195946038
5a4,7
> InterMap
> PageSecurity
> 
> 
------
RelatedEntries/WikiAdministration|1195946103
5c5
< PageSecurity
---
> PrivateUserGroups
------
PrivateUserGroups|1195946276
1,2c1,3
< ====== Describe the new page here. =
< 
---
> ===== TASK: Private User Groups =
> 
> Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like {e:UserName} or {r:UserName} to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an Authorization Error page [ AuthError ]
------
NobleWiki|1195946451
22c22
< ||Flash Object||Flash SWFs may be added using the <tt><nowiki>#FLASH</nowiki></tt> directive. See WikiFlash for more information.||
---
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki>#MAGIC flash</nowiki></tt> directive and module. See WikiFlash for more information.||
------
NobleWiki|1195946586
22c22
< ||Flash Object||Flash SWFs may be added using the <tt><nowiki>#MAGIC flash</nowiki></tt> directive and module. See WikiFlash for more information.||
---
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki>#MAGIC Flash</nowiki></tt> directive and module. See WikiFlash for more information.||
------
AuthError|1195946613
1c1
< ====== Describe the new page here. =
---
> #REDIRECT PageNotFound
------
AuthError|1195946620
------
AuthError|1195946627
------
SandBox|1195947262
2c2
< #!/usr/bin/perl
---
> #!E:/Program Files/perl/bin/perl.exe
29a29,32
> use Diff;
> use MagicContent;
> use Image::Size;
> 
32c35
< local $| = 1;  # Do not buffer output (localized for mod_perl)
---
> local $| = 1;    # Do not buffer output (localized for mod_perl)
53c56
<   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine 
---
>   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine
56,57c59,62
<   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton 
<   $EditNameLink $UseMetaWiki @ImageSites $BracketImg );
---
>   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton $HomePagePrefix
>   $EditNameLink $UseMetaWiki @ImageSites $BracketImg $DisabledDir
>   $AllowInclusion $InclusionDir $NumberDatesDelim);
>   
66c71,75
<   $ConfigError $UploadPattern );
---
>   $ConfigError $UploadPattern $WikiLineHeader $WikiLineHeaderPreview $WikiLineFooter $WikiLineDiff
>   $WikiLine $WikiLine1 $WikiLine2 $WikiLinePref $AutoMailto
>   $GLOBAL_imageCount $GLOBAL_flashCount $GLOBAL_galleryCount
>   $WikiLeftNav %TableCellDefaults $DownloadExtensions $CssDir $HomeDir
>   );
69,71c78,86
< $DataDir     = "/tmp/mywikidb"; # Main wiki directory
< $UseConfig   = 1;       # 1 = use config file,    0 = do not look for config
< $ConfigFile  = "$DataDir/config";   # Configuration file
---
> $HomeDir 		  = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org";
> $DataDir 		  = $HomeDir . "/wiki";    # Main wiki directory
> $CssDir	          = $HomeDir . "/docs/css";
> $DisabledDir      = $HomeDir . "/docs/disabled";
> $UploadDir        = $HomeDir . "/docs/attachments";
> 								  
> 
> $UseConfig = 0;    # 1 = use config file,    0 = do not look for config
> $ConfigFile = "$DataDir/config";    # Configuration file
74,115c89,149
< $CookieName  = "Wiki";          # Name for this wiki (for multi-wiki sites)
< $SiteName    = "Wiki";          # Name of site (used for titles)
< $HomePage    = "HomePage";      # Home page (change space to _)
< $RCName      = "RecentChanges"; # Name of changes page (change space to _)
< $LogoUrl     = "/wiki.gif";     # URL for site logo ("" for no logo)
< $ENV{PATH}   = "/usr/bin/";     # Path used to find "diff"
< $ScriptTZ    = "";              # Local time zone ("" means do not print)
< $RcDefault   = 30;              # Default number of RecentChanges days
< @RcDays      = qw(1 3 7 30 90); # Days for links on RecentChanges
< $KeepDays    = 14;              # Days to keep old revisions
< $SiteBase    = "";              # Full URL for <BASE> header
< $FullUrl     = "";              # Set if the auto-detected URL is wrong
< $RedirType   = 1;               # 1 = CGI.pm, 2 = script, 3 = no redirect
< $AdminPass   = "";              # Set to non-blank to enable password(s)
< $EditPass    = "";              # Like AdminPass, but for editing only
< $StyleSheet  = "";              # URL for CSS stylesheet (like "/wiki.css")
< $NotFoundPg  = "";              # Page for not-found links ("" for blank pg)
< $EmailFrom   = "Wiki";          # Text for "From: " field of email notes.
< $SendMail    = "/usr/sbin/sendmail";  # Full path to sendmail executable
< $FooterNote  = "";              # HTML for bottom of every page
< $EditNote    = "";              # HTML notice above buttons on edit page
< $MaxPost     = 1024 * 210;      # Maximum 210K posts (about 200K for pages)
< $NewText     = "";              # New page text ("" for default message)
< $HttpCharset = "";              # Charset for pages, like "iso-8859-2"
< $UserGotoBar = "";              # HTML added to end of goto bar
< $InterWikiMoniker = '';         # InterWiki moniker for this wiki. (for RSS)
< $SiteDescription  = $SiteName;  # Description of this wiki. (for RSS)
< $RssLogoUrl  = '';              # Optional image for RSS feed
< $EarlyRules  = '';              # Local syntax rules for wiki->html (evaled)
< $LateRules   = '';              # Local syntax rules for wiki->html (evaled)
< $KeepSize    = 0;               # If non-zero, maximum size of keep file
< $BGColor     = 'white';         # Background color ('' to disable)
< $DiffColor1  = '#ffffaf';       # Background color of old/deleted text
< $DiffColor2  = '#cfffcf';       # Background color of new/added text
< $FavIcon     = '';              # URL of bookmark/favorites icon, or ''
< $RssDays     = 7;               # Default number of days in RSS feed
< $UserHeader  = '';              # Optional HTML header additional content
< $UserBody    = '';              # Optional <BODY> tag additional content
< $StartUID    = 1001;            # Starting number for user IDs
< $UploadDir   = '';              # Full path (like /foo/www/uploads) for files
< $UploadUrl   = '';              # Full URL (like http://foo.com/uploads)
< @ImageSites  = qw();            # Url prefixes of good image sites: ()=all
---
> $CookieName = "NobleWiki";          # Name for this wiki (for multi-wiki sites)
> $SiteName   = "Noble Pursuit Games Wiki";          # Name of site (used for titles)
> $HomePage   = "HomePage";           # Home page (change space to _)
> $HomePagePrefix = "HomePage/";      # Which page will be linked when a valid $username is clicked in the RC history; end with slash if using Sub pages
> $RCName     = "RecentChanges";      # Name of changes page (change space to _)
> $LogoUrl    = "";                   # URL for site logo ("" for no logo)
> $ENV{PATH}  = "/usr/bin/";          # Path used to find "diff"
> $ScriptTZ   = "";                   # Local time zone ("" means do not print)
> $RcDefault  = 7;                    # Default number of RecentChanges days
> @RcDays     = qw(1 3 7 30 90 180);  # Days for links on RecentChanges
> $KeepDays   = 14;                   # Days to keep old revisions
> $SiteBase   = "";                   # Full URL for <BASE> header
> 
> 								    # Set if the auto-detected URL is wrong
> $FullUrl    = "http://wiki.kurcina.org/cgi-bin/index.cgi";
> 									# Full URL (like http://foo.com/uploads)
> $UploadUrl  = "http://wiki.kurcina.org/attachments"; #
> $RedirType  = 1;                    # 1 = CGI.pm, 2 = script, 3 = no redirect
> $AdminPass  = "linhson";            # Set to non-blank to enable password(s)
> $EditPass   = "emerald";            # Like AdminPass, but for editing only
> $StyleSheet = "/css/wiki.default.css";   # URL for CSS stylesheet (like "/wiki.css")
> $NotFoundPg = "PageNotFound";       # Page for not-found links ("" for blank pg)
> $EmailFrom  = "NobleWiki";          # Text for "From: " field of email notes.
> $SendMail   = "/usr/sbin/sendmail"; # Full path to sendmail executable
> $AutoMailto = 1;					# 0 = off; 1 = convert email address automatically to mailTo:<address>
> 									# HTML for bottom of every page
> $FooterNote = "<a href='?action=editprefs'><div id='anylogo' title='access username'>&nbsp;</div></a>";                   
> 
> $EditNote   = "";                 # HTML notice above buttons on edit page
> $MaxPost    = 1024 * 5000;        # Maximum 210K posts (about 200K for pages)
> 								  # New page text ("" for default message)
> $NewText    = "====== Describe the new page here. =\n\n";                   
> $HttpCharset      = "";           # Charset for pages, like "iso-8859-2"
> 
> $InterWikiMoniker = "NobleWiki";  # InterWiki moniker for this wiki. (for RSS)
> $SiteDescription  = $SiteName;    # Description of this wiki. (for RSS)
> $RssLogoUrl       = "";           # Optional image for RSS feed
> $EarlyRules       = "";           # Local syntax rules for wiki->html (evaled)
> $LateRules        = "";           # Local syntax rules for wiki->html (evaled)
> $KeepSize         = 0;            # If non-zero, maximum size of keep file
> $BGColor          = "";           # Background color ('' to disable)
> $DiffColor1       = "#ffffaf";    # Background color of old/deleted text
> $DiffColor2       = "#cfffcf";    # Background color of new/added text
> $FavIcon          = "";           # URL of bookmark/favorites icon, or ''
> $RssDays          = 7;            # Default number of days in RSS feed
> $UserGotoBar      = "";           # HTML added to end of goto bar
> $UserGotoBar     .= "<a href='$ScriptName?WikiHelp'>Help</a>";
> 
> $UserHeader       = "";           # Optional HTML header additional content
> $UserHeader		 .= "\n<link rel='stylesheet' type='text/css' media='screen' href='/css/jquery.lightbox-0.4.css'/>";
> $UserHeader      .= "\n<script src='/js/jquery-1.2.1.js'></script>";
> $UserHeader      .= "\n<script src='/js/ufo.js'></script>";
> $UserHeader		 .= "\n<script src='/js/jquery.lightbox-0.4.js'></script>";
> 
> $UserBody         = "";           # Optional <BODY> tag additional content
> $StartUID         = 1001;         # Starting number for user IDs
> 								  # Full path (like /foo/www/uploads) for files
> 
> 
>       
> @ImageSites       = qw();         # Url prefixes of good image sites: ()=all
118,136c152,174
< $UseSubpage  = 1;           # 1 = use subpages,       0 = do not use subpages
< $UseCache    = 0;           # 1 = cache HTML pages,   0 = generate every page
< $EditAllowed = 1;           # 1 = editing allowed,    0 = read-only
< $RawHtml     = 0;           # 1 = allow <HTML> tag,   0 = no raw HTML in pages
< $HtmlTags    = 0;           # 1 = "unsafe" HTML tags, 0 = only minimal tags
< $UseDiff     = 1;           # 1 = use diff features,  0 = do not use diff
< $FreeLinks   = 1;           # 1 = use [[word]] links, 0 = LinkPattern only
< $WikiLinks   = 1;           # 1 = use LinkPattern,    0 = use [[word]] only
< $AdminDelete = 1;           # 1 = Admin only deletes, 0 = Editor can delete
< $RunCGI      = 1;           # 1 = Run script as CGI,  0 = Load but do not run
< $EmailNotify = 0;           # 1 = use email notices,  0 = no email on changes
< $EmbedWiki   = 0;           # 1 = no headers/footers, 0 = normal wiki pages
< $DeletedPage = 'DeletedPage';   # 0 = disable, 'PageName' = tag to delete page
< $ReplaceFile = 'ReplaceFile';   # 0 = disable, 'PageName' = indicator tag
< @ReplaceableFiles = ();     # List of allowed server files to replace
< $TableSyntax = 1;           # 1 = wiki syntax tables, 0 = no table syntax
< $NewFS       = 0;           # 1 = new multibyte $FS,  0 = old $FS
< $UseUpload   = 0;           # 1 = allow uploads,      0 = no uploads
< 
---
> $UseSubpage  = 1;             # 1 = use subpages,       0 = do not use subpages
> $UseCache    = 0;             # 1 = cache HTML pages,   0 = generate every page
> $EditAllowed = 1;             # 1 = editing allowed,    0 = read-only
> $RawHtml     = 0;             # 1 = allow <HTML> tag,   0 = no raw HTML in pages
> $HtmlTags    = 1;             # 1 = "unsafe" HTML tags, 0 = only minimal tags
> $UseDiff     = 1;             # 1 = use diff features,  0 = do not use diff
> $FreeLinks   = 1;             # 1 = use [[word]] links, 0 = LinkPattern only
> $WikiLinks   = 1;             # 1 = use LinkPattern,    0 = use [[word]] only
> $AdminDelete = 1;             # 1 = Admin only deletes, 0 = Editor can delete
> $RunCGI      = 1;             # 1 = Run script as CGI,  0 = Load but do not run
> $EmailNotify = 0;             # 1 = use email notices,  0 = no email on changes
> $EmbedWiki   = 0;             # 1 = no headers/footers, 0 = normal wiki pages
> $DeletedPage = "DeletedPage"; # 0 = disable, 'PageName' = tag to delete page
> $ReplaceFile = "ReplaceFile"; # 0 = disable, 'PageName' = indicator tag
> @ReplaceableFiles = ();       # List of allowed server files to replace
> $TableSyntax      = 1;        # 1 = wiki syntax tables, 0 = no table syntax
> $NewFS            = 1;        # 1 = new multibyte $FS,  0 = old $FS
> $UseUpload        = 1;        # 1 = allow uploads,      0 = no uploads
> $AllowInclusion = 1;          # 1 = files (*.txt,*.html) may be included by include:file.html,
> 	                          # 0 = files will not be included
> 	                          # from where shall the files be included?
> $InclusionDir = "$DataDir/includes-data"; 
>   
138,178c176,226
< $LogoLeft     = 0;      # 1 = logo on left,       0 = logo on right
< $RecentTop    = 1;      # 1 = recent on top,      0 = recent on bottom
< $UseDiffLog   = 1;      # 1 = save diffs to log,  0 = do not save diffs
< $KeepMajor    = 1;      # 1 = keep major rev,     0 = expire all revisions
< $KeepAuthor   = 1;      # 1 = keep author rev,    0 = expire all revisions
< $ShowEdits    = 0;      # 1 = show minor edits,   0 = hide edits by default
< $HtmlLinks    = 0;      # 1 = allow A HREF links, 0 = no raw HTML links
< $SimpleLinks  = 0;      # 1 = only letters,       0 = allow _ and numbers
< $NonEnglish   = 0;      # 1 = extra link chars,   0 = only A-Za-z chars
< $ThinLine     = 0;      # 1 = fancy <hr> tags,    0 = classic wiki <hr>
< $BracketText  = 1;      # 1 = allow [URL text],   0 = no link descriptions
< $UseAmPm      = 1;      # 1 = use am/pm in times, 0 = use 24-hour times
< $UseIndex     = 0;      # 1 = use index file,     0 = slow/reliable method
< $UseHeadings  = 1;      # 1 = allow = h1 text =,  0 = no header formatting
< $NetworkFile  = 1;      # 1 = allow remote file:, 0 = no file:// links
< $BracketWiki  = 0;	# 1 = [WikiLnk txt] link, 0 = no local descriptions
< $UseLookup    = 1;      # 1 = lookup host names,  0 = skip lookup (IP only)
< $FreeUpper    = 1;      # 1 = force upper case,   0 = do not force case
< $FastGlob     = 1;      # 1 = new faster code,    0 = old compatible code
< $MetaKeywords = 1;      # 1 = Google-friendly,    0 = search-engine averse
< $NamedAnchors = 1;      # 0 = no anchors, 1 = enable anchors,
<                         # 2 = enable but suppress display
< $SlashLinks   = 0;      # 1 = use script/action links, 0 = script?action
< $UpperFirst   = 1;      # 1 = free links start uppercase, 0 = no ucfirst
< $AdminBar     = 1;      # 1 = admins see admin links, 0 = no admin bar
< $RepInterMap  = 0;      # 1 = intermap is replacable, 0 = not replacable
< $ConfirmDel   = 1;      # 1 = delete link confirm page, 0 = immediate delete
< $MaskHosts    = 0;      # 1 = mask hosts/IPs,      0 = no masking
< $LockCrash    = 0;      # 1 = crash if lock stuck, 0 = auto clear locks
< $HistoryEdit  = 0;      # 1 = edit links on history page, 0 = no edit links
< $OldThinLine  = 0;      # 1 = old ==== thick line, 0 = ------ for thick line
< $NumberDates  = 0;      # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
< $ParseParas   = 0;      # 1 = new paragraph markup, 0 = old markup
< $AuthorFooter = 1;      # 1 = show last author in footer, 0 = do not show
< $AllUpload    = 0;      # 1 = anyone can upload,   0 = only editor/admins
< $LimitFileUrl = 1;      # 1 = limited use of file: URLs, 0 = no limits
< $MaintTrimRc  = 0;      # 1 = maintain action trims RC, 0 = only maintainrc
< $SearchButton = 0;      # 1 = search button on page, 0 = old behavior
< $EditNameLink = 0;      # 1 = edit links use name (CSS), 0 = '?' links
< $UseMetaWiki  = 0;      # 1 = add MetaWiki search links, 0 = no MW links
< $BracketImg   = 1;      # 1 = [url url.gif] becomes image link, 0 = no img
---
> $LogoLeft     = 1;    # 1 = logo on left,       0 = logo on right
> $RecentTop    = 1;    # 1 = recent on top,      0 = recent on bottom
> $UseDiffLog   = 1;    # 1 = save diffs to log,  0 = do not save diffs
> $KeepMajor    = 1;    # 1 = keep major rev,     0 = expire all revisions
> $KeepAuthor   = 1;    # 1 = keep author rev,    0 = expire all revisions
> $ShowEdits    = 0;    # 1 = show minor edits,   0 = hide edits by default
> $HtmlLinks    = 1;    # 1 = allow A HREF links, 0 = no raw HTML links
> $SimpleLinks  = 0;    # 1 = only letters,       0 = allow _ and numbers
> $NonEnglish   = 0;    # 1 = extra link chars,   0 = only A-Za-z chars
> $ThinLine     = 0;    # 1 = fancy <hr> tags,    0 = classic wiki <hr>
> $BracketText  = 1;    # 1 = allow [URL text],   0 = no link descriptions
> $UseAmPm      = 0;    # 1 = use am/pm in times, 0 = use 24-hour times
> $UseIndex     = 0;    # 1 = use index file,     0 = slow/reliable method
> $UseHeadings  = 1;    # 1 = allow = h1 text =,  0 = no header formatting
> $NetworkFile  = 1;    # 1 = allow remote file:, 0 = no file:// links
> $BracketWiki  = 1;    # 1 = [WikiLnk txt] link, 0 = no local descriptions
> $UseLookup    = 1;    # 1 = lookup host names,  0 = skip lookup (IP only)
> $FreeUpper    = 1;    # 1 = force upper case,   0 = do not force case
> $FastGlob     = 1;    # 1 = new faster code,    0 = old compatible code
> $MetaKeywords = 1;    # 1 = Google-friendly,    0 = search-engine averse
> $NamedAnchors = 1;    # 0 = no anchors, 1 = enable anchors,
>                       # 2 = enable but suppress display
> $SlashLinks   = 0;    # 1 = use script/action links, 0 = script?action
> $UpperFirst   = 1;    # 1 = free links start uppercase, 0 = no ucfirst
> $AdminBar     = 1;    # 1 = admins see admin links, 0 = no admin bar
> $RepInterMap  = 0;    # 1 = intermap is replacable, 0 = not replacable
> $ConfirmDel   = 1;    # 1 = delete link confirm page, 0 = immediate delete
> $MaskHosts    = 0;    # 1 = mask hosts/IPs,      0 = no masking
> $LockCrash    = 0;    # 1 = crash if lock stuck, 0 = auto clear locks
> $HistoryEdit  = 0;    # 1 = edit links on history page, 0 = no edit links
> $OldThinLine  = 0;    # 1 = old ==== thick line, 0 = ------ for thick line
> $NumberDates  = 1;    # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
> $NumberDatesDelim = "-"; # If $NumberDates is 1, this character separate the year, month, day
> $ParseParas   = 1;    # 1 = new paragraph markup, 0 = old markup
> $AuthorFooter = 1;    # 1 = show last author in footer, 0 = do not show
> $AllUpload    = 0;    # 1 = anyone can upload,   0 = only editor/admins
> $LimitFileUrl = 1;    # 1 = limited use of file: URLs, 0 = no limits
> $MaintTrimRc  = 1;    # 1 = maintain action trims RC, 0 = only maintainrc
> $SearchButton = 1;    # 1 = search button on page, 0 = old behavior
> $EditNameLink = 0;    # 1 = edit links use name (CSS), 0 = '?' links
> $UseMetaWiki  = 0;    # 1 = add MetaWiki search links, 0 = no MW links
> $BracketImg   = 1;    # 1 = [url url.gif] becomes image link, 0 = no img
> 
> $WikiLineHeader = "\n<div class='wikilineheader'></div>";
> $WikiLineHeaderPreview = "\n<div class='wikilineheaderpreview'></div>";
> $WikiLineFooter = "\n<div class='wikilinefooter'></div>";
> $WikiLineDiff   = "\n<div class='wikilinediff'></div>";
> $WikiLinePref   = "\n<div class='wikilinepref'></div>";
> $WikiLine       = "\n<div class='wikiline'>&nbsp;</div>";
> $WikiLine1      = "\n<div class='wikiline1'></div>";
> $WikiLine2      = "\n<div class='wikiline2'></div>";
181c229,230
< @IsbnNames = ('bn.com', 'amazon.com', 'search');
---
> @IsbnNames = ( 'bn.com', 'amazon.com', 'search' );
> 
183,185c232,237
< @IsbnPre = ('http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=',
<             'http://www.amazon.com/exec/obidos/ISBN=',
<             'http://www.pricescan.com/books/BookDetail.asp?isbn=');
---
> @IsbnPre = (
> 	"http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=",
> 	"http://www.amazon.com/exec/obidos/ISBN=",
> 	"http://www.pricescan.com/books/BookDetail.asp?isbn="
> );
> 
187c239
< @IsbnPost = ('', '', '');
---
> @IsbnPost = ( "", "", "" );
194c246,247
<   em s strike strong tt var div center blockquote ol ul dl table caption);
---
>   em s strike strong tt var div center blockquote ol ul dl caption);
> 
197c250
< @HtmlPairs = (@HtmlPairs, @HtmlSingle);  # All singles can also be pairs
---
> @HtmlPairs  = ( @HtmlPairs, @HtmlSingle );     # All singles can also be pairs
200,215c253,266
< $IndentLimit = 20;                  # Maximum depth of nested lists
< $PageDir     = "$DataDir/page";     # Stores page data
< $HtmlDir     = "$DataDir/html";     # Stores HTML versions
< $UserDir     = "$DataDir/user";     # Stores user data
< $KeepDir     = "$DataDir/keep";     # Stores kept (old) page data
< $TempDir     = "$DataDir/temp";     # Temporary files and locks
< $LockDir     = "$TempDir/lock";     # DB is locked if this exists
< $InterFile   = "$DataDir/intermap"; # Interwiki site->url map
< $RcFile      = "$DataDir/rclog";    # New RecentChanges logfile
< $RcOldFile   = "$DataDir/oldrclog"; # Old RecentChanges logfile
< $IndexFile   = "$DataDir/pageidx";  # List of all pages
< $EmailFile   = "$DataDir/emails";   # Email notification lists
< 
< if ($RepInterMap) {
<   push @ReplaceableFiles, $InterFile;
< }
---
> $IndentLimit = 20;                             # Maximum depth of nested lists
> $PageDir     = "$DataDir/page-data";           # Stores page data
> $HtmlDir     = "$DataDir/html-version";        # Stores HTML versions
> $UserDir     = "$DataDir/user-data";           # Stores user data
> $KeepDir     = "$DataDir/keep-data";           # Stores kept (old) page data
> $TempDir     = "$DataDir/temp-files";          # Temporary files and locks
> $LockDir     = "$TempDir/lock-dir";            # DB is locked if this exists
> $InterFile   = "$DataDir/intermap";            # Interwiki site->url map
> $RcFile      = "$DataDir/recent-log";          # New RecentChanges logfile
> $RcOldFile   = "$DataDir/oldrecent-log";       # Old RecentChanges logfile
> $IndexFile   = "$DataDir/page-index";          # List of all pages
> $EmailFile   = "$DataDir/email-list";          # Email notification lists
> 
> if ($RepInterMap) { push @ReplaceableFiles, $InterFile; }
219,241c270,293
<   if ($UseConfig && (-f $ConfigFile)) {
<     $ConfigError = '';
<     if (!do $ConfigFile) {   # Some error occurred
<       $ConfigError = $@;
<       if ($ConfigError eq '') {
<         # Unfortunately, if the last expr returns 0, one will get a false
<         # error above.  To remain compatible with existing installs the
<         # wiki must not report an error unless there is error text in $@.
<         # (Errors in "use strict" may not have error text.)
<         # Uncomment the line below if you want to catch use strict errors.
< #       $ConfigError = T('Unknown Error (no error text)');
<       }
<     }
<   }
<   &InitLinkPatterns();
<   if (!&DoCacheBrowse()) {
<     eval $BrowseCode;
<     &InitRequest() or return;
<     if (!&DoBrowseRequest()) {
<       eval $OtherCode;
<       &DoOtherRequest();
<     }
<   }
---
> 	if ( $UseConfig && ( -f $ConfigFile ) ) {
> 		$ConfigError = "";
> 		if ( !do $ConfigFile ) {               # Some error occurred
> 			$ConfigError = $@;
> 			if ( $ConfigError eq "" ) {
> 
> 			  # Unfortunately, if the last expr returns 0, one will get a false
> 			  # error above.  To remain compatible with existing installs the
> 			  # wiki must not report an error unless there is error text in $@.
> 			  # (Errors in "use strict" may not have error text.)
> 			  # Uncomment the line below if you want to catch use strict errors.
> 			  #       $ConfigError = "Unknown Error (no error text)";
> 			}
> 		}
> 	}
> 	&InitLinkPatterns();
> 	if ( !&DoCacheBrowse() ) {
> 		eval $BrowseCode;
> 		&InitRequest() or return;
> 		if ( !&DoBrowseRequest() ) {
> 			eval $OtherCode;
> 			&DoOtherRequest();
> 		}
> 	}
246,324c298,400
<   my ($UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim);
< 
<   # Field separators are used in the URL-style patterns below.
<   if ($NewFS) {
<     $FS  = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
<   } else {
<     $FS  = "\xb3";    # The FS character is a superscript "3"
<   }
<   $FS1 = $FS . "1";   # The FS values are used to separate fields
<   $FS2 = $FS . "2";   # in stored hashtables and other data structures.
<   $FS3 = $FS . "3";   # The FS character is not allowed in user data.
<   $UpperLetter = "[A-Z";
<   $LowerLetter = "[a-z";
<   $AnyLetter   = "[A-Za-z";
<   if ($NonEnglish) {
<     $UpperLetter .= "\xc0-\xde";
<     $LowerLetter .= "\xdf-\xff";
<     if ($NewFS) {
<       $AnyLetter   .= "\x80-\xff";
<     } else {
<       $AnyLetter   .= "\xc0-\xff";
<     }
<   }
<   if (!$SimpleLinks) {
<     $AnyLetter .= "_0-9";
<   }
<   $UpperLetter .= "]"; $LowerLetter .= "]"; $AnyLetter .= "]";
<   # Main link pattern: lowercase between uppercase, then anything
<   $LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter
<          . $AnyLetter . "*";
<   # Optional subpage link pattern: uppercase, lowercase, then anything
<   $LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
<   if ($UseSubpage) {
<     # Loose pattern: If subpage is used, subpage may be simple name
<     $LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
<     # Strict pattern: both sides must be the main LinkPattern
<     # $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
<   } else {
<     $LinkPattern = "($LpA)";
<   }
<   $QDelim = '(?:"")?';     # Optional quote delimiter (not in output)
<   $AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
<   $LinkPattern .= $QDelim;
<   # Inter-site convention: sites must start with uppercase letter
<   # (Uppercase letter avoids confusion with URLs)
<   $InterSitePattern = $UpperLetter . $AnyLetter . "+";
<   $InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
<   if ($FreeLinks) {
<     # Note: the - character must be first in $AnyLetter definition
<     if ($NonEnglish) {
<       if ($NewFS) {
<         $AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
<       } else {
<         $AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
<       }
<     } else {
<       $AnyLetter = "[-,.()' _0-9A-Za-z]";
<     }
<   }
<   $FreeLinkPattern = "($AnyLetter+)";
<   if ($UseSubpage) {
<     $FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+)";
<   }
<   $FreeLinkPattern .= $QDelim;
<   # Url-style links are delimited by one of:
<   #   1.  Whitespace                           (kept in output)
<   #   2.  Left or right angle-bracket (< or >) (kept in output)
<   #   3.  Right square-bracket (])             (kept in output)
<   #   4.  A single double-quote (")            (kept in output)
<   #   5.  A $FS (field separator) character    (kept in output)
<   #   6.  A double double-quote ("")           (removed from output)
<   $UrlProtocols = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|"
<                   . "prospero|telnet|gopher";
<   $UrlProtocols .= '|file'  if ($NetworkFile || !$LimitFileUrl);
<   $UrlPattern = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
<   $ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
<   $RFCPattern = "RFC\\s?(\\d+)";
<   $ISBNPattern = "ISBN:?([0-9- xX]{10,})";
<   $UploadPattern = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
---
> 	my ( $UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim );
> 
> 	# Field separators are used in the URL-style patterns below.
> 	if ($NewFS) {
> 		$FS = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
> 	}
> 	else {
> 		$FS = "\xb3";                # The FS character is a superscript "3"
> 	}
> 	$FS1         = $FS . "1";  # The FS values are used to separate fields
> 	$FS2         = $FS . "2";  # in stored hashtables and other data structures.
> 	$FS3         = $FS . "3";  # The FS character is not allowed in user data.
> 	$UpperLetter = "[A-Z";
> 	$LowerLetter = "[a-z";
> 	$AnyLetter   = "[A-Za-z";
> 	
> 	if ($NonEnglish) {
> 		$UpperLetter .= "\xc0-\xde";
> 		$LowerLetter .= "\xdf-\xff";
> 		if ($NewFS) {
> 			$AnyLetter .= "\x80-\xff";
> 		}
> 		else {
> 			$AnyLetter .= "\xc0-\xff";
> 		}
> 	}
> 	if ( !$SimpleLinks ) {
> 		$AnyLetter .= "_0-9";
> 	}
> 	$UpperLetter .= "]";
> 	$LowerLetter .= "]";
> 	$AnyLetter   .= "]";
> 
> 	# Main link pattern: lowercase between uppercase, then anything
> 	$LpA =
> 	  $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
> 
> 	# Optional subpage link pattern: uppercase, lowercase, then anything
> 	$LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
> 	if ($UseSubpage) {
> 
> 		# Loose pattern: If subpage is used, subpage may be simple name
> 		$LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
> 
> 		# Strict pattern: both sides must be the main LinkPattern
> 		# $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
> 	}
> 	else {
> 		$LinkPattern = "($LpA)";
> 	}
> 	$QDelim = '(?:"")?';    # Optional quote delimiter (not in output)
> 	$AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
> 	$LinkPattern .= $QDelim;
> 
> 	# Inter-site convention: sites must start with uppercase letter
> 	# (Uppercase letter avoids confusion with URLs)
> 	$InterSitePattern = $UpperLetter . $AnyLetter . "+";
> 	$InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
> 	if ($FreeLinks) {
> 
> 		# Note: the - character must be first in $AnyLetter definition
> 		if ($NonEnglish) {
> 			if ($NewFS) {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
> 			}
> 			else {
> 				$AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
> 			}
> 		}
> 		else {
> 			$AnyLetter = "[-,.()' _0-9A-Za-z]";
> 		}
> 	}
> 	$FreeLinkPattern = "($AnyLetter+";
> 	if ($UseSubpage) {
> 		$FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+";
> 	}
> 	
> 	if ($NamedAnchors){
> 		$FreeLinkPattern .= "(?:#(?:\\w+))?)";
> 	}
> 	else {
> 		$FreeLinkPattern .= ")";
> 	}
> 	
> 	$FreeLinkPattern .= $QDelim;
> 
> 	# Url-style links are delimited by one of:
> 	#   1.  Whitespace                           (kept in output)
> 	#   2.  Left or right angle-bracket (< or >) (kept in output)
> 	#   3.  Right square-bracket (])             (kept in output)
> 	#   4.  A single double-quote (")            (kept in output)
> 	#   5.  A $FS (field separator) character    (kept in output)
> 	#   6.  A double double-quote ("")           (removed from output)
> 	$UrlProtocols    = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|prospero|telnet|gopher";
> 	$UrlProtocols   .= '|file' if ( $NetworkFile || !$LimitFileUrl );
> 	
> 	$UrlPattern      = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
> 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
> 	$DownloadExtensions = "(pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)";
> 	$RFCPattern      = "RFC\\s?(\\d+)";
> 	$ISBNPattern     = "ISBN:?([0-9- xX]{10,})";
> 	$UploadPattern   = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
329,350c405,425
<   my ($query, $idFile, $text);
< 
<   return 0  if (!$UseCache);
<   $query = $ENV{'QUERY_STRING'};
<   if (($query eq "") && ($ENV{'REQUEST_METHOD'} eq "GET")) {
<     $query = $HomePage;  # Allow caching of home page.
<   }
<   if (!($query =~ /^$LinkPattern$/)) {
<     if (!($FreeLinks && ($query =~ /^$FreeLinkPattern$/))) {
<       return 0;  # Only use cache for simple links
<     }
<   }
<   $idFile = &GetHtmlCacheFile($query);
<   if (-f $idFile) {
<     local $/ = undef;   # Read complete files
<     open(INFILE, "<$idFile") or return 0;
<     $text = <INFILE>;
<     close INFILE;
<     print $text;
<     return 1;
<   }
<   return 0;
---
> 	my ( $query, $idFile, $text );
> 	return 0 if ( !$UseCache );
> 	$query = $ENV{'QUERY_STRING'};
> 	if ( ( $query eq "" ) && ( $ENV{'REQUEST_METHOD'} eq "GET" ) ) {
> 		$query = $HomePage;    # Allow caching of home page.
> 	}
> 	if ( !( $query =~ /^$LinkPattern$/ ) ) {
> 		if ( !( $FreeLinks && ( $query =~ /^$FreeLinkPattern$/ ) ) ) {
> 			return 0;          # Only use cache for simple links
> 		}
> 	}
> 	$idFile = &GetHtmlCacheFile($query);
> 	if ( -f $idFile ) {
> 		local $/ = undef;      # Read complete files
> 		open( INFILE, "<$idFile" ) or return 0;
> 		$text = <INFILE>;
> 		close INFILE;
> 		print $text;
> 		return 1;
> 	}
> 	return 0;
354,356c429,430
<   my ($id) = @_;
< 
<   return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
---
> 	my ($id) = @_;
> 	return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
360,365c434,438
<   my ($id) = @_;
< 
<   if ($id =~ /^([a-zA-Z])/) {
<     return uc($1);
<   }
<   return "other";
---
> 	my ($id) = @_;
> 	if ( $id =~ /^([a-zA-Z])/ ) {
> 		return uc($1);
> 	}
> 	return "other";
369,374c442,446
<   my ($text) = @_;
< 
<   if (defined($Translate{$text}) && ($Translate{$text} ne ''))  {
<     return $Translate{$text};
<   }
<   return $text;
---
> 	my ($text) = @_;
> 	if ( defined( $Translate{$text} ) && ( $Translate{$text} ne "" ) ) {
> 		return $Translate{$text};
> 	}
> 	return $text;
378,382c450,453
<   my ($text, $string) = @_;
< 
<   $text = T($text);
<   $text =~ s/\%s/$string/;
<   return $text;
---
> 	my ( $text, $string ) = @_;
> 	$text = T($text);
> 	$text =~ s/\%s/$string/;
> 	return $text;
386,390c457,460
<   my $text = @_[0];
< 
<   $text = T($text);
<   $text =~ s/\%([1-9])/$_[$1]/ge;
<   return $text;
---
> 	my $text = @_[0];
> 	$text = T($text);
> 	$text =~ s/\%([1-9])/$_[$1]/ge;
> 	return $text;
394c464,465
< $BrowseCode = ""; # Comment next line to always compile (slower)
---
> $BrowseCode = "";    # Comment next line to always compile (slower)
> 
400,426c471,512
<   my @ScriptPath = split('/', "$ENV{SCRIPT_NAME}");
< 
<   $CGI::POST_MAX = $MaxPost;
<   if ($UseUpload) {
<     $CGI::DISABLE_UPLOADS = 0;  # allow uploads
<   } else {
<     $CGI::DISABLE_UPLOADS = 1;  # no uploads
<   }
<   $q = new CGI;
<   # Fix some issues with editing UTF8 pages (if charset specified)
<   if ($HttpCharset ne '') {
<     $q->charset($HttpCharset);
<   }
<   $Now = time;                     # Reset in case script is persistent
<   $ScriptName = pop(@ScriptPath);  # Name used in links
<   $IndexInit = 0;                  # Must be reset for each request
<   $InterSiteInit = 0;
<   %InterSite = ();
<   $MainPage = ".";       # For subpages only, the name of the top-level page
<   $OpenPageName = "";    # Currently open page
<   &CreateDir($DataDir);  # Create directory if it doesn't exist
<   if (!-d $DataDir) {
<     &ReportError(Ts('Could not create %s', $DataDir) . ": $!");
<     return 0;
<   }
<   &InitCookie();         # Reads in user data
<   return 1;
---
> 	my @ScriptPath = split( '/', "$ENV{SCRIPT_NAME}" );
> 	$CGI::POST_MAX = $MaxPost;
> 	
> 	if ($UseUpload) {
> 		$CGI::DISABLE_UPLOADS = 0;    # allow uploads
> 	}
> 	else {
> 		$CGI::DISABLE_UPLOADS = 1;    # no uploads
> 	}
> 	
> 	if ($SlashLinks && length($ENV{'PATH_INFO'}>1)){
> 		$ENV{'QUERY_STRING'} .= '&' if($ENV{'QUERY_STRING'});
> 		$ENV{'QUERY_STRING'} .= substr($ENV{'PATH_INFO'},1);
> 	}
> 	
> 	$q = new CGI();
> 	
> 	if ($SlashLinks){
> 		my $numberOfSlashes = ($ENV{'PATH_INFO'} = tr[/][/]);
> 		$ScriptName = ('../' x $numberOfSlashes) . $ScriptName;
> 	}
> 
> 	# Fix some issues with editing UTF8 pages (if charset specified)
> 	if ( $HttpCharset ne "" ) {
> 		$q->charset($HttpCharset);
> 	}
> 	$Now           = time;                # Reset in case script is persistent
> 	$ScriptName    = pop(@ScriptPath);    # Name used in links
> 		
> 	$IndexInit     = 0;                   # Must be reset for each request
> 	$InterSiteInit = 0;
> 	%InterSite     = ();
> 	$MainPage     = ".";    # For subpages only, the name of the top-level page
> 	$OpenPageName = "";     # Currently open page
> 	&CreateDir($DataDir);   # Create directory if it doesn't exist
> 
> 	if ( !-d $DataDir ) {
> 		&ReportError( "Could not create $DataDir : $!" );
> 		return 0;
> 	}
> 	&InitCookie();          # Reads in user data
> 	return 1;
430,451c516,539
<   %SetCookie = ();
<   $TimeZoneOffset = 0;
<   undef $q->{'.cookies'};  # Clear cache if it exists (for SpeedyCGI)
<   %UserData = ();          # Fix for persistent environments.
<   %UserCookie = $q->cookie($CookieName);
<   $UserID = $UserCookie{'id'};
<   $UserID =~ s/\D//g;  # Numeric only
<   if ($UserID < 200) {
<     $UserID = 111;
<   } else {
<     &LoadUserData($UserID);
<   }
<   if ($UserID > 199) {
<     if (($UserData{'id'}       != $UserCookie{'id'})      ||
<         ($UserData{'randkey'}  != $UserCookie{'randkey'})) {
<       $UserID = 113;
<       %UserData = ();   # Invalid.  Consider warning message.
<     }
<   }
<   if ($UserData{'tzoffset'} != 0) {
<     $TimeZoneOffset = $UserData{'tzoffset'} * (60 * 60);
<   }
---
> 	%SetCookie      = ();
> 	$TimeZoneOffset = 0;
> 	undef $q->{'.cookies'};    # Clear cache if it exists (for SpeedyCGI)
> 	%UserData   = ();                        # Fix for persistent environments.
> 	%UserCookie = $q->cookie($CookieName);
> 	$UserID     = $UserCookie{'id'};
> 	$UserID =~ s/\D//g;                      # Numeric only
> 	if ( $UserID < 200 ) {
> 		$UserID = 111;
> 	}
> 	else {
> 		&LoadUserData($UserID);
> 	}
> 	if ( $UserID > 199 ) {
> 		if (   ( $UserData{'id'} != $UserCookie{'id'} )
> 			|| ( $UserData{'randkey'} != $UserCookie{'randkey'} ) )
> 		{
> 			$UserID   = 113;
> 			%UserData = ();    # Invalid.  Consider warning message.
> 		}
> 	}
> 	if ( $UserData{'tzoffset'} != 0 ) {
> 		$TimeZoneOffset = $UserData{'tzoffset'} * ( 60 * 60 );
> 	}
455,493c543,587
<   my ($id, $action, $text);
< 
<   if (!$q->param) {             # No parameter
<     &BrowsePage($HomePage);
<     return 1;
<   }
<   $id = &GetParam('keywords', '');
<   if ($id) {                    # Just script?PageName
<     if ($FreeLinks && (!-f &GetPageFile($id))) {
<       $id = &FreeToNormal($id);
<     }
<     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
<       $id = $NotFoundPg;
<     }
<     &BrowsePage($id)  if &ValidIdOrDie($id);
<     return 1;
<   }
<   $action = lc(&GetParam('action', ''));
<   $id = &GetParam('id', '');
<   if ($action eq 'browse') {
<     if ($FreeLinks && (!-f &GetPageFile($id))) {
<       $id = &FreeToNormal($id);
<     }
<     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
<       $id = $NotFoundPg;
<     }
<     &BrowsePage($id)  if &ValidIdOrDie($id);
<     return 1;
<   } elsif ($action eq 'rc') {
<     &BrowsePage($RCName);
<     return 1;
<   } elsif ($action eq 'random') {
<     &DoRandom();
<     return 1;
<   } elsif ($action eq 'history') {
<     &DoHistory($id)   if &ValidIdOrDie($id);
<     return 1;
<   }
<   return 0;  # Request not handled
---
> 	my ( $id, $action, $text );
> 	if ( !$q->param ) {        # No parameter
> 		&BrowsePage($HomePage);
> 		return 1;
> 	}
> 	$id = &GetParam( 'keywords', "" );
> 	if ($id) {                 # Just script?PageName
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	$action = lc( &GetParam( 'action', "" ) );
> 	$id = &GetParam( 'id', "" );
> 	if ( $action eq 'browse' ) {
> 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
> 			$id = &FreeToNormal($id);
> 		}
> 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
> 			$id = $NotFoundPg;
> 		}
> 		&BrowsePage($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	elsif ( $action eq 'rc' ) {
> 		&BrowsePage($RCName);
> 		return 1;
> 	}
> 	elsif ( $action eq 'random' ) {
> 		&DoRandom();
> 		return 1;
> 	}
> 	elsif ($action eq 'orphans') {
> 		&DoOrphanList();
> 		return 1;
> 	} 
> 	elsif ($action eq 'history') {
> 		&DoHistory($id) if &ValidIdOrDie($id);
> 		return 1;
> 	}
> 	return 0;    # Request not handled
497,590c591,748
<   my ($id) = @_;
<   my ($fullHtml, $oldId, $allDiff, $showDiff, $openKept);
<   my ($revision, $goodRevision, $diffRevision, $newText);
< 
<   &OpenPage($id);
<   &OpenDefaultText();
<   $openKept = 0;
<   $revision = &GetParam('revision', '');
<   $revision =~ s/\D//g;           # Remove non-numeric chars
<   $goodRevision = $revision;      # Non-blank only if exists
<   if ($revision ne '') {
<     &OpenKeptRevisions('text_default');
<     $openKept = 1;
<     if (!defined($KeptRevisions{$revision})) {
<       $goodRevision = '';
<     } else {
<       &OpenKeptRevision($revision);
<     }
<   }
<   # Raw mode: just untranslated wiki text
<   if (&GetParam('raw', 0)) {
<      print &GetHttpHeader('text/plain');
<      print $Text{'text'};
<      return;
<   }
<   $newText = $Text{'text'};     # For differences
<   # Handle a single-level redirect
<   $oldId = &GetParam('oldid', '');
<   if (($oldId eq '') && (substr($Text{'text'}, 0, 10) eq '#REDIRECT ')) {
<     $oldId = $id;
<     if (($FreeLinks) && ($Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/)) {
<       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/);
<       $id = &FreeToNormal($id);
<     } else {
<       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+(\S+)/);
<     }
<     if (&ValidId($id) eq '') {
<       # Consider revision in rebrowse?
<       &ReBrowsePage($id, $oldId, 0);
<       return;
<     } else {  # Not a valid target, so continue as normal page
<       $id = $oldId;
<       $oldId = '';
<     }
<   }
<   $MainPage = $id;
<   $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
<   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId);
<   if ($revision ne '') {
<     if (($revision eq $Page{'revision'}) || ($goodRevision ne '')) {
<       $fullHtml .= '<b>' . Ts('Showing revision %s', $revision) . "</b><br>";
<     } else {
<       $fullHtml .= '<b>' . Ts('Revision %s not available', $revision)
<                    . ' (' . T('showing current revision instead')
<                    . ')</b><br>';
<     }
<   }
<   $allDiff  = &GetParam('alldiff', 0);
<   if ($allDiff != 0) {
<     $allDiff = &GetParam('defaultdiff', 1);
<   }
<   if ((($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName))
<       && &GetParam('norcdiff', 1)) {
<     $allDiff = 0;  # Only show if specifically requested
<   }
<   $showDiff = &GetParam('diff', $allDiff);
<   if ($UseDiff && $showDiff) {
<     $diffRevision = $goodRevision;
<     $diffRevision = &GetParam('diffrevision', $diffRevision);
<     # Eventually try to avoid the following keep-loading if possible?
<     &OpenKeptRevisions('text_default')  if (!$openKept);
<     $fullHtml .= &GetDiffHTML($showDiff, $id, $diffRevision,
<                               $revision, $newText);
<     $fullHtml .= "<hr class=wikilinediff>\n";
<   }
<   $fullHtml .= '<div class=wikitext>';
<   $fullHtml .= &WikiToHTML($Text{'text'});
<   $fullHtml .= '</div>';
<   if (!&GetParam('embed', $EmbedWiki)) {
<     $fullHtml .= "<hr class=wikilinefooter>\n";
<   }
<   if (($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName)) {
<     print $fullHtml;
<     print '<div class=wikirc>';
<     &DoRc(1);
<     print '</div>';
<     print "<hr class=wikilinefooter>\n"  if (!&GetParam('embed', $EmbedWiki));
<     print &GetFooterText($id, $goodRevision);
<     return;
<   }
<   $fullHtml .= &GetFooterText($id, $goodRevision);
<   print $fullHtml;
<   return  if ($showDiff || ($revision ne ''));  # Don't cache special version
<   &UpdateHtmlCache($id, $fullHtml)  if ($UseCache && ($oldId eq ''));
---
> 	my ($id) = @_;
> 	my ( $fullHtml, $oldId, $allDiff, $showDiff, $openKept );
> 	my ( $revision, $goodRevision, $diffRevision, $newText );
> 	my ( $fragHtml );
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$openKept = 0;
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	$goodRevision = $revision;    # Non-blank only if exists
> 
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		$openKept = 1;
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$goodRevision = "";
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 		}
> 	}
> 
> 	# Raw mode: just untranslated wiki text
> 	if ( &GetParam( 'raw', 0 ) ) {
> 		print &GetHttpHeader('text/plain');
> 		print $Text{'text'};
> 		return;
> 	}
> 	$newText = $Text{'text'};              # For differences
> 	                                       # Handle a single-level redirect
> 	$oldId   = &GetParam( 'oldid', "" );
> 	if (   ( $oldId eq "" )
> 		&& ( substr( $Text{'text'}, 0, 10 ) eq '#REDIRECT ' ) )
> 	{
> 		$oldId = $id;
> 		if ( ($FreeLinks) && ( $Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/ ) ) {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/ );
> 			$id = &FreeToNormal($id);
> 		}
> 		else {
> 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+(\S+)/ );
> 		}
> 		if ( &ValidId($id) eq "" ) {
> 
> 			# Consider revision in rebrowse?
> 			&ReBrowsePage( $id, $oldId, 0 );
> 			return;
> 		}
> 		else {    # Not a valid target, so continue as normal page
> 			$id    = $oldId;
> 			$oldId = "";
> 		}
> 	}
> 	$MainPage = $id;
> 	$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 	$fullHtml = &GetHeader( $id, &QuoteHtml($id), $oldId );
> 
> 	unless( $id eq $RCName ){ $fullHtml .= &GetLeftNav($id); }
> 	if ( $UseDiff && $showDiff ) {
> 		$fullHtml .= "\n<div class='wikiadmin'>";
> 	}
> 	else {
> 		unless ($id eq $RCName){ $fullHtml .= "\n<div class='wikitext'>"; }
> 		else { $fullHtml .= "\n<div class='wikiadmin'>"; }
> 	}
> 	
> 		if ( $revision ne "" ) {
> 		if ( ( $revision eq $Page{'revision'} ) || ( $goodRevision ne "" ) ) {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Showing revision $revision.</div>";
> 		}
> 		else {
> 			$fragHtml = "\n<div class='wikidifftexttitle'>Revision $revision not available, showing current revision instead.</div>";
> 		}
> 	}
> 	
> 	$fullHtml .= $fragHtml;
> 	
> 	$allDiff = &GetParam( 'alldiff', 0 );
> 	if ( $allDiff != 0 ) {
> 		$allDiff = &GetParam( 'defaultdiff', 1 );
> 	}
> 	
> 	if (
> 		(
> 			( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName )
> 		)
> 		&& &GetParam( 'norcdiff', 1 )
> 	  )
> 	{
> 		$allDiff = 0;    # Only show if specifically requested
> 	}
> 	
> 	$showDiff = &GetParam( 'diff', $allDiff );
> 	
> 	if ( $UseDiff && $showDiff ) {
> 		$diffRevision = $goodRevision;
> 		$diffRevision = &GetParam( 'diffrevision', $diffRevision );
> 
> 		# Eventually try to avoid the following keep-loading if possible?
> 		&OpenKeptRevisions('text_default') if ( !$openKept );
> 		$fullHtml .= &GetDiffHTML( $showDiff, $id, $diffRevision, $revision, $newText );
> 		$fullHtml .= $fragHtml;
> 
> 	}
> 
> 	# magiccontent patch - tarquin
> 	# Refactored and added position functionality --DavidClaughton.
> 	my ($magiccommand, $magicpos, $magicparams);
> 	my ($magicHTML, $magicDiv, $wikiHTML) = ("", "", "");
> 	if ( ($magicpos, $magiccommand, $magicparams) = $Text{'text'} =~ m[^\#MAGIC\s*(?:\@(top|bottom))?\s*(\w*)\s*(.*)\n] ){
> 		$Text{'text'} =~ s/^\#MAGIC.*\n//; # kill the magic command line in source
> 		$wikiHTML = &WikiToHTML($Text{'text'});
> 		
> 		#$magicDiv = "\n<hr>\n"; # Remove if using CSS.
> 		
> 		# call: MakeSection( current page, magic module, line of parameters)
> 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
> 		
> 		if (lc $magicpos eq "top"){
> 			$fullHtml .= $magicHTML . $magicDiv . $wikiHTML;
> 		}
> 		else {
> 			$fullHtml .= $wikiHTML . $magicDiv . $magicHTML;
> 		}
> 	}
> 	else {
> 		$fullHtml .= &WikiToHTML($Text{'text'});
> 	}
> 	
> 	if ( !&GetParam( 'embed', $EmbedWiki ) ) {
> 		$fullHtml .= "</div>";
> 		$fullHtml .= $WikiLineFooter;
> 	}
> 
> 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) )
> 	{
> 		print $fullHtml;
> 		print $WikiLineDiff;
> 		print &GetLeftNav($id);
> 		print "\n<div class='wikidiff'>";
> 		&DoRc(1);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter" if ( !&GetParam( 'embed', $EmbedWiki ) );
> 
> 		print &GetFooterText( $id, $goodRevision );
> 		print "\n</div></div></div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$fullHtml .= &GetFooterText( $id, $goodRevision );
> 	$fullHtml .= "</div></div></div></div></body></html>";
> 	print $fullHtml;
> 	
> 	return
> 	
> 	if ( $showDiff || ( $revision ne "" ) );    # Don't cache special version
> 	&UpdateHtmlCache( $id, $fullHtml ) if ( $UseCache && ( $oldId eq "" ) );
594,601c752,759
<   my ($id, $oldId, $isEdit) = @_;
< 
<   if ($oldId ne "") {   # Target of #REDIRECT (loop breaking)
<     print &GetRedirectPage("action=browse&id=$id&oldid=$oldId",
<                            $id, $isEdit);
<   } else {
<     print &GetRedirectPage($id, $id, $isEdit);
<   }
---
> 	my ( $id, $oldId, $isEdit ) = @_;
> 	if ( $oldId ne "" ) {    
> 		# Target of #REDIRECT (loop breaking)
> 		print &GetRedirectPage( "action=browse&id=$id&oldid=$oldId", $id, $isEdit );
> 	}
> 	else {
> 		print &GetRedirectPage( $id, $id, $isEdit );
> 	}
605,731c763,921
<   my ($rcType) = @_;   # 0 = RSS, 1 = HTML
<   my ($fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly);
<   my (@fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML);
<   my $starttime = 0;
<   my $showbar = 0;
< 
<   if (0 == $rcType) {
<     $showHTML = 0;
<   } else {
<     $showHTML = 1;
<   }
<   if (&GetParam("from", 0)) {
<     $starttime = &GetParam("from", 0);
<     if ($showHTML) {
<       print "<h2>" . Ts('Updates since %s', &TimeToText($starttime))
<             . "</h2>\n";
<     }
<   } else {
<     $daysago = &GetParam("days", 0);
<     $daysago = &GetParam("rcdays", 0)  if ($daysago == 0);
<     if ($daysago) {
<       $starttime = $Now - ((24*60*60)*$daysago);
<       if ($showHTML) {
<         print "<h2>" . Ts('Updates in the last %s day'
<                           . (($daysago != 1)?"s":""), $daysago) . "</h2>\n";
<       }
<       # Note: must have two translations (for "day" and "days")
<       # Following comment line is for translation helper script
<       # Ts('Updates in the last %s days', '');
<     }
<   }
<   if ($starttime == 0) {
<     if (0 == $rcType) {
<       $starttime = $Now - ((24*60*60)*$RssDays);
<     } else {
<       $starttime = $Now - ((24*60*60)*$RcDefault);
<     }
<     if ($showHTML) {
<       print "<h2>" . Ts('Updates in the last %s day'
<                         . (($RcDefault != 1)?"s":""), $RcDefault) . "</h2>\n";
<     }
<     # Translation of above line is identical to previous version
<   }
<   # Read rclog data (and oldrclog data if needed)
<   ($status, $fileData) = &ReadFile($RcFile);
<   $errorText = "";
<   if (!$status) {
<     # Save error text if needed.
<     $errorText = '<p><strong>' . Ts('Could not open %s log file', $RCName)
<                  . ":</strong> $RcFile<p>"
<                  . T('Error was') . ":\n<pre>$!</pre>\n" . '<p>'
<     . T('Note: This error is normal if no changes have been made.') . "\n";
<   }
<   @fullrc = split(/\n/, $fileData);
<   $firstTs = 0;
<   if (@fullrc > 0) {  # Only false if no lines in file
<     ($firstTs) = split(/$FS3/, $fullrc[0]);
<   }
<   if (($firstTs == 0) || ($starttime <= $firstTs)) {
<     ($status, $oldFileData) = &ReadFile($RcOldFile);
<     if ($status) {
<       @fullrc = split(/\n/, $oldFileData . $fileData);
<     } else {
<       if ($errorText ne "") {  # could not open either rclog file
<         print $errorText;
<         print "<p><strong>"
<               . Ts('Could not open old %s log file', $RCName)
<               . ":</strong> $RcOldFile<p>"
<               . T('Error was') . ":\n<pre>$!</pre>\n";
<         return;
<       }
<     }
<   }
<   $lastTs = 0;
<   if (@fullrc > 0) {  # Only false if no lines in file
<     ($lastTs) = split(/$FS3/, $fullrc[$#fullrc]);
<   }
<   $lastTs++  if (($Now - $lastTs) > 5);  # Skip last unless very recent
< 
<   $idOnly = &GetParam("rcidonly", "");
<   if ($idOnly && $showHTML) {
<     print '<b>(' . Ts('for %s only', &ScriptLink($idOnly, $idOnly))
<           . ')</b><br>';
<   }
<   if ($showHTML) {
<     foreach $i (@RcDays) {
<       print " | "  if $showbar;
<       $showbar = 1;
<       print &ScriptLink("action=rc&days=$i",
<                         Ts('%s day' . (($i != 1)?'s':''), $i));
<         # Note: must have two translations (for "day" and "days")
<         # Following comment line is for translation helper script
<         # Ts('%s days', '');
<     }
<     print "<br>" . &ScriptLink("action=rc&from=$lastTs",
<                                T('List new changes starting from'));
<     print " " . &TimeToText($lastTs) . "<br>\n";
<   }
<   $i = 0;
<   while ($i < @fullrc) {  # Optimization: skip old entries quickly
<     ($ts) = split(/$FS3/, $fullrc[$i]);
<     if ($ts >= $starttime) {
<       $i -= 1000  if ($i > 0);
<       last;
<     }
<     $i += 1000;
<   }
<   $i -= 1000  if (($i > 0) && ($i >= @fullrc));
<   for (; $i < @fullrc ; $i++) {
<     ($ts) = split(/$FS3/, $fullrc[$i]);
<     last if ($ts >= $starttime);
<   }
<   if ($i == @fullrc && $showHTML) {
<     print '<br><strong>' . Ts('No updates since %s',
<                               &TimeToText($starttime)) . "</strong><br>\n";
<   } else {
<     splice(@fullrc, 0, $i);  # Remove items before index $i
<     # Consider an end-time limit (items older than X)
<     if (0 == $rcType) {
<       print &GetRcRss(@fullrc);
<     } else {
<       print &GetRcHtml(@fullrc);
<     }
<   }
<   if ($showHTML) {
<     print '<p>' . Ts('Page generated %s', &TimeToText($Now)), "<br>\n";
<   }
---
> 	my ($rcType) = @_;       # 0 = RSS, 1 = HTML
> 	my ( $fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly );
> 	my ( @fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML );
> 	my $starttime = 0;
> 	my $showbar   = 0;
> 	if ( 0 == $rcType ) {
> 		$showHTML = 0;
> 	}
> 	else {
> 		$showHTML = 1;
> 	}
> 	if ( &GetParam( "from", 0 ) ) {
> 		$starttime = &GetParam( "from", 0 );
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print "\nUpdates since " . &TimeToText($starttime);
> 			print "\n</h2>";
> 		}
> 	}
> 	else {
> 		$daysago = &GetParam( "days", 0 );
> 		$daysago = &GetParam( "rcdays", 0 ) if ( $daysago == 0 );
> 		if ($daysago) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $daysago );
> 			if ($showHTML) {
> 				print "\n<h2>";
> 				print Ts( 'Updates in the last %s day' . ( ( $daysago != 1 ) ? "s" : "" ), $daysago );
> 				print "\n</h2>";
> 			}
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('Updates in the last %s days', '');
> 		}
> 	}
> 	if ( $starttime == 0 ) {
> 		if ( 0 == $rcType ) {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RssDays );
> 		}
> 		else {
> 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RcDefault );
> 		}
> 		if ($showHTML) {
> 			print "\n<h2>";
> 			print Ts('Updates in the last %s day'. ( ( $RcDefault != 1 ) ? "s" : "" ),$RcDefault );
> 			print "\n</h2>";
> 		}
> 
> 		# Translation of above line is identical to previous version
> 	}
> 
> 	# Read rclog data (and oldrclog data if needed)
> 	( $status, $fileData ) = &ReadFile($RcFile);
> 	$errorText = "";
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>";
> 		$errorText .= "Could not open $RCName log file";
> 		$errorText .= ":</strong> $RcFile</p>";
> 		$errorText .= "Error was ";
> 		$errorText .= ":<pre>$!</pre><p>";
> 		$errorText .= "Note: This error is normal if no changes have been made.";
> 
> 	}
> 	@fullrc = split( /\n/, $fileData );
> 	$firstTs = 0;
> 	if ( @fullrc > 0 ) {    # Only false if no lines in file
> 		($firstTs) = split( /$FS3/, $fullrc[0] );
> 	}
> 	if ( ( $firstTs == 0 ) || ( $starttime <= $firstTs ) ) {
> 		( $status, $oldFileData ) = &ReadFile($RcOldFile);
> 		if ($status) {
> 			@fullrc = split( /\n/, $oldFileData . $fileData );
> 		}
> 		else {
> 			if ( $errorText ne "" ) {    
> 			
> 				# could not open either rclog file
> 				print $errorText;
> 				print "\n<p><strong>";
> 				print "\nCould not open old $RCName log file";
> 				print "\n:</strong> $RcOldFile</p>";
> 				print "\nError was";
> 				print "\n:<pre>$!</pre>";
> 				
> 				return;
> 			}
> 		}
> 	}
> 	$lastTs = 0;
> 	if ( @fullrc > 0 ) {                 
> 		# Only false if no lines in file
> 		($lastTs) = split( /$FS3/, $fullrc[$#fullrc] );
> 	}
> 	$lastTs++ if ( ( $Now - $lastTs ) > 5 );    # Skip last unless very recent
> 	$idOnly = &GetParam( "rcidonly", "" );
> 	if ( $idOnly && $showHTML ) {
> 		print "\n<b>(";
> 		print "\nfor ";
> 		print &ScriptLink( $idOnly, $idOnly );
> 		print "\n only";
> 		print "\n)</b><br>";
> 	}
> 	if ($showHTML) {
> 		foreach $i (@RcDays) {
> 			print "\n | " if $showbar;
> 			$showbar = 1;
> 			print &ScriptLink( "action=rc&days=$i",
> 				Ts( '%s day' . ( ( $i != 1 ) ? 's' : '' ), $i ) );
> 
> 			# Note: must have two translations (for "day" and "days")
> 			# Following comment line is for translation helper script
> 			# Ts('%s days', '');
> 		}
> 		print "\n<br><br>";
> 		print &ScriptLink( "action=rc&from=$lastTs", "List new changes starting from" );
> 		print "\n " . &TimeToText($lastTs);
> 		print "\n<br><br>";
> 	}
> 	
> 	$i = 0;
> 	while ( $i < @fullrc ) {    
> 		# Optimization: skip old entries quickly
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		if ( $ts >= $starttime ) {
> 			$i -= 1000 if ( $i > 0 );
> 			last;
> 		}
> 		$i += 1000;
> 	}
> 	
> 	$i -= 1000 if ( ( $i > 0 ) && ( $i >= @fullrc ) );
> 	for ( ; $i < @fullrc ; $i++ ) {
> 		($ts) = split( /\W/, $fullrc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	if ( $i == @fullrc && $showHTML ) {
> 		print "\n<br><strong>";
> 		print "\nNo updates since ";
> 		print &TimeToText($starttime);
> 		print "\n</strong><br>";
> 	}
> 	else {
> 		splice( @fullrc, 0, $i );    # Remove items before index $i
> 		
> 		# Consider an end-time limit (items older than X)
> 		if ( 0 == $rcType ) {
> 			print &GetRcRss(@fullrc);
> 		}
> 		else {
> 			print &GetRcHtml(@fullrc);
> 		}
> 	}
> 	if ($showHTML) {
> 		print "\nPage generated ";
> 		print &TimeToText($Now);
> 		print "\n<br>";
> 	}
735,822c925,1029
<   my $rcType = shift;
<   my @outrc = @_;
<   my ($rcline, $date, $newtop, $author, $inlist, $result);
<   my ($showedit, $link, $all, $idOnly, $headItem, $item);
<   my ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp);
<   my ($rcchangehist, $tEdit, $tChanges, $tDiff);
<   my ($headList, $historyPrefix, $diffPrefix);
<   my %extra = ();
<   my %changetime = ();
<   my %pagecount = ();
< 
<   # Slice minor edits
<   $showedit = &GetParam("rcshowedit", $ShowEdits);
<   $showedit = &GetParam("showedit", $showedit);
<   if ($showedit != 1) {
<     my @temprc = ();
<     foreach $rcline (@outrc) {
<       ($ts, $pagename, $summary, $isEdit, $host) = split(/$FS3/, $rcline);
<       if ($showedit == 0) {  # 0 = No edits
<         push(@temprc, $rcline)  if (!$isEdit);
<       } else {               # 2 = Only edits
<         push(@temprc, $rcline)  if ($isEdit);
<       }
<     }
<     @outrc = @temprc;
<   }
<   # Optimize param fetches out of main loop
<   $rcchangehist = &GetParam("rcchangehist", 1);
<   # Optimize translations out of main loop
<   $tEdit    = T('(edit)');
<   $tDiff    = T('(diff)');
<   $tChanges = T('changes');
<   $diffPrefix = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
<   $historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
<   foreach $rcline (@outrc) {
<     ($ts, $pagename) = split(/$FS3/, $rcline);
<     $pagecount{$pagename}++;
<     $changetime{$pagename} = $ts;
<   }
<   $date = "";
<   $all = &GetParam("rcall", 0);
<   $all = &GetParam("all", $all);
<   $newtop = &GetParam("rcnewtop", $RecentTop);
<   $newtop = &GetParam("newtop", $newtop);
<   $idOnly = &GetParam("rcidonly", "");
<   $inlist = 0;
<   $headList = '';
<   $result = '';
<   @outrc = reverse @outrc if ($newtop);
<   foreach $rcline (@outrc) {
<     ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp)
<       = split(/$FS3/, $rcline);
<     next  if ((!$all) && ($ts < $changetime{$pagename}));
<     next  if (($idOnly ne "") && ($idOnly ne $pagename));
<     %extra = split(/$FS2/, $extraTemp, -1);
<     if ($date ne &CalcDay($ts)) {
<       $date = &CalcDay($ts);
<       if (1 == $rcType) {  # HTML
<         # add date, properly closing lists first
<         if ($inlist) {
<           $result .= "</UL>\n";
<           $inlist = 0;
<         }
<         $result .= "<p><strong>" . $date . "</strong></p>\n";
<         if (!$inlist) {
<           $result .= "<UL>\n";
<           $inlist = 1;
<         }
<       }
<     }
<     if (0 == $rcType) {  # RSS
<       ($headItem, $item) = &GetRssRcLine($pagename, $ts, $host,
<                               $extra{'name'}, $extra{'id'}, $summary, $isEdit,
<                               $pagecount{$pagename}, $extra{'revision'},
<                               $diffPrefix, $historyPrefix);
<       $headList .= $headItem;
<       $result   .= $item;
<     } else {  # HTML
<       $result .= &GetHtmlRcLine($pagename, $ts, $host, $extra{'name'},
<                          $extra{'id'}, $summary, $isEdit,
<                          $pagecount{$pagename}, $extra{'revision'},
<                          $tEdit, $tDiff, $tChanges, $all, $rcchangehist);
<     }
<   }
<   if (1 == $rcType) {
<     $result .= "</UL>\n"  if ($inlist);  # Close final tag
<   }
<   return ($headList, $result);  # Just ignore headList for HTML
---
> 	my $rcType = shift;
> 	my @outrc  = @_;
> 	my ( $rcline,   $date, $newtop, $author, $inlist,   $result );
> 	my ( $showedit, $link, $all,    $idOnly, $headItem, $item );
> 	my ( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp );
> 	my ( $rcchangehist, $tEdit, $tChanges, $tDiff );
> 	my ( $headList, $historyPrefix, $diffPrefix );
> 	my %extra      = ();
> 	my %changetime = ();
> 	my %pagecount  = ();
> 
> 	# Slice minor edits
> 	$showedit = &GetParam( "rcshowedit", $ShowEdits );
> 	$showedit = &GetParam( "showedit",   $showedit );
> 	if ( $showedit != 1 ) {
> 		my @temprc = ();
> 		foreach $rcline (@outrc) {
> 			( $ts, $pagename, $summary, $isEdit, $host ) =
> 			  split( /$FS3/, $rcline );
> 			if ( $showedit == 0 ) {    # 0 = No edits
> 				push( @temprc, $rcline ) if ( !$isEdit );
> 			}
> 			else {                     # 2 = Only edits
> 				push( @temprc, $rcline ) if ($isEdit);
> 			}
> 		}
> 		@outrc = @temprc;
> 	}
> 
> 	# Optimize param fetches out of main loop
> 	$rcchangehist = &GetParam( "rcchangehist", 1 );
> 
> 	# Optimize translations out of main loop
> 	$tEdit         = "(edit)";
> 	$tDiff         = "(diff)";
> 	$tChanges      = "changes";
> 	$diffPrefix    = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
> 	$historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
> 	
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename ) = split( /$FS3/, $rcline );
> 		$pagecount{$pagename}++;
> 		$changetime{$pagename} = $ts;
> 	}
> 	
> 	$date     = "";
> 	$all      = &GetParam( "rcall", 0 );
> 	$all      = &GetParam( "all", $all );
> 	$newtop   = &GetParam( "rcnewtop", $RecentTop );
> 	$newtop   = &GetParam( "newtop", $newtop );
> 	$idOnly   = &GetParam( "rcidonly", "" );
> 	$inlist   = 0;
> 	$headList = "";
> 	$result   = "";
> 	@outrc    = reverse @outrc if ($newtop);
> 
> 	foreach $rcline (@outrc) {
> 		( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp ) =
> 		  split( /$FS3/, $rcline );
> 		next if ( ( !$all ) && ( $ts < $changetime{$pagename} ) );
> 		next if ( ( $idOnly ne "" ) && ( $idOnly ne $pagename ) );
> 		%extra = split( /$FS2/, $extraTemp, -1 );
> 		if ( $date ne &CalcDay($ts) ) {
> 			$date = &CalcDay($ts);
> 			if ( 1 == $rcType ) {    # HTML
> 				                     # add date, properly closing lists first
> 				if ($inlist) {
> 					$result .= "</ul>";
> 					$inlist = 0;
> 				}
> 				$result .= "\n<p><strong>" . $date . "</strong></p>";
> 				if ( !$inlist ) {
> 					$result .= "\n<ul>";
> 					$inlist = 1;
> 				}
> 			}
> 		}
> 		if ( 0 == $rcType ) {        # RSS
> 			( $headItem, $item ) = &GetRssRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $diffPrefix,
> 				$historyPrefix
> 			);
> 			$headList .= $headItem;
> 			$result   .= $item;
> 		}
> 		else {                       # HTML
> 			$result .= &GetHtmlRcLine(
> 				$pagename,          $ts,
> 				$host,              $extra{'name'},
> 				$extra{'id'},       $summary,
> 				$isEdit,            $pagecount{$pagename},
> 				$extra{'revision'}, $tEdit,
> 				$tDiff,             $tChanges,
> 				$all,               $rcchangehist
> 			);
> 		}
> 	}
> 	if ( 1 == $rcType ) {
> 		$result .= "</ul>" if ($inlist);    # Close final tag
> 	}
> 	return ( $headList, $result );            # Just ignore headList for HTML
826,829c1033,1035
<   my ($html, $extra);
< 
<   ($extra, $html) = &GetRc(1, @_);
<   return $html;
---
> 	my ( $html, $extra );
> 	( $extra, $html ) = &GetRc( 1, @_ );
> 	return $html;
833,870c1039,1084
<   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
<       $isEdit, $pagecount, $revision, $tEdit, $tDiff, $tChanges, $all,
<       $rcchangehist) = @_;
<   my ($author, $sum, $edit, $count, $link, $html);
< 
<   $html = '';
<   $host = &QuoteHtml($host);
<   if (defined($userName) && defined($userID)) {
<     $author = &GetAuthorLink($host, $userName, $userID);
<   } else {
<     $author = &GetAuthorLink($host, "", 0);
<   }
<   $sum = "";
<   if (($summary ne "") && ($summary ne "*")) {
<     $summary = &QuoteHtml($summary);
<     $sum = "<strong>[$summary]</strong> ";
<   }
<   $edit = "";
<   $edit = "<em>$tEdit</em> "  if ($isEdit);
<   $count = "";
<   if ((!$all) && ($pagecount > 1)) {
<     $count = "($pagecount ";
<     if ($rcchangehist) {
<       $count .= &GetHistoryLink($pagename, $tChanges);
<     } else {
<       $count .= $tChanges;
<     }
<     $count .= ") ";
<   }
<   $link = "";
<   if ($UseDiff && &GetParam("diffrclink", 1)) {
<     $link .= &ScriptLinkDiff(4, $pagename, $tDiff, "") . "  ";
<   }
<   $link .= &GetPageLink($pagename);
<   $html .= "<li>$link ";
<   $html .=  &CalcTime($timestamp) . " $count$edit" . " $sum";
<   $html .= ". . . . . $author\n";
<   return $html;
---
> 	my (
> 		$pagename, $timestamp, $host,      $userName, $userID,
> 		$summary,  $isEdit,    $pagecount, $revision, $tEdit,
> 		$tDiff,    $tChanges,  $all,       $rcchangehist
> 	  )
> 	  = @_;
> 	my ( $author, $sum, $edit, $count, $link, $html );
> 	
> 	$html = "";
> 	$host = &QuoteHtml($host);
> 	if ( defined($userName) && defined($userID) ) {
> 		$author = &GetAuthorLink( $host, $userName, $userID );
> 	}
> 	else {
> 		$author = &GetAuthorLink( $host, "", 0 );
> 	}
> 	
> 	$sum = "";
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);
> 		$sum     = "<strong>[$summary]</strong> ";
> 	}
> 	
> 	$edit  = "";
> 	$edit  = "<em>$tEdit</em> " if ($isEdit);
> 	$count = "";	
> 	if ( ( !$all ) && ( $pagecount > 1 ) ) {
> 		$count = "($pagecount ";
> 		if ($rcchangehist) {
> 			$count .= &GetHistoryLink( $pagename, $tChanges, "Click to view revision history" );
> 		}
> 		else {
> 			$count .= $tChanges;
> 		}
> 		$count .= ") ";
> 	}
> 	
> 	$link = "";
> 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) {
> 		$link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  ";
> 	}
> 	$link .= &GetPageLink($pagename);
> 	$html .= "\n<li>$link ";
> 	$html .= &CalcTime($timestamp) . " : $count$edit" . " $sum";
> 	$html .= ". . . . . $author";
> 	return $html;
874,883c1088,1096
<   my ($rssHeader, $headList, $items);
< 
<   # Normally get URL from script, but allow override
<   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
<   $QuotedFullUrl = &QuoteHtml($FullUrl);
<   $SiteDescription = &QuoteHtml($SiteDescription);
< 
<   my $ChannelAbout = &QuoteHtml($FullUrl . &ScriptLinkChar()
<                                 . $ENV{QUERY_STRING});
<   $rssHeader = <<RSS ;
---
> 	my ( $rssHeader, $headList, $items );
> 
> 	# Normally get URL from script, but allow override
> 	$FullUrl         = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$QuotedFullUrl   = &QuoteHtml($FullUrl);
> 	$SiteDescription = &QuoteHtml($SiteDescription);
> 	my $ChannelAbout =
> 	  &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
> 	$rssHeader = <<RSS ;
903,905c1116,1118
<   ($headList, $items) = &GetRc(0, @_);
<   $rssHeader .= $headList;
<   return <<RSS ;
---
> 	( $headList, $items ) = &GetRc( 0, @_ );
> 	$rssHeader .= $headList;
> 	return <<RSS ;
920,951c1133,1173
< sub GetRssRcLine{
<   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
<       $isEdit, $pagecount, $revision, $diffPrefix, $historyPrefix) = @_;
<   my ($itemID, $description, $authorLink, $author, $status,
<       $importance, $date, $item, $headItem);
< 
<   # Add to list of items in the <channel/>
<   $itemID = $FullUrl . &ScriptLinkChar()
<             . &GetOldPageParameters('browse', $pagename, $revision);
<   $itemID = &QuoteHtml($itemID);
<   $headItem = "                <rdf:li rdf:resource=\"$itemID\"/>\n";
<   # Add to list of items proper.
<   if (($summary ne "") && ($summary ne "*")) {
<     $description = &QuoteHtml($summary);
<   }
<   $host = &QuoteHtml($host);
<   if ($userName) {
<     $author = &QuoteHtml($userName);
<     $authorLink = "link=\"$QuotedFullUrl?$author\"";
<   } else {
<     $author = $host;
<   }
<   $status = (1 == $revision) ? 'new' : 'updated';
<   $importance = $isEdit ? 'minor' : 'major';
<   $timestamp += $TimeZoneOffset;
<   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($timestamp);
<   $year += 1900;
<   $date = sprintf("%4d-%02d-%02dT%02d:%02d:%02d+%02d:00",
<     $year, $mon+1, $mday, $hour, $min, $sec, $TimeZoneOffset/(60*60));
<   $pagename = &QuoteHtml($pagename);
<   # Write it out longhand
<   $item = <<RSS ;
---
> sub GetRssRcLine {
> 	my (
> 		$pagename, $timestamp,  $host,   $userName,
> 		$userID,   $summary,    $isEdit, $pagecount,
> 		$revision, $diffPrefix, $historyPrefix
> 	  )
> 	  = @_;
> 	my (
> 		$itemID,     $description, $authorLink, $author, $status,
> 		$importance, $date,        $item,       $headItem
> 	);
> 
> 	# Add to list of items in the <channel/>
> 	$itemID = $FullUrl
> 	  . &ScriptLinkChar()
> 	  . &GetOldPageParameters( 'browse', $pagename, $revision );
> 	$itemID   = &QuoteHtml($itemID);
> 	$headItem = "                <rdf:li rdf:resource=\"$itemID\"/>";
> 
> 	# Add to list of items proper.
> 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$description = &QuoteHtml($summary);
> 	}
> 	$host = &QuoteHtml($host);
> 	if ($userName) {
> 		$author     = &QuoteHtml($userName);
> 		$authorLink = "link=\"$QuotedFullUrl?$author\"";
> 	}
> 	else {
> 		$author = $host;
> 	}
> 	$status     = ( 1 == $revision ) ? 'new'   : 'updated';
> 	$importance = $isEdit            ? 'minor' : 'major';
> 	$timestamp += $TimeZoneOffset;
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($timestamp);
> 	$year += 1900;
> 	$date = sprintf( "%4d-%02d-%02dT%02d:%02d:%02d+%02d:00", $year, $mon + 1, $mday, $hour, $min, $sec, $TimeZoneOffset / ( 60 * 60 ) );
> 	$pagename = &QuoteHtml($pagename);
> 
> 	# Write it out longhand
> 	$item = <<RSS ;
969c1191
<   return ($headItem, $item);
---
> 	return ( $headItem, $item );
973,974c1195,1196
<   print "Content-type: text/xml\n\n";
<   &DoRc(0);
---
> 	print "\nContent-type: text/xml\n\n";
> 	&DoRc(0);
978,982c1200,1205
<   my ($id, @pageList);
< 
<   @pageList = &AllPagesList();  # Optimize?
<   $id = $pageList[int(rand($#pageList + 1))];
<   &ReBrowsePage($id, "", 0);
---
> 	my ( $id, @pageList );
> 	
> 	@pageList = &AllPagesList();                              # Optimize?
> 	$id       = $pageList[ int( rand( $#pageList + 1 ) ) ];
> 	
> 	&ReBrowsePage( $id, "", 0 );
984a1207
>    
986,1018c1209,1250
<   my ($id) = @_;
<   my ($html, $canEdit, $row, $newText);
< 
<   print &GetHeader('', Ts('History of %s', $id), '') . '<br>';
<   &OpenPage($id);
<   &OpenDefaultText();
<   $newText = $Text{'text'};
<   $canEdit = 0;
<   $canEdit = &UserCanEdit($id)  if ($HistoryEdit);
<   if ($UseDiff) {
<     print <<EOF ;
<       <form action='$ScriptName' METHOD='GET'>
<           <input type='hidden' name='action' value='browse'/>
<           <input type='hidden' name='diff' value='1'/>
<           <input type='hidden' name='id' value='$id'/>
<       <table border='0' width='100%'><tr>
< EOF
<   }
<   $html = &GetHistoryLine($id, $Page{'text_default'}, $canEdit, $row++);
<   &OpenKeptRevisions('text_default');
<   foreach (reverse sort {$a <=> $b} keys %KeptRevisions) {
<     next  if ($_ eq "");  # (needed?)
<     $html .= &GetHistoryLine($id, $KeptRevisions{$_}, $canEdit, $row++);
<   }
<   print $html;
<   if ($UseDiff) {
<     my $label = T('Compare');
<     print "<tr><td align='center'><input type='submit' "
<           . "value='$label'/>&nbsp;&nbsp;</td></table></form>\n";
<     print "<hr class=wikilinediff>\n";
<     print &GetDiffHTML(&GetParam('defaultdiff', 1), $id, '', '', $newText);
<   }
<   print &GetCommonFooter();
---
> 	my ($id) = @_;
> 	my ( $html, $canEdit, $row, $newText );
> 
> 	print &GetHeader( "", Ts( 'History of %s', $id ), "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikiadmin'>";
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$newText = $Text{'text'};
> 	$canEdit = 0;
> 	$canEdit = &UserCanEdit($id) if ($HistoryEdit);
> 		
> 	if ($UseDiff) {
>       print "\n<form id='wikiform' action='$ScriptName' method='get'>";
>       print "\n<input type='hidden' name='action' value='browse'/>";
>       print "\n<input type='hidden' name='diff' value='1'/>";
>       print "\n<input type='hidden' name='id' value=\"$id\"/>";
>       print "\n<table class='wikihistory' border='0'>";
> 	}
> 	
> 	$html = &GetHistoryLine( $id, $Page{'text_default'}, $canEdit, $row++ );
> 	&OpenKeptRevisions('text_default');
> 	
> 	foreach ( reverse sort { $a <=> $b } keys %KeptRevisions ) {
> 		next if ( $_ eq "" );    # (needed?)
> 		$html .= &GetHistoryLine( $id, $KeptRevisions{$_}, $canEdit, $row++ );
> 	}
> 	
> 	print $html;
> 	
> 	if ($UseDiff) {
> 		my $label = "Compare";
> 		
> 		print "\n<tr><td colspan='5' align='left'><br>";
> 		print "\n<input type='submit' value='$label'/>&nbsp;&nbsp;</td></tr></table></form>";
> 		print &GetDiffHTML( &GetParam( 'defaultdiff', 1 ), $id, "", "", $newText );
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 
> 	print "\n</div></div></div></div></body></html>";	
1022,1032c1254,1263
<   my ($text) = @_;
<   my ($logText);
< 
<   if (!$MaskHosts) {
<     return $text;
<   }
<   $logText = T('(logged)');
<   if (!($text =~ s/\d+$/$logText/)) { # IP address (ending numbers masked)
<     $text =~ s/^[^\.\(]+/$logText/;   # Host name: mask until first .
<   }
<   return $text;
---
> 	my ($text) = @_;
> 	my ($logText);
> 	if ( !$MaskHosts ) {
> 		return $text;
> 	}
> 	$logText = "(logged)";
> 	if ( !( $text =~ s/\d+$/$logText/ ) ) { # IP address (ending numbers masked)
> 		$text =~ s/^[^\.\(]+/$logText/;     # Host name: mask until first .
> 	}
> 	return $text;
1036,1083c1267,1332
<   my ($id, $section, $canEdit, $row) = @_;
<   my ($html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor);
<   my (%sect, %revtext);
< 
<   %sect = split(/$FS2/, $section, -1);
<   %revtext = split(/$FS3/, $sect{'data'});
<   $rev = $sect{'revision'};
<   $summary = $revtext{'summary'};
<   if ((defined($sect{'host'})) && ($sect{'host'} ne '')) {
<     $host = $sect{'host'};
<   } else {
<     $host = $sect{'ip'};
<   }
<   $host = &GetMaskedHost($host);
<   $user = $sect{'username'};
<   $uid = $sect{'id'};
<   $ts = $sect{'ts'};
<   $minor = '';
<   $minor = '<i>' . T('(edit)') . '</i> '  if ($revtext{'minor'});
<   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
<   if ($UseDiff) {
<     my ($c1, $c2);
<     $c1 = 'checked="checked"' if 1 == $row;
<     $c2 = 'checked="checked"' if 0 == $row;
<     $html .= "<tr><td align='center'><input type='radio' "
<              . "name='diffrevision' value='$rev' $c1/> ";
<     $html .= "<input type='radio' name='revision' value='$rev' $c2/></td><td>";
<   }
<   if (0 == $row) { # current revision
<     $html .= &GetPageLinkText($id, Ts('Revision %s', $rev)) . ' ';
<     if ($canEdit) {
<       $html .= &GetEditLink($id, T('Edit')) . ' ';
<     }
<   } else {
<     $html .= &GetOldPageLink('browse', $id, $rev,
<                              Ts('Revision %s', $rev)) . ' ';
<     if ($canEdit) {
<       $html .= &GetOldPageLink('edit',   $id, $rev, T('Edit')) . ' ';
<     }
<   }
<   $html .= ". . " . $minor . &TimeToText($ts) . " ";
<   $html .= T('by') . ' ' . &GetAuthorLink($host, $user, $uid) . " ";
<   if (defined($summary) && ($summary ne "") && ($summary ne "*")) {
<     $summary = &QuoteHtml($summary);   # Thanks Sunir! :-)
<     $html .= "<b>[$summary]</b> ";
<   }
<   $html .= $UseDiff ? "</tr>\n" : "<br>\n";
<   return $html;
---
> 	my ( $id, $section, $canEdit, $row ) = @_;
> 	my ( $html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor );
> 	my ( %sect, %revtext );
> 	
> 	%sect = split( /$FS2/, $section, -1 );
> 	%revtext = split( /$FS3/, $sect{'data'} );
> 	$rev     = $sect{'revision'};
> 	$summary = $revtext{'summary'};
> 	
> 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) {
> 		$host = $sect{'host'};
> 	}
> 	else {
> 		$host = $sect{'ip'};
> 	}
> 	
> 	$host     = &GetMaskedHost($host);
> 	$user     = $sect{'username'};
> 	$uid      = $sect{'id'};
> 	$ts       = $sect{'ts'};
> 	$minor    = "";
> 	$minor    = "<i>(edited) </i>" if ( $revtext{'minor'} );
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 
> 	if ($UseDiff) {
> 		my ( $c1, $c2 );
> 		
> 		$c1 = "checked='checked'" if 1 == $row;
> 		$c2 = "checked='checked'" if 0 == $row;
> 		$html .= "\n<tr>";
> 		$html .= "\n<td style='width: 50px; text-align: center;' nowrap valign='top'>";
> 		$html .= "\n<input style='_margin-right: -10px;' type='radio' name='diffrevision' value='$rev' $c1/>";
> 		$html .= "\n<input type='radio' name='revision' value='$rev' $c2/>";
> 		$html .= "</td>";
> 		$html .= "\n<td  valign='top' style='width: 120px;'>";
> 	}
> 	
> 	if ( 0 == $row ) {    
> 		# current revision
> 		$html .= &GetPageLinkText( $id, Ts( 'RevisionB %s', $rev ) ) . ' ';
> 		
> 		if ($canEdit) {
> 			$html .= &GetEditLink( $id, "Edit" ) . ' ';
> 		}
> 	}
> 	else {
> 		$html .= &GetOldPageLink( 'browse', $id, $rev, Ts( 'RevisionA %s', $rev ) ) . ' ';
> 		
> 		if ($canEdit) {
> 			$html .= &GetOldPageLink( 'edit', $id, $rev, "Edit" ) . ' ';
> 		}
> 	}
> 	$html .= "\n<td  valign='top'style='width: 125px'  nowrap>" . &TimeToText($ts) . "</td>";
> 	$html .= "\n<td  valign='top'style='width: 200px'> by " . &GetAuthorLink( $host, $user, $uid ) . " $minor</td>";
> 	
> 	if ( defined($summary) && ( $summary ne "" ) && ( $summary ne "*" ) ) {
> 		$summary = &QuoteHtml($summary);    # Thanks Sunir! :-)
> 		$html .= "\n<td valign='top'>[$summary]</td>";
> 	}
> 	else {
> 		$html .= "\n<td>_</td>";
> 	}
> 	
> 	$html .= $UseDiff ? "</tr>" : "\n<br>";
> 	
> 	return $html;
1088,1091c1337,1340
<   if ($SlashLinks) {
<     return '/';
<   }
<   return '?';
---
> 	if ($SlashLinks) {
> 		return '/';
> 	}
> 	return '?';
1095,1097c1344,1346
<   my ($action, $text) = @_;
< 
<   return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\">$text</a>";
---
> 	my ( $action, $text ) = @_;
> 	
> 	return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\" class='wikiscriptlink' title='Click to visit page'>$text</a>";
1101,1104c1350,1354
<   my ($action, $text, $class) = @_;
< 
<   return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\""
<          . ' class=' . $class . ">$text</a>";
---
> 	my ( $action, $text, $class, $title ) = @_;
> 	
> 	return "<a href='$ScriptName"
> 	  . &ScriptLinkChar()
> 	  . "$action' class='$class' title='$title'>$text</a>";
1107,1115c1357,1388
< sub GetPageLinkText {
<   my ($id, $name) = @_;
< 
<   $id =~ s|^/|$MainPage/|;
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<     $name =~ s/_/ /g;
<   }
<   return &ScriptLinkClass($id, $name, 'wikipagelink');
---
> sub ScriptLinkLeftNav {
> 	my ($id, $action, $target, $label, $type) = @_;
> 	my $html;
> 	my $title;
> 	my $class;	
> 	
> 	if ($type eq "1"){
> 		if ($action eq $target){ $html .= "\n<li class='disabled'>$label</li>"; }
> 		else { $html .= "\n<li><a class='wikipagelink' title='Click to visit this page.' href='\?action=$target'>$label</a></li>"; }	
> 		
> 	}
> 	else {
> 		my $authtype = &CheckIsAuthUser($target);
> 		
> 		if ($authtype eq ""){
> 			$title = "This page is private.";
> 			$class = "wikipagelink private";
> 			$label .= "!";
> 		}
> 		elsif ( $authtype eq "1"){
> 			$title = "Click to visit this locked page.";
> 			$class = "wikipagelink locked";
> 			$label .= "&not;";
> 		}
> 		else {
> 			$title = "Click to visit this page.";
> 			$class = "wikipagelink";		
> 		}
> 		
> 		if ($id eq $target){ $html .= "\n<li class='selected'>$label</li>"; }
> 		else { $html .= "\n<li><a class='$class' title='$title' href='\?$target'>$label</a></li>"; }		
> 	}
1118,1121c1391,1392
< sub GetPageLink {
<   my ($id) = @_;
< 
<   return &GetPageLinkText($id, $id);
---
> sub GetOrphanLink {
> 	return &ScriptLink("action=orphans", T('Orphans'));
1124,1131c1395,1402
< sub GetEditLink {
<   my ($id, $name) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<     $name =~ s/_/ /g;
<   }
<   return &ScriptLinkClass("action=edit&id=$id", $name, 'wikipageedit');
---
> sub DoOrphanList {
> 	print &GetHeader("", &QuoteHtml(T('Full Orphan List')), "");
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print &PrintPageList( "", &GetOrphanList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
1134,1141c1405,1432
< sub GetDeleteLink {
<   my ($id, $name, $confirm) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<     $name =~ s/_/ /g;
<   }
<   return &ScriptLink("action=delete&id=$id&confirm=$confirm", $name);
---
> sub GetOrphanList {
> 	my @found;	
> 	my %seen = ();
> 	my @pglist = &AllPagesList();
> 	
> 	foreach my $name (@pglist) {
> 		$seen{$name} = 0;
> 	}
> 	
> 	# pages linked from menu bar aren't orphans
> 	$seen{$HomePage} = 1;
> 	$seen{$RCName} = 1;
> 	
> 	foreach my $name (@pglist) {
> 		my @links = &GetPageLinks($name, 1, 0, 0, 0);
> 		
> 		foreach my $link (@links) {
> 			#don't include self links
> 			unless ($link eq $name) {
> 				$seen{$link}++ if exists $seen{$link};
> 			}
> 		}
> 	}
> 	
> 	foreach my $name (sort keys %seen) {
> 		push(@found, $name) if $seen{$name} < 1;
> 	}
> 	return @found;
1144,1148c1436,1455
< sub GetOldPageParameters {
<   my ($kind, $id, $revision) = @_;
< 
<   $id = &FreeToNormal($id) if $FreeLinks;
<   return "action=$kind&id=$id&revision=$revision";
---
> sub GetPageLinkText {
> 	my ( $id, $name ) = @_;
> 	$id =~ s|^/|$MainPage/|;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 
> 	if ($authtype eq ""){
> 		return &ScriptLinkClass( $id, "$name!", 'wikipagelink private', 'This page is private.' );
> 	}
> 		
> 	if ( -f &GetLockedPageFile($id) || $authtype eq "1"){
> 		return &ScriptLinkClass( $id, "$name&not;", 'wikipagelink locked', 'Click to visit this locked page' );
> 	}
> 	
> 	return &ScriptLinkClass( $id, $name, 'wikipagelink', 'Click to visit page' );
1151,1155c1458,1460
< sub GetOldPageLink {
<   my ($kind, $id, $revision, $name) = @_;
< 
<   $name =~ s/_/ /g if $FreeLinks;
<   return &ScriptLink(&GetOldPageParameters($kind, $id, $revision), $name);
---
> sub GetPageLink {
> 	my ($id) = @_;
> 	return &GetPageLinkText( $id, $id );
1158,1195c1463,1470
< sub GetPageOrEditAnchoredLink {
<   my ($id, $anchor, $name) = @_;
<   my (@temp, $exists);
< 
<   if ($name eq "") {
<     $name = $id;
<     if ($FreeLinks) {
<       $name =~ s/_/ /g;
<     }
<   }
<   $id =~ s|^/|$MainPage/|;
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
<   $exists = 0;
<   if ($UseIndex) {
<     if (!$IndexInit) {
<       @temp = &AllPagesList();          # Also initializes hash
<     }
<     $exists = 1  if ($IndexHash{$id});
<   } elsif (-f &GetPageFile($id)) {      # Page file exists
<     $exists = 1;
<   }
<   if ($exists) {
<     $id = "$id#$anchor"  if $anchor;
<     $name = "$name#$anchor"  if $anchor && $NamedAnchors != 2;
<     return &GetPageLinkText($id, $name);
<   }
<   if ($FreeLinks && !$EditNameLink) {
<     if ($name =~ m| |) {  # Not a single word
<       $name = "[$name]";  # Add brackets so boundaries are obvious
<     }
<   }
<   if ($EditNameLink) {
<     return &GetEditLink($id, $name);
<   } else {
<     return $name . &GetEditLink($id, '?');
<   }
---
> sub GetEditLink {
> 	my ( $id, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	return &ScriptLinkClass( "action=edit&id=$id", $name, 'wikipageedit', 'Click to edit page' );
1198,1200c1473,1489
< sub GetPageOrEditLink {
<     my ($id, $name) = @_;
<     return &GetPageOrEditAnchoredLink($id, "", $name);
---
> sub GetCreateNewLink {
> 	my ( $id, $name ) = @_;
> 	my ( $html );
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	
> 	$html  = "<a href='$ScriptName";
> 	$html .= &ScriptLinkChar();
> 	$html .= "action=edit&id=$id' class='wikicreatepagelink' title='Create this entry'>";
> 	$html .= $name;
> 	$html .= "<span class='wikilinkicon'>&nbsp;</span>";
> 	$html .= "</a>";
> 	
> 	return $html;
1203,1212c1492,1499
< sub GetBackLinksSearchLink {
<   my ($id) = @_;
<   my $name = $id;
< 
<   $id =~ s|.+/|/|;   # Subpage match: search for just /SubName
<   if ($FreeLinks) {
<     $name =~ s/_/ /g;  # Display with spaces
<     $id =~ s/_/+/g;    # Search for url-escaped spaces
<   }
<   return &ScriptLink("back=$id", $name);
---
> sub GetDeleteLink {
> 	my ( $id, $name, $confirm ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 		$name =~ s/_/ /g;
> 	}
> 	return &ScriptLink( "action=delete&id=$id&confirm=$confirm", $name );
1215,1216c1502,1505
< sub GetPrefsLink {
<   return &ScriptLink("action=editprefs", T('Preferences'));
---
> sub GetOldPageParameters {
> 	my ( $kind, $id, $revision ) = @_;
> 	$id = &FreeToNormal($id) if $FreeLinks;
> 	return "action=$kind&id=$id&revision=$revision";
1219,1220c1508,1511
< sub GetRandomLink {
<   return &ScriptLink("action=random", T('Random Page'));
---
> sub GetOldPageLink {
> 	my ( $kind, $id, $revision, $name ) = @_;
> 	$name =~ s/_/ /g if $FreeLinks;
> 	return &ScriptLink( &GetOldPageParameters( $kind, $id, $revision ), $name );
1223,1228c1514,1561
< sub ScriptLinkDiff {
<   my ($diff, $id, $text, $rev) = @_;
< 
<   $rev = "&revision=$rev"  if ($rev ne "");
<   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
<   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
---
> sub GetPageOrEditAnchoredLink {
> 	my ( $id, $anchor, $name ) = @_;
> 	my ( @temp, $exists );
> 	my $NamedFreeLink = 0;
> 	
> 	if ( $name eq "" ) {
> 		$name = $id;
> 		if ($FreeLinks) {
> 			$name =~ s/_/ /g;
> 		}
> 	}
> 	else {
> 		$NamedFreeLink = 1;
> 	}
> 	
> 	$id =~ s|^/|$MainPage/|;
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	$exists = 0;
> 	
> 	if ($UseIndex) {
> 		if ( !$IndexInit ) {
> 			@temp = &AllPagesList();    # Also initializes hash
> 		}
> 		$exists = 1 if ( $IndexHash{$id} );
> 	}
> 	elsif ( -f &GetPageFile($id) ) {    # Page file exists
> 		$exists = 1;
> 	}
> 	
> 	if ($exists) {
> 		$id = "$id#$anchor" if $anchor;
> 		$name = "$name#$anchor"  if $anchor && $NamedAnchors != 2 && !$NamedFreeLink;
> 		
> 		return &GetPageLinkText( $id, $name );
> 	}
> 	if ( $FreeLinks && !$EditNameLink ) {
> 		if ( $name =~ m| | ) {          # Not a single word
> 			$name = "[$name]";          # Add brackets so boundaries are obvious
> 		}
> 	}
> 	if ($EditNameLink) {
> 		return &GetEditLink( $id, $name );
> 	}
> 	else {
> 		return &GetCreateNewLink( $id, $name );
> 	}
1231,1236c1564,1568
< sub ScriptLinkDiffRevision {
<   my ($diff, $id, $rev, $text) = @_;
< 
<   $rev = "&diffrevision=$rev"  if ($rev ne "");
<   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
<   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
---
> sub GetPageOrEditLink {
> 	my ( $id, $name ) = @_;
> 	my ($link, $anchor) = split( /#/, $id, 2);
> 	
> 	return &GetPageOrEditAnchoredLink($link, $anchor, $name);
1239,1240c1571,1580
< sub GetUploadLink {
<   return &ScriptLink('action=upload', T('Upload'));
---
> sub GetBackLinksSearchLink {
> 	my ($id) = @_;
> 	my $name = $id;
> 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
> 	
> 	if ($FreeLinks) {
> 		$name =~ s/_/ /g;    # Display with spaces
> 		$id   =~ s/_/+/g;    # Search for url-escaped spaces
> 	}
> 	return &ScriptLinkTitle( "back=$id", $name, "Click to see which pages link to this one" );
1243,1250c1583,1584
< sub ScriptLinkTitle {
<   my ($action, $text, $title) = @_;
< 
<   if ($FreeLinks) {
<     $action =~ s/ /_/g;
<   }
<   return "<a href=\"$ScriptName" . &ScriptLinkChar()
<          . "$action\" title=\"$title\">$text</a>";
---
> sub GetPrefsLink {
> 	return &ScriptLink( "action=editprefs", "Preferences" );
1253,1271c1587,1588
< sub GetAuthorLink {
<   my ($host, $userName, $uid) = @_;
<   my ($html, $title, $userNameShow);
< 
<   $userNameShow = $userName;
<   if ($FreeLinks) {
<     $userName     =~ s/ /_/g;
<     $userNameShow =~ s/_/ /g;
<   }
<   if (&ValidId($userName) ne "") {  # Invalid under current rules
<     $userName = "";  # Just pretend it isn't there.
<   }
<   if (($uid > 0) && ($userName ne "")) {
<     $html = &ScriptLinkTitle($userName, $userNameShow,
<             Ts('ID %s', $uid) . ' ' . Ts('from %s', $host));
<   } else {
<     $html = $host;
<   }
<   return $html;
---
> sub GetRandomLink {
> 	return &ScriptLink( "action=random", "Random Page" );
1274,1280c1591,1597
< sub GetHistoryLink {
<   my ($id, $text) = @_;
< 
<   if ($FreeLinks) {
<     $id =~ s/ /_/g;
<   }
<   return &ScriptLink("action=history&id=$id", $text);
---
> sub ScriptLinkDiff {
> 	my ( $diff, $id, $text, $rev ) = @_;
> 	
> 	$rev = "&revision=$rev" if ( $rev ne "" );
> 	$diff = &GetParam( "defaultdiff", 1 ) if ( $diff == 4 );
> 	
> 	return &ScriptLinkTitle( "action=browse&diff=$diff&id=$id$rev", $text, "Click to view last revision" );
1283,1319c1600,1601
< sub GetHeader {
<   my ($id, $title, $oldId) = @_;
<   my $header = "";
<   my $logoImage = "";
<   my $result = "";
<   my $embed = &GetParam('embed', $EmbedWiki);
<   my $altText = T('[Home]');
< 
<   $result = &GetHttpHeader('');
<   if ($FreeLinks) {
<     $title =~ s/_/ /g;   # Display as spaces
<   }
<   $result .= &GetHtmlHeader("$SiteName: $title");
<   return $result  if ($embed);
< 
<   $result .= '<div class=wikiheader>';
<   if ($oldId ne '') {
<     $result .= $q->h3('(' . Ts('redirected from %s', 
<                                &GetEditLink($oldId, $oldId)) . ')');
<   }
<   if ((!$embed) && ($LogoUrl ne "")) {
<     $logoImage = "img src=\"$LogoUrl\" alt=\"$altText\" border=0";
<     if (!$LogoLeft) {
<       $logoImage .= " align=\"right\"";
<     }
<     $header = &ScriptLink($HomePage, "<$logoImage>");
<   }
<   if ($id ne '') {
<     $result .= $q->h1($header . &GetBackLinksSearchLink($id));
<   } else {
<     $result .= $q->h1($header . $title);
<   }
<   if (&GetParam("toplinkbar", 1)) {
<     $result .= &GetGotoBar($id) . "<hr class=wikilineheader>";
<   }
<   $result .= '</div>';
<   return $result;
---
> sub GetUploadLink {
> 	return &ScriptLink( 'action=upload', "Upload" );
1322,1342c1604,1611
< sub GetHttpHeader {
<   my ($type) = @_;
<   my $cookie;
< 
<   $type = 'text/html'  if ($type eq '');
<   if (defined($SetCookie{'id'})) {
<     $cookie = "$CookieName="
<             . "rev&" . $SetCookie{'rev'}
<             . "&id&" . $SetCookie{'id'}
<             . "&randkey&" . $SetCookie{'randkey'};
<     $cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
<     if ($HttpCharset ne '') {
<       return $q->header(-cookie=>$cookie,
<                         -type=>"$type; charset=$HttpCharset");
<     }
<     return $q->header(-cookie=>$cookie);
<   }
<   if ($HttpCharset ne '') {
<     return $q->header(-type=>"$type; charset=$HttpCharset");
<   }
<   return $q->header(-type=>$type);
---
> sub ScriptLinkTitle {
> 	my ( $action, $text, $title ) = @_;
> 	if ($FreeLinks) {
> 		$action =~ s/ /_/g;
> 	}
> 	return "<a href=\"$ScriptName"
> 	  . &ScriptLinkChar()
> 	  . "$action\" title=\"$title\" class='wikiscriptlinktitle'>$text</a>";
1345,1380c1614,1632
< sub GetHtmlHeader {
<   my ($title) = @_;
<   my ($dtd, $html, $bodyExtra, $stylesheet);
< 
<   $html = '';
<   $dtd = '-//IETF//DTD HTML//EN';
<   $html = qq(<!DOCTYPE HTML PUBLIC "$dtd">\n);
<   $title = $q->escapeHTML($title);
<   $html .= "<HTML><HEAD><TITLE>$title</TITLE>\n";
<   if ($FavIcon ne '') {
<     $html .= '<LINK REL="SHORTCUT ICON" HREF="' . $FavIcon . '">' 
<   }
<   if ($MetaKeywords) {
<       my $keywords = $OpenPageName;
<       $keywords =~ s/([a-z])([A-Z])/$1, $2/g;
<       $html .= "<META NAME='KEYWORDS' CONTENT='$keywords'/>\n" if $keywords;
<   }
<   if ($SiteBase ne "") {
<     $html .= qq(<BASE HREF="$SiteBase">\n);
<   }
<   $stylesheet = &GetParam('stylesheet', $StyleSheet);
<   $stylesheet = $StyleSheet  if ($stylesheet eq '');
<   $stylesheet = ''  if ($stylesheet eq '*');  # Allow removing override
<   if ($stylesheet ne '') {
<     $html .= qq(<LINK REL="stylesheet" HREF="$stylesheet">\n);
<   }
<   $html .= $UserHeader;
<   $bodyExtra = '';
<   if ($UserBody ne '') {
<     $bodyExtra = ' ' . $UserBody;
<   }
<   if ($BGColor ne '') {
<     $bodyExtra .= qq( BGCOLOR="$BGColor");
<   }
<   $html .= "</HEAD><BODY$bodyExtra>\n";
<   return $html;
---
> sub GetAuthorLink {
> 	my ( $host, $userName, $uid ) = @_;
> 	my ( $html, $title, $userNameShow );
> 	$userNameShow = $userName;
> 	
> 	if ($FreeLinks) {
> 		$userName     =~ s/ /_/g;
> 		$userNameShow =~ s/_/ /g;
> 	}
> 	if ( &ValidId($userName) ne "" ) {    # Invalid under current rules
> 		$userName = "";                   # Just pretend it isn't there.
> 	}
> 	if ( ( $uid > 0 ) && ( $userName ne "" ) ) {
> 		$html = &ScriptLinkTitle( "$HomePagePrefix$userName", $userNameShow, Ts( 'ID %s', $uid ) . ' ' . Ts( 'from %s', $host ) );
> 	}
> 	else {
> 		$html = $host;
> 	}
> 	return $html;
1383,1448c1635,1640
< sub GetFooterText {
<   my ($id, $rev) = @_;
<   my $result;
< 
<   if (&GetParam('embed', $EmbedWiki)) {
<     return $q->end_html;
<   }
<   $result = '<div class=wikifooter>';
<   $result .= &GetFormStart();
<   $result .= &GetGotoBar($id);
<   if (&UserCanEdit($id, 0)) {
<     if ($rev ne '') {
<       $result .= &GetOldPageLink('edit',   $id, $rev,
<                                  Ts('Edit revision %s of this page', $rev));
<     } else {
<       $result .= &GetEditLink($id, T('Edit text of this page'));
<     }
<   } else {
<     $result .= T('This page is read-only');
<   }
<   $result .= ' | ';
<   $result .= &GetHistoryLink($id, T('View other revisions'));
<   if ($rev ne '') {
<     $result .= ' | ';
<     $result .= &GetPageLinkText($id, T('View current revision'));
<   }
<   if ($UseMetaWiki) {
<     $result .= ' | <a href="http://sunir.org/apps/meta.pl?' . $id . '">'
<                . T('Search MetaWiki') . '</a>';
<   }
<   if ($Section{'revision'} > 0) {
<     $result .= '<br>';
<     if ($rev eq '') {  # Only for most current rev
<       $result .= T('Last edited');
<     } else {
<       $result .= T('Edited');
<     }
<     $result .= ' ' . &TimeToText($Section{ts});
<     if ($AuthorFooter) {
<       $result .= ' ' . Ts('by %s', &GetAuthorLink($Section{'host'},
<                                      $Section{'username'}, $Section{'id'}));
<     }
<   }
<   if ($UseDiff) {
<     $result .= ' ' . &ScriptLinkDiff(4, $id, T('(diff)'), $rev);
<   }
<   $result .= '<br>' . &GetSearchForm();
<   if ($AdminBar && &UserIsAdmin()) {
<     $result .= '<br>' . &GetAdminBar($id);
<   }
<   if ($DataDir =~ m|/tmp/|) {
<     $result .= '<br><b>' . T('Warning') . ':</b> '
<                . Ts('Database is stored in temporary directory %s',
<                     $DataDir) . '<br>';
<   }
<   if ($ConfigError ne '') {
<     $result .= '<br><b>' . T('Config file error:') . '</b> '
<                . $ConfigError . '<br>';
<   }
<   $result .= $q->endform;
<   if ($FooterNote ne '') {
<     $result .= T($FooterNote);
<   }
<   $result .= '</div>';
<   $result .= &GetMinimumFooter();
<   return $result;
---
> sub GetHistoryLink {
> 	my ( $id, $text, $title ) = @_;
> 	if ($FreeLinks) {
> 		$id =~ s/ /_/g;
> 	}
> 	return &ScriptLinkTitle( "action=history&id=$id", $text, $title );
1451,1461c1643,1702
< sub GetCommonFooter {
<   my ($html);
< 
<   $html = '<hr class=wikilinefooter>' . '<div class=wikifooter>'
<           . &GetFormStart() . &GetGotoBar('')
<           . &GetSearchForm() . $q->endform;
<   if ($FooterNote ne '') {
<     $html .= T($FooterNote);
<   }
<   $html .= '</div>' . $q->end_html;
<   return $html;
---
> sub GetHeader {
> 	my ( $id, $title, $oldId ) = @_;
> 	my $header    = "";
> 	my $logoImage = "";
> 	my $result    = "";
> 	my $embed     = &GetParam( 'embed', $EmbedWiki );
> 	my $altText   = "[Home]";
> 	my $temp      = "";
> 	
> 	$result = &GetHttpHeader("");
> 	
> 	if ($FreeLinks) {
> 		$title =~ s/_/ /g;    # Display as spaces
> 	}
> 	
> 	$result .= &GetHtmlHeader("$SiteName: $title", $id);
> 	
> 	return $result if ($embed);
> 	$result .= "\n<div class='wikiheader'>";
> 	
> 	if ( $oldId ne "" ) {
> 		$result .= $q->h3( '(' . Ts( 'redirected from %s', &GetEditLink( $oldId, $oldId ) )  . ')' );
> 	}
> 	else { $result .= "<h3>&nbsp;</h3>"; }
> 	
> 	if ( ( !$embed ) && ( $LogoUrl ne "" ) ) {
> 		$logoImage = "img class='wikilogo' src=\"$LogoUrl\" alt=\"$altText\" border=0";
> 		
> 		if ( !$LogoLeft ) {
> 			$logoImage .= " align=\"right\"";
> 		}
> 		$header = &ScriptLink( $HomePage, "\n<$logoImage>" );
> 	}
> 	
> 	if ( $id ne "" ) {
> 		my $authtype = &CheckIsAuthUser($id);
> 		if (&PageIsLocked($id, 1) || $authtype eq "1"){
> 			$temp = "<span class='wikilockicon' title='This page is locked.'>&nbsp;</span>";
> 		}
> 		else {	
> 			if ( -f &GetLockedPageFile($id) ) {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='This page locked for others. Click to edit page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 			else {
> 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='Click to edit this page'><span class='wikiediticon'>&nbsp;</span></a>";
> 			}
> 		}		
> 		$result .= $q->h1( $header . &GetBackLinksSearchLink($id) . $temp );
> 	}
> 	else {
> 		$result .= $q->h1( $header . $title );
> 	}
> 	
> 
> 	if ( &GetParam( "toplinkbar", 1 ) ) {		
> 		$result .= &GetGotoBar($id);
> 		$result .= $WikiLineHeader;
> 	}
> 	$result .= "</div>";	
> 	return $result;
1464,1465c1705,1728
< sub GetMinimumFooter {
<   return $q->end_html;
---
> sub GetHttpHeader {
> 	my ($type) = @_;
> 	my $cookie;
> 	$type = "text/html" if ( $type eq "" );
> 	if ( defined( $SetCookie{'id'} ) ) {
> 		$cookie =
> 		   "$CookieName=" . "rev&"
> 		  . $SetCookie{'rev'} . "&id&"
> 		  . $SetCookie{'id'}
> 		  . "&randkey&"
> 		  . $SetCookie{'randkey'};
> 		$cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
> 		if ( $HttpCharset ne "" ) {
> 			return $q->header(
> 				-cookie => $cookie,
> 				-type   => "$type; charset=$HttpCharset"
> 			);
> 		}
> 		return $q->header( -cookie => $cookie );
> 	}
> 	if ( $HttpCharset ne "" ) {
> 		return $q->header( -type => "$type; charset=$HttpCharset" );
> 	}
> 	return $q->header( -type => $type );
1468,1470c1731,1779
< sub GetFormStart {
<   return $q->startform("POST", "$ScriptName",
<                        "application/x-www-form-urlencoded");
---
> sub GetHtmlHeader {
> 	my ($title, $id) = @_;
> 	my ( $dtd, $html, $bodyExtra, $stylesheet );
> 	
> 	$html  = "";
> 	$dtd   = "-//IETF//DTD HTML//EN";
> 	$html  = qq(<!DOCTYPE HTML PUBLIC "$dtd">);
> 	$title = $q->escapeHTML($title);
> 	$html .= "\n<html><head><title>$title</title>";
> 	
> 	if ( $FavIcon ne "" ) {
> 		$html .= "\n<link rel='SHORTCUT ICON' href='$FavIcon'>";
> 	}
> 	
> 	if ($MetaKeywords) {
> 		my $keywords = $OpenPageName;
> 		$keywords =~ s/([a-z])([A-Z])/$1, $2/g;
> 		$html .= "\n<meta name='keywords' content='$keywords'/>" if $keywords;
> 	}
> 	
> 	if ( $SiteBase ne "" ) {
> 		$html .= qq(<base href="$SiteBase">);
> 	}
> 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
> 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
> 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
> 	
> 	if ( $stylesheet ne "" ) {
> 		$html .= qq(<link rel="stylesheet" href="$stylesheet">);
> 	}
> 
>    my $bots = "";
>    # actions and non-existant page views don't get indexed or followed by robots
>    if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
>    $bots = $bots . 'index,' . $bots . 'follow';
>    $html .= qq(<meta name="robots" content="$bots" />\n);
> 	
> 	$html .= $UserHeader;
> 	$bodyExtra = "";
> 	
> 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
> 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
> 	
> 	$html .= "</head><body$bodyExtra>";
> 	$html .= "\n<div id='wikicontainer-outer'>";
> 	$html .= "\n<div id='wikicontainer-inner'>";
> 	$html .= "\n<div id='wikicontainer'>";
> 		
> 	return $html;
1473,1495c1782,1839
< sub GetGotoBar {
<   my ($id) = @_;
<   my ($main, $bartext);
< 
<   $bartext  = &GetPageLink($HomePage);
<   if ($id =~ m|/|) {
<     $main = $id;
<     $main =~ s|/.*||;  # Only the main page name (remove subpage)
<     $bartext .= " | " . &GetPageLink($main);
<   }
<   $bartext .= " | " . &GetPageLink($RCName);
<   $bartext .= " | " . &GetPrefsLink();
<   if ($UseUpload && &UserCanUpload()) {
<     $bartext .= " | " . &GetUploadLink();
<   }
<   if (&GetParam("linkrandom", 0)) {
<     $bartext .= " | " . &GetRandomLink();
<   }
<   if ($UserGotoBar ne '') {
<     $bartext .= " | " . $UserGotoBar;
<   }
<   $bartext .= "<br>\n";
<   return $bartext;
---
> sub GetLeftNav {
> 	my $id = shift;
> 	my $action = &GetParam( "action", "" );
> 	my $html = "";
> 	
> 	$html .= "\n<div class='wikileftnav'>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'HomePage', 'Home page', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'NobleWiki', 'Wiki Info', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'CategoryCategory', 'Contents', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'FeaturedContent', 'Featured', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'random', 'Random Article', "1");	
> 	
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>	";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'RecentChanges', 'Recent changes', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'ListOfWantedPages', 'Wanted Pages', "");
> 					
> 	if ($id ne ""){
> 		unless ($id eq 'ListOfWantedPages' or $id eq 'RecentChanges' or $id =~ /^\d/){	
> 			if (&UserCanEdit( $id, 0 )){ $html .= "\n<li><a href='?action=edit&id=$id'>Edit this Page</a></li>";	}
> 			else { $html .= "\n<li class='disabled'>Edit this Page</li>"; }
> 							
> 			if ($action eq 'history'){ $html .= "\n<li class='disabled'>Version History</li>"; }
> 			else { $html .= "\n<li><a href='?action=history&id=$id'>Version History</a></li>"; }
> 		}
> 		else {
> 			$html .= "\n<li class='disabled'>Edit this Page</li>"; 
> 			$html .= "\n<li class='disabled'>Version History</li>"; 
> 		}
> 	}
> 	
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'SandBox', 'SandBox', "");
> 	
> 	$html .= "\n	</ul></div>";
> 	$html .= "\n	<div class='wikileftnavbox'>";
> 	$html .= "\n		<ul>";
> 
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'editprefs', 'Preferences', "1");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiContacts', 'Contact Us', "");
> 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiHelp', 'Help', "");
> 		
> 	$html .= "\n		</ul>";
> 	$html .= "\n	</div>";
> 	$html .= "\n	<div class='wikileftnavsearch' style='text-align:right;'>";
> 	$html .= "\n		<form>";
> 	$html .= "\n			<div class='wikisearchlabel' style='text-align:left;'><b>Search</b></div>";
> 	$html .= "\n			<input type='text' title='Enter ! before search term for exclusion' name='search' id='searchterm' />";
> 	$html .= "\n			<input type='submit' value='Go!' name='dosearch' title='Click to perform your search request.' />";
> 	$html .= "\n		</form></div>";
> 	$html .= "\n</div>";
> 	
> 	return $html;	
1498,1507c1842,1915
< sub GetSearchForm {
<   my ($result);
< 
<   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
<   if ($SearchButton) {
<     $result .= $q->submit('dosearch', T('Go!'));
<   } else {  
<     $result .= &GetHiddenValue("dosearch", 1);
<   }
<   return $result;
---
> sub GetFooterText {
> 	my ( $id, $rev ) = @_;
> 	my $result;
> 	
> 	if ( &GetParam( 'embed', $EmbedWiki ) ) {
> 		return "";
> 	}
> 	
> 	$result = "\n<div class='wikifooter'>";
> 	$result .= &GetGotoBar($id);
> 	$result .= "\n<div class='wikirevision'>";
> 	
> 	if ($id ne ""){
> 		if ( &UserCanEdit( $id, 0 )) {
> 			if ( $rev ne "" ) {
> 				$result .=
> 				  &GetOldPageLink( 'edit', $id, $rev, Ts( 'Edit revision %s of this page', $rev ) );
> 			}
> 			else {
> 				$result .= &GetEditLink( $id, "Edit text of this page" );
> 			}
> 		}
> 		else {
> 			$result .= "This page is read-only";
> 		}
> 	}
> 	
> 	if ($id ne ""){ $result .= " | " . &GetHistoryLink( $id, "View other revisions", "Click to view revision history" ); }	
> 	if ( $rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
> 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?$id' class='wikiusemetalink'>Search MetaWiki</a>"; }
> 	
> 	$result .= "</div>";
> 	
> 	if ($id ne ""){ 
> 		if ( $Section{'revision'} > 0 ) {
> 			$result .= "\n<div class='wikirevision'>";		
> 			$result .= "Created " . &TimeToText($Page{'tscreate'});
> 			
> 			if ($Page{'authorcreate'}) { $result .= " by " . $Page{'authorcreate'}; } 
> 			
> 			$result .= " | ";	
> 			if ( $rev eq "" ) { $result .= "Last edited"; }
> 			else { $result .= "Edited"; }
> 			
> 			$result .= " " . &TimeToText( $Section{ts} );
> 				
> 			if ($AuthorFooter) { $result .= " by " . &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}); }
> 		}
> 		
> 		if ($UseDiff) { $result .= " " . &ScriptLinkDiff( 4, $id, "(diff)", $rev ); }
> 	}
> 	
> 	$result .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$result .= &GetSearchForm();	
> 	if ( $DataDir =~ m|/tmp/| ) {
> 		$result .= "\n<br><b>";
> 		$result .= "Warning";
> 		$result .= ":</b> ";
> 		$result .= "Database is stored in temporary directory $DataDir";
> 		$result .= "\n<br>";
> 	}
> 	
> 	if ( $ConfigError ne "" ) {
> 		$result .= "\n<br>";
> 		$result .= "\n<b>Config file error:</b>";
> 		$result .= "$ConfigError <br>";
> 	}
> 	
> 	$result .= "</form>";
> 	$result .= &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { $result .= &GetAdminBar($id, ""); }
> 	$result .= "</div>";
> 		
> 	return $result;
1510,1543c1918,1941
< sub GetRedirectPage {
<   my ($newid, $name, $isEdit) = @_;
<   my ($url, $html);
<   my ($nameLink);
< 
<   # Normally get URL from script, but allow override.
<   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
<   $url = $FullUrl . &ScriptLinkChar() . $newid;
<   $nameLink = "<a href=\"$url\">$name</a>";
<   if ($RedirType < 3) {
<     if ($RedirType == 1) {             # Use CGI.pm
<       # NOTE: do NOT use -method (does not work with old CGI.pm versions)
<       # Thanks to Daniel Neri for fixing this problem.
<       $html = $q->redirect(-uri=>$url);
<     } else {                           # Minimal header
<       $html  = "Status: 302 Moved\n";
<       $html .= "Location: $url\n";
<       $html .= "Content-Type: text/html\n";  # Needed for browser failure
<       $html .= "\n";
<     }
<     $html .= "\n" . Ts('Your browser should go to the %s page.', $newid);
<     $html .= ' ' . Ts('If it does not, click %s to continue.', $nameLink);
<   } else {
<     if ($isEdit) {
<       $html  = &GetHeader('', T('Thanks for editing...'), '');
<       $html .= Ts('Thank you for editing %s.', $nameLink);
<     } else {
<       $html  = &GetHeader('', T('Link to another page...'), '');
<     }
<     $html .= "\n<p>";
<     $html .= Ts('Follow the %s link to continue.', $nameLink);
<     $html .= &GetMinimumFooter();
<   }
<   return $html;
---
> sub getFooterNote {
> 	my $html;
> 	my $userid = &GetParam("username", "");
> 	my $access = "Guest ";
> 	my $username = "Anonymous";
> 
> 	if (UserIsAdmin()){
> 		$access = "Admin ";
> 	}
> 	elsif (UserIsEditor()){
> 		$access = "Editor ";
> 	}
> 	
> 	if ($userid ne ""){
> 		$username = $userid;
> 	}
> 	
> 	if ($FooterNote ne ""){
> 		$html = $FooterNote;
> 		$html =~ s/access/$access/;
> 		$html =~ s/username/$userid/;
> 	}
> 	
> 	return $html;
1546,1551c1944,1959
< # ==== Common wiki markup ====
< sub RestoreSavedText {
<   my ($text) = @_;
< 
<   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
<   return $text;
---
> sub GetCommonFooter {
> 	my ($html);
> 	my $id = &GetParam( "id",     "" );
> 	
> 	$html = $WikiLineFooter;
> 	$html .= "\n<div class='wikifooter'>";
> 	$html .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	$html .= &GetGotoBar("");
> 	$html .= &GetSearchForm();
> 	$html .= "</form>";	
> 	$html .= &getFooterNote();
> 	
> 	if ( $AdminBar && &UserIsAdmin() ) { $html .= &GetAdminBar($id, "class='wikirevision'"); }
> 	$html .= "\n<div>"; ## ??NEEDED ??
> 	
> 	return $html;
1554,1559c1962,1997
< sub RemoveFS {
<   my ($text) = @_;
< 
<   # Note: must remove all $FS, and $FS may be multi-byte/char separator
<   $text =~ s/($FS)+(\d)/$2/g;
<   return $text;
---
> sub GetGotoBar {
> 	my ($id) = @_;
> 	my ( $main, $bartext );
> 	
> 	$bartext = "\n<div class='wikigotobar'>";
> 	$bartext .= &GetPageLink($HomePage);
> 	
> 	if ( $id =~ m|/| ) {
> 		$main = $id;
> 		$main =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		unless ($main eq $HomePage){
> 			$bartext .= " | " . &GetPageLink($main);
> 		}
> 	}
> 	
> 	$bartext .= " | " . &GetPageLink($RCName);
> 	$bartext .= " | " . &GetPrefsLink();
> 	
> 	if ( $UseUpload && &UserCanUpload() ) {
> 		$bartext .= " | " . &GetUploadLink();
> 	}
> 	
> 	$bartext .= " | " . &ScriptLink( "action=listfiles&filter=sample", "List Assets" );
> 	
> 	if ( &GetParam( "linkrandom", 0 ) ) {
> 		$bartext .= " | " . &GetRandomLink();
> 	}
> 	
> 	if ( $UserGotoBar ne "" ) {
> 		$bartext .= " | " . $UserGotoBar;
> 	}
> 	
> 	$bartext .= "</div>";
> 	
> 	return $bartext;
1562,1599c2000,2014
< sub WikiToHTML {
<   my ($pageText) = @_;
<   $TableMode = 0;
< 
<   %SaveUrl = ();
<   %SaveNumUrl = ();
<   $SaveUrlIndex = 0;
<   $SaveNumUrlIndex = 0;
<   $pageText = &RemoveFS($pageText);
<   if ($RawHtml) {
<     $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
<   }
<   $pageText = &QuoteHtml($pageText);
<   $pageText =~ s/\\ *\r?\n/ /g;          # Join lines with backslash at end
<   if ($ParseParas) {
<     # Note: The following 3 rules may span paragraphs, so they are
<     #       copied from CommonMarkup
<     $pageText =~
<         s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
<     $pageText =~
<         s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
<     $pageText =~
<         s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
<     $pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
<     $pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
<   } else {
<     $pageText = &CommonMarkup($pageText, 1, 0);   # Multi-line markup
<     $pageText = &WikiLinesToHtml($pageText);      # Line-oriented markup
<   }
<   while (@HeadingNumbers) {
<     pop @HeadingNumbers;
<     $TableOfContents .= "</dd></dl>\n\n";
<   }
<   $pageText =~ s/&lt;toc&gt;/$TableOfContents/gi;
<   if ($LateRules ne '') {
<     $pageText = &EvalLocalRules($LateRules, $pageText, 0);
<   }
<   return &RestoreSavedText($pageText);
---
> sub GetSearchForm {
> 	my ($html);
> 	
> 	$html =  "\n<div class='wikisearch'>";
> 	$html .= "\n<div class='wikisearchlabel'>Search:</div>";
> 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";	
> 	if ($SearchButton) {
> 		$html .= " " . $q->submit( 'dosearch', "Go!" );
> 	}
> 	else {
> 		$html .= &GetHiddenValue( "dosearch", 1 );
> 	}
> 	
> 	$html .= "</div>";
> 	return $html;
1601a2017,2134
> sub GetRedirectPage {
> 	my ( $newid, $name, $isEdit ) = @_;
> 	my ( $url, $html );
> 	my ($nameLink);
> 
> 	# Normally get URL from script, but allow override.
> 	$FullUrl  = $q->url( -full => 1 ) if ( $FullUrl eq "" );
> 	$url      = $FullUrl . &ScriptLinkChar() . $newid;
> 	$nameLink = "<a href='$url' class='wikiredirect'>$name</a>";
> 	
> 	if ( $RedirType < 3 ) {
> 		if ( $RedirType == 1 ) {    # Use CGI.pm
> 			 # NOTE: do NOT use -method (does not work with old CGI.pm versions)
> 			 # Thanks to Daniel Neri for fixing this problem.
> 			$html = $q->redirect( -uri => $url );
> 		}
> 		else {    # Minimal header
> 			$html = "Status: 302 Moved\n";
> 			$html .= "Location: $url\n";
> 			$html .= "Content-Type: text/html\n";   # Needed for browser failure
> 		}
> 		$html .= " Your browser should go to the $newid page.";
> 		$html .= " If it does not, click $nameLink to continue.";
> 	}
> 	else {
> 		if ($isEdit) {
> 			$html  = &GetHeader( "", "Thanks for editing...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
>  			$html .= "Thank you for editing $nameLink ";
> 		}
> 		else {
> 			$html = &GetHeader( "", "Link to another page...", "" );
> 			$html .= &GetLeftNav("");
> 			$html .= "\n<div class='wikiadmin'>";
> 		}
> 		
> 		$html .= "Follow the $nameLink link to continue.";
> 		$html .= "</div>";
> 		$html .= "</div></div></div></div></body></html>";	
> 	}
> 	
> 	return $html;
> }
> 
> # ==== Common wiki markup ====
> sub RestoreSavedText {
> 	my ($text) = @_;
> 	
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
> }
> 
> sub RemoveFS {
> 	my ($text) = @_;
> 
> 	# Note: must remove all $FS, and $FS may be multi-byte/char separator
> 	$text =~ s/($FS)+(\d)/$2/g;
> 	
> 	return $text;
> }
> 
> sub WikiToHTML {
> 	my ($pageText) = @_;
> 	
> 	$TableMode       = 0;
> 	%SaveUrl         = ();
> 	%SaveNumUrl      = ();
> 	$SaveUrlIndex    = 0;
> 	$SaveNumUrlIndex = 0;
> 	$pageText        = &RemoveFS($pageText);
> 	
> 	if ($RawHtml) {
> 		$pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
> 	}
> 	
> 	$pageText = &QuoteHtml($pageText);
> 	$pageText =~ s/\\ *\r?\n/ /g;    # Join lines with backslash at end
> 		
> 	if ($ParseParas) {
> 
> 		# Note: The following 3 rules may span paragraphs, so they are
> 		#       copied from CommonMarkup
> 		$pageText =~ s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 		$pageText =~ s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		$pageText =~ s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		$pageText =~ s/\{{template:(\w+\s*.*?)}}/&StoreTemplate($1)/iges;
> 		$pageText =~ s/\{{flash:\s*(.*?)}}/&StoreRaw(&GetFlash($1))/iges;
> 		$pageText =~ s/\{{gallery:\s*(.*?)}}/&StoreRaw(&GetGallery($1))/iges;
> 		
> 		$pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
> 		$pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
> 		
> 	}
> 	else {
> 		$pageText = &WikiLinesToHtml($pageText);         # Line-oriented markup
> 		$pageText = &CommonMarkup( $pageText, 1, 0 );    # Multi-line markup
> 
> 	}
> 	
> 	while (@HeadingNumbers) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$pageText =~ s/&lt;toc&gt;/<div class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/&lt;toc ((\d)+)?&gt;/<div style='width: $1;' class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
> 	$pageText =~ s/\#SUBPAGES\s+(\w+.*?)/&StoreRaw("\n<h6>" . Ts('Subpages of: %s', &QuoteHtml($1)) . "<\/h6>" . &GetPageList(&GetSubpages($1)))/ige;
> 	$pageText =~ s/\#SUBPAGES/&StoreRaw("\n<h6>" . Ts('Subpages for %s', $MainPage) . "<\/h6>" . &GetPageList(&GetSubpages($MainPage)))/ige;
> 	
> 	if ( $LateRules ne "" ) {
> 		$pageText = &EvalLocalRules( $LateRules, $pageText, 0 );
> 	}
> 	
> 	return &RestoreSavedText($pageText);
> }
> 
1603,1691c2136,2310
<   my ($text, $useImage, $doLines) = @_;
<   local $_ = $text;
< 
<   if ($doLines < 2) { # 2 = do line-oriented only
<     # The <nowiki> tag stores text with no markup (except quoting HTML)
<     s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
<     # The <pre> tag wraps the stored text with the HTML <pre> tag
<     s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
<     s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
<     if ($EarlyRules ne '') {
<       $_ = &EvalLocalRules($EarlyRules, $_, !$useImage);
<     }
<     s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
<     if ($HtmlTags) {
<       my ($t);
<       foreach $t (@HtmlPairs) {
<         s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
<       }
<       foreach $t (@HtmlSingle) {
<         s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
<       }
<     } else {
<       # Note that these tags are restricted to a single line
<       s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
<       s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
<       s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
<       s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
<     }
<     s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;  # <tt> (MeatBall)
<     s/\&lt;br\&gt;/<br>/gi;  # Allow simple line break anywhere
<     if ($HtmlLinks) {
<       s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
<     }
<     if ($FreeLinks) {
<       # Consider: should local free-link descriptions be conditional?
<       # Also, consider that one could write [[Bad Page|Good Page]]?
<       s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
<       s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
<     }
<     if ($BracketText) {  # Links like [URL text of link]
<       s/\[$UrlPattern\s+([^\]]+?)\]/&StoreBracketUrl($1, $2, $useImage)/geos;
<       s/\[$InterLinkPattern\s+([^\]]+?)\]/&StoreBracketInterPage($1, $2,
<                                                              $useImage)/geos;
<       if ($WikiLinks && $BracketWiki) {  # Local bracket-links
<         s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
<         s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1,
<                                                $2, $3)/geos if $NamedAnchors;
<       }
<     }
<     s/\[$UrlPattern\]/&StoreBracketUrl($1, "", 0)/geo;
<     s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0)/geo;
<     s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
<     s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
<     if ($WikiLinks) {
<       s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1,
<                              $2, ""))/geo if $NamedAnchors;
<       # CAA: Putting \b in front of $LinkPattern breaks /SubPage links
<       #      (subpage links without the main page)
<       s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
<     }
<     s/\b$RFCPattern/&StoreRFC($1)/geo;
<     s/\b$ISBNPattern/&StoreISBN($1)/geo;
<     if ($UseUpload) {
<       s/$UploadPattern/&StoreUpload($1)/geo;
<     }
<     if ($ThinLine) {
<       if ($OldThinLine) {  # Backwards compatible, conflicts with headers
<         s/====+/<hr noshade class=wikiline size=2>/g;
<       } else {             # New behavior--no conflict
<         s/------+/<hr noshade class=wikiline size=2>/g;
<       }
<       s/----+/<hr noshade class=wikiline size=1>/g;
<     } else {
<       s/----+/<hr class=wikiline>/g;
<     }
<   }
<   if ($doLines) { # 0 = no line-oriented, 1 or 2 = do line-oriented
<     # The quote markup patterns avoid overlapping tags (with 5 quotes)
<     # by matching the inner quotes for the strong pattern.
<     s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g;
<     s/''(.*?)''/<em>$1<\/em>/g;
<     if ($UseHeadings) {
<       s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
<     }
<     if ($TableMode) {
<       s/((\|\|)+)/"<\/TD><TD COLSPAN=\"" . (length($1)\/2) . "\">"/ge;
<     }
<   }
<   return $_;
---
> 	my ( $text, $useImage, $doLines ) = @_;
> 	local $_ = $text;
> 	
> 	if ( $doLines < 2 ) {    # 2 = do line-oriented only
> 		
> 		while ( m!\#INCLUDE\s*((\w+\.?\w*|/)+)!gi and $AllowInclusion ) {		
> 			my $FileName = $1;
> 			
> 			open FILE, "$InclusionDir/$FileName"
> 			or &ReportError(T("Cannot open $FileName: $!"));
> 			
> 			local $/;			
> 			my $FileContent = <FILE>;
> 			
> 			close FILE
> 			or &ReportError(T("Cannot close $FileName: $!"));
> 			s!\#INCLUDE\s*$FileName!$FileContent!i unless $FileName !~ /(html?|txt)$/i;
> 		}
>   
> 		# The <nowiki> tag stores text with no markup (except quoting HTML)
> 		s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
> 
> 		# The <pre> tag wraps the stored text with the HTML <pre> tag
> 		s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
> 		s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
> 		
> 		if ( $EarlyRules ne "" ) {
> 			$_ = &EvalLocalRules( $EarlyRules, $_, !$useImage );
> 		}
> 		
> 		s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
> 		
> 		if ($HtmlTags) {
> 			my ($t);
> 			foreach $t (@HtmlPairs) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
> 			}
> 			foreach $t (@HtmlSingle) {
> 				s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
> 			}
> 		}
> 		else {
> 
> 			# Note that these tags are restricted to a single line
> 			s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
> 			s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
> 			s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
> 			s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
> 		}
> 
> 		# Auto signature if use ~~~~ ; useful for quick comments
> 	    my $id = &GetParam("username", "");
> 		my $idLink = "$HomePagePrefix$id";
> 		my $timestamp = &TimeToText($Now);
> 		my $finalText = "";
> 		
> 		$id =~ s/ /_/g;
> 
> 		if ($id){
> 			$finalText = &StorePageOrEditLink($idLink, $id);
> 			s/\~\~\~\~/<i>\[$finalText]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$finalText at $timestamp]<\/i>/gi;
> 		}
> 		else {
> 			$id = "Guest";			
> 			s/\~\~\~\~/<i>\[$id at $timestamp]<\/i>/gi;
> 			s/\$\$\$\$/<i>\[$id at $timestamp]<\/i>/gi;
> 		}
> 		
> 		s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;    # <tt> (MeatBall)
> 		s/\&lt;br\&gt;/<br>/gi;    # Allow simple line break anywhere
> 		
> 		if ($HtmlLinks) {
> 			s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
> 		}
> 		
> 		if ($FreeLinks) {
> 
> 			# Consider: should local free-link descriptions be conditional?
> 			# Also, consider that one could write [[Bad Page|Good Page]]?
> 			s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
> 			s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
> 		}
> 		
> 		if ($BracketText) {        
> 			# Links like [URL text of link]
> 			s/\[$UrlPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketUrl($1, $2, $useImage, $3)/geos;
> 			s/\[$InterLinkPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketInterPage($1, $2, $useImage, $3)/geos;
> 			
> 			if ( $WikiLinks && $BracketWiki ) {    # Local bracket-links
> 				s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
> 				s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1, $2, $3)/geos if $NamedAnchors;
> 			}
> 		}
> 		
> 		if ($UseUpload) {
> 			s/$UploadPattern/&StoreUpload($1)/geo;
> 		}
> 				
> 		s/\[$UrlPattern(\|(.*))?\]/&StoreBracketUrl($1, "", 0, "")/geo;
> 		s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0, "")/geo;
> 		s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
> 		s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
> 		
> 		if ($WikiLinks) {
> 			s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1, $2, ""))/geo if $NamedAnchors;
> 
> 			# CAA: Putting \b in front of $LinkPattern breaks /SubPage links
> 			#      (subpage links without the main page)
> 			s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
> 		}
> 		s/\b$RFCPattern/&StoreRFC($1)/geo;
> 		s/\b$ISBNPattern/&StoreISBN($1)/geo;
> 		
> 		if ($ThinLine) {
> 			if ($OldThinLine) {   
> 				# Backwards compatible, conflicts with headers
> 				s/====+/$WikiLine2/g;
> 			}
> 			else {                
> 				# New behavior--no conflict
> 				s/------+/$WikiLine2/g;
> 			}
> 			s/----+/$WikiLine1/g;
> 		}
> 		else {
> 			s/----+/$WikiLine/g;
> 		}
> 		
> 		if ($AutoMailto) {
> 			s/([A-z0-9-_]+(?:\.[A-z0-9-_]+)*)\@([A-z0-9-_]+(?:\.[A-z0-9-_]+)*(?:\.[A-z]{2,})+)/<a href="mailto:$1\@$2">$1\@$2<\/a>/g;
> 		}
> 	}
> 	
> 	if ($doLines) {    
> 			# 0 = no line-oriented, 1 or 2 = do line-oriented
> 		    # The quote markup patterns avoid overlapping tags (with 5 quotes)
> 		    # by matching the inner quotes for the strong pattern.
> 		s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g; #'REMARK
> 		s/''(.*?)''/<em>$1<\/em>/g;
> 		
> 		if ($UseHeadings) {
> 		 ## s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
> 			s/(^|\n)\s*(\=+)\s*(#)?\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $4, $3)/geo;
> 		}
> 		
> 		if ($TableMode == 1) {
> 			my @cells = split(/\|\|/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\|\|)+([^\|<]+)/) {	
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\|\|)+)/"<\/td><td $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;
> 			} 
> 			s/(\|\w*=\w*)+([^\|<]+)//g;   
> 		}
> 		elsif  ($TableMode == 2) {
> 			my @cells = split(/\!\!/);
> 			my $cellIndex = 0;
> 			
> 			while (/(\!\!)+([^\!<]+)/) {			
> 				my $switches = @cells->[++$cellIndex];
> 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
> 				my $cellOptions = "$class $style $width $align";
> 				
> 				s/((\!\!)+)/"<\/th><th $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;				
> 			}
> 			s/(\|\w*=\w*)+([^\!<]+)//g;
> 		}
> 	}
> 	
> 	return $_;
1693a2313,2371
> sub GetTableCellModifiers {
> 	my ($given, $initialCell, $cellIndex) = @_;	
> 	my ($options) = $given;
> 
> 	/^(\s*(\w+)\s*)\|/;
> 	my $align = $2;
> 	if ($initialCell ne ""){ $align = $initialCell; }
> 		
> 	$align = $align =~ /^  / ? ($align =~ /  $/ ? 'center' : 'right') : 'left';
> 	$align = "align='$align'";
> 	
> 	my ($options) = $options =~ /(\|\S*=\S*)+/g;
> 	my %options = &GetOptions($options);
> 
> 	my $class;
> 	my $style;
> 	my $width;	
> 	my $rowclass;
> 	my $rowstyle;
> 	my $rowalign;
> 	my $tablewidth;
> 	my $tableclass;
> 	my $tablestyle;
> 		
> 	if ($TableCellDefaults{"rowclass"} =~ /clear/){ $TableCellDefaults{"rowclass"} = ""; }
> 	if ($TableCellDefaults{"rowstyle"} =~ /clear/){ $TableCellDefaults{"rowstyle"} = ""; }
> 	if ($TableCellDefaults{"rowalign"} =~ /clear/){ $TableCellDefaults{"rowalign"} = ""; }
> 				
> 	if ($TableCellDefaults{"rowclass"}){ $rowclass = $TableCellDefaults{"rowclass"}; }
> 	if ($TableCellDefaults{"rowstyle"}){ $rowstyle = $TableCellDefaults{"rowstyle"}; }
> 	if ($TableCellDefaults{"rowalign"}){ $rowalign = $TableCellDefaults{"rowalign"}; }
> 		
> 	if ($options{'rowclass'}){ $rowclass = "class='" . $options{'rowclass'} . "'"; $TableCellDefaults{"rowclass"} = $rowclass; }
> 	if ($options{'rowstyle'}){ $rowstyle = "style='" . $options{'rowstyle'} . "'"; $TableCellDefaults{"rowstyle"} = $rowstyle; }
> 	if ($options{'rowalign'}){ $rowalign = "align='" . $options{'rowalign'} . "'"; $TableCellDefaults{"rowalign"} = $rowalign; }
> 	
> 	if ($rowclass){ $class = $rowclass; }
> 	if ($rowstyle){ $style = $rowstyle; }
> 	if ($rowalign){ $align = $rowalign; }
> 
> 	if ($TableCellDefaults{"class$cellIndex"} =~ /clear/){ $TableCellDefaults{"class$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"style$cellIndex"} =~ /clear/){ $TableCellDefaults{"style$cellIndex"} = ""; }
> 	if ($TableCellDefaults{"align$cellIndex"} =~ /clear/){ $TableCellDefaults{"align$cellIndex"} = ""; }
> 			
> 	if ($TableCellDefaults{"class$cellIndex"}){ $class = $TableCellDefaults{"class$cellIndex"}; }
> 	if ($TableCellDefaults{"style$cellIndex"}){ $style = $TableCellDefaults{"style$cellIndex"}; }
> 	if ($TableCellDefaults{"align$cellIndex"}){ $align = $TableCellDefaults{"align$cellIndex"}; }
> 
> 	if ($options{'class'}){ $class = "class='" . $options{'class'} . "'"; $TableCellDefaults{"class$cellIndex"} = $class; }
> 	if ($options{'style'}){ $style = "style='" . $options{'style'} . "'"; $TableCellDefaults{"style$cellIndex"} = $style; }
> 	if ($options{'align'}){ $align = "align='" . $options{'align'} . "'"; $TableCellDefaults{"align$cellIndex"} = $align; }
> 	if ($options{'width'}){ $width = "width='" . $options{'width'} . "'"; }
> 	if ($options{'tablewidth'}){ $tablewidth = "width='" . $options{'tablewidth'} . "'"; }
> 	if ($options{'tablestyle'}){ $tablestyle = "style='" . $options{'tablestyle'} . "'"; }
> 	if ($options{'tableclass'}){ $tableclass = "class='" . $options{'tableclass'} . "'"; } else { $tableclass = "class='wikilargelist'"; }
> 					
> 	return ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass);				
> }
> 
1695,1757c2373,2477
<   my ($pageText) = @_;
<   my ($pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode);
< 
<   @htmlStack = ();
<   $depth = 0;
<   $pageHtml = "";
<   foreach (split(/\n/, $pageText)) {  # Process lines one-at-a-time
<     $code = '';
<     $codeAttributes = '';
<     $TableMode = 0;
<     $_ .= "\n";
<     if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
<       $code = "DL";
<       $depth = length $1;
<     } elsif (s/^(\:+)/<dt><dd>/) {
<       $code = "DL";
<       $depth = length $1;
<     } elsif (s/^(\*+)/<li>/) {
<       $code = "UL";
<       $depth = length $1;
<     } elsif (s/^(\#+)/<li>/) {
<       $code = "OL";
<       $depth = length $1;
<     } elsif ($TableSyntax &&
<              s/^((\|\|)+)(.*)\|\|\s*$/"<TR VALIGN='CENTER' "
<                                       . "ALIGN='CENTER'><TD colspan='"
<                                . (length($1)\/2) . "'>$3<\/TD><\/TR>\n"/e) {
<       $code = 'TABLE';
<       $codeAttributes = "BORDER='1'";
<       $TableMode = 1;
<       $depth = 1;
<     } elsif (/^[ \t].*\S/) {
<       $code = "PRE";
<       $depth = 1;
<     } else {
<       $depth = 0;
<     }
<     while (@htmlStack > $depth) {   # Close tags as needed
<       $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
<     }
<     if ($depth > 0) {
<       $depth = $IndentLimit  if ($depth > $IndentLimit);
<       if (@htmlStack) {  # Non-empty stack
<         $oldCode = pop(@htmlStack);
<         if ($oldCode ne $code) {
<           $pageHtml .= "</$oldCode><$code>\n";
<         }
<         push(@htmlStack, $code);
<       }
<       while (@htmlStack < $depth) {
<         push(@htmlStack, $code);
<         $pageHtml .= "<$code $codeAttributes>\n";
<       }
<     }
<     if (!$ParseParas) {
<       s/^\s*$/<p>\n/;                      # Blank lines become <p> tags
<     }
<     $pageHtml .= &CommonMarkup($_, 1, 2);  # Line-oriented common markup
<   }
<   while (@htmlStack > 0) {       # Clear stack
<     $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
<   }
<   return $pageHtml;
---
> 	my ($pageText) = @_;
> 	my ( $pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode );
> 	
> 	@htmlStack = ();
> 	$depth     = 0;
> 	$pageHtml  = "";
> 	
> 	foreach ( split( /\r?\n/, $pageText ) ) {    # Process lines one-at-a-time
> 		$code           = "";
> 		$codeAttributes = "";
> 		$TableMode      = 0;
> 		$_ .= "\n";
> 		
> 		if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\:+)/<dt><dd>/) {
> 			$code  = "dl";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\*+)/<li>/) {
> 			$code  = "ul";
> 			$depth = length $1;
> 		}
> 		elsif (s/^(\#+)/<li>/) {
> 			$code  = "ol";
> 			$depth = length $1;
> 		}
> 		elsif ($TableSyntax && /^(\!\!)+.*\!\!\s*$/) {
> 			/^(\!\!)+([^\!]+)/;
> 			
> 			%TableCellDefaults = {};
> 			
> 			my $switches = $2;
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, "", 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/th><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 2;
> 			$depth = 1;
> 		}
> 		elsif ($TableSyntax && /^(\|\|)+.*\|\|\s*$/) {
> 			/^((\|\|)+)(.*?)\|\|/;	
> 	
> 			my ($alignInitial) = $3;
> 			my $switches = $3;
> 			($alignInitial) = $alignInitial =~ /(.*)\|/;	
> 
> 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, $alignInitial, 0);
> 			my $cellOptions = "$class $style $width $align";
> 			
> 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/td><\/tr>\n"/e;
> 			
> 			$code = "table";
> 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
> 			$TableMode = 1;
> 			$depth = 1;
> 		}
> 		elsif (/^[ \t].*\S/) {
> 			$code  = "pre";
> 			$depth = 1;
> 		}
> 		else {
> 			$depth = 0;
> 		}
> 		
> 		while ( @htmlStack > $depth ) {    
> 			# Close tags as needed
> 			$pageHtml .= "</" . pop(@htmlStack) . ">";
> 		}
> 		
> 		if ( $depth > 0 ) {
> 			$depth = $IndentLimit if ( $depth > $IndentLimit );
> 			if (@htmlStack) {              
> 				# Non-empty stack
> 				$oldCode = pop(@htmlStack);
> 				
> 				if ( $oldCode ne $code ) {
> 					$pageHtml .= "</$oldCode><$code>";
> 				}
> 				push( @htmlStack, $code );
> 			}
> 			
> 			while ( @htmlStack < $depth ) {
> 				push( @htmlStack, $code );
> 				$pageHtml .= "\n<$code $codeAttributes>";
> 			}
> 		}
> 		
> 		if ( !$ParseParas ) {
> 			s/^\s*$/<p>\n/;    # Blank lines become <p> tags
> 		}
> 		$pageHtml .= &CommonMarkup( $_, 1, 2 );    # Line-oriented common markup
> 	}
> 	
> 	while ( @htmlStack > 0 ) {                     
> 		# Clear stack
> 		$pageHtml .= "</" . pop(@htmlStack) . ">";
> 	}
> 	
> 	return $pageHtml;
1761,1783c2481,2509
<   my ($rules, $origText, $isDiff) = @_;
<   my ($text, $reportError, $errorText);
< 
<   $text = $origText;
<   $reportError = 1;
<   # Basic idea: the $rules should change $text, possibly with different
<   # behavior if $isDiff is true (no images or color changes?)
<   # Note: for fun, the $rules could also change $reportError and $origText
<   if (!eval $rules) {
<     $errorText = $@;
<     if ($errorText eq '') {
<       # Search for "Unknown Error" for the reason the next line is commented
< #     $errorText = T('Unknown Error (no error text)');
<     }
<     if ($errorText ne '') {
<       $text = $origText;    # Consider: should partial results be kept?
<       if ($reportError) {
<         $text .= '<hr><b>' . T('Local rule error:') . '</b><br>'
<                  . &QuoteHtml($errorText);
<       }
<     }
<   }
<   return $text;
---
> 	my ( $rules, $origText, $isDiff ) = @_;
> 	my ( $text, $reportError, $errorText );
> 	
> 	$text        = $origText;
> 	$reportError = 1;
> 
> 	# Basic idea: the $rules should change $text, possibly with different
> 	# behavior if $isDiff is true (no images or color changes?)
> 	# Note: for fun, the $rules could also change $reportError and $origText
> 	if ( !eval $rules ) {
> 		$errorText = $@;
> 		
> 		if ( $errorText eq "" ) {
> 
> 		  # Search for "Unknown Error" for the reason the next line is commented
> 		  #     $errorText = "Unknown Error (no error text)";
> 		}
> 		if ( $errorText ne "" ) {
> 			$text = $origText;    # Consider: should partial results be kept?
> 			
> 			if ($reportError) {
> 				$text .= "\n<hr>";
> 				$text .= "<b>Local rule error:</b><br>";
> 				$text .= &QuoteHtml($errorText);
> 			}
> 		}
> 	}
> 	
> 	return $text;
1785d2511
<  
1787,1793c2513,2520
<   my ($html) = @_;
< 
<   $html =~ s/&/&amp;/g;
<   $html =~ s/</&lt;/g;
<   $html =~ s/>/&gt;/g;
<   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
<   return $html;
---
> 	my ($html) = @_;
> 	
> 	$html =~ s/&/&amp;/g;
> 	$html =~ s/</&lt;/g;
> 	$html =~ s/>/&gt;/g;
> 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
> 	
> 	return $html;
1797,1801c2524,2530
<   my ($text) = @_;
< 
<   $text = &CommonMarkup($text, 1, 0);   # Multi-line markup
<   $text = &WikiLinesToHtml($text);      # Line-oriented markup
<   return "<p>$text</p>\n";
---
> 	my ($text) = @_;
> 	
> 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
> 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
> 	
> 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
> 	return "\n<p>$text</p>";
1805,1811c2534,2542
<   my ($id, $useImage) = @_;
<   my ($link, $extra);
< 
<   ($link, $extra) = &InterPageLink($id, $useImage);
<   # Next line ensures no empty links are stored
<   $link = &StoreRaw($link)  if ($link ne "");
<   return $link . $extra;
---
> 	my ( $id, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &InterPageLink( $id, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
1815,1825c2546,2559
<   my ($id, $useImage) = @_;
<   my ($name, $site, $remotePage, $url, $punct);
< 
<   ($id, $punct) = &SplitUrlPunct($id);
<   $name = $id;
<   ($site, $remotePage) = split(/:/, $id, 2);
<   $url = &GetSiteUrl($site);
<   return ("", $id . $punct)  if ($url eq "");
<   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
<   $url .= $remotePage;
<   return (&UrlLinkOrImage($url, $name, $useImage), $punct);
---
> 	my ( $id, $useImage ) = @_;
> 	my ( $name, $site, $remotePage, $url, $punct );
> 	
> 	( $id, $punct ) = &SplitUrlPunct($id);
> 	$name = $id;
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$url = &GetSiteUrl($site);
> 	
> 	return ( "", $id . $punct ) if ( $url eq "" );
> 	
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url .= $remotePage;
> 	
> 	return ( &UrlLinkOrImage( $url, $name, $useImage ), $punct );
1829,1847c2563,2582
<   my ($id, $text, $useImage) = @_;
<   my ($site, $remotePage, $url, $index);
< 
<   ($site, $remotePage) = split(/:/, $id, 2);
<   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
<   $url = &GetSiteUrl($site);
<   if ($text ne "") {
<     return "[$id $text]"  if ($url eq "");
<   } else {
<     return "[$id]"  if ($url eq "");
<     $text = &GetBracketUrlIndex($id);
<   }
<   $url .= $remotePage;
<   if ($BracketImg && $useImage && &ImageAllowed($text)) {
<     $text = "<img src=\"$text\">";
<   } else {
<     $text = "[$text]";
<   }
<   return &StoreRaw("<a href=\"$url\">$text</a>");
---
> 	my ( $id, $text, $useImage, $options ) = @_;
> 	my ( $site, $remotePage, $url, $index );
> 	
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url = &GetSiteUrl($site);
> 	
> 	if ( $text ne "" ) {
> 		return "[$id $text]" if ( $url eq "" );
> 	}
> 	else {
> 		return "[$id]" if ( $url eq "" );
> 		$text = &GetBracketUrlIndex($id);
> 	}
> 	
> 	$url .= $remotePage;
> 	
> 	$text = StoreBracketUrl( $url, $text, $useImage, $options);
> 	
> 	return $text;
1851,1860c2586,2597
<   my ($id) = @_;
<   my ($index, $key);
< 
<   # Consider plain array?
<   if ($SaveNumUrl{$id} > 0) {
<     return $SaveNumUrl{$id};
<   }
<   $SaveNumUrlIndex++;  # Start with 1
<   $SaveNumUrl{$id} = $SaveNumUrlIndex;
<   return $SaveNumUrlIndex;
---
> 	my ($id) = @_;
> 	my ( $index, $key );
> 
> 	# Consider plain array?
> 	if ( $SaveNumUrl{$id} > 0 ) {
> 		return $SaveNumUrl{$id};
> 	}
> 	
> 	$SaveNumUrlIndex++;    # Start with 1
> 	$SaveNumUrl{$id} = $SaveNumUrlIndex;
> 	
> 	return $SaveNumUrlIndex;
1864,1882c2601,2624
<   my ($site) = @_;
<   my ($data, $status);
< 
<   if (!$InterSiteInit) {
<     ($status, $data) = &ReadFile($InterFile);
<     if ($status) {
<       %InterSite = split(/\s+/, $data);  # Consider defensive code
<     }
<     # Check for definitions to allow file to override automatic settings
<     if (!defined($InterSite{'LocalWiki'})) {
<       $InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
<     }
<     if (!defined($InterSite{'Local'})) {
<       $InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
<     }
<     $InterSiteInit = 1;  # Init only once per request
<   }
<   return $InterSite{$site}  if (defined($InterSite{$site}));
<   return '';
---
> 	my ($site) = @_;
> 	my ( $data, $status );
> 	
> 	if ( !$InterSiteInit ) {
> 		( $status, $data ) = &ReadFile($InterFile);
> 		
> 		if ($status) {
> 			%InterSite = split( /\s+/, $data );    # Consider defensive code
> 		}
> 
> 		# Check for definitions to allow file to override automatic settings
> 		if ( !defined( $InterSite{'LocalWiki'} ) ) {
> 			$InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		if ( !defined( $InterSite{'Local'} ) ) {
> 			$InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
> 		}
> 		
> 		$InterSiteInit = 1;                        # Init only once per request
> 	}
> 	
> 	return $InterSite{$site} if ( defined( $InterSite{$site} ) );
> 	return "";
1886,1889c2628,2632
<   my ($html) = @_;
< 
<   $SaveUrl{$SaveUrlIndex} = $html;
<   return $FS . $SaveUrlIndex++ . $FS;
---
> 	my ($html) = @_;
> 	
> 	$SaveUrl{$SaveUrlIndex} = $html;
> 	
> 	return $FS . $SaveUrlIndex++ . $FS;
1893,1895c2636,2638
<   my ($html, $tag) = @_;
< 
<   return &StoreRaw("<$tag>" . $html . "</$tag>");
---
> 	my ( $html, $tag ) = @_;
> 	
> 	return &StoreRaw( "<$tag>" . $html . "</$tag>" );
1898,1901c2641,2652
< sub StoreHref {
<   my ($anchor, $text) = @_;
< 
<   return "<a" . &StoreRaw($anchor) . ">$text</a>";
---
> sub ReadWikiFile {
> 	my ($fileName) = @_;
> 	my ($fileData, %tempPage, %tempSection, %tempText);
> 	
> 	return unless -f $fileName;
> 	
> 	$fileData = &ReadFileOrDie($fileName);
> 	%tempPage = split(/$FS1/, $fileData, -1);
> 	%tempSection = split(/$FS2/, $tempPage{'text_default'}, -1);
> 	%tempText = split(/$FS3/, $tempSection{'data'}, -1);
> 	
> 	return $tempText{'text'};
1904,1911c2655,2677
< sub StoreUrl {
<   my ($name, $useImage) = @_;
<   my ($link, $extra);
< 
<   ($link, $extra) = &UrlLink($name, $useImage);
<   # Next line ensures no empty links are stored
<   $link = &StoreRaw($link)  if ($link ne "");
<   return $link . $extra;
---
> sub WikiFileToHTML {
> 	my ($text) = @_;
> 	my ($output);
> 	my ($mySaveUrlIndex, $mySaveNumUrlIndex, $myTableMode, %mySaveUrl, %mySaveNumUrl);
> 	
> 	return unless $text;
> 	
> 	# Global variables do not help this code. Nasty, but easiest solution.
> 	%mySaveUrl= %SaveUrl;
> 	%mySaveNumUrl= %SaveNumUrl;
> 	$mySaveUrlIndex= $SaveUrlIndex;
> 	$mySaveNumUrlIndex = $SaveNumUrlIndex;
> 	$myTableMode= $TableMode;
> 	
> 	$output = &WikiToHTML($text);
> 	
> 	%SaveUrl = %mySaveUrl;
> 	%SaveNumUrl = %mySaveNumUrl;
> 	$SaveUrlIndex = $mySaveUrlIndex;
> 	$SaveNumUrlIndex = $mySaveNumUrlIndex;
> 	$TableMode = $myTableMode;
> 	
> 	return $output;
1914,1926c2680,2702
< sub UrlLink {
<   my ($rawname, $useImage) = @_;
<   my ($name, $punct);
< 
<   ($name, $punct) = &SplitUrlPunct($rawname);
<   if ($LimitFileUrl && ($NetworkFile && $name =~ m|^file:|)) {
<     # Only do remote file:// links. No file:///c|/windows.
<     if ($name =~ m|^file://[^/]|) {
<       return ("<a href=\"$name\">$name</a>", $punct);
<     }
<     return ($rawname, '');
<   }
<   return (&UrlLinkOrImage($name, $name, $useImage), $punct);
---
> sub StoreTemplate {
> 	my ($params) = @_;	
> 	my $id = &GetParam( "id",     "" );
> 	my ($templateId, $templateFile, $templateText, $output, %substitutes);
> 	
> 	$params =~ s/^\s*(\S+)\s*/$templateId=$1,''/e;
> 	return &StoreRaw(T('No template name')) unless $templateId;
> 	
> 	$templateFile = &GetPageFile($templateId);
> 	return &StoreRaw(Ts('Template %s not found', $templateId)) unless -f $templateFile;
> 	
> 	while ($params =~ /^(\S+)\s*=(.*)$/gm) {
> 		$substitutes{$1} = $2;
> 	}
> 
> 	$substitutes{'PID'} = '/RalphMorgan';
> 	
> 	$templateText = &ReadWikiFile($templateFile);
> 	$templateText =~ s/\$(\S+)\$/$substitutes{$1}/gi;
> 	$templateText =~ s/{{//g; # Avoid nesting.
> 	$output = &WikiFileToHTML($templateText);
> 	
> 	return &StoreRaw($output);
1929,1936c2705,2708
< sub UrlLinkOrImage {
<   my ($url, $name, $useImage) = @_;
< 
<   # Restricted image URLs so that mailto:foo@bar.gif is not an image
<   if ($useImage && &ImageAllowed($url)) {
<     return "<img src=\"$url\">";
<   }
<   return "<a href=\"$url\">$name</a>";
---
> sub StoreHref {
> 	my ( $anchor, $text ) = @_;
> 	
> 	return "<a" . &StoreRaw($anchor) . ">$text</a>";
1939,1952c2711,2720
< sub ImageAllowed {
<   my ($url) = @_;
<   my ($site, $imagePrefixes);
< 
<   $imagePrefixes = 'http:|https:|ftp:';
<   $imagePrefixes .= '|file:'  if (!$LimitFileUrl);
<   return 0  unless ($url =~ /^($imagePrefixes).+\.$ImageExtensions$/);
<   return 0  if ($url =~ /"/);      # No HTML-breaking quotes allowed
<   return 1  if (@ImageSites < 1);  # Most common case: () means all allowed
<   return 0  if ($ImageSites[0] eq 'none');  # Special case: none allowed
<   foreach $site (@ImageSites) {
<     return 1  if ($site eq substr($url, 0, length($site)));  # Match prefix
<   }
<   return 0;
---
> sub StoreUrl {
> 	my ( $name, $useImage ) = @_;
> 	my ( $link, $extra );
> 	
> 	( $link, $extra ) = &UrlLink( $name, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
> 	
> 	return $link . $extra;
1955,1966c2723,2739
< sub StoreBracketUrl {
<   my ($url, $text, $useImage) = @_;
< 
<   if ($text eq "") {
<     $text = &GetBracketUrlIndex($url);
<   }
<   if ($BracketImg && $useImage && &ImageAllowed($text)) {
<     $text = "<img src=\"$text\">";
<   } else {
<     $text = "[$text]";
<   }
<   return &StoreRaw("<a href=\"$url\">$text</a>");
---
> sub UrlLink {
> 	my ( $rawname, $useImage ) = @_;
> 	my ( $name, $punct );
> 	
> 	( $name, $punct ) = &SplitUrlPunct($rawname);
> 	
> 	if ( $LimitFileUrl && ( $NetworkFile && $name =~ m|^file:| ) ) {
> 
> 		# Only do remote file:// links. No file:///c|/windows.
> 		if ( $name =~ m|^file://[^/]| ) {
> 			return ( "<a href='$name' class='wikiurllink'>$name</a>", $punct );
> 		}
> 		
> 		return ( $rawname, "" );
> 	}
> 	
> 	return ( &UrlLinkOrImage( $name, $name, $useImage ), $punct );
1969,1972c2742,2750
< sub StoreBracketLink {
<   my ($name, $text) = @_;
< 
<   return &StoreRaw(&GetPageLinkText($name, "[$text]"));
---
> sub UrlLinkOrImage {
> 	my ( $url, $name, $useImage ) = @_;
> 	
> 	# Restricted image URLs so that mailto:foo@bar.gif is not an image
> 	if ( $useImage && &ImageAllowed($url) ) {
> 		return "<a href='$url' class='wikiurlorimage' target='_blank'><img class='wikiurlorimage' src='$url'></a>";
> 	}
> 	
> 	return "<a href='$url' class='wikiurlorimage'>$name</a>";
1975,1978c2753,2770
< sub StoreBracketAnchoredLink {
<   my ($name, $anchor, $text) = @_;
< 
<   return &StoreRaw(&GetPageLinkText("$name#$anchor", "[$text]"));
---
> sub ImageAllowed {
> 	my ($url) = @_;
> 	my ( $site, $imagePrefixes );
> 	
> 	$imagePrefixes = 'http:|https:|ftp:|upload:';
> 	$imagePrefixes .= '|file:' if ( !$LimitFileUrl );
> 	
> 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
> 	return 0 if ( $url =~ /"/ );    #" No HTML-breaking quotes allowed
> 	return 1 if ( @ImageSites < 1 );    # Most common case: () means all allowed
> 	return 0 if ( $ImageSites[0] eq 'none' );    # Special case: none allowed
> 
> 	foreach $site (@ImageSites) {
> 		return 1
> 		  if ( $site eq substr( $url, 0, length($site) ) );    # Match prefix
> 	}
> 	
> 	return 0;
1981,1991c2773,2778
< sub StorePageOrEditLink {
<   my ($page, $name) = @_;
< 
<   if ($FreeLinks) {
<     $page =~ s/^\s+//;      # Trim extra spaces
<     $page =~ s/\s+$//;
<     $page =~ s|\s*/\s*|/|;  # ...also before/after subpages
<   }
<   $name =~ s/^\s+//;
<   $name =~ s/\s+$//;
<   return &StoreRaw(&GetPageOrEditLink($page, $name));
---
> sub ExtensionAllowed {
> 	my ($file) = @_;
> 	
> 	return 1 if ( $file =~ m/\.(jpg|bmp|pdf|gif|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
> 	
> 	return 0;	
1994,1997c2781,2784
< sub StoreRFC {
<   my ($num) = @_;
< 
<   return &StoreRaw(&RFCLink($num));
---
> sub GetUploadUrl {
> 	my ($url) = @_;
> 	
> 	&StoreRaw($url);
2000,2003c2787,2796
< sub RFCLink {
<   my ($num) = @_;
< 
<   return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\">RFC $num</a>";
---
> sub GetOptions {
> 	my ($text) = @_;
> 	my %options;
> 	
> 	foreach my $pair (split(/\|/, $text)){
> 		my @keyvalues = split (/=/, $pair);
> 		$options{$keyvalues[0]} = $keyvalues[1];
> 	}
> 	
> 	return %options;	
2006,2009c2799,2824
< sub StoreUpload {
<   my ($url) = @_;
< 
<   return &StoreRaw(&UploadLink($url));
---
> sub ComputeImageRatio {
> 	my ($imageName, $desiredWidth, $desiredHeight, $okayLarger) = @_;
> 	my $filepath = "$UploadDir/$imageName";
> 	my ($imageWidth, $imageHeight) = Image::Size::imgsize($filepath);
> 	
> 	my $ratioWidth = 1;
> 	my $ratioHeight = 1;
> 	my $ratioFinal = 1;
> 	
> 	if ($desiredWidth){ $ratioWidth = $desiredWidth/$imageWidth; }
> 	if ($desiredHeight){ $ratioHeight = $desiredHeight/$imageHeight; }
> 	
> 	if ($okayLarger){
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioWidth; }
> 		else { $ratioFinal = $ratioHeight; }
> 	}
> 	else {
> 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioHeight; }
> 		else { $ratioFinal = $ratioWidth; }
> 	
> 	}
> 	
> 	my $finalWidth = int($ratioFinal * $imageWidth);
> 	my $finalHeight = int($ratioFinal * $imageHeight);
> 	
> 	return ($finalWidth, $finalHeight);
2012,2026c2827,2898
< sub UploadLink {
<   my ($filename) = @_;
<   my ($html, $url);
<  
<   return $filename  if ($UploadUrl eq '');  # No bad links if misconfigured
<   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
<   $url = $UploadUrl . $filename;
<   $html = '<a href="' . $url . '">';
<   if (&ImageAllowed($url)) {
<     $html .= '<img src="' . $url . '" alt="upload:' . $filename . '">';
<   } else {
<     $html .= 'upload:' . $filename;
<   }
<   $html .= '</a>';
<   return $html;
---
> sub StoreBracketUrl {
> 	my ( $url, $text, $useImage, $options ) = @_;
> 	my %options = &GetOptions($options);
> 	my $imageFloat;
> 	my $imageClear = "\n<br class='clear$options{clear}'/>";
> 	my $boxFloat = " float" . $options{'boxfloat'};
> 	my $boxClear = "\n<br class='clear$options{boxclear}'/>";
> 	my $width;
> 	my $height;
> 	my $title;
> 	my $caption;
> 	my $description;
> 	my $imageLink;
> 	my $boxWidth = "style='width: 300px !important;'";
> 
> 	if ( $text eq "" ) { $text = &GetBracketUrlIndex($url); }
> 
> 	if ($options{'float'}){ $imageFloat = "float" . $options{'float'}; }
> 	if ($options{'clear'}){ $imageClear = "\n<br class='clear$options{clear}'/>"; }
> 	if ($options{'title'}){ $title = $options{title}; } else { $title = $text; }
> 	if ($options{'width'}){ $width = $options{'width'}; }
> 	if ($options{'height'}){ $height = $options{'height'}; }
> 			
> 	if ($options{'boxfloat'}){ $boxFloat = "float" . $options{'boxfloat'}; }
> 	if ($options{'boxclear'}){ $boxClear = "\n<br class='clear$options{boxclear}'/>"; }
> 	if ($options{'boxwidth'}){ $boxWidth = "style='width: $options{boxwidth} !important;'"; }
> 	if ($options{'caption'}){ 
> 		if ($options{'description'}){ $description = $options{description}; } 
> 		else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 		
> 		$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div><div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 	}
> 	
> 	if ($url =~ /$UploadPattern/){ $url = "$UploadUrl/$1"; }	
> 	if ( $BracketImg && $useImage && &ImageAllowed($text) ) {		
> 		if ($text =~ /$UploadPattern/){
> 			my $imageName = $1;
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($imageName, $width, $height, "");
> 			my $imageStyle = "style='width: $imageWidth; height: $imageHeight;'";
> 			
> 			$imageLink = "$UploadUrl/" . &GetUploadUrl($1);			
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' $imageStyle src='$imageLink'></a>";
> 		}
> 		else {
> 			$imageLink = $text;
> 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' src='$imageLink'></a>";
> 		}
> 		my $expandlink =  "<a target='_blank' class='wikiexpandimageicon' href='$imageLink' title='View source image'>&nbsp;</a>";
> 		
> 		if ($options{'caption'}){ 
> 			if ($options{'description'}){ $description = $options{description}; } 
> 			else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
> 			
> 			$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div>$expandlink<div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
> 		}
> 			
> 		if ($imageClear){ $text .= $imageClear; }		
> 					
> 		if ($caption){
> 			$text = "\n<div title='$title' class='wikibracketbox $boxFloat' $boxWidth>$text$caption</div>";		
> 		}
> 		else {
> 			$text = "\n<div title='$title' class='$boxFloat'>$text</div>";	
> 		}
> 		
> 		if ($boxClear){ $text .= $boxClear; }
> 	}
> 	else {
> 		$text = "<a href='$url' title='$title' class='wikibracketurl'>[$text]</a>";
> 	}
> 	
> 	return &StoreRaw($text);
2029,2032c2901,2904
< sub StoreISBN {
<   my ($num) = @_;
< 
<   return &StoreRaw(&ISBNLink($num));
---
> sub StoreBracketLink {
> 	my ( $name, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( $name, "[$text]" ) );
2035,2038c2907,2910
< sub ISBNALink {
<   my ($num, $pre, $post, $text) = @_;
< 
<   return '<a href="' . $pre . $num . $post . '">' . $text . '</a>';
---
> sub StoreBracketAnchoredLink {
> 	my ( $name, $anchor, $text ) = @_;
> 	
> 	return &StoreRaw( &GetPageLinkText( "$name#$anchor", "[$text]" ) );
2041,2067c2913,2924
< sub ISBNLink {
<   my ($rawnum) = @_;
<   my ($rawprint, $html, $num, $numSites, $i);
< 
<   $num = $rawnum;
<   $rawprint = $rawnum;
<   $rawprint =~ s/ +$//;
<   $num =~ s/[- ]//g;
<   $numSites = scalar @IsbnNames;  # Number of entries
<   if ((length($num) != 10) || ($numSites < 1)) {
<     return "ISBN $rawnum";
<   }
<   $html = &ISBNALink($num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint);
<   if ($numSites > 1) {
<     $html .= ' (';
<     $i = 1;
<     while ($i < $numSites) {
<       $html .= &ISBNALink($num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i]);
<       if ($i < ($numSites - 1)) {  # Not the last site
<         $html .= ', ';
<       }
<       $i++;
<     }
<     $html .= ')';
<   }
<   $html .= " "  if ($rawnum =~ / $/);  # Add space if old ISBN had space.
<   return $html;
---
> sub StorePageOrEditLink {
> 	my ( $page, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$page =~ s/^\s+//;        # Trim extra spaces
> 		$page =~ s/\s+$//;
> 		$page =~ s|\s*/\s*|/|;    # ...also before/after subpages
> 	}
> 	$name =~ s/^\s+//;
> 	$name =~ s/\s+$//;
> 	
> 	return &StoreRaw( &GetPageOrEditLink( $page, $name ) );
2070,2085c2927,2929
< sub SplitUrlPunct {
<   my ($url) = @_;
<   my ($punct);
< 
<   if ($url =~ s/\"\"$//) {
<     return ($url, "");   # Delete double-quote delimiters here
<   }
<   $punct = "";
<   if ($NewFS) {
<     ($punct) = ($url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/);
<     $url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
<   } else {
<     ($punct) = ($url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/);
<     $url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
<   }
<   return ($url, $punct);
---
> sub StoreRFC {
> 	my ($num) = @_;
> 	return &StoreRaw( &RFCLink($num) );
2088,2093c2932,2934
< sub StripUrlPunct {
<   my ($url) = @_;
<   my ($junk);
< 
<   ($url, $junk) = &SplitUrlPunct($url);
<   return $url;
---
> sub RFCLink {
> 	my ($num) = @_;
> 	return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\" class='wikirfclink'>RFC $num</a>";
2096,2130c2937,2940
< sub WikiHeadingNumber {
<     my ($depth, $text) = @_;
<     my ($anchor, $number);
< 
<     return '' unless --$depth > 0;  # Don't number H1s because it looks stupid
<     while (scalar @HeadingNumbers < ($depth-1)) {
<         push @HeadingNumbers, 1;
<         $TableOfContents .= '<dl><dt> </dt><dd>';
<     }
<     if (scalar @HeadingNumbers < $depth) {
<         push @HeadingNumbers, 0;
<         $TableOfContents .= '<dl><dt> </dt><dd>';
<     }
<     while (scalar @HeadingNumbers > $depth) {
<         pop @HeadingNumbers;
<         $TableOfContents .= "</dd></dl>\n\n";
<     }
<     $HeadingNumbers[$#HeadingNumbers]++;
<     $number = (join '.', @HeadingNumbers) . '. ';
<     # Remove embedded links. THIS IS FRAGILE!
<     $text = &RestoreSavedText($text);
<     $text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si; # No such page syntax
<     $text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
<     # Cook anchor by canonicalizing $text.
<     $anchor = $text;
<     $anchor =~ s/\<.*?\>//g; 
<     $anchor =~ s/\W/_/g;   
<     $anchor =~ s/__+/_/g;
<     $anchor =~ s/^_//;
<     $anchor =~ s/_$//;
<     # Last ditch effort
<     $anchor = '_' . (join '_', @HeadingNumbers) unless $anchor;
<     $TableOfContents .= $number . &ScriptLink("$OpenPageName#$anchor",$text)
<                         . "</dd>\n<dt> </dt><dd>";
<     return &StoreHref(" name=\"$anchor\"") . $number;
---
> sub StoreUpload {
> 	my ($url) = @_;
> 	
> 	return &StoreRaw( &UploadLink($url) );
2133,2139c2943,2961
< sub WikiHeading {
<   my ($pre, $depth, $text) = @_;
< 
<   $depth = length($depth);
<   $depth = 6  if ($depth > 6);
<   $text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e; # $' == $POSTMATCH
<   return $pre . "<H$depth>$text</H$depth>\n";
---
> sub UploadLink {
> 	my ($filename) = @_;
> 	my ( $html, $url );
> 	
> 	return $filename if ( $UploadUrl eq "" );    # No bad links if misconfigured
> 	
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$url  = $UploadUrl . $filename;
> 	$html = "<a href='$url' class='wikiuploadlink' target='_blank'>";
> 	
> 	if ( &ImageAllowed($url) ) {
> 		$html .= "<img class='wikiuploadlink' src='$url' alt='upload:$filename'>";
> 	}
> 	else {
> 		$html .= "upload:$filename";
> 	}
> 	$html .= "</a>";
> 	
> 	return $html;
2142,2228c2964,2967
< # ==== Difference markup and HTML ====
< sub GetDiffHTML {
<   my ($diffType, $id, $revOld, $revNew, $newText) = @_;
<   my ($html, $diffText, $diffTextTwo, $priorName, $links, $usecomma);
<   my ($major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName);
< 
<   $links = "(";
<   $usecomma = 0;
<   $major  = &ScriptLinkDiff(1, $id, T('major diff'), "");
<   $minor  = &ScriptLinkDiff(2, $id, T('minor diff'), "");
<   $author = &ScriptLinkDiff(3, $id, T('author diff'), "");
<   $useMajor  = 1;
<   $useMinor  = 1;
<   $useAuthor = 1;
<   $diffType = &GetParam("defaultdiff", 1)  if ($diffType == 4);
<   if ($diffType == 1) {
<     $priorName = T('major');
<     $cacheName = 'major';
<     $useMajor  = 0;
<   } elsif ($diffType == 2) {
<     $priorName = T('minor');
<     $cacheName = 'minor';
<     $useMinor  = 0;
<   } elsif ($diffType == 3) {
<     $priorName = T('author');
<     $cacheName = 'author';
<     $useAuthor = 0;
<   }
<   if ($revOld ne "") {
<     # Note: OpenKeptRevisions must have been done by caller.
<     # Eventually optimize if same as cached revision
<     $diffText = &GetKeptDiff($newText, $revOld, 1);  # 1 = get lock
<     if ($diffText eq "") {
<       $diffText = T('(The revisions are identical or unavailable.)');
<     }
<   } else {
<     $diffText  = &GetCacheDiff($cacheName);
<   }
<   $useMajor  = 0  if ($useMajor  && ($diffText eq &GetCacheDiff("major")));
<   $useMinor  = 0  if ($useMinor  && ($diffText eq &GetCacheDiff("minor")));
<   $useAuthor = 0  if ($useAuthor && ($diffText eq &GetCacheDiff("author")));
<   $useMajor  = 0  if ((!defined(&GetPageCache('oldmajor'))) ||
<                       (&GetPageCache("oldmajor") < 1));
<   $useAuthor = 0  if ((!defined(&GetPageCache('oldauthor'))) ||
<                       (&GetPageCache("oldauthor") < 1));
<   if ($useMajor) {
<     $links .= $major;
<     $usecomma = 1;
<   }
<   if ($useMinor) {
<     $links .= ", "  if ($usecomma);
<     $links .= $minor;
<     $usecomma = 1;
<   }
<   if ($useAuthor) {
<     $links .= ", "  if ($usecomma);
<     $links .= $author;
<   }
<   if (!($useMajor || $useMinor || $useAuthor)) {
<     $links .= T('no other diffs');
<   }
<   $links .= ")";
<   if ((!defined($diffText)) || ($diffText eq "")) {
<     $diffText = T('No diff available.');
<   }
<   if ($revOld ne "") {
<     my $currentRevision = T('current revision');
<     $currentRevision = Ts('revision %s', $revNew) if $revNew;
<     $html = '<b>'
<       . Tss("Difference (from revision %1 to %2)", $revOld, $currentRevision)
<       . "</b>\n" . "$links<br>" . &DiffToHTML($diffText);
<   } else {
<     if (($diffType != 2) &&
<         ((!defined(&GetPageCache("old$cacheName"))) ||
<          (&GetPageCache("old$cacheName") < 1))) {
<       $html = '<b>'
<               . Ts('No diff available--this is the first %s revision.',
<                    $priorName) . "</b>\n$links";
<     } else {
<       $html = '<b>'
<               . Ts('Difference (from prior %s revision)', $priorName)
<               . "</b>\n$links<br>" . &DiffToHTML($diffText);
<     }
<   }
<   @HeadingNumbers = ();
<   $TableOfContents = '';
<   return $html;
---
> sub StoreISBN {
> 	my ($num) = @_;
> 	
> 	return &StoreRaw( &ISBNLink($num) );
2231,2238c2970,2973
< sub GetCacheDiff {
<   my ($type) = @_;
<   my ($diffText);
< 
<   $diffText = &GetPageCache("diff_default_$type");
<   $diffText = &GetCacheDiff('minor')  if ($diffText eq "1");
<   $diffText = &GetCacheDiff('major')  if ($diffText eq "2");
<   return $diffText;
---
> sub ISBNALink {
> 	my ( $num, $pre, $post, $text ) = @_;
> 	
> 	return "<a href='$pre$num$post' class='wikiisbnalink'>$text</a>";
2241,2253c2976,3008
< # Must be done after minor diff is set and OpenKeptRevisions called
< sub GetKeptDiff {
<   my ($newText, $oldRevision, $lock) = @_;
<   my (%sect, %data, $oldText);
< 
<   $oldText = "";
<   if (defined($KeptRevisions{$oldRevision})) {
<     %sect = split(/$FS2/, $KeptRevisions{$oldRevision}, -1);
<     %data = split(/$FS3/, $sect{'data'}, -1);
<     $oldText = $data{'text'};
<   }
<   return ""  if ($oldText eq "");  # Old revision not found
<   return &GetDiff($oldText, $newText, $lock);
---
> sub ISBNLink {
> 	my ($rawnum) = @_;
> 	my ( $rawprint, $html, $num, $numSites, $i );
> 	
> 	$num      = $rawnum;
> 	$rawprint = $rawnum;
> 	$rawprint =~ s/ +$//;
> 	$num      =~ s/[- ]//g;
> 	$numSites = scalar @IsbnNames;    # Number of entries
> 	
> 	if ( ( length($num) != 10 ) || ( $numSites < 1 ) ) {
> 		return "ISBN $rawnum";
> 	}
> 	
> 	$html = &ISBNALink( $num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint );
> 	
> 	if ( $numSites > 1 ) {
> 		$html .= " (";
> 		$i = 1;
> 		while ( $i < $numSites ) {
> 			$html .=
> 			  &ISBNALink( $num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i] );
> 			if ( $i < ( $numSites - 1 ) ) {    # Not the last site
> 				$html .= ", ";
> 			}
> 			$i++;
> 		}
> 		$html .= ")";
> 	}
> 	
> 	$html .= " " if ( $rawnum =~ / $/ );    # Add space if old ISBN had space.
> 	
> 	return $html;
2256,2274c3011,3029
< sub GetDiff {
<   my ($old, $new, $lock) = @_;
<   my ($diff_out, $oldName, $newName);
< 
<   &CreateDir($TempDir);
<   $oldName = "$TempDir/old_diff";
<   $newName = "$TempDir/new_diff";
<   if ($lock) {
<     &RequestDiffLock() or return "";
<     $oldName .= "_locked";
<     $newName .= "_locked";
<   }
<   &WriteStringToFile($oldName, $old);
<   &WriteStringToFile($newName, $new);
<   $diff_out = `diff $oldName $newName`;
<   &ReleaseDiffLock()  if ($lock);
<   $diff_out =~ s/\\ No newline.*\n//g;   # Get rid of common complaint.
<   # No need to unlink temp files--next diff will just overwrite.
<   return $diff_out;
---
> sub SplitUrlPunct {
> 	my ($url) = @_;
> 	my ($punct);
> 	
> 	if ( $url =~ s/\"\"$// ) {  #"REMARK
> 		return ( $url, "" );    # Delete double-quote delimiters here
> 	}
> 	
> 	$punct = "";
> 	if ($NewFS) {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	else {
> 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/ );
> 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
> 	}
> 	
> 	return ( $url, $punct );
2277,2291c3032,3038
< sub DiffToHTML {
<   my ($html) = @_;
<   my ($tChanged, $tRemoved, $tAdded);
< 
<   $tChanged = T('Changed:');
<   $tRemoved = T('Removed:');
<   $tAdded   = T('Added:');
<   $html =~ s/\n--+//g;
<   # Note: Need spaces before <br> to be different from diff section.
<   $html =~ s/(^|\n)(\d+.*c.*)/$1 <br><strong>$tChanged $2<\/strong><br>/g;
<   $html =~ s/(^|\n)(\d+.*d.*)/$1 <br><strong>$tRemoved $2<\/strong><br>/g;
<   $html =~ s/(^|\n)(\d+.*a.*)/$1 <br><strong>$tAdded $2<\/strong><br>/g;
<   $html =~ s/\n((<.*\n)+)/&ColorDiff($1, $DiffColor1, 0)/ge;
<   $html =~ s/\n((>.*\n)+)/&ColorDiff($1, $DiffColor2, 1)/ge;
<   return $html;
---
> sub StripUrlPunct {
> 	my ($url) = @_;
> 	my ($junk);
> 	
> 	( $url, $junk ) = &SplitUrlPunct($url);
> 	
> 	return $url;
2294,2322c3041,3091
< sub ColorDiff {
<   my ($diff, $color, $type) = @_;
<   my ($colorHtml, $classHtml);
< 
<   $diff =~ s/(^|\n)[<>]/$1/g;
<   $diff = &QuoteHtml($diff);
<   # Do some of the Wiki markup rules:
<   %SaveUrl = ();
<   %SaveNumUrl = ();
<   $SaveUrlIndex = 0;
<   $SaveNumUrlIndex = 0;
<   $diff = &RemoveFS($diff);
<   $diff = &CommonMarkup($diff, 0, 1);      # No images, all patterns
<   if ($LateRules ne '') {
<     $diff = &EvalLocalRules($LateRules, $diff, 1);
<   }
<   1 while $diff =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
<   $diff =~ s/\r?\n/<br>/g;
<   $colorHtml = '';
<   if ($color ne '') {
<     $colorHtml = " bgcolor=$color";
<   }
<   if ($type) {
<     $classHtml = ' class=wikidiffnew';
<   } else {
<     $classHtml = ' class=wikidiffold';
<   }
<   return "<table width=\"95\%\"$colorHtml$classHtml><tr><td>\n" . $diff
<          . "</td></tr></table>\n";
---
> sub WikiHeadingNumber {
> 	my ( $depth, $text, $useNumber) = @_;
> 	#my ( $depth, $text ) = @_;
> 	my ( $anchor, $number );
> 	
> 	return "" unless --$depth > 0;    # Don't number H1s because it looks stupid
> 		
> 	while ( scalar @HeadingNumbers < ( $depth - 1 ) ) {
> 		push @HeadingNumbers, 1;
> 		$TableOfContents .= "\n<dl><dt></dt><dd>";
> 	}
> 	
> 	if ( scalar @HeadingNumbers < $depth ) {
> 		push @HeadingNumbers, 0;
> 		$TableOfContents .= "\n<dl><dt></dt><dd>";
> 	}
> 	
> 	while ( scalar @HeadingNumbers > $depth ) {
> 		pop @HeadingNumbers;
> 		$TableOfContents .= "</dd></dl>";
> 	}
> 	
> 	$HeadingNumbers[$#HeadingNumbers]++;
> 	$number = ( join '.', @HeadingNumbers ) . '. ';
> 
> 	# Remove embedded links. THIS IS FRAGILE!
> 	$text = &RestoreSavedText($text);
> 	$text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si;        # No such page syntax
> 	$text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
> 
> 	# Cook anchor by canonicalizing $text.
> 	$anchor = $text;
> 	$anchor =~ s/\<.*?\>//g;
> 	$anchor =~ s/\W/_/g;
> 	$anchor =~ s/__+/_/g;
> 	$anchor =~ s/^_//;
> 	$anchor =~ s/_$//;
> 
> 	# Last ditch effort
> 	$anchor = "_" . ( join '_', @HeadingNumbers ) unless $anchor;
> 	$TableOfContents .= ('&nbsp;' x (2 * $depth)) . $number;
> 	$TableOfContents .= &ScriptLink( "$OpenPageName#$anchor", $text );
> 	$TableOfContents .= "</dd><dt>";
> 	$TableOfContents .= "</dt><dd>";
> 	  
> 	## return &StoreHref(" name='$anchor'") . $number;
> 	if ($useNumber) {
> 		return &StoreHref(" name='$anchor'") . $number;
> 	} else {
> 		return &StoreHref(" name='$anchor'");
> 	}
2325,2333c3094,3105
< # ==== Database (Page, Section, Text, Kept, User) functions ====
< sub OpenNewPage {
<   my ($id) = @_;
< 
<   %Page = ();
<   $Page{'version'} = 3;      # Data format version
<   $Page{'revision'} = 0;     # Number of edited times
<   $Page{'tscreate'} = $Now;  # Set once at creation
<   $Page{'ts'} = $Now;        # Updated every edit
---
> sub WikiHeading {
> 	## my ( $pre, $depth, $text ) = @_;
> 	my ($pre, $depth, $text, $useNumber) = @_;
> 	$depth = length($depth);
> 	$depth = 6 if ( $depth > 6 );
> 	##$text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e;    # $' == $POSTMATCH
> 	if ($useNumber) {
> 		$text = &WikiHeadingNumber($depth,$text, 1) . $text;
> 	} else {
> 		$text = &WikiHeadingNumber($depth,$text, 0) . $text;
> 	}	
> 	return $pre . "<h$depth>$text</h$depth>";
2336,2350c3108,3211
< sub OpenNewSection {
<   my ($name, $data) = @_;
< 
<   %Section = ();
<   $Section{'name'} = $name;
<   $Section{'version'} = 1;      # Data format version
<   $Section{'revision'} = 0;     # Number of edited times
<   $Section{'tscreate'} = $Now;  # Set once at creation
<   $Section{'ts'} = $Now;        # Updated every edit
<   $Section{'ip'} = $ENV{REMOTE_ADDR};
<   $Section{'host'} = '';        # Updated only for real edits (can be slow)
<   $Section{'id'} = $UserID;
<   $Section{'username'} = &GetParam("username", "");
<   $Section{'data'} = $data;
<   $Page{$name} = join($FS2, %Section);  # Replace with save?
---
> # ==== Difference markup and HTML ====
> sub GetDiffHTML {
> 	my ( $diffType, $id, $revOld, $revNew, $newText ) = @_;
> 	my ( $html, $diffText, $diffTextTwo, $priorName, $links, $usecomma );
> 	my ( $major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName );
> 	
> 	$links     = " (";
> 	$usecomma  = 0;
> 	$major     = &ScriptLinkDiff( 1, $id, "major diff", "" );
> 	$minor     = &ScriptLinkDiff( 2, $id, "minor diff", "" );
> 	$author    = &ScriptLinkDiff( 3, $id, "author diff", "" );
> 	$useMajor  = 1;
> 	$useMinor  = 1;
> 	$useAuthor = 1;
> 	$diffType  = &GetParam( "defaultdiff", 1 ) if ( $diffType == 4 );
> 	
> 	if ( $diffType == 1 ) {
> 		$priorName = "major";
> 		$cacheName = "major";
> 		$useMajor  = 0;
> 	}
> 	elsif ( $diffType == 2 ) {
> 		$priorName = "minor";
> 		$cacheName = "minor";
> 		$useMinor  = 0;
> 	}
> 	elsif ( $diffType == 3 ) {
> 		$priorName = "author";
> 		$cacheName = "author";
> 		$useAuthor = 0;
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 
> 		# Note: OpenKeptRevisions must have been done by caller.
> 		# Eventually optimize if same as cached revision
> 		$diffText = &GetKeptDiff( $newText, $revOld, 1 );    # 1 = get lock
> 		if ( $diffText eq "" ) {
> 			$diffText = "(The revisions are identical or unavailable.)";
> 		}
> 	}
> 	else {
> 		$diffText = &GetCacheDiff($cacheName);
> 	}
> 	
> 	$useMajor = 0 if ( $useMajor && ( $diffText eq &GetCacheDiff("major") ) );
> 	$useMinor = 0 if ( $useMinor && ( $diffText eq &GetCacheDiff("minor") ) );
> 	$useAuthor = 0 if ( $useAuthor && ( $diffText eq &GetCacheDiff("author") ) );
> 	$useMajor = 0 if ( ( !defined( &GetPageCache('oldmajor') ) ) || ( &GetPageCache("oldmajor") < 1 ) );
> 	$useAuthor = 0 if ( ( !defined( &GetPageCache('oldauthor') ) ) || ( &GetPageCache("oldauthor") < 1 ) );
> 	
> 	if ($useMajor) {
> 		$links .= $major;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useMinor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $minor;
> 		$usecomma = 1;
> 	}
> 	
> 	if ($useAuthor) {
> 		$links .= ", " if ($usecomma);
> 		$links .= $author;
> 	}
> 	
> 	if ( !( $useMajor || $useMinor || $useAuthor ) ) {
> 		$links .= "no other diffs";
> 	}
> 	$links .= ")";
> 	
> 	if ( ( !defined($diffText) ) || ( $diffText eq "" ) ) {
> 		$diffText = "No diff available.";
> 	}
> 	
> 	if ( $revOld ne "" ) {
> 		my $currentRevision = "current revision";
> 		
> 		$currentRevision = "revision $revNew " if $revNew;
> 		$html .= "<h4>Difference (from revision $revOld to $currentRevision)</h4>";
> 		$html .= "$links<br><br>";
> 		$html .= &DiffToHTML($diffText);
> 	}
> 	else {
> 		if (
> 			( $diffType != 2 )
> 			&& (   ( !defined( &GetPageCache("old$cacheName") ) )
> 				|| ( &GetPageCache("old$cacheName") < 1 ) )
> 		  )
> 		{
> 			$html .= "<h4>No diff available -- this is the first $priorName revision.</h4>";
> 			$html .= "$links<br><br>";
> 		}
> 		else {
> 			$html .= "<h4>Difference from prior $priorName revision</h4>";
> 			$html .= "$links<br><br>";
> 			$html .= &DiffToHTML($diffText);
> 		}
> 	}
> 	@HeadingNumbers  = ();
> 	$TableOfContents = "";
> 		
> 	return $html;
2353,2365c3214,3220
< sub OpenNewText {
<   my ($name) = @_;  # Name of text (usually "default")
<   %Text = ();
<   if ($NewText ne '') {
<     $Text{'text'} = T($NewText);
<   } else {
<     $Text{'text'} = T('Describe the new page here.') . "\n";
<   }
<   $Text{'text'} .= "\n"  if (substr($Text{'text'}, -1, 1) ne "\n");
<   $Text{'minor'} = 0;      # Default as major edit
<   $Text{'newauthor'} = 1;  # Default as new author
<   $Text{'summary'} = '';
<   &OpenNewSection("text_$name", join($FS3, %Text));
---
> sub GetCacheDiff {
> 	my ($type) = @_;
> 	my ($diffText);
> 	$diffText = &GetPageCache("diff_default_$type");
> 	$diffText = &GetCacheDiff('minor') if ( $diffText eq "1" );
> 	$diffText = &GetCacheDiff('major') if ( $diffText eq "2" );
> 	return $diffText;
2368,2371c3223,3234
< sub GetPageFile {
<   my ($id) = @_;
< 
<   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
---
> # Must be done after minor diff is set and OpenKeptRevisions called
> sub GetKeptDiff {
> 	my ( $newText, $oldRevision, $lock ) = @_;
> 	my ( %sect, %data, $oldText );
> 	$oldText = "";
> 	if ( defined( $KeptRevisions{$oldRevision} ) ) {
> 		%sect = split( /$FS2/, $KeptRevisions{$oldRevision}, -1 );
> 		%data = split( /$FS3/, $sect{'data'}, -1 );
> 		$oldText = $data{'text'};
> 	}
> 	return "" if ( $oldText eq "" );    # Old revision not found
> 	return &GetDiff( $oldText, $newText, $lock );
2374,2379c3237,3286
< sub OpenPage {
<   my ($id) = @_;
<   my ($fname, $data);
< 
<   if ($OpenPageName eq $id) {
<     return;
---
> sub GetDiff {
>   my $textOld = shift;
>   my $textNew = shift;
> 
>   my %format = (
>     paraIdent     => '<tr valign=top><td class="diff-para-ident">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident">%text%</td></tr>',
>     paraAdded     => '<tr valign=top><td class="diff-para-ident"></td><td class="diff-vertical"></td><td class="diff-para-added">%text%</td></tr>',
>     paraDeleted   => '<tr valign=top><td class="diff-para-deleted">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident"></td></tr>',
>     paraChanged   => '<tr valign=top><td class="diff-para-changed-old">%text%</td><td class="diff-vertical"></td><td class="diff-para-changed-new">%text%</td></tr>',
>     paraReplaced  => '<tr valign=top><td class="diff-para-deleted">%textDeleted%</td><td class="diff-vertical"></td><td class="diff-para-added">%textAdded%</td></tr>',
>   
>     changeContext => 1,
>     changeHeader  => '<tr valign=top><td class="diff-header">Paragraph %oldFrom%</td><td class="diff-vertical">&nbsp;</td><td class="diff-header">Paragraph %newFrom%</td></tr>',
>   
>     spanIdent     => '<span class="diff-span-ident">%text%</span>',
>     spanAdded     => '<span class="diff-span-added">%text%</span>',
>     spanDeleted   => '<span class="diff-span-deleted">%text%</span>',
> 
>     processText => sub {
> 
>       my $text = shift;
> 
>       $text =~ s[&]               [&amp;]g;
>       $text =~ s[<]               [&lt;]g;
>       $text =~ s[>]               [&gt;]g;
>       $text =~ s[\n]              [<br>\n]g;
>       $text =~ s[\r]              []g;
>       $text =~ s[([\t ]+)([\t ])] [('&nbsp;' x length($1)) . $2]ge;
>       $text =~ s[^[\t ]]          [&nbsp;];
> 
>       return $text;
>     }
>   );
> 
>   my $diff = Diff::diffText($textOld, $textNew, %format);
>   
>   if ($diff ne "") {
>     $diff =~ s[<td class="diff-para-changed-old">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-added">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>     
>     $diff =~ s[<td class="diff-para-changed-new">(.*?)</td>] [
>       my $textChanged = $1;
>       $textChanged =~ s[<span class="diff-span-deleted">.*?</span>] []gs;
>       qq[<td class="diff-para-changed">$textChanged</td>];
>     ]ges;
>   
>     $diff = qq[<div id=wikidiffdiv><table id=wikidifftable>$diff</table></div>];
2381,2393c3289
<   %Section = ();
<   %Text = ();
<   $fname = &GetPageFile($id);
<   if (-f $fname) {
<     $data = &ReadFileOrDie($fname);
<     %Page = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<   } else {
<     &OpenNewPage($id);
<   }
<   if ($Page{'version'} != 3) {
<     &UpdatePageVersion();
<   }
<   $OpenPageName = $id;
---
>   return $diff;
2396,2403c3292,3304
< sub OpenSection {
<   my ($name) = @_;
< 
<   if (!defined($Page{$name})) {
<     &OpenNewSection($name, "");
<   } else {
<     %Section = split(/$FS2/, $Page{$name}, -1);
<   }
---
> sub DiffToHTML { shift }
> 
> 
> 
> # ==== Database (Page, Section, Text, Kept, User) functions ====
> sub OpenNewPage {
> 	my ($id) = @_;
> 	%Page             = ();
> 	$Page{'version'}  = 3;       # Data format version
> 	$Page{'revision'} = 0;       # Number of edited times
> 	$Page{'tscreate'} = $Now;    # Set once at creation
> 	$Page{'ts'}       = $Now;    # Updated every edit
> 	$Page{'authorcreate'} = GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
2406,2414c3307,3321
< sub OpenText {
<   my ($name) = @_;
< 
<   if (!defined($Page{"text_$name"})) {
<     &OpenNewText($name);
<   } else {
<     &OpenSection("text_$name");
<     %Text = split(/$FS3/, $Section{'data'}, -1);
<   }
---
> sub OpenNewSection {
> 	my ( $name, $data ) = @_;
> 	%Section             = ();
> 	$Section{'name'}     = $name;
> 	$Section{'version'}  = 1;                   # Data format version
> 	$Section{'revision'} = 0;                   # Number of edited times
> 	$Section{'tscreate'} = $Now;                # Set once at creation
> 	$Section{'ts'}       = $Now;                # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'host'} 	 = "";        # Updated only for real edits (can be slow)
> 	$Section{'id'}   	 = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} 		 = join( $FS2, %Section );    # Replace with save?
> 	$Page{'authorcreate'}= GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
2417,2418c3324,3340
< sub OpenDefaultText {
<   &OpenText('default');
---
> sub OpenNewText {
> 	my ($name) = @_;                          # Name of text (usually "default")
> 	%Text = ();
> 	
> 	if ( $NewText ne "" ) {
> 		$Text{'text'} = $NewText;
> 	}
> 	else {
> 		$Text{'text'} = "Describe the new page here.";
> 	}
> 	
> 	$Text{'text'} .= "\n" if ( substr( $Text{'text'}, -1, 1 ) ne "\n" );
> 	$Text{'minor'}     = 0;                   # Default as major edit
> 	$Text{'newauthor'} = 1;                   # Default as new author
> 	$Text{'summary'}   = "";
> 	
> 	&OpenNewSection( "text_$name", join( $FS3, %Text ) );
2421,2426c3343,3345
< # Called after OpenKeptRevisions
< sub OpenKeptRevision {
<   my ($revision) = @_;
< 
<   %Section = split(/$FS2/, $KeptRevisions{$revision}, -1);
<   %Text = split(/$FS3/, $Section{'data'}, -1);
---
> sub GetPageFile {
> 	my ($id) = @_;
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
2429,2432c3348,3372
< sub GetPageCache {
<   my ($name) = @_;
< 
<   return $Page{"cache_$name"};
---
> sub OpenPage {
> 	my ($id) = @_;
> 	my ( $fname, $data );
> 	
> 	if (!CheckIsAuthUser($id)) { $id = "AuthError"; } #auth patch
> 	if ( $OpenPageName eq $id ) { return; }
> 	if ( $id eq ""){ return; }
> 		
> 	%Section = ();
> 	%Text    = ();
> 	$fname   = &GetPageFile($id);
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		%Page = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	}
> 	else {
> 		&OpenNewPage($id);
> 	}
> 	
> 	if ( $Page{'version'} != 3 ) {
> 		&UpdatePageVersion();
> 	}
> 	
> 	$OpenPageName = $id;
2435,2442c3375,3382
< # Always call SavePage within a lock.
< sub SavePage {
<   my $file = &GetPageFile($OpenPageName);
< 
<   $Page{'revision'} += 1;    # Number of edited times
<   $Page{'ts'} = $Now;        # Updated every edit
<   &CreatePageDir($PageDir, $OpenPageName);
<   &WriteStringToFile($file, join($FS1, %Page));
---
> sub OpenSection {
> 	my ($name) = @_;
> 	if ( !defined( $Page{$name} ) ) {
> 		&OpenNewSection( $name, "" );
> 	}
> 	else {
> 		%Section = split( /$FS2/, $Page{$name}, -1 );
> 	}
2445,2454c3385,3393
< sub SaveSection {
<   my ($name, $data) = @_;
< 
<   $Section{'revision'} += 1;   # Number of edited times
<   $Section{'ts'} = $Now;       # Updated every edit
<   $Section{'ip'} = $ENV{REMOTE_ADDR};
<   $Section{'id'} = $UserID;
<   $Section{'username'} = &GetParam("username", "");
<   $Section{'data'} = $data;
<   $Page{$name} = join($FS2, %Section);
---
> sub OpenText {
> 	my ($name) = @_;
> 	if ( !defined( $Page{"text_$name"} ) ) {
> 		&OpenNewText($name);
> 	}
> 	else {
> 		&OpenSection("text_$name");
> 		%Text = split( /$FS3/, $Section{'data'}, -1 );
> 	}
2457,2460c3396,3397
< sub SaveText {
<   my ($name) = @_;
< 
<   &SaveSection("text_$name", join($FS3, %Text));
---
> sub OpenDefaultText {
> 	&OpenText('default');
2463,2464c3400,3404
< sub SaveDefaultText {
<   &SaveText('default');
---
> # Called after OpenKeptRevisions
> sub OpenKeptRevision {
> 	my ($revision) = @_;
> 	%Section = split( /$FS2/, $KeptRevisions{$revision}, -1 );
> 	%Text = split( /$FS3/, $Section{'data'}, -1 );
2467,2470c3407,3409
< sub SetPageCache {
<   my ($name, $data) = @_;
< 
<   $Page{"cache_$name"} = $data;
---
> sub GetPageCache {
> 	my ($name) = @_;
> 	return $Page{"cache_$name"};
2473,2474c3412,3418
< sub UpdatePageVersion {
<   &ReportError(T('Bad page version (or corrupt page).'));
---
> # Always call SavePage within a lock.
> sub SavePage {
> 	my $file = &GetPageFile($OpenPageName);
> 	$Page{'revision'} += 1;    # Number of edited times
> 	$Page{'ts'} = $Now;        # Updated every edit
> 	&CreatePageDir( $PageDir, $OpenPageName );
> 	&WriteStringToFile( $file, join( $FS1, %Page ) );
2477,2479c3421,3429
< sub KeepFileName {
<   return $KeepDir . "/" . &GetPageDirectory($OpenPageName)
<          . "/$OpenPageName.kp";
---
> sub SaveSection {
> 	my ( $name, $data ) = @_;
> 	$Section{'revision'} += 1;    # Number of edited times
> 	$Section{'ts'}       = $Now;                          # Updated every edit
> 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
> 	$Section{'id'}       = $UserID;
> 	$Section{'username'} = &GetParam( "username", "" );
> 	$Section{'data'}     = $data;
> 	$Page{$name} = join( $FS2, %Section );
2482,2490c3432,3434
< sub SaveKeepSection {
<   my $file = &KeepFileName();
<   my $data;
< 
<   return  if ($Section{'revision'} < 1);  # Don't keep "empty" revision
<   $Section{'keepts'} = $Now;
<   $data = $FS1 . join($FS2, %Section);
<   &CreatePageDir($KeepDir, $OpenPageName);
<   &AppendStringToFileLimited($file, $data, $KeepSize);
---
> sub SaveText {
> 	my ($name) = @_;
> 	&SaveSection( "text_$name", join( $FS3, %Text ) );
2492a3437,3465
> sub SaveDefaultText {
> 	&SaveText('default');
> }
> 
> sub SetPageCache {
> 	my ( $name, $data ) = @_;
> 	$Page{"cache_$name"} = $data;
> }
> 
> sub UpdatePageVersion {
> 	&ReportError( "Bad page version (or corrupt page)." );
> }
> 
> sub KeepFileName {
> 	return $KeepDir . "/"
> 	  . &GetPageDirectory($OpenPageName)
> 	  . "/$OpenPageName.kp";
> }
> 
> sub SaveKeepSection {
> 	my $file = &KeepFileName();
> 	my $data;
> 	return if ( $Section{'revision'} < 1 );    # Don't keep "empty" revision
> 	$Section{'keepts'} = $Now;
> 	$data = $FS1 . join( $FS2, %Section );
> 	&CreatePageDir( $KeepDir, $OpenPageName );
> 	&AppendStringToFileLimited( $file, $data, $KeepSize );
> }
> 
2494,2554c3467,3541
<   my ($fname, $data, @kplist, %tempSection, $expirets);
<   my ($anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev);
<   my ($oldMajor, $oldAuthor);
< 
<   $fname = &KeepFileName();
<   return  if (!(-f $fname));
<   $data = &ReadFileOrDie($fname);
<   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<   return  if (length(@kplist) < 1);  # Also empty
<   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
<   return  if (length(@kplist) < 1);  # Also empty
<   %tempSection = split(/$FS2/, $kplist[0], -1);
<   if (!defined($tempSection{'keepts'})) {
<     return;  # Bad keep file
<   }
<   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
<   return  if ($tempSection{'keepts'} >= $expirets);  # Nothing old enough
<   $anyExpire = 0;
<   $anyKeep   = 0;
<   %keepFlag  = ();
<   $oldMajor  = &GetPageCache('oldmajor');
<   $oldAuthor = &GetPageCache('oldauthor');
<   foreach (reverse @kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     $sectRev = $tempSection{'revision'};
<     $expire = 0;
<     if ($sectName eq "text_default") {
<       if (($KeepMajor  && ($sectRev == $oldMajor)) ||
<           ($KeepAuthor && ($sectRev == $oldAuthor))) {
<         $expire = 0;
<       } elsif ($tempSection{'keepts'} < $expirets) {
<         $expire = 1;
<       }
<     } else {
<       if ($tempSection{'keepts'} < $expirets) {
<         $expire = 1;
<       }
<     }
<     if (!$expire) {
<       $keepFlag{$sectRev . "," . $sectName} = 1;
<       $anyKeep = 1;
<     } else {
<       $anyExpire = 1;
<     }
<   }
<   if (!$anyKeep) {  # Empty, so remove file
<     unlink($fname);
<     return;
<   }
<   return  if (!$anyExpire);  # No sections expired
<   open (OUT, ">$fname") or die (Ts('cant write %s', $fname) . ": $!");
<   foreach (@kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     $sectRev = $tempSection{'revision'};
<     if ($keepFlag{$sectRev . "," . $sectName}) {
<       print OUT $FS1, $_;
<     }
<   }
<   close(OUT);
---
> 	my ( $fname, $data, @kplist, %tempSection, $expirets );
> 	my ( $anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev );
> 	my ( $oldMajor, $oldAuthor );
> 	$fname = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );    # Also empty
> 	
> 	shift(@kplist) if ( $kplist[0] eq "" );    # First can be empty
> 	return if ( length(@kplist) < 1 );         # Also empty
> 	
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;                                # Bad keep file
> 	}
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	return if ( $tempSection{'keepts'} >= $expirets );    # Nothing old enough
> 	
> 	$anyExpire = 0;
> 	$anyKeep   = 0;
> 	%keepFlag  = ();
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	foreach ( reverse @kplist ) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		$expire      = 0;
> 		
> 		if ( $sectName eq "text_default" ) {
> 			if (   ( $KeepMajor && ( $sectRev == $oldMajor ) )
> 				|| ( $KeepAuthor && ( $sectRev == $oldAuthor ) ) )
> 			{
> 				$expire = 0;
> 			}
> 			elsif ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		else {
> 			if ( $tempSection{'keepts'} < $expirets ) {
> 				$expire = 1;
> 			}
> 		}
> 		if ( !$expire ) {
> 			$keepFlag{ $sectRev . "," . $sectName } = 1;
> 			$anyKeep = 1;
> 		}
> 		else {
> 			$anyExpire = 1;
> 		}
> 	}
> 	if ( !$anyKeep ) {    # Empty, so remove file
> 		unlink($fname);
> 		return;
> 	}
> 	return if ( !$anyExpire );    # No sections expired
> 	
> 	open( OUT, ">$fname" ) or die( Ts( 'cant write %s', $fname ) . ": $!" );
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName    = $tempSection{'name'};
> 		$sectRev     = $tempSection{'revision'};
> 		
> 		if ( $keepFlag{ $sectRev . "," . $sectName } ) {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
2558,2564c3545,3551
<   my ($fname, $data);
< 
<   @KeptList = ();
<   $fname = &KeepFileName();
<   return  if (!(-f $fname));
<   $data = &ReadFileOrDie($fname);
<   @KeptList = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
---
> 	my ( $fname, $data );
> 	@KeptList = ();
> 	$fname    = &KeepFileName();
> 	return if ( !( -f $fname ) );
> 	
> 	$data = &ReadFileOrDie($fname);
> 	@KeptList = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
2568,2577c3555,3565
<   my ($name) = @_;  # Name of section
<   my ($fname, $data, %tempSection);
< 
<   %KeptRevisions = ();
<   &OpenKeptList();
<   foreach (@KeptList) {
<     %tempSection = split(/$FS2/, $_, -1);
<     next  if ($tempSection{'name'} ne $name);
<     $KeptRevisions{$tempSection{'revision'}} = $_;
<   }
---
> 	my ($name) = @_;    # Name of section
> 	my ( $fname, $data, %tempSection );
> 	
> 	%KeptRevisions = ();
> 	&OpenKeptList();
> 	
> 	foreach (@KeptList) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		next if ( $tempSection{'name'} ne $name );
> 		$KeptRevisions{ $tempSection{'revision'} } = $_;
> 	}
2581,2589c3569,3577
<   my ($data, $status);
< 
<   %UserData = ();
<   ($status, $data) = &ReadFile(&UserDataFilename($UserID));
<   if (!$status) {
<     $UserID = 112;  # Could not open file.  Consider warning message?
<     return;
<   }
<   %UserData = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
---
> 	my ( $data, $status );
> 	%UserData = ();
> 	( $status, $data ) = &ReadFile( &UserDataFilename($UserID) );
> 	
> 	if ( !$status ) {
> 		$UserID = 112;    # Could not open file.  Consider warning message?
> 		return;
> 	}
> 	%UserData = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
2593,2596c3581,3588
<   my ($id) = @_;
< 
<   return ""  if ($id < 1);
<   return $UserDir . "/" . ($id % 10) . "/$id.db";
---
> 	my ($id) = @_;
> 	if ($id =~ /(\d+)/){
> 		$id = $1;
> 	}
> 	else { die "The userid must be a positive integer"; }
> 	
> 	return "" if ( $id < 1 );
> 	return $UserDir . "/" . ( $id % 10 ) . "/$id.db";
2601,2603c3593,3601
<   my ($errmsg) = @_;
< 
<   print $q->header, "<H2>", $errmsg, "</H2>", $q->end_html;
---
> 	my ($errmsg) = @_;
> 	
> 	print &GetHeader( "", "ERROR!", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>$errmsg</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
2607,2648c3605,3650
<   my ($id) = @_;
< 
<   if (length($id) > 120) {
<     return Ts('Page name is too long: %s', $id);
<   }
<   if ($id =~ m| |) {
<     return Ts('Page name may not contain space characters: %s', $id);
<   }
<   if ($UseSubpage) {
<     if ($id =~ m|.*/.*/|) {
<       return Ts('Too many / characters in page %s', $id);
<     }
<     if ($id =~ /^\//) {
<       return Ts('Invalid Page %s (subpage without main page)', $id);
<     }
<     if ($id =~ /\/$/) {
<       return Ts('Invalid Page %s (missing subpage name)', $id);
<     }
<   }
<   if ($FreeLinks) {
<     $id =~ s/ /_/g;
<     if (!$UseSubpage) {
<       if ($id =~ /\//) {
<         return Ts('Invalid Page %s (/ not allowed)', $id);
<       }
<     }
<     if (!($id =~ m|^$FreeLinkPattern$|)) {
<       return Ts('Invalid Page %s', $id);
<     }
<     if ($id =~ m|\.db$|) {
<       return Ts('Invalid Page %s (must not end with .db)', $id);
<     }
<     if ($id =~ m|\.lck$|) {
<       return Ts('Invalid Page %s (must not end with .lck)', $id);
<     }
<     return "";
<   } else {
<     if (!($id =~ /^$LinkPattern$/)) {
<       return Ts('Invalid Page %s', $id);
<     }
<   }
<   return "";
---
> 	my ($id) = @_;
> 	if ( length($id) > 120 ) {
> 		return Ts( 'Page name is too long: %s', $id );
> 	}
> 	
> 	if ( $id =~ m| | ) {
> 		return Ts( 'Page name may not contain space characters: %s', $id );
> 	}
> 	
> 	if ($UseSubpage) {
> 		if ( $id =~ m|.*/.*/| ) {
> 			return Ts( 'Too many / characters in page %s', $id );
> 		}
> 		if ( $id =~ /^\// ) {
> 			return Ts( 'Invalid Page %s (subpage without main page)', $id );
> 		}
> 		if ( $id =~ /\/$/ ) {
> 			return Ts( 'Invalid Page %s (missing subpage name)', $id );
> 		}
> 	}
> 	
> 	if ($FreeLinks) {
> 		$id =~ s/ /_/g;
> 		if ( !$UseSubpage ) {
> 			if ( $id =~ /\// ) {
> 				return Ts( 'Invalid Page %s (/ not allowed)', $id );
> 			}
> 		}
> 		if ( !( $id =~ m|^$FreeLinkPattern$| ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 		if ( $id =~ m|\.db$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .db)', $id );
> 		}
> 		if ( $id =~ m|\.lck$| ) {
> 			return Ts( 'Invalid Page %s (must not end with .lck)', $id );
> 		}
> 		return "";
> 	}
> 	else {
> 		if ( !( $id =~ /^$LinkPattern$/ ) ) {
> 			return Ts( 'Invalid Page %s', $id );
> 		}
> 	}
> 	
> 	return "";
2652,2660c3654,3663
<   my ($id) = @_;
<   my $error;
< 
<   $error = &ValidId($id);
<   if ($error ne "") {
<     &ReportError($error);
<     return 0;
<   }
<   return 1;
---
> 	my ($id) = @_;
> 	my $error;
> 	
> 	$error = &ValidId($id);
> 	
> 	if ( $error ne "" ) {
> 		&ReportError($error);
> 		return 0;
> 	}
> 	return 1;
2664,2684c3667,3691
<   my ($id, $deepCheck) = @_;
< 
<   # Optimized for the "everyone can edit" case (don't check passwords)
<   if (($id ne "") && (-f &GetLockedPageFile($id))) {
<     return 1  if (&UserIsAdmin());  # Requires more privledges
<     # Consider option for editor-level to edit these pages?
<     return 0;
<   }
<   if (!$EditAllowed) {
<     return 1  if (&UserIsEditor());
<     return 0;
<   }
<   if (-f "$DataDir/noedit") {
<     return 1  if (&UserIsEditor());
<     return 0;
<   }
<   if ($deepCheck) {   # Deeper but slower checks (not every page)
<     return 1  if (&UserIsEditor());
<     return 0  if (&UserIsBanned());
<   }
<   return 1;
---
> 	my ( $id, $deepCheck ) = @_;
> 	my $authtype = &CheckIsAuthUser($id);
> 	
> 	# Optimized for the "everyone can edit" case (don't check passwords)
> 	if ( ( $id ne "" ) && ( -f &GetLockedPageFile($id) ) ) {
> 		return 1 if ( &UserIsAdmin() );    # Requires more privledges
> 		     # Consider option for editor-level to edit these pages?
> 		return 0;
> 	}
> 	if ( !$EditAllowed ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ( -f "$DataDir/noedit" ) {
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0;
> 	}
> 	if ($deepCheck) {    # Deeper but slower checks (not every page)
> 		return 1 if ( $authtype eq "2" || $authtype eq "3");
> 		return 1 if ( &UserIsEditor() );
> 		return 0 if ( &UserIsBanned() );
> 	}
> 	return 1;
2688,2700c3695,3707
<   my ($host, $ip, $data, $status);
< 
<   ($status, $data) = &ReadFile("$DataDir/banlist");
<   return 0  if (!$status);  # No file exists, so no ban
<   $data =~ s/\r//g;
<   $ip = $ENV{'REMOTE_ADDR'};
<   $host = &GetRemoteHost(0);
<   foreach (split(/\n/, $data)) {
<     next  if ((/^\s*$/) || (/^#/));  # Skip empty, spaces, or comments
<     return 1  if ($ip   =~ /$_/i);
<     return 1  if ($host =~ /$_/i);
<   }
<   return 0;
---
> 	my ( $host, $ip, $data, $status );
> 	( $status, $data ) = &ReadFile("$DataDir/banlist");
> 	return 0 if ( !$status );    # No file exists, so no ban
> 	$data =~ s/\r//g;
> 	$ip   = $ENV{'REMOTE_ADDR'};
> 	$host = &GetRemoteHost(0);
> 	
> 	foreach ( split( /\n/, $data ) ) {
> 		next if ( (/^\s*$/) || (/^#/) );    # Skip empty, spaces, or comments
> 		return 1 if ( $ip   =~ /$_/i );
> 		return 1 if ( $host =~ /$_/i );
> 	}
> 	return 0;
2704,2713c3711,3722
<   my (@pwlist, $userPassword);
< 
<   return 0  if ($AdminPass eq "");
<   $userPassword = &GetParam("adminpw", "");
<   return 0  if ($userPassword eq "");
<   foreach (split(/\s+/, $AdminPass)) {
<     next  if ($_ eq "");
<     return 1  if ($userPassword eq $_);
<   }
<   return 0;
---
> 	my ( @pwlist, $userPassword );
> 	
> 	return 0 if ( $AdminPass eq "" );
> 	$userPassword = &GetParam( "adminpw", "" );
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $AdminPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
2717,2727c3726,3738
<   my (@pwlist, $userPassword);
< 
<   return 1  if (&UserIsAdmin());             # Admin includes editor
<   return 0  if ($EditPass eq "");
<   $userPassword = &GetParam("adminpw", "");  # Used for both
<   return 0  if ($userPassword eq "");
<   foreach (split(/\s+/, $EditPass)) {
<     next  if ($_ eq "");
<     return 1  if ($userPassword eq $_);
<   }
<   return 0;
---
> 	my ( @pwlist, $userPassword );
> 	
> 	return 1 if ( &UserIsAdmin() );    # Admin includes editor
> 	return 0 if ( $EditPass eq "" );
> 	$userPassword = &GetParam( "password", "" );    # Used for both
> 	return 0 if ( $userPassword eq "" );
> 	
> 	foreach ( split( /\s+/, $EditPass ) ) {
> 		next     if ( $_            eq "" );
> 		return 1 if ( $userPassword eq $_ );
> 	}
> 	
> 	return 0;
2729a3741,3744
> sub UserIsEditorOrAdmin {
> 	return (UserIsEditor || UserIsAdmin);	
> }
> 
2731,2732c3746,3747
<   return 1  if (&UserIsEditor());
<   return $AllUpload;
---
> 	return 1 if ( &UserIsEditor() );
> 	return $AllUpload;
2736,2738c3751,3752
<   my ($id) = @_;
< 
<   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
---
> 	my ($id) = @_;
> 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
2742,2756c3756,3769
<   my ($name, $tries, $wait, $errorDie) = @_;
<   my ($lockName, $n);
< 
<   &CreateDir($TempDir);
<   $lockName = $LockDir . $name;
<   $n = 0;
<   while (mkdir($lockName, 0555) == 0) {
<     if ($! != 17) {
<       die(Ts('can not make %s', $LockDir) . ": $!\n")  if $errorDie;
<       return 0;
<     }
<     return 0  if ($n++ >= $tries); 
<     sleep($wait);
<   }
<   return 1;
---
> 	my ( $name, $tries, $wait, $errorDie ) = @_;
> 	my ( $lockName, $n );
> 	&CreateDir($TempDir);
> 	$lockName = $LockDir . $name;
> 	$n        = 0;
> 	while ( mkdir( $lockName, 0555 ) == 0 ) {
> 		if ( $! != 17 ) {
> 			die( Ts( 'can not make %s', $LockDir ) . ": $!\n" ) if $errorDie;
> 			return 0;
> 		}
> 		return 0 if ( $n++ >= $tries );
> 		sleep($wait);
> 	}
> 	return 1;
2760,2762c3773,3774
<   my ($name) = @_;
< 
<   rmdir($LockDir . $name);
---
> 	my ($name) = @_;
> 	rmdir( $LockDir . $name );
2766,2767c3779,3780
<   # 10 tries, 3 second wait, possibly die on error
<   return &RequestLockDir("main", 10, 3, $LockCrash);
---
> 	# 10 tries, 3 second wait, possibly die on error
> 	return &RequestLockDir( "main", 10, 3, $LockCrash );
2771c3784
<   &ReleaseLockDir('main');
---
> 	&ReleaseLockDir('main');
2775,2782c3788,3795
<   my ($name) = @_;
<   my $forced;
< 
<   # First try to obtain lock (in case of normal edit lock)
<   # 5 tries, 3 second wait, do not die on error
<   $forced = !&RequestLockDir($name, 5, 3, 0);
<   &ReleaseLockDir($name);  # Release the lock, even if we didn't get it.
<   return $forced;
---
> 	my ($name) = @_;
> 	my $forced;
> 
> 	# First try to obtain lock (in case of normal edit lock)
> 	# 5 tries, 3 second wait, do not die on error
> 	$forced = !&RequestLockDir( $name, 5, 3, 0 );
> 	&ReleaseLockDir($name);    # Release the lock, even if we didn't get it.
> 	return $forced;
2786,2787c3800,3801
<   # 4 tries, 2 second wait, do not die on error
<   return &RequestLockDir('cache', 4, 2, 0);
---
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'cache', 4, 2, 0 );
2791c3805
<   &ReleaseLockDir('cache');
---
> 	&ReleaseLockDir('cache');
2795,2796c3810,3811
<   # 4 tries, 2 second wait, do not die on error
<   return &RequestLockDir('diff', 4, 2, 0);
---
> 	# 4 tries, 2 second wait, do not die on error
> 	return &RequestLockDir( 'diff', 4, 2, 0 );
2800c3815
<   &ReleaseLockDir('diff');
---
> 	&ReleaseLockDir('diff');
2805,2806c3821,3822
<   # 1 try, 2 second wait, do not die on error
<   return &RequestLockDir('index', 1, 2, 0);
---
> 	# 1 try, 2 second wait, do not die on error
> 	return &RequestLockDir( 'index', 1, 2, 0 );
2810c3826
<   &ReleaseLockDir('index');
---
> 	&ReleaseLockDir('index');
2814,2823c3830,3838
<   my ($fileName) = @_;
<   my ($data);
<   local $/ = undef;   # Read complete files
< 
<   if (open(IN, "<$fileName")) {
<     $data=<IN>;
<     close IN;
<     return (1, $data);
<   }
<   return (0, "");
---
> 	my ($fileName) = @_;
> 	my ($data);
> 	local $/ = undef;    # Read complete files
> 	if ( open( IN, "<$fileName" ) ) {
> 		$data = <IN>;
> 		close IN;
> 		return ( 1, $data );
> 	}
> 	return ( 0, "" );
2827,2834c3842,3848
<   my ($fileName) = @_;
<   my ($status, $data);
< 
<   ($status, $data) = &ReadFile($fileName);
<   if (!$status) {
<     die(Ts('Can not open %s', $fileName) . ": $!");
<   }
<   return $data;
---
> 	my ($fileName) = @_;
> 	my ( $status, $data );
> 	( $status, $data ) = &ReadFile($fileName);
> 	if ( !$status ) {
> 		die( Ts( 'Can not open %s', $fileName ) . ": $!" );
> 	}
> 	return $data;
2838,2842c3852,3855
<   my ($file, $string) = @_;
< 
<   open (OUT, ">$file") or die(Ts('cant write %s', $file) . ": $!");
<   print OUT  $string;
<   close(OUT);
---
> 	my ( $file, $string ) = @_;
> 	open( OUT, ">$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
2846,2850c3859,3862
<   my ($file, $string) = @_;
< 
<   open (OUT, ">>$file") or die(Ts('cant write %s', $file) . ": $!");
<   print OUT  $string;
<   close(OUT);
---
> 	my ( $file, $string ) = @_;
> 	open( OUT, ">>$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
> 	print OUT $string;
> 	close(OUT);
2854,2858c3866,3869
<   my ($file, $string, $limit) = @_;
< 
<   if (($limit < 1) || (((-s $file) + length($string)) <= $limit)) {
<     &AppendStringToFile($file, $string);
<   }
---
> 	my ( $file, $string, $limit ) = @_;
> 	if ( ( $limit < 1 ) || ( ( ( -s $file ) + length($string) ) <= $limit ) ) {
> 		&AppendStringToFile( $file, $string );
> 	}
2862,2864c3873,3874
<   my ($newdir) = @_;
< 
<   mkdir($newdir, 0775)  if (!(-d $newdir));
---
> 	my ($newdir) = @_;
> 	mkdir( $newdir, 0775 ) if ( !( -d $newdir ) );
2868,2877c3878,3886
<   my ($dir, $id) = @_;
<   my $subdir;
< 
<   &CreateDir($dir);  # Make sure main page exists
<   $subdir = $dir . "/" . &GetPageDirectory($id);
<   &CreateDir($subdir);
<   if ($id =~ m|([^/]+)/|) {
<     $subdir = $subdir . "/" . $1;
<     &CreateDir($subdir);
<   }
---
> 	my ( $dir, $id ) = @_;
> 	my $subdir;
> 	&CreateDir($dir);    # Make sure main page exists
> 	$subdir = $dir . "/" . &GetPageDirectory($id);
> 	&CreateDir($subdir);
> 	if ( $id =~ m|([^/]+)/| ) {
> 		$subdir = $subdir . "/" . $1;
> 		&CreateDir($subdir);
> 	}
2881,2889c3890,3897
<   my ($id, $html) = @_;
<   my $idFile;
< 
<   $idFile = &GetHtmlCacheFile($id);
<   &CreatePageDir($HtmlDir, $id);
<   if (&RequestCacheLock()) {
<     &WriteStringToFile($idFile, $html);
<     &ReleaseCacheLock();
<   }
---
> 	my ( $id, $html ) = @_;
> 	my $idFile;
> 	$idFile = &GetHtmlCacheFile($id);
> 	&CreatePageDir( $HtmlDir, $id );
> 	if ( &RequestCacheLock() ) {
> 		&WriteStringToFile( $idFile, $html );
> 		&ReleaseCacheLock();
> 	}
2893,2938c3901,3951
<   my (@pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId);
< 
<   @pages = ();
<   if ($FastGlob) {
<     # The following was inspired by the FastGlob code by Marc W. Mengel.
<     # Thanks to Bob Showalter for pointing out the improvement.
<     opendir(PAGELIST, $PageDir);
<     @dirs = readdir(PAGELIST);
<     closedir(PAGELIST);
<     @dirs = sort(@dirs);
<     foreach $dir (@dirs) {
<       next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs or files
<       opendir(PAGELIST, "$PageDir/$dir");
<       @pageFiles = readdir(PAGELIST);
<       closedir(PAGELIST);
<       foreach $id (@pageFiles) {
<         next  if (($id eq '.') || ($id eq '..'));
<         if (substr($id, -3) eq '.db') {
<           push(@pages, substr($id, 0, -3));
<         } elsif (substr($id, -4) ne '.lck') {
<           opendir(PAGELIST, "$PageDir/$dir/$id");
<           @subpageFiles = readdir(PAGELIST);
<           closedir(PAGELIST);
<           foreach $subId (@subpageFiles) {
<             if (substr($subId, -3) eq '.db') {
<               push(@pages, "$id/" . substr($subId, 0, -3));
<             }
<           }
<         }
<       }
<     }
<   } else {
<     # Old slow/compatible method.
<     @dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
<     foreach $dir (@dirs) {
<       if (-e "$PageDir/$dir") {  # Thanks to Tim Holt
<         while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
<           s|^$PageDir/||;
<           m|^[^/]+/(\S*).db|;
<           $id = $1;
<           push(@pages, $id);
<         }
<       }
<     }
<   }
<   return sort(@pages);
---
> 	my ( @pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId );
> 	@pages = ();
> 	if ($FastGlob) {
> 
> 		# The following was inspired by the FastGlob code by Marc W. Mengel.
> 		# Thanks to Bob Showalter for pointing out the improvement.
> 		opendir( PAGELIST, $PageDir );
> 		@dirs = readdir(PAGELIST);
> 		closedir(PAGELIST);
> 		@dirs = sort(@dirs);
> 		foreach $dir (@dirs) {
> 			next
> 			  if ( substr( $dir, 0, 1 ) eq '.' );  # No ., .., or .dirs or files
> 			opendir( PAGELIST, "$PageDir/$dir" );
> 			@pageFiles = readdir(PAGELIST);
> 			closedir(PAGELIST);
> 			foreach $id (@pageFiles) {
> 				next if ( ( $id eq '.' ) || ( $id eq '..' ) );
> 				if ( substr( $id, -3 ) eq '.db' ) {
> 					push( @pages, substr( $id, 0, -3 ) );
> 				}
> 				elsif ( substr( $id, -4 ) ne '.lck' ) {
> 					opendir( PAGELIST, "$PageDir/$dir/$id" );
> 					@subpageFiles = readdir(PAGELIST);
> 					closedir(PAGELIST);
> 					foreach $subId (@subpageFiles) {
> 						if ( substr( $subId, -3 ) eq '.db' ) {
> 							push( @pages, "$id/" . substr( $subId, 0, -3 ) );
> 						}
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		# Old slow/compatible method.
> 		@dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
> 		
> 		foreach $dir (@dirs) {
> 			if ( -e "$PageDir/$dir" ) {    # Thanks to Tim Holt
> 				while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
> 					s|^$PageDir/||;
> 					m|^[^/]+/(\S*).db|;
> 					$id = $1;
> 					push( @pages, $id );
> 				}
> 			}
> 		}
> 	}
> 	
> 	return sort(@pages);
2942,2974c3955,3995
<   my ($rawIndex, $refresh, $status);
< 
<   if (!$UseIndex) {
<     return &GenerateAllPagesList();
<   }
<   $refresh = &GetParam("refresh", 0);
<   if ($IndexInit && !$refresh) {
<     # Note for mod_perl: $IndexInit is reset for each query
<     # Eventually consider some timestamp-solution to keep cache?
<     return @IndexList;
<   }
<   if ((!$refresh) && (-f $IndexFile)) {
<     ($status, $rawIndex) = &ReadFile($IndexFile);
<     if ($status) {
<       %IndexHash = split(/\s+/, $rawIndex);
<       @IndexList = sort(keys %IndexHash);
<       $IndexInit = 1;
<       return @IndexList;
<     }
<     # If open fails just refresh the index
<   }
<   @IndexList = ();
<   %IndexHash = ();
<   @IndexList = &GenerateAllPagesList();
<   foreach (@IndexList) {
<     $IndexHash{$_} = 1;
<   }
<   $IndexInit = 1;  # Initialized for this run of the script
<   # Try to write out the list for future runs
<   &RequestIndexLock() or return @IndexList;
<   &WriteStringToFile($IndexFile, join(" ", %IndexHash));
<   &ReleaseIndexLock();
<   return @IndexList;
---
> 	my ( $rawIndex, $refresh, $status );
> 	
> 	if ( !$UseIndex ) {
> 		return &GenerateAllPagesList();
> 	}
> 	
> 	$refresh = &GetParam( "refresh", 0 );
> 	if ( $IndexInit && !$refresh ) {
> 
> 		# Note for mod_perl: $IndexInit is reset for each query
> 		# Eventually consider some timestamp-solution to keep cache?
> 		return @IndexList;
> 	}
> 	
> 	if ( ( !$refresh ) && ( -f $IndexFile ) ) {
> 		( $status, $rawIndex ) = &ReadFile($IndexFile);
> 		
> 		if ($status) {
> 			%IndexHash = split( /\s+/, $rawIndex );
> 			@IndexList = sort( keys %IndexHash );
> 			$IndexInit = 1;
> 			
> 			return @IndexList;
> 		}
> 
> 		# If open fails just refresh the index
> 	}
> 	@IndexList = ();
> 	%IndexHash = ();
> 	@IndexList = &GenerateAllPagesList();
> 	
> 	foreach (@IndexList) {
> 		$IndexHash{$_} = 1;
> 	}
> 	$IndexInit = 1;    # Initialized for this run of the script
> 	                   # Try to write out the list for future runs
> 	&RequestIndexLock() or return @IndexList;
> 	&WriteStringToFile( $IndexFile, join( " ", %IndexHash ) );
> 	&ReleaseIndexLock();
> 	
> 	return @IndexList;
2976a3998,4011
> sub AllSubPagesList {
> 	my $GivenPage = shift;
> 	my @PageList = &AllPagesList();
> 	my @Results;
> 	
> 	foreach (@PageList){
> 		if (/^$GivenPage\//i){
> 			push @Results, $_;	
> 		}
> 	}
> 	
> 	return @Results;
> }
> 
2978,2987c4013,4034
<   my ($ts) = @_;
< 
<   $ts += $TimeZoneOffset;
<   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
<   if ($NumberDates) {
<     return ($year + 1900) . '-' . ($mon+1) . '-' . $mday;
<   }
<   return ("January", "February", "March", "April", "May", "June",
<           "July", "August", "September", "October", "November",
<           "December")[$mon]. " " . $mday . ", " . ($year+1900);
---
> 	my ($ts) = @_;
> 	
> 	$ts += $TimeZoneOffset;
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	
> 	if ($NumberDates) {
> 		$year = $year + 1900;
> 		$mon = $mon + 1;
> 		if ($mon < 10){ $mon = "0$mon"; }
> 		if ($mday < 10){ $mday = "0$mday"; }
> 		
> 		return "$year$NumberDatesDelim$mon$NumberDatesDelim$mday";
> 	}
> 	
> 	return (
> 		"January",   "February", "March",    "April",
> 		"May",       "June",     "July",     "August",
> 		"September", "October",  "November", "December"
> 	  )[$mon]
> 	  . " "
> 	  . $mday . ", "
> 	  . ( $year + 1900 );
2991,3010c4038,4062
<   my ($ts) = @_;
<   my ($ampm, $mytz);
< 
<   $ts += $TimeZoneOffset;
<   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
<   $mytz = "";
<   if (($TimeZoneOffset == 0) && ($ScriptTZ ne "")) {
<     $mytz = " " . $ScriptTZ;
<   }
<   $ampm = "";
<   if ($UseAmPm) {
<     $ampm = " am";
<     if ($hour > 11) {
<       $ampm = " pm";
<       $hour = $hour - 12;
<     }
<     $hour = 12   if ($hour == 0);
<   }
<   $min = "0" . $min   if ($min<10);
<   return $hour . ":" . $min . $ampm . $mytz;
---
> 	my ($ts) = @_;
> 	my ( $ampm, $mytz );
> 	
> 	$ts += $TimeZoneOffset;
> 	
> 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
> 	$mytz = "";
> 	
> 	if ( ( $TimeZoneOffset == 0 ) && ( $ScriptTZ ne "" ) ) {
> 		$mytz = " " . $ScriptTZ;
> 	}
> 	$ampm = "";
> 	
> 	if ($UseAmPm) {
> 		$ampm = " am";
> 		if ( $hour > 11 ) {
> 			$ampm = " pm";
> 			$hour = $hour - 12;
> 		}
> 		$hour = 12 if ( $hour == 0 );
> 	}
> 	
> 	$min = "0" . $min if ( $min < 10 );
> 	
> 	return $hour . ":" . $min . $ampm . $mytz;
3014,3016c4066,4068
<   my ($t) = @_;
< 
<   return &CalcDay($t) . " " . &CalcTime($t);
---
> 	my ($t) = @_;
> 	
> 	return &CalcDay($t) . " " . &CalcTime($t);
3020,3031c4072,4086
<   my ($name, $default) = @_;
<   my $result;
< 
<   $result = $q->param($name);
<   if (!defined($result)) {
<     if (defined($UserData{$name})) {
<       $result = $UserData{$name};
<     } else {
<       $result = $default;
<     }
<   }
<   return $result;
---
> 	my ( $name, $default ) = @_;
> 	my $result;
> 	
> 	$result = $q->param($name);
> 	
> 	if ( !defined($result) ) {
> 		if ( defined( $UserData{$name} ) ) {
> 			$result = $UserData{$name};
> 		}
> 		else {
> 			$result = $default;
> 		}
> 	}
> 	
> 	return $result;
3035,3038c4090,4094
<   my ($name, $value) = @_;
< 
<   $q->param($name, $value);
<   return $q->hidden($name);
---
> 	my ( $name, $value ) = @_;
> 	
> 	$q->param( $name, $value );
> 	
> 	return $q->hidden($name);
3042,3055c4098,4116
<   my ($doMask) = @_;
<   my ($rhost, $iaddr);
< 
<   $rhost = $ENV{REMOTE_HOST};
<   if ($UseLookup && ($rhost eq "")) {
<     # Catch errors (including bad input) without aborting the script
<     eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
<          . '$rhost = gethostbyaddr($iaddr, AF_INET)';
<   }
<   if ($rhost eq "") {
<     $rhost = $ENV{REMOTE_ADDR};
<   }
<   $rhost = &GetMaskedHost($rhost)  if ($doMask);
<   return $rhost;
---
> 	my ($doMask) = @_;
> 	my ( $rhost, $iaddr );
> 	
> 	$rhost = $ENV{REMOTE_HOST};
> 	
> 	if ( $UseLookup && ( $rhost eq "" ) ) {
> 
> 		# Catch errors (including bad input) without aborting the script
> 		eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
> 		  . '$rhost = gethostbyaddr($iaddr, AF_INET)';
> 	}
> 	
> 	if ( $rhost eq "" ) {
> 		$rhost = $ENV{REMOTE_ADDR};
> 	}
> 	
> 	$rhost = &GetMaskedHost($rhost) if ($doMask);
> 	
> 	return $rhost;
3059,3078c4120,4144
<   my ($id) = @_;
< 
<   $id =~ s/ /_/g;
<   $id = ucfirst($id)  if ($UpperFirst || $FreeUpper);
<   if (index($id, '_') > -1) {  # Quick check for any space/underscores
<     $id =~ s/__+/_/g;
<     $id =~ s/^_//;
<     $id =~ s/_$//;
<     if ($UseSubpage) {
<       $id =~ s|_/|/|g;
<       $id =~ s|/_|/|g;
<     }
<   }
<   if ($FreeUpper) {
<     # Note that letters after ' are *not* capitalized
<     if ($id =~ m|[-_.,\(\)/][a-z]|) {    # Quick check for non-canonical case
<       $id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
<     }
<   }
<   return $id;
---
> 	my ($id) = @_;
> 	
> 	$id =~ s/ /_/g;
> 	$id = ucfirst($id) if ( $UpperFirst || $FreeUpper );
> 	
> 	if ( index( $id, '_' ) > -1 ) {    # Quick check for any space/underscores
> 		$id =~ s/__+/_/g;
> 		$id =~ s/^_//;
> 		$id =~ s/_$//;
> 		
> 		if ($UseSubpage) {
> 			$id =~ s|_/|/|g;
> 			$id =~ s|/_|/|g;
> 		}
> 	}
> 	
> 	if ($FreeUpper) {
> 
> 		# Note that letters after ' are *not* capitalized
> 		if ( $id =~ m|[-_.,\(\)/][a-z]| ) { # Quick check for non-canonical case
> 			$id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
> 		}
> 	}
> 	
> 	return $id;
3083c4149,4150
< $OtherCode = ""; # Comment next line to always compile (slower)
---
> $OtherCode = "";    # Comment next line to always compile (slower)
> 
3087,3174c4153,4280
<   my ($id, $action, $text, $search);
< 
<   $action = &GetParam("action", "");
<   $id = &GetParam("id", "");
<   if ($action ne "") {
<     $action = lc($action);
<     if      ($action eq "edit") {
<       &DoEdit($id, 0, 0, "", 0)  if &ValidIdOrDie($id);
<     } elsif ($action eq "unlock") {
<       &DoUnlock();
<     } elsif ($action eq "index") {
<       &DoIndex();
<     } elsif ($action eq "links") {
<       &DoLinks();
<     } elsif ($action eq "maintain") {
<       &DoMaintain();
<     } elsif ($action eq "pagelock") {
<       &DoPageLock();
<     } elsif ($action eq "editlock") {
<       &DoEditLock();
<     } elsif ($action eq "editprefs") {
<       &DoEditPrefs();
<     } elsif ($action eq "editbanned") {
<       &DoEditBanned();
<     } elsif ($action eq "editlinks") {
<       &DoEditLinks();
<     } elsif ($action eq "login") {
<       &DoEnterLogin();
<     } elsif ($action eq "newlogin") {
<       $UserID = 0;
<       &DoEditPrefs();  # Also creates new ID
<     } elsif ($action eq "version") {
<       &DoShowVersion();
<     } elsif ($action eq "rss") {
<       &DoRss();
<     } elsif ($action eq "delete") {
<       &DoDeletePage($id);
<     } elsif ($UseUpload && ($action eq "upload")) {
<       &DoUpload();
<     } elsif ($action eq "maintainrc") {
<       &DoMaintainRc();
<     } elsif ($action eq "convert") {
<       &DoConvert();
<     } elsif ($action eq "trimusers") {
<       &DoTrimUsers();
<     } else {
<       &ReportError(Ts('Invalid action parameter %s', $action));
<     }
<     return;
<   }
<   if (&GetParam("edit_prefs", 0)) {
<     &DoUpdatePrefs();
<     return;
<   }
<   if (&GetParam("edit_ban", 0)) {
<     &DoUpdateBanned();
<     return;
<   }
<   if (&GetParam("enter_login", 0)) {
<     &DoLogin();
<     return;
<   }
<   if (&GetParam("edit_links", 0)) {
<     &DoUpdateLinks();
<     return;
<   }
<   if ($UseUpload && (&GetParam("upload", 0))) {
<     &SaveUpload();
<     return;
<   }
<   $search = &GetParam("search", "");
<   if (($search ne "") || (&GetParam("dosearch", "") ne "")) {
<     &DoSearch($search);
<     return;
<   } else {
<     $search = &GetParam("back","");
<     if ($search ne "") {
<       &DoBackLinks($search);
<       return;
<     }
<   }
<   # Handle posted pages
<   if (&GetParam("oldtime", "") ne "") {
<     $id = &GetParam("title", "");
<     &DoPost()  if &ValidIdOrDie($id);
<     return;
<   }
<   &ReportError(T('Invalid URL.'));
---
> 	my ( $id, $action, $filter, $text, $search );
> 	
> 	$action = &GetParam( "action", "" );
> 	$id     = &GetParam( "id",     "" );
> 	$filter = &GetParam( "filter", "" );
> 	
> 	if ( $action ne "" ) {
> 		$action = lc($action);
> 		
> 		if ( $action eq "edit" ) {
> 			&DoEdit( $id, 0, 0, "", 0 ) if &ValidIdOrDie($id);
> 		}
> 		elsif ( $action eq "unlock" ) {
> 			&DoUnlock();
> 		}
> 		elsif ( $action eq "index" ) {
> 			&DoIndex();
> 		}
> 		elsif ( $action eq "links" ) {
> 			&DoLinks();
> 		}
> 		elsif ( $action eq "maintain" ) {
> 			&DoMaintain();
> 		}
> 		elsif ( $action eq "pagelock" ) {
> 			&DoPageLock();
> 		}
> 		elsif ( $action eq "editlock" ) {
> 			&DoEditLock();
> 		}
> 		elsif ( $action eq "editprefs" ) {
> 			&DoEditPrefs();
> 		}
> 		elsif ( $action eq "editbanned" ) {
> 			&DoEditBanned();
> 		}
> 		elsif ( $action eq "editlinks" ) {
> 			&DoEditLinks();
> 		}
> 		elsif ( $action eq "login" ) {
> 			&DoEnterLogin();
> 		}
> 		elsif ( $action eq "newlogin" ) {
> 			$UserID = 0;
> 			&DoEditPrefs();    # Also creates new ID
> 		}
> 		elsif ( $action eq "version" ) {
> 			&DoShowVersion();
> 		}
> 		elsif ( $action eq "rss" ) {
> 			&DoRss();
> 		}
> 		elsif ( $action eq "delete" ) {
> 			&DoDeletePage($id);
> 		}
> 		elsif ( $UseUpload && ( $action eq "upload" ) ) {
> 			&DoUpload();
> 		}
> 		elsif ( $action eq "maintainrc" ) {
> 			&DoMaintainRc();
> 		}
> 		elsif ( $action eq "convert" ) {
> 			&DoConvert();
> 		}
> 		elsif ( $action eq "trimusers" ) {
> 			&DoTrimUsers();
> 		}
> 		elsif ( $action eq "listfiles" ) {
> 			&DoListFiles($id, $filter, 0);	
> 		}
> 		elsif ( $action eq "listdisabled" ) {
> 			&DoListFiles($id, $filter, 1);	
> 		}
> 		else {
> 			&ReportError( Ts( 'Invalid action parameter %s', $action ) );
> 		}
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_prefs", 0 ) ) {
> 		&DoUpdatePrefs();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_ban", 0 ) ) {
> 		&DoUpdateBanned();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "enter_login", 0 ) ) {
> 		&DoLogin();
> 		return;
> 	}
> 	
> 	if ( &GetParam( "edit_links", 0 ) ) {
> 		&DoUpdateLinks();
> 		return;
> 	}
> 	
> 	if ( $UseUpload && ( &GetParam( "upload", 0 ) ) ) {
> 		&SaveUpload();
> 		return;
> 	}
> 	
> 	$search = &GetParam( "search", "" );
> 	
> 	if ( ( $search ne "" ) || ( &GetParam( "dosearch", "" ) ne "" ) ) {
> 		&DoSearch($search, $filter);
> 		return;
> 	}
> 	else {
> 		$search = &GetParam( "back", "" );
> 		if ( $search ne "" ) {
> 			&DoBackLinks($search, $filter);
> 			
> 			return;
> 		}
> 	}
> 
> 	# Handle posted pages
> 	if ( &GetParam( "oldtime", "" ) ne "" ) {
> 		$id = &GetParam( "title", "" );
> 		&DoPost() if &ValidIdOrDie($id);
> 		
> 		return;
> 	}
> 	
> 	&ReportError( "Invalid URL." );
3176a4283,4299
> sub PageIsLocked {
> 	my ($id, $deepedit) = @_;
> 	my ($result) = 0;
> 	
> 	if ( !&UserCanEdit( $id, $deepedit ) ) {
> 			$result = 1;
> 		if ( &UserIsBanned() ) {
> 			$result = 2;
> 		}
> 		else {
> 			$result = 3;
> 		}
> 	}
> 	
> 	return $result;
> }
> 
3178,3309c4301,4518
<   my ($id, $isConflict, $oldTime, $newText, $preview) = @_;
<   my ($header, $editRows, $editCols, $userName, $revision, $oldText);
<   my ($summary, $isEdit, $pageTime);
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);  # Take care of users like Markus Lude :-)
<   }
<   if (!&UserCanEdit($id, 1)) {
<     print &GetHeader("", T('Editing Denied'), "");
<     if (&UserIsBanned()) {
<       print T('Editing not allowed: user, ip, or network is blocked.');
<       print "<p>";
<       print T('Contact the wiki administrator for more information.');
<     } else {
<       print Ts('Editing not allowed: %s is read-only.', $SiteName);
<     }
<     print &GetCommonFooter();
<     return;
<   }
<   # Consider sending a new user-ID cookie if user does not have one
<   &OpenPage($id);
<   &OpenDefaultText();
<   $pageTime = $Section{'ts'};
<   $header = Ts('Editing %s', $id);
<   # Old revision handling
<   $revision = &GetParam('revision', '');
<   $revision =~ s/\D//g;  # Remove non-numeric chars
<   if ($revision ne '') {
<     &OpenKeptRevisions('text_default');
<     if (!defined($KeptRevisions{$revision})) {
<       $revision = '';
<       # Consider better solution like error message?
<     } else {
<       &OpenKeptRevision($revision);
<       $header = Ts('Editing revision %s of ', $revision ) . $id;
<     }
<   }
<   $oldText = $Text{'text'};
<   if ($preview && !$isConflict) {
<     $oldText = $newText;
<   }
<   $editRows = &GetParam("editrows", 20);
<   $editCols = &GetParam("editcols", 65);
<   print &GetHeader('', &QuoteHtml($header), '');
<   if ($revision ne '') {
<     print "\n<b>"
<           . Ts('Editing old revision %s.', $revision) . "  "
<     . T('Saving this page will replace the latest revision with this text.')
<           . '</b><br>'
<   }
<   if ($isConflict) {
<     $editRows -= 10  if ($editRows > 19);
<     print "\n<H1>" . T('Edit Conflict!') . "</H1>\n";
<     if ($isConflict>1) {
<       # The main purpose of a new warning is to display more text
<       # and move the save button down from its old location.
<       print "\n<H2>" . T('(This is a new conflict)') . "</H2>\n";
<     }
<     print "<p><strong>",
<           T('Someone saved this page after you started editing.'), " ",
<           T('The top textbox contains the saved text.'), " ",
<           T('Only the text in the top textbox will be saved.'),
<           "</strong><br>\n",
<           T('Scroll down to see your edited text.'), "<br>\n";
<     print T('Last save time:'), ' ', &TimeToText($oldTime),
<           " (", T('Current time is:'), ' ', &TimeToText($Now), ")<br>\n";
<   }
<   print &GetFormStart();
<   print &GetHiddenValue("title", $id), "\n",
<         &GetHiddenValue("oldtime", $pageTime), "\n",
<         &GetHiddenValue("oldconflict", $isConflict), "\n";
<   if ($revision ne "") {
<     print &GetHiddenValue("revision", $revision), "\n";
<   }
<   print &GetTextArea('text', $oldText, $editRows, $editCols);
<   $summary = &GetParam("summary", "*");
<   print "<p>", T('Summary:'),
<         $q->textfield(-name=>'summary',
<                       -default=>$summary, -override=>1,
<                       -size=>60, -maxlength=>200);
<   if (&GetParam("recent_edit") eq "on") {
<     print "<br>", $q->checkbox(-name=>'recent_edit', -checked=>1,
<                                -label=>T('This change is a minor edit.'));
<   } else {
<     print "<br>", $q->checkbox(-name=>'recent_edit',
<                                -label=>T('This change is a minor edit.'));
<   }
<   if ($EmailNotify) {
<     print "&nbsp;&nbsp;&nbsp;" .
<            $q->checkbox(-name=> 'do_email_notify',
<       -label=>Ts('Send email notification that %s has been changed.', $id));
<   }
<   print "<br>";
<   if ($EditNote ne '') {
<     print T($EditNote) . '<br>';  # Allow translation
<   }
<   print $q->submit(-name=>'Save', -value=>T('Save')), "\n";
<   $userName = &GetParam("username", "");
<   if ($userName ne "") {
<     print ' (', T('Your user name is'), ' ',
<           &GetPageLink($userName) . ') ';
<   } else {
<     print ' (', Ts('Visit %s to set your user name.', &GetPrefsLink()), ') ';
<   }
<   print $q->submit(-name=>'Preview', -value=>T('Preview')), "\n";
<   if ($isConflict) {
<     print "\n<br><hr><p><strong>", T('This is the text you submitted:'),
<           "</strong><p>",
<           &GetTextArea('newtext', $newText, $editRows, $editCols),
<           "<p>\n";
<   }
<   print "<hr class=wikilinefooter>\n";
<   if ($preview) {
<     print '<div class=wikipreview>';
<     print "<h2>", T('Preview:'), "</h2>\n";
<     if ($isConflict) {
<       print "<b>",
<             T('NOTE: This preview shows the revision of the other author.'),
<             "</b><hr>\n";
<     }
<     $MainPage = $id;
<     $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
<     print &WikiToHTML($oldText) . "<hr class=wikilinefooter>\n";
<     print "<h2>", T('Preview only, not yet saved'), "</h2>\n";
<     print '</div>';
<   }
<   print '<div class=wikifooter>';
<   print &GetHistoryLink($id, T('View other revisions')) . "<br>\n";
<   print &GetGotoBar($id);
<   print $q->endform;
<   print '</div>';
<   print &GetMinimumFooter();
---
> 	my ( $id, $isConflict, $oldTime, $newText, $preview ) = @_;
> 	my ( $header, $editRows, $editCols, $userName, $revision, $oldText );
> 	my ( $summary, $isEdit, $pageTime, $isLocked );
> 	
> 	my $authtype = &CheckIsAuthUser($id);
> 	if (!$authtype) { $id = "AuthError"; } #auth patch	
> 	if ($FreeLinks) { $id = &FreeToNormal($id); }   # Take care of users like Markus Lude :-)	
> 	
> 	$isLocked = &PageIsLocked( $id, 1 );
> 	
> 	if ( $isLocked > 0 or $authtype eq "" || $authtype eq "1") {
> 		print &GetHeader( "", "Editing Denied", "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		
> 		if ( $isLocked == 2 ) {
> 			print "\n<h2>Editing not allowed: user, ip, or network is blocked.</h2>";
> 			print "\nContact the wiki administrator for more information.";
> 		}
> 		else {
> 			print "\n<h2>Editing not allowed: $id is read-only.</h2>";
> 		}
> 		
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></div></body></html>";
> 			
> 		return;
> 	}
> 
> 	# Consider sending a new user-ID cookie if user does not have one
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$pageTime = $Section{'ts'};
> 	$header   = Ts( 'Editing %s', $id );
> 
> 	# Old revision handling
> 	$revision = &GetParam( 'revision', "" );
> 	$revision =~ s/\D//g;    # Remove non-numeric chars
> 	
> 	if ( $revision ne "" ) {
> 		&OpenKeptRevisions('text_default');
> 		
> 		if ( !defined( $KeptRevisions{$revision} ) ) {
> 			$revision = "";
> 
> 			# Consider better solution like error message?
> 		}
> 		else {
> 			&OpenKeptRevision($revision);
> 			$header = Ts( 'Editing revision %s of ', $revision ) . $id;
> 		}
> 	}
> 	
> 	$oldText = $Text{'text'};
> 	
> 	if ( $preview && !$isConflict ) {
> 		$oldText = $newText;
> 	}
> 	
> 	$editRows = &GetParam( "editrows", 20 );
> 	$editCols = &GetParam( "editcols", 65 );
> 	print &GetHeader( "", &QuoteHtml($header), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $revision ne "" ) {
> 		print "\n<b>Editing old revision $revision. Saving this page will replace the latest revision with this text.</b><br>";
> 	}
> 	
> 	if ($isConflict) {
> 		$editRows -= 10 if ( $editRows > 19 );
> 		print "\n<H1>Edit Conflict!</H1>";
> 		
> 		if ( $isConflict > 1 ) {
> 
> 			# The main purpose of a new warning is to display more text
> 			# and move the save button down from its old location.
> 			print "\n<h2>(This is a new conflict)</h2>";
> 		}
> 		
> 		print "\n<p><strong>";
> 		print "\nSomeone saved this page after you started editing. ";
> 		print "\nThe top textbox contains the saved text. ";
> 		print "\nOnly the text in the top textbox will be saved.";
> 		print "\n</strong></p><br>";
> 		print "\nScroll down to see your edited text.";
> 		print "\n<br>";
> 		print "\nLast save time: ";
> 		print &TimeToText($oldTime);
> 		print "\n(Current time is: ";
> 		print &TimeToText($Now);
> 		print "\n)<br>";
> 	}
> 	print "\n<div id='wikieditbar'>";
> 	print "<a href='$ScriptName?WikiStyleGuide'>WikiStyleGuide</a> | ";
> 	print "<a href='$ScriptName?WikiHeadings'>WikiHeadings</a> | ";
> 	print "<a href='$ScriptName?WikiGallery'>WikiGallery</a>| ";
> 	print "<a href='$ScriptName?WikiFlash'>WikiFlash</a>| ";
> 	print "<a href='$ScriptName?WikiTOCs'>WikiTOCs</a> | ";
> 	print "<a href='$ScriptName?WikiURLs'>WikiURLs</a> | ";
> 	print "<a href='$ScriptName?WikiImages'>WikiImages</a> | ";
> 	print "<a href='$ScriptName?WikiTables'>WikiTables</a> | ";
> 	print "<a href='$ScriptName?WikiLists'>WikiLists</a> | ";
> 	print "<a href='$ScriptName?WikiMarkup'>WikiMarkup</a>";
> 	print "\n</div>";
> 	
> 	print "\n<br>";
> 	print "\n<form id='wikiform' action='$ScriptName#preview-anchor' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "title",   $id );
> 	print &GetHiddenValue( "oldtime",     $pageTime );
> 	print &GetHiddenValue( "oldconflict", $isConflict );
> 	  
> 	if ( $revision ne "" ) {
> 		print &GetHiddenValue( "revision", $revision );
> 	}
> 	
> 	print &GetTextArea( 'text', $oldText, $editRows, $editCols );
> 	$summary = &GetParam( "summary", "*" );
> 	
> 	print "\n<br><br><div id='wikisaveedit'>Summary:";
> 	print
> 	  $q->textfield(
> 		-name      => 'summary',
> 		-id		   => 'summarytext',
> 		-default   => $summary,
> 		-override  => 1,
> 		-size      => 60,
> 		-maxlength => 200
> 	  );
> 	  
> 	if ( &GetParam("recent_edit") eq "on" ) {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name    => 'recent_edit',
> 			-checked => 1,
> 			-label   => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	else {
> 		print "\n<br>",
> 		  $q->checkbox(
> 			-name  => 'recent_edit',
> 			-checked => 0,
> 			-label => "This change is a minor edit."
> 		  );
> 		print "\n<br>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n&nbsp;&nbsp;&nbsp;"
> 		  . $q->checkbox(
> 			-name  => 'do_email_notify',
> 			-label =>
> 			  Ts( 'Send email notification that %s has been changed.', $id )
> 		  );
> 	}
> 	
> 	print "\n<br>";
> 	
> 	if ( $EditNote ne "" ) {
> 		print $EditNote . '<br>';
> 	}
> 	$userName = &GetParam( "username", "" );
> 	print $q->submit( -name => 'Preview', -value => 'Preview' );
> 	print $q->button( -name => 'Cancel', -value => 'Cancel', -onclick => 'window.location="' . $ScriptName . '?' . $id . '";' );
> 	print $q->submit( -name => 'Save', -value => "Save" );	
> 	
> 	if ( $userName ne "" ) {
> 		print "\n (Your user name is ";
> 		print &GetPageLinkText("$HomePagePrefix$userName", $userName);
> 		print "\n )";
> 	}
> 	else {
> 		print ' (', Ts( 'Visit %s to set your user name.', &GetPrefsLink() ), ') ';
> 	}
> 
> 	if ($isConflict) {
> 		print "\n<br><hr><p><strong>";
> 		print "\nThis is the text you submitted:";
> 		print  "</strong><p>";
> 		print &GetTextArea( 'newtext', $newText, $editRows, $editCols );
> 	}
> 	
> 	print "\n</div>";
> 	print "\n</form>";
> 	print "<a name='preview-anchor'></a>";
> 	print "\n</div>";			
> 	print "\n$WikiLineFooter";
> 	
> 	if ($preview) {
> 		
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print $WikiLineHeaderPreview;
> 		print "\n<div id='wikipreview' class='wikipreview'>";				
> 		if ($isConflict) {
> 			print "\n<b>NOTE: This preview shows the revision of the other author.</b><hr>";
> 		}
> 		
> 		$MainPage = $id;
> 		$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
> 		
> 		print &WikiToHTML($oldText);
> 		print "\n</div>";
> 		print "\n$WikiLineFooter";
> 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
> 		print "\n<div id='wikibar'>&nbsp</div>";
> 	}
> 
> 	print "\n<div class='wikifooter'>";	
> 	print "\n<div class='wikirevision'>";
> 	print &GetHistoryLink( $id, "View other revisions<br>", "Click to view revision history");
> 	print "</div>";
> 	print &GetGotoBar($id);
> 	print &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }		
> 	print "\n</div></div></div></div></body></html>";	
3313,3322c4522,4552
<   my ($name, $text, $rows, $cols) = @_;
< 
<   if (&GetParam("editwide", 1)) {
<     return $q->textarea(-name=>$name, -default=>$text,
<                         -rows=>$rows, -columns=>$cols, -override=>1,
<                         -style=>'width:100%', -wrap=>'virtual');
<   }
<   return $q->textarea(-name=>$name, -default=>$text,
<                       -rows=>$rows, -columns=>$cols, -override=>1,
<                       -wrap=>'virtual');
---
> 	my ( $name, $text, $rows, $cols ) = @_;
> 	my ( $html );
> 	
> 	$html = "\n<div style='width: 100%;'>";
> 	if ( &GetParam( "editwide", 1 ) ) {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-style    => 'width:100%',
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	else {
> 		$html .= $q->textarea(
> 			-name     => $name,
> 			-default  => $text,
> 			-id       => 'wikitextarea' . $name,
> 			-rows     => $rows,
> 			-columns  => $cols,
> 			-override => 1,
> 			-wrap     => 'virtual'
> 		);
> 	}
> 	
> 	$html .= "</div>";
> 	
> 	return $html;
3326,3413c4556,4687
<   my ($check, $recentName, %labels);
< 
<   $recentName = $RCName;
<   $recentName =~ s/_/ /g;
<   &DoNewLogin()  if ($UserID < 400);
<   print &GetHeader('', T('Editing Preferences'), "");
<   print '<div class=wikipref>';
<   print &GetFormStart();
<   print GetHiddenValue("edit_prefs", 1), "\n";
<   print '<b>' . T('User Information:') . "</b>\n";
<   print '<br>' . Ts('Your User ID number: %s', $UserID) . "\n";
<   print '<br>' . T('UserName:') . ' ', &GetFormText('username', "", 20, 50);
<   print ' ' . T('(blank to remove, or valid page name)');
<   print '<br>' . T('Set Password:') . ' ',
<         $q->password_field(-name=>'p_password', -value=>'*', 
<                            -size=>15, -maxlength=>50),
<         ' ', T('(blank to remove password)'), '<br>(',
<         T('Passwords allow sharing preferences between multiple systems.'),
<         ' ', T('Passwords are completely optional.'), ')';
<   if (($AdminPass ne '') || ($EditPass ne '')) {
<     print '<br>', T('Administrator Password:'), ' ',
<           $q->password_field(-name=>'p_adminpw', -value=>'*', 
<                              -size=>15, -maxlength=>50),
<           ' ', T('(blank to remove password)'), '<br>',
<           T('(Administrator passwords are used for special maintenance.)');
<   }
<   if ($EmailNotify) {
<     print "<br>";
<     print &GetFormCheck('notify', 1,
<           T('Include this address in the site email list.')), ' ',
<           T('(Uncheck the box to remove the address.)');
<     print '<br>', T('Email Address:'), ' ',
<           &GetFormText('email', "", 30, 60);
<   }
<   print "<hr class=wikilinepref><b>$recentName:</b>\n";
<   print '<br>', T('Default days to display:'), ' ',
<         &GetFormText('rcdays', $RcDefault, 4, 9);
<   print "<br>", &GetFormCheck('rcnewtop', $RecentTop,
<                               T('Most recent changes on top'));
<   print "<br>", &GetFormCheck('rcall', 0,
<                               T('Show all changes (not just most recent)'));
<   %labels = (0=>T('Hide minor edits'), 1=>T('Show minor edits'),
<              2=>T('Show only minor edits'));
<   print '<br>', T('Minor edit display:'), ' ';
<   print $q->popup_menu(-name=>'p_rcshowedit',
<                        -values=>[0,1,2], -labels=>\%labels,
<                        -default=>&GetParam("rcshowedit", $ShowEdits));
<   print "<br>", &GetFormCheck('rcchangehist', 1,
<                               T('Use "changes" as link to history'));
<   if ($UseDiff) {
<     print '<hr class=wikilinepref><b>', T('Differences:'), "</b>\n";
<     print "<br>", &GetFormCheck('diffrclink', 1,
<                                 Ts('Show (diff) links on %s', $recentName));
<     print "<br>", &GetFormCheck('alldiff', 0,
<                                 T('Show differences on all pages'));
<     print "  (",  &GetFormCheck('norcdiff', 1,
<                                 Ts('No differences on %s', $recentName)), ")";
<     %labels = (1=>T('Major'), 2=>T('Minor'), 3=>T('Author'));
<     print '<br>', T('Default difference type:'), ' ';
<     print $q->popup_menu(-name=>'p_defaultdiff',
<                          -values=>[1,2,3], -labels=>\%labels,
<                          -default=>&GetParam("defaultdiff", 1));
<   }
<   print '<hr class=wikilinepref><b>', T('Misc:'), "</b>\n";
<   # Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
<   print '<br>', T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset);
<   print '<br>', T('Time Zone offset (hours):'), ' ',
<         &GetFormText('tzoffset', 0, 4, 9);
<   print '<br>', &GetFormCheck('editwide', 1,
<                               T('Use 100% wide edit area (if supported)'));
<   print '<br>',
<         T('Edit area rows:'), ' ', &GetFormText('editrows', 20, 4, 4),
<         ' ', T('columns:'),   ' ', &GetFormText('editcols', 65, 4, 4);
< 
<   print '<br>', &GetFormCheck('toplinkbar', 1,
<                               T('Show link bar on top'));
<   print '<br>', &GetFormCheck('linkrandom', 0,
<                               T('Add "Random Page" link to link bar'));
<   print '<br>' . T('StyleSheet URL:') . ' ',
<         &GetFormText('stylesheet', "", 30, 150);
<   print '<br>', $q->submit(-name=>'Save', -value=>T('Save')), "\n";
<   print '</div>';
<   print "<hr class=wikilinefooter>\n";
<   print '<div class=wikifooter>';
<   print &GetGotoBar('');
<   print $q->endform;
<   print '</div>';
<   print &GetMinimumFooter();
---
> 	my ( $check, $recentName, %labels );
> 	
> 	$recentName = $RCName;
> 	$recentName =~ s/_/ /g;
> 	
> 	&DoNewLogin() if ( $UserID < 400 );
> 	
> 	print &GetHeader( "", "Editing Preferences", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikidiff'>";
> 	print "\n<h2>Access Controls</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( "edit_prefs", 1 );
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th colspan='2'><b>User Information </b></th></tr>";
> 	print "\n<tr><td>Your User ID number </td><td>$UserID</td></tr>";
> 	print "\n<tr><td>UserName</td>";
> 	print "\n<td>" . &GetFormText( 'username', "", 30, 50 );
> 	print "\n<br>(blank to remove, or valid page name)</td></tr>";
> 	print "\n<tr><td>Set Password </td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => '*',
> 		-size      => 30,
> 		-maxlength => 50
> 	  );
> 	 print "\n<br>(blank to remove password)";
> 	 print "\n<br>Passwords allow sharing preferences between multiple systems. Passwords are completely optional. ";
> 	 print "\n</td></tr>";
> 
> 
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		print "\n<tr><td>Administrator Password </td>";
> 		print "\n<td>";
> 		print
> 		  $q->password_field(
> 			-name      => 'p_adminpw',
> 			-value     => '*',
> 			-size      => 30,
> 			-maxlength => 50
> 		  );
> 		print "\n<br>(blank to remove password)";
> 		print "\n<br>(Administrator passwords are used for special maintenance.)";
> 		print "\n</td></tr>";
> 	}
> 	
> 	if ($EmailNotify) {
> 		print "\n<tr><td>Email Address</td>";
> 		print "\n<td>" . &GetFormText( 'email', "", 30, 60 );
> 		print "\n<br>" . &GetFormCheck( 'notify', 1, "Include this address in the site email list." );
> 		print "\n<br>(Uncheck the box to remove the address.) ";
> 		
> 		print "\n</td></tr>";
> 	}
> 	
> 	print "\n</table>";
> 	
> 	print "\n$WikiLinePref<b>$recentName:</b>";
> 	print "\n<br>Default days to display: ";
> 	print &GetFormText( 'rcdays', $RcDefault, 4, 9 );
> 	print "\n<br>", &GetFormCheck( 'rcnewtop', $RecentTop, "Most recent changes on top" );
> 	print "\n<br>", &GetFormCheck( 'rcall', 0, "Show all changes (not just most recent)" );
> 	
> 	%labels = (
> 		0 => "Hide minor edits",
> 		1 => "Show minor edits",
> 		2 => "Show only minor edits"
> 	);
> 	
> 	print "\n<br>Minor edit display: ";
> 	print $q->popup_menu(
> 		-name   => 'p_rcshowedit',
> 		-values => [ 0, 1, 2 ],
> 		-labels => \%labels,
> 		-default => &GetParam( "rcshowedit", $ShowEdits )
> 	);
> 	
> 	print "\n<br>", &GetFormCheck( 'rcchangehist', 1, "Use 'changes' as link to history" );
> 
> 	if ($UseDiff) {
> 		print "\n$WikiLinePref<b>Differences:</b>";
> 		print "\n<br>", &GetFormCheck( 'diffrclink', 1, "Show (diff) links on $recentName " );
> 		print "\n<br>", &GetFormCheck( 'alldiff', 0, "Show differences on all pages" );
> 		print "\n  (", &GetFormCheck( 'norcdiff', 1, "No differences on $recentName " ), ")";
> 		%labels = ( 1 => "Major", 2 => "Minor", 3 => "Author" );
> 		print "\n<br>Default difference type: ";
> 		print $q->popup_menu(
> 			-name   => 'p_defaultdiff',
> 			-values => [ 1, 2, 3 ],
> 			-labels => \%labels,
> 			-default => &GetParam( "defaultdiff", 1 )
> 		);
> 	}
> 	
> 	print "\n$WikiLinePref<b>Misc:</b>";
> 
> 	# Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
> 	print "\n<br>";
> 	print "\nServer time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print &GetFormText( 'tzoffset', 0, 4, 9 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'editwide', 1, "Use 100% wide edit area (if supported)" );
> 	print "\n<br>";
> 	print "\nEdit area rows: ";
> 	print &GetFormText( 'editrows', 20, 4, 4 );
> 	print "\n columns: ";
> 	print &GetFormText( 'editcols', 65, 4, 4 );
> 	print "\n<br>";
> 	print &GetFormCheck( 'toplinkbar', 1, "Show link bar on top" );
> 	print "\n<br>";
> 	print &GetFormCheck( 'linkrandom', 0, "Add 'Random Page' link to link bar" );
> 	print "\n<br>";
> 	print "\nStyleSheet URL: ";
> 
> 	print &GetCssChoices();	
> 	
> 	print "\n<br><br>";
> 	print "\n<input type='button' name='Cancel' value='Cancel' onclick='history.go(-1);' style='margin-right: 20px;'>";
> 	print "\n<input type='reset' name='Reset'> ";
> 	print $q->submit( -name => 'Save', -value => "Save" );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print "\n$WikiLineFooter";
> 	print "\n<div class='wikifooter'>";
> 	print &GetGotoBar("");
> 
> 	print &getFooterNote();
> 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
> 	print "\n</div></div></div></div></body></html>";	
3417,3421c4691,4700
<   my ($name, $default, $size, $max) = @_;
<   my $text = &GetParam($name, $default);
< 
<   return $q->textfield(-name=>"p_$name", -default=>$text,
<                        -override=>1, -size=>$size, -maxlength=>$max);
---
> 	my ( $name, $default, $size, $max ) = @_;
> 	my $text = &GetParam( $name, $default );
> 	
> 	return $q->textfield(
> 		-name      => "p_$name",
> 		-default   => $text,
> 		-override  => 1,
> 		-size      => $size,
> 		-maxlength => $max
> 	);
3425,3429c4704,4712
<   my ($name, $default, $label) = @_;
<   my $checked = (&GetParam($name, $default) > 0);
< 
<   return $q->checkbox(-name=>"p_$name", -override=>1, -checked=>$checked,
<                       -label=>$label);
---
> 	my ( $name, $default, $label ) = @_;
> 	my $checked = ( &GetParam( $name, $default ) > 0 );
> 	
> 	return $q->checkbox(
> 		-name     => "p_$name",
> 		-override => 1,
> 		-checked  => $checked,
> 		-label    => $label
> 	);
3433,3531c4716,4847
<   my ($username, $password, $stylesheet);
< 
<   # All link bar settings should be updated before printing the header
<   &UpdatePrefCheckbox("toplinkbar");
<   &UpdatePrefCheckbox("linkrandom");
<   print &GetHeader('',T('Saving Preferences'), '');
<   print '<br>';
<   if ($UserID < 1001) {
<     print '<b>',
<           Ts('Invalid UserID %s, preferences not saved.', $UserID), '</b>';
<     if ($UserID == 111) {
<       print '<br>',
<             T('(Preferences require cookies, but no cookie was sent.)');
<     }
<     print &GetCommonFooter();
<     return;
<   }
<   $username = &GetParam("p_username",  "");
<   if ($FreeLinks) {
<     $username =~ s/^\[\[(.+)\]\]/$1/;  # Remove [[ and ]] if added
<     $username =  &FreeToNormal($username);
<     $username =~ s/_/ /g;
<   }
<   if ($username eq "") {
<     print T('UserName removed.'), '<br>';
<     undef $UserData{'username'};
<   } elsif ((!$FreeLinks) && (!($username =~ /^$LinkPattern$/))) {
<     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
<   } elsif ($FreeLinks && (!($username =~ /^$FreeLinkPattern$/))) {
<     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
<   } elsif (length($username) > 50) {  # Too long
<     print T('UserName must be 50 characters or less. (not saved)'), "<br>\n";
<   } else {
<     print Ts('UserName %s saved.', $username), '<br>';
<     $UserData{'username'} = $username;
<   }
<   $password = &GetParam("p_password",  "");
<   if ($password eq "") {
<     print T('Password removed.'), '<br>';
<     undef $UserData{'password'};
<   } elsif ($password ne "*") {
<     print T('Password changed.'), '<br>';
<     $UserData{'password'} = $password;
<   }
<   if (($AdminPass ne "") || ($EditPass ne "")) {
<     $password = &GetParam("p_adminpw",  "");
<     if ($password eq "") {
<       print T('Administrator password removed.'), '<br>';
<       undef $UserData{'adminpw'};
<     } elsif ($password ne "*") {
<       print T('Administrator password changed.'), '<br>';
<       $UserData{'adminpw'} = $password;
<       if (&UserIsAdmin()) {
<         print T('User has administrative abilities.'), '<br>';
<       } elsif (&UserIsEditor()) {
<         print T('User has editor abilities.'), '<br>';
<       } else {
<         print T('User does not have administrative abilities.'), ' ',
<               T('(Password does not match administrative password(s).)'),
<               '<br>';
<       }
<     }
<   }
<   if ($EmailNotify) {
<     &UpdatePrefCheckbox("notify");
<     &UpdateEmailList();
<   }
<   &UpdatePrefNumber("rcdays", 0, 0, 999999);
<   &UpdatePrefCheckbox("rcnewtop");
<   &UpdatePrefCheckbox("rcall");
<   &UpdatePrefCheckbox("rcchangehist");
<   &UpdatePrefCheckbox("editwide");
<   if ($UseDiff) {
<     &UpdatePrefCheckbox("norcdiff");
<     &UpdatePrefCheckbox("diffrclink");
<     &UpdatePrefCheckbox("alldiff");
<     &UpdatePrefNumber("defaultdiff", 1, 1, 3);
<   }
<   &UpdatePrefNumber("rcshowedit", 1, 0, 2);
<   &UpdatePrefNumber("tzoffset", 0, -999, 999);
<   &UpdatePrefNumber("editrows", 1, 1, 999);
<   &UpdatePrefNumber("editcols", 1, 1, 999);
<   print T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset), '<br>';
<   $TimeZoneOffset = &GetParam("tzoffset", 0) * (60 * 60);
<   print T('Local time:'), ' ', &TimeToText($Now), '<br>';
<   $stylesheet = &GetParam('p_stylesheet', '');
<   if ($stylesheet eq '') {
<     if (&GetParam('stylesheet', '') ne '') {
<       print T('StyleSheet URL removed.'), '<br>';
<     }
<     undef $UserData{'stylesheet'};
<   } else {
<     $stylesheet =~ s/[">]//g;  # Remove characters that would cause problems
<     $UserData{'stylesheet'} = $stylesheet;
<     print T('StyleSheet setting saved.'), '<br>';
<   }
<   &SaveUserData();
<   print '<b>', T('Preferences saved.'), '</b>';
<   print &GetCommonFooter();
---
> 	my ( $username, $password, $stylesheet );
> 
> 	# All link bar settings should be updated before printing the header
> 	&UpdatePrefCheckbox("toplinkbar");
> 	&UpdatePrefCheckbox("linkrandom");
> 	
> 	print &GetHeader( "", "Saving Preferences" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $UserID < 1001 ) {
> 		print "\n<h2>Invalid UserID $UserID, preferences not saved.</h2>";
> 		
> 		if ( $UserID == 111 ) {
> 			print "\n<br>(Preferences require cookies, but no cookie was sent.)";
> 		}
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></div></body></html>";
> 		
> 		return;
> 	}
> 	
> 	$username = &GetParam( "p_username", "" );
> 	
> 	if ($FreeLinks) {
> 		$username =~ s/^\[\[(.+)\]\]/$1/;    # Remove [[ and ]] if added
> 		$username = &FreeToNormal($username);
> 		$username =~ s/_/ /g;
> 	}
> 	
> 	if ( $username eq "" ) {
> 		print "\n<h2>UserName removed.</h2>";
> 		undef $UserData{'username'};
> 	}
> 	elsif ( ( !$FreeLinks ) && ( !( $username =~ /^$LinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( $FreeLinks && ( !( $username =~ /^$FreeLinkPattern$/ ) ) ) {
> 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
> 	}
> 	elsif ( length($username) > 50 ) {    # Too long
> 		print "\n<h2>UserName must be 50 characters or less. (not saved)</h2>";
> 	}
> 	else {
> 		print "\n<h2>UserName $username saved.</h2>";
> 		$UserData{'username'} = $username;
> 	}
> 	
> 	$password = &GetParam( "p_password", "" );
> 	
> 	if ( $password eq "" ) {
> 		print "\nPassword removed.<br>";
> 		undef $UserData{'password'};
> 	}
> 	elsif ( $password ne "*" ) {
> 		print "\nPassword changed.<br>";
> 		$UserData{'password'} = $password;
> 	}
> 	
> 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
> 		$password = &GetParam( "p_adminpw", "" );
> 		if ( $password eq "" ) {
> 			print "\nAdministrator password removed.<br>";
> 			undef $UserData{'adminpw'};
> 		}
> 		elsif ( $password ne "*" ) {
> 			print "\nAdministrator password changed.<br>";
> 			$UserData{'adminpw'} = $password;
> 			
> 			if ( &UserIsAdmin() ) {
> 				print "\nUser has administrative abilities.<br>";
> 			}
> 			elsif ( &UserIsEditor() ) {
> 				print "\nUser has editor abilities.<br>";
> 			}
> 			else {
> 				print "\nUser does not have administrative abilities. (Password does not match administrative password(s).) <br>";
> 			}
> 		}
> 	}
> 	if ($EmailNotify) {
> 		&UpdatePrefCheckbox("notify");
> 		&UpdateEmailList();
> 	}
> 	
> 	&UpdatePrefNumber( "rcdays", 0, 0, 999999 );
> 	&UpdatePrefCheckbox("rcnewtop");
> 	&UpdatePrefCheckbox("rcall");
> 	&UpdatePrefCheckbox("rcchangehist");
> 	&UpdatePrefCheckbox("editwide");
> 	
> 	if ($UseDiff) {
> 		&UpdatePrefCheckbox("norcdiff");
> 		&UpdatePrefCheckbox("diffrclink");
> 		&UpdatePrefCheckbox("alldiff");
> 		&UpdatePrefNumber( "defaultdiff", 1, 1, 3 );
> 	}
> 	
> 	&UpdatePrefNumber( "rcshowedit", 1, 0,    2 );
> 	&UpdatePrefNumber( "tzoffset",   0, -999, 999 );
> 	&UpdatePrefNumber( "editrows",   1, 1,    999 );
> 	&UpdatePrefNumber( "editcols",   1, 1,    999 );
> 	
> 	print "\n<br>Server time: ";
> 	print &TimeToText( $Now - $TimeZoneOffset );
> 	print "\n<br>";
> 	$TimeZoneOffset = &GetParam( "tzoffset", 0 ) * ( 60 * 60 );
> 	
> 	print"Local time: ";
> 	print &TimeToText($Now);
> 	print "\n<br>";
> 	$stylesheet = &GetParam( 'p_stylesheet', "" );
> 
> 	if ( $stylesheet eq "" ) {
> 		if ( &GetParam( 'stylesheet', "" ) ne "" ) {
> 			print "\nStyleSheet URL removed.<br>";
> 		}
> 		undef $UserData{'stylesheet'};
> 	}
> 	else {
> 		$stylesheet =~ s/[">]//g;  # Remove characters that would cause problems"
> 		$UserData{'stylesheet'} = $stylesheet;
> 		print "\nStyleSheet setting saved.<br>";
> 	}
> 	
> 	&SaveUserData();
> 	
> 	print "\n<br><b>Preferences saved.</b>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
3536,3572c4852,4892
<   my (@old_emails);
< 
<   local $/ = "\n";  # don't slurp whole files in this sub.
<   if (my $new_email = $UserData{'email'} = &GetParam("p_email", "")) {
<     my $notify = $UserData{'notify'};
<     if (-f $EmailFile) {
<       open(NOTIFY, $EmailFile)
<         or die(Ts('Could not read from %s:', $EmailFile) . " $!\n");
<       @old_emails = <NOTIFY>;
<       close(NOTIFY);
<     } else {
<       @old_emails = ();
<     }
<     my $already_in_list = grep /$new_email/, @old_emails;
<     if ($notify and (not $already_in_list)) {
<       &RequestLock() or die(T('Could not get mail lock'));
<       if (!open(NOTIFY, ">>$EmailFile")) {
<         &ReleaseLock();  # Don't leave hangling locks
<         die(Ts('Could not append to %s:', $EmailFile) . " $!\n");
<       }
<       print NOTIFY $new_email, "\n";
<       close(NOTIFY);
<       &ReleaseLock();
<     }
<     elsif ((not $notify) and $already_in_list) {
<       &RequestLock() or die(T('Could not get mail lock'));
<       if (!open(NOTIFY, ">$EmailFile")) {
<         &ReleaseLock();
<         die(Ts('Could not overwrite %s:', "$EmailFile") . " $!\n");
<       }
<       foreach (@old_emails) {
<         print NOTIFY "$_" unless /$new_email/;
<       }
<       close(NOTIFY);
<       &ReleaseLock();
<     }
<   }
---
> 	my (@old_emails);
> 	local $/ = "\n";               # don't slurp whole files in this sub.
> 	
> 	if ( my $new_email = $UserData{'email'} = &GetParam( "p_email", "" ) ) {
> 		my $notify = $UserData{'notify'};
> 		if ( -f $EmailFile ) {
> 			open( NOTIFY, $EmailFile ) or die( Ts( 'Could not read from %s:', $EmailFile ) . " $!\n" );
> 			@old_emails = <NOTIFY>;
> 			close(NOTIFY);
> 		}
> 		else {
> 			@old_emails = ();
> 		}
> 		
> 		my $already_in_list = grep /$new_email/, @old_emails;
> 		
> 		if ( $notify and ( not $already_in_list ) ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">>$EmailFile" ) ) {
> 				&ReleaseLock();    # Don't leave hangling locks
> 				die( "Could not append to $EmailFile : $!\n" );
> 			}
> 			
> 			print NOTIFY $new_email, "\n";
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 		elsif ( ( not $notify ) and $already_in_list ) {
> 			&RequestLock() or die( "Could not get mail lock" );
> 			if ( !open( NOTIFY, ">$EmailFile" ) ) {
> 				&ReleaseLock();
> 				die( "Could not overwrite $EmailFile : $!\n" );
> 			}
> 			foreach (@old_emails) {
> 				print NOTIFY "$_" unless /$new_email/;
> 			}
> 			
> 			close(NOTIFY);
> 			&ReleaseLock();
> 		}
> 	}
3576,3581c4896,4902
<   my ($param) = @_;
<   my $temp = &GetParam("p_$param", "*");
< 
<   $UserData{$param} = 1  if ($temp eq "on");
<   $UserData{$param} = 0  if ($temp eq "*");
<   # It is possible to skip updating by using another value, like "2"
---
> 	my ($param) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	$UserData{$param} = 1 if ( $temp eq "on" );
> 	$UserData{$param} = 0 if ( $temp eq "*" );
> 
> 	# It is possible to skip updating by using another value, like "2"
3585,3593c4906,4917
<   my ($param, $integer, $min, $max) = @_;
<   my $temp = &GetParam("p_$param", "*");
< 
<   return  if ($temp eq "*");
<   $temp =~ s/[^-\d\.]//g;
<   $temp =~ s/\..*//  if ($integer);
<   return  if ($temp eq "");
<   return  if (($temp < $min) || ($temp > $max));
<   $UserData{$param} = $temp;
---
> 	my ( $param, $integer, $min, $max ) = @_;
> 	my $temp = &GetParam( "p_$param", "*" );
> 	
> 	return if ( $temp eq "*" );
> 	
> 	$temp =~ s/[^-\d\.]//g;
> 	$temp =~ s/\..*// if ($integer);
> 	
> 	return if ( $temp eq "" );
> 	return if ( ( $temp < $min ) || ( $temp > $max ) );
> 	
> 	$UserData{$param} = $temp;
3597,3600c4921,4927
<   print &GetHeader('', T('Index of all pages'), '');
<   print '<br>';
<   &PrintPageList(&AllPagesList());
<   print &GetCommonFooter();
---
> 	print &GetHeader( "", "Index of all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( "", &AllPagesList() );
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
3605,3617c4933,4946
<   # Consider warning if cookie already exists
<   # (maybe use "replace=1" parameter)
<   &CreateUserDir();
<   $SetCookie{'id'} = &GetNewUserId();
<   $SetCookie{'randkey'} = int(rand(1000000000));
<   $SetCookie{'rev'} = 1;
<   %UserCookie = %SetCookie;
<   $UserID = $SetCookie{'id'};
<   # The cookie will be transmitted in the next header
<   %UserData = %UserCookie;
<   $UserData{'createtime'} = $Now;
<   $UserData{'createip'} = $ENV{REMOTE_ADDR};
<   &SaveUserData();
---
> 	# Consider warning if cookie already exists
> 	# (maybe use "replace=1" parameter)
> 	&CreateUserDir();
> 	$SetCookie{'id'}      = &GetNewUserId();
> 	$SetCookie{'randkey'} = int( rand(1000000000) );
> 	$SetCookie{'rev'}     = 1;
> 	%UserCookie           = %SetCookie;
> 	$UserID               = $SetCookie{'id'};
> 
> 	# The cookie will be transmitted in the next header
> 	%UserData               = %UserCookie;
> 	$UserData{'createtime'} = $Now;
> 	$UserData{'createip'}   = $ENV{REMOTE_ADDR};
> 	&SaveUserData();
3621,3634c4950,4982
<   print &GetHeader('', T('Login'), "");
<   print &GetFormStart();
<   print &GetHiddenValue('enter_login', 1), "\n";
<   print '<br>', T('User ID number:'), ' ',
<         $q->textfield(-name=>'p_userid', -value=>'',
<                       -size=>15, -maxlength=>50);
<   print '<br>', T('Password:'), ' ',
<         $q->password_field(-name=>'p_password', -value=>'', 
<                            -size=>15, -maxlength=>50);
<   print '<br>', $q->submit(-name=>'Login', -value=>T('Login')), "\n";
<   print "<hr class=wikilinefooter>\n";
<   print &GetGotoBar('');
<   print $q->endform;
<   print &GetMinimumFooter();
---
> 	print &GetHeader( "", "Login", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>Enter UserID</h2>";
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print &GetHiddenValue( 'enter_login', 1 );
> 	print "\n<table><tr>";
> 	print "\n<td>User ID number &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->textfield(
> 		-name      => 'p_userid',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n<tr>";
> 	print "\n<td>Password  &nbsp;</td>";
> 	print "\n<td>";
> 	print
> 	  $q->password_field(
> 		-name      => 'p_password',
> 		-value     => "",
> 		-size      => 15,
> 		-maxlength => 50
> 	  );
> 	print "\n</td>";
> 	print "\n</tr></table><br>";
> 	print $q->submit( -name => 'Login', -value => 'Login' );
> 	print "\n<br></form></div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></body></html>";	
3638,3666c4986,5025
<   my ($uid, $password, $success);
< 
<   $success = 0;
<   $uid = &GetParam("p_userid", "");
<   $uid =~ s/\D//g;
<   $password = &GetParam("p_password",  "");
<   if (($uid > 199) && ($password ne "") && ($password ne "*")) {
<     $UserID = $uid;
<     &LoadUserData();
<     if ($UserID > 199) {
<       if (defined($UserData{'password'}) &&
<           ($UserData{'password'} eq $password)) {
<         $SetCookie{'id'} = $uid;
<         $SetCookie{'randkey'} = $UserData{'randkey'};
<         $SetCookie{'rev'} = 1;
<         $success = 1;
<       }
<     }
<   }
<   print &GetHeader('', T('Login Results'), '');
<   if ($success) {
<     print Ts('Login for user ID %s complete.', $uid);
<   } else {
<     print Ts('Login for user ID %s failed.', $uid);
<   }
<   print "<hr class=wikilinefooter>\n";
<   print &GetGotoBar('');
<   print $q->endform;
<   print &GetMinimumFooter();
---
> 	my ( $uid, $password, $success );
> 	
> 	$success = 0;
> 	$uid = &GetParam( "p_userid", "" );
> 	$uid =~ s/\D//g;
> 	$password = &GetParam( "p_password", "" );
> 	
> 	print &GetHeader( "", "Login Results", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( ( $uid > 199 ) && ( $password ne "" ) && ( $password ne "*" ) ) {
> 		$UserID = $uid;
> 		&LoadUserData();
> 		if ( $UserID > 199 ) {
> 			if ( defined( $UserData{'password'} ) && ( $UserData{'password'} eq $password ) ) {
> 				$SetCookie{'id'}      = $uid;
> 				$SetCookie{'randkey'} = $UserData{'randkey'};
> 				$SetCookie{'rev'}     = 1;
> 				$success              = 1;
> 			}
> 			else {
> 				print "\nUserID Account Undefined<br>";
> 			}
> 		}
> 		else {
> 			print "\nUserID must be above 199<br>";
> 		}
> 	}
> 	
> 	
> 	if ($success) {
> 		print "\n<h2>Login for user ID $uid complete.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Login for user ID $uid failed.</h2>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter;
> 	print "\n</div></div></div></body></html>";	
3670,3688c5029,5053
<   my ($id);
< 
<   $id = $StartUID;
<   while (-f &UserDataFilename($id+1000)) {
<     $id += 1000;
<   }
<   while (-f &UserDataFilename($id+100)) {
<     $id += 100;
<   }
<   while (-f &UserDataFilename($id+10)) {
<     $id += 10;
<   }
<   &RequestLock() or die(T('Could not get user-ID lock'));
<   while (-f &UserDataFilename($id)) {
<     $id++;
<   }
<   &WriteStringToFile(&UserDataFilename($id), "lock");  # reserve the ID
<   &ReleaseLock();
<   return $id;
---
> 	my ($id);
> 	
> 	$id = $StartUID;
> 	
> 	while ( -f &UserDataFilename( $id + 1000 ) ) {
> 		$id += 1000;
> 	}
> 	
> 	while ( -f &UserDataFilename( $id + 100 ) ) {
> 		$id += 100;
> 	}
> 	
> 	while ( -f &UserDataFilename( $id + 10 ) ) {
> 		$id += 10;
> 	}
> 	
> 	&RequestLock() or die( "Could not get user-ID lock" );
> 	while ( -f &UserDataFilename($id) ) {
> 		$id++;
> 	}
> 	
> 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
> 	&ReleaseLock();
> 	
> 	return $id;
3693,3698c5058,5063
<   my ($userFile, $data);
< 
<   &CreateUserDir();
<   $userFile = &UserDataFilename($UserID);
<   $data = join($FS1, %UserData);
<   &WriteStringToFile($userFile, $data);
---
> 	my ( $userFile, $data );
> 	
> 	&CreateUserDir();
> 	$userFile = &UserDataFilename($UserID);
> 	$data = join( $FS1, %UserData );
> 	&WriteStringToFile( $userFile, $data );
3702,3711c5067,5075
<   my ($n, $subdir);
< 
<   if (!(-d "$UserDir/0")) {
<     &CreateDir($UserDir);
< 
<     foreach $n (0..9) {
<       $subdir = "$UserDir/$n";
<       &CreateDir($subdir);
<     }
<   }
---
> 	my ( $n, $subdir );
> 	
> 	if ( !( -d "$UserDir/0" ) ) {
> 		&CreateDir($UserDir);
> 		foreach $n ( 0 .. 9 ) {
> 			$subdir = "$UserDir/$n";
> 			&CreateDir($subdir);
> 		}
> 	}
3715,3724c5079,5098
<   my ($string) = @_;
< 
<   if ($string eq '') {
<     &DoIndex();
<     return;
<   }
<   print &GetHeader('', &QuoteHtml(Ts('Search for: %s', $string)), '');
<   print '<br>';
<   &PrintPageList(&SearchTitleAndBody($string));
<   print &GetCommonFooter();
---
> 	my ($string, $filter) = @_;
> 	my ( $title );
> 	if ( $string eq "" ) {
> 		&DoIndex();
> 		return;
> 	}
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( "Search for: $title %s", $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print PrintPageList( $filter, &SearchTitleAndBody($string, $filter) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='search' value='$string'>";
> 	print "\n<input type='hidden' name='dosearch' value='1'>";	
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
3728,3737c5102,5126
<   my ($string) = @_;
< 
<   print &GetHeader('', &QuoteHtml(Ts('Backlinks for: %s', $string)), '');
<   print '<br>';
<   # At this time the backlinks are mostly a renamed search.
<   # An initial attempt to match links only failed on subpages and free links.
<   # Escape some possibly problematic characters:
<   $string =~ s/([-'().,])/\\$1/g; 
<   &PrintPageList(&SearchTitleAndBody($string));
<   print &GetCommonFooter();
---
> 	my ($string, $filter) = @_;
> 	my ($title);
> 	
> 	$title = $string;
> 	
> 	print &GetHeader( "", &QuoteHtml( Ts( 'Backlinks for: %s', $string ) ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	# At this time the backlinks are mostly a renamed search.
> 	# An initial attempt to match links only failed on subpages and free links.
> 	# Escape some possibly problematic characters:
> 	
> 	$string =~ s/([_ ])/( |_)/g;
> 	$string =~ s/([-'(),])/\\$1/g; #'REMARK
> 	$string =~ m,/, ? "\\b$string\\b" : "$string\\b";
> 	
> 	print PrintPageList( grep($_ !~ $title, $filter, &SearchTitleAndBody($string, $filter, "")) );
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
> 	print "\n<input type='hidden' name='back' value='$string'>";
> 	print "\n<input type='submit' value='Apply Filter'>";	
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
3741,3775c5130,5153
<   my $pagename;
< 
<   print "<h2>", Ts('%s pages found:', ($#_ + 1)), "</h2>\n";
<   foreach $pagename (@_) {
<     print ".... "  if ($pagename =~ m|/|);
<     print &GetPageLink($pagename), "<br>\n";
<   }
< }
< 
< sub DoLinks {
<   print &GetHeader('', &QuoteHtml(T('Full Link List')), '');
<   print "<hr><pre>\n\n\n\n\n";  # Extra lines to get below the logo
<   &PrintLinkList(&GetFullLinkList());
<   print "</pre>\n";
<   print &GetMinimumFooter();
< }
< 
< sub PrintLinkList {
<   my ($pagelines, $page, $names, $editlink);
<   my ($link, $extra, @links, %pgExists);
< 
<   %pgExists = ();
<   foreach $page (&AllPagesList()) {
<     $pgExists{$page} = 1;
<   }
<   $names = &GetParam("names", 1);
<   $editlink = &GetParam("editlink", 0);
<   foreach $pagelines (@_) {
<     @links = ();
<     foreach $page (split(' ', $pagelines)) {
<       if ($page =~ /\:/) {  # URL or InterWiki form
<         if ($page =~ /$UrlPattern/) {
<           ($link, $extra) = &UrlLink($page, 0);  # No images
<         } else {
<           ($link, $extra) = &InterPageLink($page, 0);  # No images
---
> 	my ($filter, @results) = @_;
> 	my $term;
>     my $pagename;
>     my $html = "";
>     my $pagecount = scalar(@results);
>     my $currentInitial = "";
>     my $thisInitial;
>     my $lastInitial;
>     my $letterGrouping = ($pagecount > 25);
>     my $currentParent = "";
>     my $linktext = "";
>     my $notFirst;
> 
> 	if ($filter ne ""){ $term = " using filter '<em>$filter</em>'"; }
> 	$html .= "<h2>" . ( scalar(@results) ) . " pages found: $term</h2>";
>     
>     if ($letterGrouping) {
>         $html .= "<h3 class='lettergroup'>";
>         foreach $pagename (@results) {
>             $thisInitial = substr($pagename,0,1);
>             if ($thisInitial ne $lastInitial) {
>                     $html .= "<a href=\"#letter".$thisInitial."\">".$thisInitial."</a> ";
>                     $lastInitial = $thisInitial;
>             }
3777,3787c5155
<       } else {
<         if ($pgExists{$page}) {
<           $link = &GetPageLink($page);
<         } else {
<           $link = $page;
<           if ($editlink) {
<             $link .= &GetEditLink($page, "?");
<           }
<         }
<       }
<       push(@links, $link);
---
>         $html .= "</h3>";
3789,3790c5157,5185
<     if (!$names) {
<       shift(@links);
---
>     
>     foreach $pagename (@results) {
>         if ($letterGrouping) {
>             $thisInitial = substr($pagename,0,1);
>             if ($currentInitial ne $thisInitial) {
>                 $html .= "\n<br><br><h3 class='lettergroup'><a name=\"letter$thisInitial\"> $thisInitial </h3>\n$WikiLine\n";
>                 $currentInitial = $thisInitial; 
>                 $notFirst = 0;
>             }
>         }
>         $html .= "   ";
>         if (not($pagename =~ m|(.*)/(.*)|)) {
>             $currentParent = $pagename;
>             $linktext = $pagename;
>         } 
>         else {
>             if ($1 eq $currentParent) {
>                 if ($letterGrouping){  $linktext = "$currentParent/$2";}
>                 else { $html .= "... "; $linktext = "/$2";}                
>             } 
>             else {
>                 $linktext = $pagename;
>             }
>         }
>         if ($notFirst){ $notFirst = 1; $linktext = ", $linktext"; }
>         $html .= &GetPageLinkText($pagename,$linktext);
> 
>         if ($letterGrouping){ $html .= ", "; }
>         else { $html .= "\n<br>"; }
3792,3793c5187,5190
<     print join(' ', @links), "\n";
<   }
---
>     #$html .= "</ol>\n"; # commented to keep a 'original' usemod look
>     $html .= "\n<br>";
>     
>     return $html;
3795a5193,5263
> sub DoLinks {	
> 	print &GetHeader( "", &QuoteHtml( "Full Link List" ), "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<hr><pre>\n\n\n\n";    # Extra lines to get below the logo
> 
> 	print &PrintLinkList(&GetFullLinkList(
> 		&GetParam("unique", 1),
> 		&GetParam("sort", 1),
> 		&GetParam("page", 1),
> 		&GetParam("inter", 0),
> 		&GetParam("url", 0),
> 		&GetParam("exists", 2),
> 		&GetParam("empty", 0),
> 		&GetParam("search", "")
> 	));
> 	
> 	print "\n</pre>";
> 	print "\n</div>";
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> sub PrintLinkList {
> 	my ( $pagelines, $page,  $names, $editlink );
> 	my ( $link, $text, $extra, @links, %pgExists );
> 	
> 	%pgExists = ();
> 	
> 	foreach $page ( &AllPagesList() ) {
> 		$pgExists{$page} = 1;
> 	}
> 	
> 	$names    = &GetParam( "names",    1 );
> 	$editlink = &GetParam( "editlink", 0 );
> 	
> 	foreach $pagelines (@_) {
> 		@links = ();
> 		
> 		foreach $page ( split( ' ', $pagelines ) ) {
> 			if ( $page =~ /\:/ ) {    # URL or InterWiki form
> 				if ( $page =~ /$UrlPattern/ ) {
> 					( $link, $extra ) = &UrlLink( $page, 0 );    # No images
> 				}
> 				else {
> 					( $link, $extra ) = &InterPageLink( $page, 0 );  # No images
> 				}
> 			}
> 			else {
> 				if ( $pgExists{$page} ) {
> 					$link = &GetPageLink($page);
> 				}
> 				else {
> 					$link = $page;
> 					if ($editlink) {
> 						$link .= &GetEditLink( $page, "?" );
> 					}
> 				}
> 			}
> 			
> 			push( @links, $link );
> 		}
> 		if ( !$names ) {
> 			shift(@links);
> 		}
> 		
> 		$text .= join(' ', @links) . "\n";
> 	}
> 	
> 	return $text;
> }
> 
3797,3849c5265,5336
<   my ($name, $unique, $sort, $exists, $empty, $link, $search);
<   my ($pagelink, $interlink, $urllink);
<   my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
< 
<   $unique = &GetParam("unique", 1);
<   $sort = &GetParam("sort", 1);
<   $pagelink = &GetParam("page", 1);
<   $interlink = &GetParam("inter", 0);
<   $urllink = &GetParam("url", 0);
<   $exists = &GetParam("exists", 2);
<   $empty = &GetParam("empty", 0);
<   $search = &GetParam("search", "");
<   if (($interlink == 2) || ($urllink == 2)) {
<     $pagelink = 0;
<   }
<   %pgExists = ();
<   @pglist = &AllPagesList();
<   foreach $name (@pglist) {
<     $pgExists{$name} = 1;
<   }
<   %seen = ();
<   foreach $name (@pglist) {
<     @newlinks = ();
<     if ($unique != 2) {
<       %seen = ();
<     }
<     @links = &GetPageLinks($name, $pagelink, $interlink, $urllink);
<     foreach $link (@links) {
<       $seen{$link}++;
<       if (($unique > 0) && ($seen{$link} != 1)) {
<         next;
<       }
<       if (($exists == 0) && ($pgExists{$link} == 1)) {
<         next;
<       }
<       if (($exists == 1) && ($pgExists{$link} != 1)) {
<         next;
<       }
<       if (($search ne "") && !($link =~ /$search/)) {
<         next;
<       }
<       push(@newlinks, $link);
<     }
<     @links = @newlinks;
<     if ($sort) {
<       @links = sort(@links);
<     }
<     unshift (@links, $name);
<     if ($empty || ($#links > 0)) {  # If only one item, list is empty.
<       push(@found, join(' ', @links));
<     }
<   }
<   return @found;
---
> 	my ($unique, $sort, $pagelink, $interlink, $urllink, $exists, $empty, $search, $listWantedPages )= @_ ;
> 	my ($name, $link ); # foreach iterators (though why not use $_ ?)
> 	#my ($name, $unique, $sort, $exists, $empty, $link, $search);
> 	#my ($pagelink, $interlink, $urllink);
> 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
> 	
> 	#$unique = &GetParam("unique", 1);
> 	#$sort = &GetParam("sort", 1);
> 	#$pagelink = &GetParam("page", 1);
> 	#$interlink = &GetParam("inter", 0);
> 	#$urllink = &GetParam("url", 0);
> 	#$exists = &GetParam("exists", 2);
> 	#$empty = &GetParam("empty", 0);
> 	#$search = &GetParam("search", "");
> 	
> 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) {
> 		$pagelink = 0;
> 	}
> 	%pgExists = ();
> 	@pglist   = &AllPagesList();
> 	
> 	foreach $name (@pglist) {
> 		$pgExists{$name} = 1;
> 	}
> 	%seen = ();
> 	
> 	foreach $name (@pglist) {
> 		@newlinks = ();
> 		if ( $unique != 2 ) {
> 			%seen = ();
> 		}
> 		
> 		@links = &GetPageLinks($name, $pagelink, $interlink, $urllink, $listWantedPages);
> 	
> 	    foreach $link (@links) {
> 			if ($link =~ m/^\//){
> 				$name =~ m/(.*)\//;
> 				
> 				if ($1){ $link = $1 . $link; }
> 				else { $link = $name . $link; }
> 			}
> 			
> 			$seen{$link}++;
> 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) {
> 				next;
> 			}
> 			
> 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) {
> 				next;
> 			}
> 			push( @newlinks, $link );
> 		}
> 		
> 		@links = @newlinks;
> 		if ($sort) {
> 			@links = sort(@links);
> 		}
> 		unshift( @links, $name );
> 		
> 		if ( $empty || ( $#links > 0 ) ) {    # If only one item, list is empty.
> 			push( @found, join( ' ', @links ) );
> 		}
> 	}
> 	return @found;
3851a5339,5369
> sub GetSubpages {
> 	my ($parentPage) = @_;
> 	my ($dir, @subpageFiles, @pages, $subId);
> 	
> 	return "" unless $parentPage;
> 	$dir = GetPageDirectory($parentPage);
> 	
> 	opendir(PAGELIST, "$PageDir/$dir/$parentPage") or return "";
> 	@subpageFiles = readdir(PAGELIST);
> 	closedir(PAGELIST);
> 	
> 	foreach $subId (@subpageFiles) {
> 		if (substr($subId, -3) eq '.db') {
> 		  push(@pages, "$parentPage/" . substr($subId, 0, -3));
> 		}
> 	}
> 	return @pages;
> }
> 
> sub GetPageList {
> 	my ($pagename, $retval);
> 	my (@list) = @_;
> 
> 	foreach $pagename (@list) {
> 	##	$retval .= ".... " if ($pagename =~ m|/|);
> 		$retval .= "&nbsp;" . &GetPageLink($pagename) . "<br>";
> 	}
> 
> 	return $retval;
> }
> 
3853,3886c5371,5415
<   my ($name, $pagelink, $interlink, $urllink) = @_;
<   my ($text, @links);
< 
<   @links = ();
<   &OpenPage($name);
<   &OpenDefaultText();
<   $text = $Text{'text'};
<   $text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
<   $text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
<   $text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
<   $text =~ s/<code>(.|\n)*?\<\/code>/ /ig;
<   if ($interlink) {
<     $text =~ s/''+/ /g;  # Quotes can adjacent to inter-site links
<     $text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
<   } else {
<     $text =~ s/$InterLinkPattern/ /g;
<   }
<   if ($urllink) {
<     $text =~ s/''+/ /g;  # Quotes can adjacent to URLs
<     $text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
<   } else {
<     $text =~ s/$UrlPattern/ /g;
<   }
<   if ($pagelink) {
<     if ($FreeLinks) {
<       my $fl = $FreeLinkPattern;
<       $text =~ s/\[\[$fl\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
<       $text =~ s/\[\[$fl\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
<     }
<     if ($WikiLinks) {
<       $text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
<     }
<   }
<   return @links;
---
> 	my ( $name, $pagelink, $interlink, $urllink, $listWantedPages ) = @_;
> 	my ( $text, @links );
> 	
> 	@links = ();
> 	&OpenPage($name);
> 	&OpenDefaultText();
> 	
> 	$text = $Text{'text'};
> 	$text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
> 	$text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
> 	$text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
> 	$text =~ s/<tt>(.|\n)*?\<\/tt>/ /ig;
> 	
> 	if ($interlink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to inter-site links
> 		$text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$InterLinkPattern/ /g;
> 	}
> 	
> 	if ($urllink) {
> 		$text =~ s/''+/ /g;    # Quotes can adjacent to URLs
> 		$text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 	}
> 	else {
> 		$text =~ s/$UrlPattern/ /g;
> 	}
> 	
> 	if ($pagelink) {
> 		if ($FreeLinks) {
> 			my $f2 = $FreeLinkPattern;
> 			
> 			$text =~ s/\[\[$f2\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 			$text =~ s/\[\[$f2\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
> 		}
> 		
> 		if ($listWantedPages){ $text =~ s/\[((.|\n)*?)\]/ /ig; }
> 			
> 		if ($WikiLinks) {
> 			$text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
> 		}
> 	}
> 	
> 	return @links;
3890,4006c5419,5574
<   my ($editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user);
<   my $string = &GetParam("text", undef);
<   my $id = &GetParam("title", "");
<   my $summary = &GetParam("summary", "");
<   my $oldtime = &GetParam("oldtime", "");
<   my $oldconflict = &GetParam("oldconflict", "");
<   my $isEdit = 0;
<   my $editTime = $Now;
<   my $authorAddr = $ENV{REMOTE_ADDR};
< 
<   if (!&UserCanEdit($id, 1)) {
<     # This is an internal interface--we don't need to explain
<     &ReportError(Ts('Editing not allowed for %s.', $id));
<     return;
<   }
<   if (($id eq   'SampleUndefinedPage')    ||
<       ($id eq T('SampleUndefinedPage'))   ||
<       ($id eq   'Sample_Undefined_Page')  ||
<       ($id eq T('Sample_Undefined_Page'))) {
<     &ReportError(Ts('%s cannot be defined.', $id));
<     return;
<   }
<   $string  = &RemoveFS($string);
<   $summary = &RemoveFS($summary);
<   $summary =~ s/[\r\n]//g;
<   if (length($summary) > 300) {  # Too long (longer than form allows)
<     $summary = substr($summary, 0, 300);
<   }
<   # Add a newline to the end of the string (if it doesn't have one)
<   $string .= "\n"  if (!($string =~ /\n$/));
<   # Lock before getting old page to prevent races
<   # Consider extracting lock section into sub, and eval-wrap it?
<   # (A few called routines can die, leaving locks.)
<   if ($LockCrash) {
<     &RequestLock() or die(T('Could not get editing lock'));
<   } else {
<     if (!&RequestLock()) {
<       &ForceReleaseLock('main');
<     }
<     # Clear all other locks.
<     &ForceReleaseLock('cache');
<     &ForceReleaseLock('diff');
<     &ForceReleaseLock('index');
<   }
<   &OpenPage($id);
<   &OpenDefaultText();
<   $old = $Text{'text'};
<   $oldrev = $Section{'revision'};
<   $pgtime = $Section{'ts'};
<   $preview = 0;
<   $preview = 1  if (&GetParam("Preview", "") ne "");
<   if (!$preview && ($old eq $string)) {  # No changes (ok for preview)
<     &ReleaseLock();
<     &ReBrowsePage($id, "", 1);
<     return;
<   }
<   if (($UserID > 399) || ($Section{'id'} > 399))  {
<     $newAuthor = ($UserID ne $Section{'id'});       # known user(s)
<   } else {
<     $newAuthor = ($Section{'ip'} ne $authorAddr);  # hostname fallback
<   }
<   $newAuthor = 1  if ($oldrev == 0);  # New page
<   $newAuthor = 0  if (!$newAuthor);   # Standard flag form, not empty
<   # Detect editing conflicts and resubmit edit
<   if (($oldrev > 0) && ($newAuthor && ($oldtime != $pgtime))) {
<     &ReleaseLock();
<     if ($oldconflict > 0) {  # Conflict again...
<       &DoEdit($id, 2, $pgtime, $string, $preview);
<     } else {
<       &DoEdit($id, 1, $pgtime, $string, $preview);
<     }
<     return;
<   }
<   if ($preview) {
<     &ReleaseLock();
<     &DoEdit($id, 0, $pgtime, $string, 1);
<     return;
<   }
<   $user = &GetParam("username", "");
<   # If the person doing editing chooses, send out email notification
<   if ($EmailNotify) {
<     &EmailNotify($id, $user) if &GetParam("do_email_notify", "") eq 'on';
<   }
<   if (&GetParam("recent_edit", "") eq 'on') {
<     $isEdit = 1;
<   }
<   if (!$isEdit) {
<     &SetPageCache('oldmajor', $Section{'revision'});
<   }
<   if ($newAuthor) {
<     &SetPageCache('oldauthor', $Section{'revision'});
<   }
<   &SaveKeepSection();
<   &ExpireKeepFile();
<   if ($UseDiff) {
<     &UpdateDiffs($id, $editTime, $old, $string, $isEdit, $newAuthor);
<   }
<   $Text{'text'} = $string;
<   $Text{'minor'} = $isEdit;
<   $Text{'newauthor'} = $newAuthor;
<   $Text{'summary'} = $summary;
<   $Section{'host'} = &GetRemoteHost(1);
<   &SaveDefaultText(); 
<   &SavePage();
<   &WriteRcLog($id, $summary, $isEdit, $editTime, $Section{'revision'},
<               $user, $Section{'host'});
<   if ($UseCache) {
<     &UnlinkHtmlCache($id);         # Old cached copy is invalid
<     if ($Page{'revision'} < 2) {   # If this is a new page...
<       &NewPageCacheClear($id);     # ...uncache pages linked to this one.
<     }
<   }
<   if ($UseIndex && ($Page{'revision'} == 1)) {
<     unlink($IndexFile);  # Regenerate index on next request
<   }
<   &ReleaseLock();
<   &ReBrowsePage($id, "", 1);
---
> 	my ( $editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user );
> 	my $string      = &GetParam( "text",        undef );
> 	my $id          = &GetParam( "title",       "" );
> 	my $summary     = &GetParam( "summary",     "" );
> 	my $oldtime     = &GetParam( "oldtime",     "" );
> 	my $oldconflict = &GetParam( "oldconflict", "" );
> 	my $isEdit      = 0;
> 	my $editTime    = $Now;
> 	my $authorAddr  = $ENV{REMOTE_ADDR};
> 	
> 	if ($id =~ /($LinkPattern)/){
> 		$id = $1;
> 	}
> 	else {
> 		die "The page name $id is not valid";
> 	}
> 	
> 	if ($FreeLinks){
> 		$id = &FreeToNormal($id);
> 	}
> 	
> 	if ( !&UserCanEdit( $id, 1 ) ) {
> 		# This is an internal interface--we don't need to explain
> 		&ReportError( Ts( 'Editing not allowed for %s.', $id ) );
> 		return;
> 	}
> 	
> 	if (   ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'SampleUndefinedPage' )
> 		|| ( $id eq 'Sample_Undefined_Page' )
> 		|| ( $id eq 'Sample_Undefined_Page' ) )
> 	{
> 		&ReportError( " $id cannot be defined." );
> 		return;
> 	}
> 	
> 	$string  = &RemoveFS($string);
> 	$summary = &RemoveFS($summary);
> 	$summary =~ s/[\r\n]//g;
> 	
> 	if ( length($summary) > 300 ) {    # Too long (longer than form allows)
> 		$summary = substr( $summary, 0, 300 );
> 	}
> 
> 	# Add a newline to the end of the string (if it doesn't have one)
> 	$string .= "\n" if ( !( $string =~ /\n$/ ) );
> 
> 
> 	# Lock before getting old page to prevent races
> 	# Consider extracting lock section into sub, and eval-wrap it?
> 	# (A few called routines can die, leaving locks.)
> 	if ($LockCrash) {
> 		&RequestLock() or die( "Could not get editing lock" );
> 	}
> 	else {
> 		if ( !&RequestLock() ) {
> 			&ForceReleaseLock('main');
> 		}
> 
> 		# Clear all other locks.
> 		&ForceReleaseLock('cache');
> 		&ForceReleaseLock('diff');
> 		&ForceReleaseLock('index');
> 	}
> 	
> 	&OpenPage($id);
> 	&OpenDefaultText();
> 	$old     = $Text{'text'};
> 	$oldrev  = $Section{'revision'};
> 	$pgtime  = $Section{'ts'};
> 	$preview = 0;
> 	$preview = 1 if ( &GetParam( "Preview", "" ) ne "" );
> 	
> 	if ( !$preview && ( $old eq $string ) ) {    # No changes (ok for preview)
> 		&ReleaseLock();
> 		&ReBrowsePage( $id, "", 1 );
> 		return;
> 	}
> 	
> 	if ( ( $UserID > 399 ) || ( $Section{'id'} > 399 ) ) {
> 		$newAuthor = ( $UserID ne $Section{'id'} );    # known user(s)
> 	}
> 	else {
> 		$newAuthor = ( $Section{'ip'} ne $authorAddr );    # hostname fallback
> 	}
> 	$newAuthor = 1 if ( $oldrev == 0 );    # New page
> 	$newAuthor = 0 if ( !$newAuthor );     # Standard flag form, not empty
> 	                                       # Detect editing conflicts and resubmit edit
> 	                                       
> 	if ( ( $oldrev > 0 ) && ( $newAuthor && ( $oldtime != $pgtime ) ) ) {
> 		&ReleaseLock();
> 		if ( $oldconflict > 0 ) {    # Conflict again...
> 			&DoEdit( $id, 2, $pgtime, $string, $preview );
> 		}
> 		else {
> 			&DoEdit( $id, 1, $pgtime, $string, $preview );
> 		}
> 		return;
> 	}
> 	
> 	if ($preview) {
> 		&ReleaseLock();
> 		&DoEdit( $id, 0, $pgtime, $string, 1 );
> 		return;
> 	}
> 	
> 	$user = &GetParam( "username", "" );
> 
> 	# If the person doing editing chooses, send out email notification
> 	if ($EmailNotify) {
> 		&EmailNotify( $id, $user )
> 		  if &GetParam( "do_email_notify", "" ) eq 'on';
> 	}
> 	
> 	if ( &GetParam( "recent_edit", "" ) eq 'on' ) {
> 		$isEdit = 1;
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'oldmajor', $Section{'revision'} );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'oldauthor', $Section{'revision'} );
> 	}
> 	
> 	&SaveKeepSection();
> 	&ExpireKeepFile();
> 	
> 	if ($UseDiff) {
> 		&UpdateDiffs( $id, $editTime, $old, $string, $isEdit, $newAuthor );
> 	}
> 	
> 	$Text{'text'}      = $string;
> 	$Text{'minor'}     = $isEdit;
> 	$Text{'newauthor'} = $newAuthor;
> 	$Text{'summary'}   = $summary;
> 	$Section{'host'}   = &GetRemoteHost(1);
> 	
> 	&SaveDefaultText();
> 	&SavePage();
> 	&WriteRcLog( $id, $summary, $isEdit, $editTime, $Section{'revision'}, $user,
> 		$Section{'host'} );
> 
> 	if ($UseCache) {
> 		&UnlinkHtmlCache($id);    # Old cached copy is invalid
> 		if ( $Page{'revision'} < 2 ) {    # If this is a new page...
> 			&NewPageCacheClear($id);      # ...uncache pages linked to this one.
> 		}
> 	}
> 	
> 	if ( $UseIndex && ( $Page{'revision'} == 1 ) ) {
> 		unlink($IndexFile);               # Regenerate index on next request
> 	}
> 	&ReleaseLock();
> 	&ReBrowsePage( $id, "", 1 );
4010,4034c5578,5612
<   my ($id, $editTime, $old, $new, $isEdit, $newAuthor) = @_;
<   my ($editDiff, $oldMajor, $oldAuthor);
< 
<   $editDiff  = &GetDiff($old, $new, 0);     # 0 = already in lock
<   $oldMajor  = &GetPageCache('oldmajor');
<   $oldAuthor = &GetPageCache('oldauthor');
<   if ($UseDiffLog) {
<     &WriteDiff($id, $editTime, $editDiff);
<   }
<   &SetPageCache('diff_default_minor', $editDiff);
<   if ($isEdit || !$newAuthor) {
<     &OpenKeptRevisions('text_default');
<   }
<   if (!$isEdit) {
<     &SetPageCache('diff_default_major', "1");
<   } else {
<     &SetPageCache('diff_default_major', &GetKeptDiff($new, $oldMajor, 0));
<   }
<   if ($newAuthor) {
<     &SetPageCache('diff_default_author', "1");
<   } elsif ($oldMajor == $oldAuthor) {
<     &SetPageCache('diff_default_author', "2");
<   } else {
<     &SetPageCache('diff_default_author', &GetKeptDiff($new, $oldAuthor, 0));
<   }
---
> 	my ( $id, $editTime, $old, $new, $isEdit, $newAuthor ) = @_;
> 	my ( $editDiff, $oldMajor, $oldAuthor );
> 	
> 	$editDiff  = &GetDiff( $old, $new, 0 );    # 0 = already in lock
> 	$oldMajor  = &GetPageCache('oldmajor');
> 	$oldAuthor = &GetPageCache('oldauthor');
> 	
> 	if ($UseDiffLog) {
>   		my $editDiff = Diff::diffClassic($old, $new);  # add this line
>   		&WriteDiff($id, $editTime, $editDiff);
> 	}
> 	
> 	&SetPageCache( 'diff_default_minor', $editDiff );
> 	if ( $isEdit || !$newAuthor ) {
> 		&OpenKeptRevisions('text_default');
> 	}
> 	
> 	if ( !$isEdit ) {
> 		&SetPageCache( 'diff_default_major', "1" );
> 	}	
> 	else {
> 		&SetPageCache( 'diff_default_major',
> 			&GetKeptDiff( $new, $oldMajor, 0 ) );
> 	}
> 	
> 	if ($newAuthor) {
> 		&SetPageCache( 'diff_default_author', "1" );
> 	}	
> 	elsif ( $oldMajor == $oldAuthor ) {
> 		&SetPageCache( 'diff_default_author', "2" );
> 	}
> 	else {
> 		&SetPageCache( 'diff_default_author',
> 			&GetKeptDiff( $new, $oldAuthor, 0 ) );
> 	}
4040,4054c5618,5630
<   my ($to, $from, $reply, $subject, $message) = @_;
< 
<   # sendmail options:
<   #    -odq : send mail to queue (i.e. later when convenient)
<   #    -oi  : do not wait for "." line to exit
<   #    -t   : headers determine recipient.
<   open (SENDMAIL, "| $SendMail -oi -t ") or die "Can't send email: $!\n";
<   print SENDMAIL <<"EOF";
< From: $from
< To: $to
< Reply-to: $reply
< Subject: $subject\n
< $message
< EOF
<   close(SENDMAIL) or warn "sendmail didn't close nicely";
---
> 	my ( $to, $from, $reply, $subject, $message ) = @_;
> 
> 	# sendmail options:
> 	#    -odq : send mail to queue (i.e. later when convenient)
> 	#    -oi  : do not wait for "." line to exit
> 	#    -t   : headers determine recipient.
> 	open( SENDMAIL, "| $SendMail -oi -t " ) or die "Can't send email: $!\n";
> 	print SENDMAIL "From: $from\n";
> 	print SENDMAIL "To: $to\n";
> 	print SENDMAIL "Reply-to: $reply\n";
> 	print SENDMAIL "Subject: $subject\n";
> 	print SENDMAIL "$message\n";
> 	close(SENDMAIL) or warn "sendmail didn't close nicely";
4059,4082c5634,5664
<   local $/ = "\n";   # don't slurp whole files in this sub.
< 
<   if ($EmailNotify) {
<     my ($id, $user) = @_;
<     if ($user) {
<       $user = " by $user";
<     }
<     my $address;
<     return  if (!-f $EmailFile);  # No notifications yet
<     open(EMAIL, $EmailFile)
<       or die "Can't open $EmailFile: $!\n";
<     $address = join ",", <EMAIL>;
<     $address =~ s/\n//g;
<     close(EMAIL);
<     my $home_url = $q->url();
<     my $page_url = $home_url . "?$id";
<     my $editors_summary = $q->param("summary");
<     if (($editors_summary eq "*") or ($editors_summary eq "")){
<       $editors_summary = "";
<     }
<     else {
<       $editors_summary = "\n Summary: $editors_summary";
<     }
<     my $content = <<"END_MAIL_CONTENT";
---
> 	local $/ = "\n";    # don't slurp whole files in this sub.
> 	
> 	if ($EmailNotify) {
> 		my ( $id, $user ) = @_;
> 		
> 		if ($user) {
> 			$user = " by $user";
> 		}
> 		
> 		my $address;
> 		
> 		return if ( !-f $EmailFile );    # No notifications yet
> 		
> 		open( EMAIL, $EmailFile )
> 		  or die "Can't open $EmailFile: $!\n";
> 		$address = join ",", <EMAIL>;
> 		$address =~ s/\n//g;
> 		close(EMAIL);
> 		
> 		my $home_url        = $q->url();
> 		my $page_url        = $home_url . "?$id";
> 		my $editors_summary = $q->param("summary");
> 
> 		if ( ( $editors_summary eq "*" ) or ( $editors_summary eq "" ) ) {
> 			$editors_summary = "";
> 		}
> 		else {
> 			$editors_summary = " Summary: $editors_summary";
> 		}
> 		
> 		my $content = <<"END_MAIL_CONTENT";
4095,4100c5677,5683
<     my $subject = "The $id page at $SiteName has been changed.";
<     # I'm setting the "reply-to" field to be the same as the "to:" field
<     # which seems appropriate for a mailing list, especially since the
<     # $EmailFrom string needn't be a real email address.
<     &SendEmail($address, $EmailFrom, $address, $subject, $content);
<   }
---
> 		my $subject = "The $id page at $SiteName has been changed.";
> 
> 		# I'm setting the "reply-to" field to be the same as the "to:" field
> 		# which seems appropriate for a mailing list, especially since the
> 		# $EmailFrom string needn't be a real email address.
> 		&SendEmail( $address, $EmailFrom, $address, $subject, $content );
> 	}
4104,4120c5687,5741
<   my ($string) = @_;
<   my ($name, $freeName, @found);
< 
<   foreach $name (&AllPagesList()) {
<     &OpenPage($name);
<     &OpenDefaultText();
<     if (($Text{'text'} =~ /$string/i) || ($name =~ /$string/i)) {
<       push(@found, $name);
<     } elsif ($FreeLinks && ($name =~ m/_/)) {
<       $freeName = $name;
<       $freeName =~ s/_/ /g;
<       if ($freeName =~ /$string/i) {
<         push(@found, $name);
<       }
<     }
<   }
<   return @found;
---
> 	my ($term, $filter) = @_;
> 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
> 	
> 	#If the search term has a !preceding it, strip it and set the exclusion flag
> 	if ($term =~ m/^\!/){ 
> 		$excludeTerm = 1;
> 		$term = substr($term, 1);	
> 	}
> 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
> 	if ($filter =~ m/^\!/){ 
> 		$excludeFilter = 1;
> 		$filter = substr($filter, 1);	
> 	}
> 
> 	foreach $name ( &AllPagesList() ) {
> 		if ($excludeFilter){
> 			if ($filter) { next if ($name =~ m/$filter/); }
> 		}
> 		else {
> 			if ($filter) { next unless ($name =~ m/$filter/); }
> 
> 		}
> 		
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if (!$excludeTerm){  
> 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( $freeName =~ /$term/i ) {
> 					push( @found, $name );
> 				}
> 			}
> 		}
> 		else { 
> 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( ! ($freeName =~ /$term/i) ) {
> 					push( @found, $name );
> 				}
> 			}			
> 		}
> 	}
> 	
> 	return @found;
4124,4134c5745,5757
<   my ($string) = @_;
<   my ($name, @found);
< 
<   foreach $name (&AllPagesList()) {
<     &OpenPage($name);
<     &OpenDefaultText();
<     if ($Text{'text'} =~ /$string/i){
<       push(@found, $name);
<     }
<   }
<   return @found;
---
> 	my ($string) = @_;
> 	my ( $name, @found );
> 	
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		if ( $Text{'text'} =~ /$string/i ) {
> 			push( @found, $name );
> 		}
> 	}
> 	
> 	return @found;
4138,4144c5761,5768
<   my ($id) = @_;
<   my $idFile;
< 
<   $idFile = &GetHtmlCacheFile($id);
<   if (-f $idFile) {
<     unlink($idFile);
<   }
---
> 	my ($id) = @_;
> 	my $idFile;
> 	
> 	$idFile = &GetHtmlCacheFile($id);
> 	
> 	if ( -f $idFile ) {
> 		unlink($idFile);
> 	}
4148,4156c5772,5781
<   my ($id) = @_;
<   my $name;
< 
<   return if (!$UseCache);
<   $id =~ s|.+/|/|;  # If subpage, search for just the subpage
<   # The following code used to search the body for the $id
<   foreach $name (&AllPagesList()) {  # Remove all to be safe
<     &UnlinkHtmlCache($name);
<   }
---
> 	my ($id) = @_;
> 	my $name;
> 	
> 	return if ( !$UseCache );
> 	
> 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
> 	                    # The following code used to search the body for the $id
> 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
> 		&UnlinkHtmlCache($name);
> 	}
4161,4172c5786,5804
<   my $LockMessage = T('Normal Unlock.');
< 
<   print &GetHeader('', T('Removing edit lock'), '');
<   print '<p>', T('This operation may take several seconds...'), "\n";
<   if (&ForceReleaseLock('main')) {
<     $LockMessage = T('Forced Unlock.');
<   }
<   &ForceReleaseLock('cache');
<   &ForceReleaseLock('diff');
<   &ForceReleaseLock('index');
<   print "<br><h2>$LockMessage</h2>";
<   print &GetCommonFooter();
---
> 	my $LockMessage = "Normal Unlock.";
> 	
> 	print &GetHeader( "", "Removing edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>This operation may take several seconds...</h2>\n";
> 	
> 	if ( &ForceReleaseLock('main') ) {
> 		$LockMessage = "Forced Unlock.";
> 	}
> 	
> 	&ForceReleaseLock('cache');
> 	&ForceReleaseLock('diff');
> 	&ForceReleaseLock('index');
> 	
> 	print "\n<br><h2>$LockMessage</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4177,4192c5809,5826
<   my ($id, $summary, $isEdit, $editTime, $revision, $name, $rhost) = @_;
<   my ($extraTemp, %extra);
< 
<   %extra = ();
<   $extra{'id'} = $UserID          if ($UserID > 0);
<   $extra{'name'} = $name          if ($name ne "");
<   $extra{'revision'} = $revision  if ($revision ne "");
<   $extraTemp = join($FS2, %extra);
<   # The two fields at the end of a line are kind and extension-hash
<   my $rc_line = join($FS3, $editTime, $id, $summary,
<                      $isEdit, $rhost, "0", $extraTemp);
<   if (!open(OUT, ">>$RcFile")) {
<     die(Ts('%s log error:', $RCName) . " $!");
<   }
<   print OUT  $rc_line . "\n";
<   close(OUT);
---
> 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
> 	my ( $extraTemp, %extra );
> 	
> 	%extra = ();
> 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
> 	$extra{'name'}     = $name     if ( $name ne "" );
> 	$extra{'revision'} = $revision if ( $revision ne "" );
> 	$extraTemp = join( $FS2, %extra );
> 
> 	# The two fields at the end of a line are kind and extension-hash
> 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
> 	
> 	if ( !open( OUT, ">>$RcFile" ) ) {
> 		die( Ts( '%s log error:', $RCName ) . " $!" );
> 	}
> 	
> 	print OUT $rc_line . "\n";
> 	close(OUT);
4196,4201c5830,5835
<   my ($id, $editTime, $diffString) = @_;
< 
<   open (OUT, ">>$DataDir/diff_log") or die(T('can not write diff_log'));
<   print OUT  "------\n" . $id . "|" . $editTime . "\n";
<   print OUT  $diffString;
<   close(OUT);
---
> 	my ( $id, $editTime, $diffString ) = @_;
> 	
> 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
> 	print OUT "------\n" . $id . "|" . $editTime . "\n";
> 	print OUT $diffString;
> 	close(OUT);
4211,4234c5845,5873
<   my ($expirets);
< 
<   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
<   return (0, T('(done)'))  unless $Page{'ts'} < $expirets;
<   if ($DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o) {
<     &DeletePage($OpenPageName, 1, 1);
<     return (1, T('(deleted)'));
<   }
<   if ($ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o) {
<     my $fname = $1;
<     # Only replace an allowed, existing file.
<     if ((grep {$_ eq $fname} @ReplaceableFiles) && -e $fname) {
<        if ($Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims)
<        {
<          my $string = $1;
<          $string =~ s/\r\n/\n/gms;
<          open (OUT, ">$fname") or return 0;
<          print OUT $string;
<          close OUT;
<          return (0, T('(replaced)'));
<       }
<     }
<   }
<   return (0, T('(done)'));
---
> 	my ($expirets);
> 	
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
> 	
> 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
> 	
> 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
> 		&DeletePage( $OpenPageName, 1, 1 );
> 		return ( 1, "(deleted)" );
> 	}
> 	
> 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
> 		my $fname = $1;
> 
> 		# Only replace an allowed, existing file.
> 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
> 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
> 				my $string = $1;
> 				
> 				$string =~ s/\r\n/\n/gms;
> 				open( OUT, ">$fname" ) or return 0;
> 				print OUT $string;
> 				close OUT;
> 				
> 				return ( 0, "(replaced)" );
> 			}
> 		}
> 	}
> 	return ( 0, "(done)" );
4238,4278c5877,5934
<   my ($name, $fname, $data, $message, $status);
<   print &GetHeader('', T('Maintenance on all pages'), '');
<   print "<br>";
<   $fname = "$DataDir/maintain";
<   if (!&UserIsAdmin()) {
<     if ((-f $fname) && ((-M $fname) < 0.5)) {
<       print T('Maintenance not done.'), ' ';
<       print T('(Maintenance can only be done once every 12 hours.)');
<       print ' ', T('Remove the "maintain" file or wait.');
<       print &GetCommonFooter();
<       return;
<     }
<   }
<   &RequestLock() or die(T('Could not get maintain-lock'));
<   foreach $name (&AllPagesList()) {
<     &OpenPage($name);
<     &OpenDefaultText();
<     ($status, $message) = &ProcessVetos();
<     &ExpireKeepFile() unless $status;
<     print ".... "  if ($name =~ m|/|);
<     print &GetPageLink($name);
<     print " $message<br>\n";
<   }
<   &WriteStringToFile($fname, Ts('Maintenance done at %s', &TimeToText($Now)));
<   &ReleaseLock();
<   # Do any rename/deletion commands
<   # (Must be outside lock because it will grab its own lock)
<   $fname = "$DataDir/editlinks";
<   if (-f $fname) {
<     $data = &ReadFileOrDie($fname);
<     print '<hr>', T('Processing rename/delete commands:'), "<br>\n";
<     &UpdateLinksList($data, 1, 1);  # Always update RC and links
<     unlink("$fname.old");
<     rename($fname, "$fname.old");
<   }
<   if ($MaintTrimRc) {
<     &RequestLock() or die(T('Could not get lock for RC maintenance'));
<     $status = &TrimRc();  # Consider error messages?
<     &ReleaseLock();
<   }
<   print &GetCommonFooter();
---
> 	my ( $name, $fname, $data, $message, $status );
> 	
> 	print &GetHeader( "", "Maintenance on all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	$fname = "$DataDir/maintain";
> 	
> 	if ( !&UserIsAdmin() ) {
> 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
> 			print "\nMaintenance not done. ";
> 			print "\n(Maintenance can only be done once every 12 hours.)";
> 			print "\nRemove the 'maintain' file or wait.";
> 			print "\n</div>";
> 			print &GetCommonFooter();
> 			print "\n</div></div></div></div></body></html>";
> 			
> 			return;
> 		}
> 	}
> 	
> 	&RequestLock() or die( "Could not get maintain-lock" );
> 
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		( $status, $message ) = &ProcessVetos();
> 		&ExpireKeepFile() unless $status;
> 		
> 		print "\n.... " if ( $name =~ m|/| );
> 		print &GetPageLink($name);
> 		print "\n $message<br>";
> 	}
> 
> 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
> 	&ReleaseLock();
> 
> 	# Do any rename/deletion commands
> 	# (Must be outside lock because it will grab its own lock)
> 	$fname = "$DataDir/editlinks";
> 	
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		print "\n<hr>Processing rename/delete commands:<br>";
> 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
> 		unlink("$fname.old");
> 		rename( $fname, "$fname.old" );
> 	}
> 	
> 	if ($MaintTrimRc) {
> 		&RequestLock() or die( "Could not get lock for RC maintenance" );
> 		$status = &TrimRc();                # Consider error messages?
> 		&ReleaseLock();
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4284,4321c5940,5983
<   my (@rc, @temp, $starttime, $days, $status, $data, $i, $ts);
< 
<   # Determine the number of days to go back
<   $days = 0;
<   foreach (@RcDays) {
<     $days = $_  if $_ > $days;
<   }
<   $starttime = $Now - $days * 24 * 60 * 60;
<   return 1  if (!-f $RcFile);  # No work if no file exists
<   ($status, $data) = &ReadFile($RcFile);
<   if (!$status) {
<     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
<           . ":</strong> $RcFile<p>"
<           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
<     return 0;
<   }
<   # Move the old stuff from rc to temp
<   @rc = split(/\n/, $data);
<   for ($i = 0; $i < @rc; $i++) {
<     ($ts) = split(/$FS3/, $rc[$i]);
<     last  if ($ts >= $starttime);
<   }
<   return 1  if ($i < 1);  # No lines to move from new to old
<   @temp = splice(@rc, 0, $i);
<   # Write new files and backups
<   if (!open(OUT, ">>$RcOldFile")) {
<     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
<           . ":</strong> $RcOldFile<p>"
<           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
<     return 0;
<   }
<   print OUT  join("\n", @temp) . "\n";
<   close(OUT);
<   &WriteStringToFile($RcFile . '.old', $data);
<   $data = join("\n", @rc);
<   $data .= "\n"  if ($data ne '');  # If no entries, don't add blank line
<   &WriteStringToFile($RcFile, $data);
<   return 1;
---
> 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
> 
> 	# Determine the number of days to go back
> 	$days = 0;
> 	
> 	foreach (@RcDays) {
> 		$days = $_ if $_ > $days;
> 	}
> 	$starttime = $Now - $days * 24 * 60 * 60;
> 	return 1 if ( !-f $RcFile );    # No work if no file exists
> 	( $status, $data ) = &ReadFile($RcFile);
> 	
> 	if ( !$status ) {
> 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
> 		
> 		return 0;
> 	}
> 
> 	# Move the old stuff from rc to temp
> 	@rc = split( /\n/, $data );
> 	
> 	for ( $i = 0 ; $i < @rc ; $i++ ) {
> 		($ts) = split( /$FS3/, $rc[$i] );
> 		last if ( $ts >= $starttime );
> 	}
> 	
> 	return 1 if ( $i < 1 );    # No lines to move from new to old
> 	
> 	@temp = splice( @rc, 0, $i );
> 
> 	# Write new files and backups
> 	if ( !open( OUT, ">>$RcOldFile" ) ) {
> 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
> 		return 0;
> 	}
> 	print OUT join( "\n", @temp ) . "\n";
> 	close(OUT);
> 	
> 	&WriteStringToFile( $RcFile . '.old', $data );
> 	$data = join( "\n", @rc );
> 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
> 	&WriteStringToFile( $RcFile, $data );
> 	
> 	return 1;
4325,4334c5987,6004
<   print &GetHeader('', T('Maintaining RC log'), '');
<   return  if (!&UserIsAdminOrError());
<   &RequestLock() or die(T('Could not get lock for RC maintenance'));
<   if (&TrimRc()) {
<     print '<br>' . T('RC maintenance done.') . '<br>';
<   } else {
<     print '<br>' . T('RC maintenance not done.') . '<br>';
<   }
<   &ReleaseLock();
<   print &GetCommonFooter();
---
> 	print &GetHeader( "", "Maintaining RC log", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	&RequestLock() or die( "Could not get lock for RC maintenance" );
> 	
> 	if ( &TrimRc() ) {
> 		print "\n<br>RC maintenance done.<br>";
> 	}
> 	else {
> 		print "\n<br>RC maintenance not done.<br>";
> 	}
> 	&ReleaseLock();
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4338,4343c6008,6017
<   if (!&UserIsEditor()) {
<     print '<p>', T('This operation is restricted to site editors only...');
<     print &GetCommonFooter();
<     return 0;
<   }
<   return 1;
---
> 	if ( !&UserIsEditor() ) {
> 		print "\n<h2>This operation is restricted to site editors only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></body></html>";
> 			
> 		return 0;
> 	}
> 	
> 	return 1;
4347,4352c6021,6029
<   if (!&UserIsAdmin()) {
<     print '<p>', T('This operation is restricted to administrators only...');
<     print &GetCommonFooter();
<     return 0;
<   }
<   return 1;
---
> 	if ( !&UserIsAdmin() ) {
> 		print "\n<h2>This operation is restricted to administrators only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></body></html>";	
> 		return 0;
> 	}
> 	
> 	return 1;
4354a6032,6079
> sub CheckIsAuthUser {
> 	my ($id) = @_;
> 	my $auth = ""; 
> 	my $found = 0;
> 	my $authtype;
> 	my $authname; 
> 	my $aname;
> 	my $afname;
> 	my $linecount = 0;
> 
> 	if (!(&UserIsAdmin())) {
> 		$aname = $id;
> 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
> 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
> 		
> 		if (-r $afname) {			
> 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
> 			
> 			open (AFN,"<$afname");
> 			while (<AFN>) {
> 				if (/$FS1/) { next; }       	# skip header and footer
> 				if (/^>\s[^\w]/) { next; }  	# skip comments	
> 				if (/diff-/){ next; }		
> 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
> 					$authtype = $1;
> 					$authname = $2; 
> 					
> 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
> 					elsif ($authtype eq "r"){ $authtype = "1"; }
> 					else { $authtype = "1"; }
> 					
> 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
> 				}
> 			}
> 			close AFN;
> 			if ($linecount == 0){ $auth = "3"; }
> 			elsif ($found == 0) { $auth = ""; }
> 		}
> 		else {
> 			$auth = "3";
> 		}
> 	}
> 	else {
> 		$auth = "3";
> 	}
> 	return $auth;
> }
> 
4356,4371c6081,6106
<   my ($fname);
< 
<   print &GetHeader('', T('Set or Remove global edit lock'), '');
<   return  if (!&UserIsAdminOrError());
<   $fname = "$DataDir/noedit";
<   if (&GetParam("set", 1)) {
<     &WriteStringToFile($fname, "editing locked.");
<   } else {
<     unlink($fname);
<   }
<   if (-f $fname) {
<     print '<p>', T('Edit lock created.'), '<br>';
<   } else {
<     print '<p>', T('Edit lock removed.'), '<br>';
<   }
<   print &GetCommonFooter();
---
> 	my ($fname);
> 	
> 	print &GetHeader( "", "Set or Remove global edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	$fname = "$DataDir/noedit";
> 
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 	
> 	if ( -f $fname ) {
> 		print "\n<h2>Edit lock created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Edit lock removed.</h2>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4375,4397c6110,6144
<   my ($fname, $id);
< 
<   print &GetHeader('', T('Set or Remove page edit lock'), '');
<   # Consider allowing page lock/unlock at editor level?
<   return  if (!&UserIsAdminOrError());
<   $id = &GetParam("id", "");
<   if ($id eq "") {
<     print '<p>', T('Missing page id to lock/unlock...');
<     return;
<   }
<   return  if (!&ValidIdOrDie($id));       # Consider nicer error?
<   $fname = &GetLockedPageFile($id);
<   if (&GetParam("set", 1)) {
<     &WriteStringToFile($fname, "editing locked.");
<   } else {
<     unlink($fname);
<   }
<   if (-f $fname) {
<     print '<p>', Ts('Lock for %s created.', $id), '<br>';
<   } else {
<     print '<p>', Ts('Lock for %s removed.', $id), '<br>';
<   }
<   print &GetCommonFooter();
---
> 	my ( $fname, $id );
> 	
> 	print &GetHeader( "", "Set or Remove page edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	# Consider allowing page lock/unlock at editor level?
> 	return if ( !&UserIsAdminOrError() );
> 		
> 	$id = &GetParam( "id", "" );
> 	if ( $id eq "" ) {
> 		print "\n<p>Missing page id to lock/unlock...</p>";
> 		
> 		return;
> 	}
> 	
> 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
> 	$fname = &GetLockedPageFile($id);
> 	
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 
> 	if ( -f $fname ) {
> 		print "\n<h2>Lock for '$id' created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Lock for '$id' removed.</h2>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4401,4426c6148,6178
<   my ($banList, $status);
< 
<   print &GetHeader("", "Editing Banned list", "");
<   return  if (!&UserIsAdminOrError());
<   ($status, $banList) = &ReadFile("$DataDir/banlist");
<   $banList = ""  if (!$status);
<   print &GetFormStart();
<   print GetHiddenValue("edit_ban", 1), "\n";
<   print "<b>Banned IP/network/host list:</b><br>\n";
<   print "<p>Each entry is either a commented line (starting with #), ",
<         "or a Perl regular expression (matching either an IP address or ",
<         "a hostname).  <b>Note:</b> To test the ban on yourself, you must ",
<         "give up your admin access (remove password in Preferences).";
<   print "<p>Example:<br>",
<         "# blocks hosts ending with .foocorp.com<br>",
<         "\\.foocorp\\.com\$<br>",
<         "# blocks exact IP address<br>",
<         "^123\\.21\\.3\\.9\$<br>",
<         "# blocks whole 123.21.3.* IP network<br>",
<         "^123\\.21\\.3\\.\\d+\$<p>";
<   print &GetTextArea('banlist', $banList, 12, 50);
<   print "<br>", $q->submit(-name=>'Save'), "\n";
<   print "<hr class=wikilinefooter>\n";
<   print &GetGotoBar("");
<   print $q->endform;
<   print &GetMinimumFooter();
---
> 	my ( $banList, $status );
> 	
> 	print &GetHeader( "", "Editing Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	return if ( !&UserIsAdminOrError() );
> 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
> 	$banList = "" if ( !$status );
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_ban", 1 );
> 	print "\n<h2> Banned IP/network/host list:</h2>";
> 	print "\nEach entry is either a commented line (starting with #), ";
> 	print "\nor a Perl regular expression (matching either an IP address or ";
> 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
> 	print "\ngive up your admin access (remove password in Preferences).";
> 	print "\n<p><br><b>Example:</b><br><br>";
> 	print "\n# blocks hosts ending with .foocorp.com<br>";
> 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
> 	print "\n# blocks exact IP address<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
> 	print "\n# blocks whole 123.21.3.* IP network<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
> 	print &GetTextArea( 'banlist', $banList, 12, 50 );
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Save' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	;
4430,4446c6182,6206
<   my ($newList, $fname);
< 
<   print &GetHeader("", "Updating Banned list", "");
<   return  if (!&UserIsAdminOrError());
<   $fname = "$DataDir/banlist";
<   $newList = &GetParam("banlist", "#Empty file");
<   if ($newList eq "") {
<     print "<p>Empty banned list or error.";
<     print "<p>Resubmit with at least one space character to remove.";
<   } elsif ($newList =~ /^\s*$/s) {
<     unlink($fname);
<     print "<p>Removed banned list";
<   } else {
<     &WriteStringToFile($fname, $newList);
<     print "<p>Updated banned list";
<   }
<   print &GetCommonFooter();
---
> 	my ( $newList, $fname );
> 	
> 	print &GetHeader( "", "Updating Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$fname = "$DataDir/banlist";
> 	$newList = &GetParam( "banlist", "#Empty file" );
> 	
> 	if ( $newList eq "" ) {
> 		print "\n<p>Empty banned list or error.</p>";
> 		print "\n<p>Resubmit with at least one space character to remove.</p>";
> 	}
> 	elsif ( $newList =~ /^\s*$/s ) {
> 		unlink($fname);
> 		print "\n<p>Removed banned list</p>";
> 	}
> 	else {
> 		&WriteStringToFile( $fname, $newList );
> 		print "\n<p>Updated banned list</p>";
> 	}
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4451,4478c6211,6252
<   print &GetHeader("", "Editing Links", "");
<   if ($AdminDelete) {
<     return  if (!&UserIsAdminOrError());
<   } else {
<     return  if (!&UserIsEditorOrError());
<   }
<   print &GetFormStart();
<   print GetHiddenValue("edit_links", 1), "\n";
<   print "<b>Editing/Deleting page titles:</b><br>\n";
<   print "<p>Enter one command on each line.  Commands are:<br>",
<         "<tt>!PageName</tt> -- deletes the page called PageName<br>\n",
<         "<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName ",
<         "to NewPageName and updates links to OldPageName.<br>\n",
<         "<tt>|OldPageName|NewPageName</tt> -- Changes links to OldPageName ",
<         "to NewPageName.",
<         " (Used to rename links to non-existing pages.)<br>\n",
<         "<b>Note: page names are case-sensitive!</b>\n";
<   print &GetTextArea('commandlist', "", 12, 50);
<   print $q->checkbox(-name=>"p_changerc", -override=>1, -checked=>1,
<                       -label=>"Edit $RCName");
<   print "<br>\n";
<   print $q->checkbox(-name=>"p_changetext", -override=>1, -checked=>1,
<                       -label=>"Substitute text for rename");
<   print "<br>", $q->submit(-name=>'Edit'), "\n";
<   print "<hr class=wikilinefooter>\n";
<   print &GetGotoBar("");
<   print $q->endform;
<   print &GetMinimumFooter();
---
> 	print &GetHeader( "", "Editing Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_links", 1 );
> 	print "\n<h2>Editing/Deleting page titles:</h2>";
> 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
> 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
> 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
> 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
> 	print &GetTextArea( 'commandlist', "", 12, 50 );
> 	print "\n<br><br>";
> 	print $q->checkbox(
> 		-name     => "p_changerc",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Edit $RCName"
> 	);
> 	print "\n<br>";
> 	print $q->checkbox(
> 		-name     => "p_changetext",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Substitute text for rename"
> 	);
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Process Command' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4482,4503c6256,6304
<   my ($commandList, $doRC, $doText) = @_;
< 
<   if ($doText) {
<     &BuildLinkIndex();
<   }
<   &RequestLock() or die T('UpdateLinksList could not get main lock');
<   unlink($IndexFile)  if ($UseIndex);
<   foreach (split(/\n/, $commandList)) {
<     s/\s+$//g;
<     next  if (!(/^[=!|]/));  # Only valid commands.
<     print "Processing $_<br>\n";
<     if (/^\!(.+)/) {
<       &DeletePage($1, $doRC, $doText);
<     } elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
<       &RenamePage($1, $2, $doRC, $doText);
<     } elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
<       &RenameTextLinks($1, $2);
<     }
<   }
<   &NewPageCacheClear(".");  # Clear cache (needs testing?)
<   unlink($IndexFile)  if ($UseIndex);
<   &ReleaseLock();
---
> 	my ( $commandList, $doRC, $doText ) = @_;
> 	
> 	if ($doText) {
> 		&BuildLinkIndex();
> 	}
> 	&RequestLock() or die "UpdateLinksList could not get main lock";
> 	unlink($IndexFile) if ($UseIndex);
> 	
> 	foreach ( split( /\n/, $commandList ) ) {
> 		s/\s+$//g;
> 		
> 		next if ( !(/^[=!|?]/) );    # Only valid commands.
> 		print "\nProcessing $_<br>\n";
> 		
> 		if (/^\!(.+)/) {
> 			&DeletePage( $1, $doRC, $doText );
> 		}
> 		elsif (/^\?(.+)/){
> 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
> 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
> 			print "\n<br><br>";
> 		}
> 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
>       		my $GivenPage = $1;
>       		my $GivenNewName = $2;
>       
>       		if ($GivenPage =~ s[\/\*][]) {
>        			print "\nRenaming subpages of $GivenPage too...<br>";
>         
>         		foreach (&AllSubPagesList($GivenPage)) {
> 					my $NewSubName = $_;
> 					
> 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
> 					print "\nrenaming $_ to $NewSubName<br>";
> 					&RenamePage($_, $NewSubName, $doRC, $doText);
> 		        }
>       		}
> 		      # rename the page itself
> 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
> 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
> 		}
> 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
> 			&RenameTextLinks( $1, $2 );
> 		}
> 	}
> 	
> 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
> 	unlink($IndexFile) if ($UseIndex);
> 	&ReleaseLock();
4507,4513c6308,6315
<   my (@pglist, $page, @links, $link, %seen);
< 
<   @pglist = &AllPagesList();
<   %LinkIndex = ();
<   foreach $page (@pglist) {
<     &BuildLinkIndexPage($page);
<   }
---
> 	my ( @pglist, $page, @links, $link, %seen );
> 	
> 	@pglist    = &AllPagesList();
> 	%LinkIndex = ();
> 	
> 	foreach $page (@pglist) {
> 		&BuildLinkIndexPage($page);
> 	}
4517,4531c6319,6335
<   my ($page) = @_;
<   my (@links, $link, %seen);
< 
<   @links = &GetPageLinks($page, 1, 0, 0);
<   %seen = ();
<   foreach $link (@links) {
<     if (defined($LinkIndex{$link})) {
<       if (!$seen{$link}) {
<         $LinkIndex{$link} .= " " . $page;
<       }
<     } else {
<       $LinkIndex{$link} .= " " . $page;
<     }
<     $seen{$link} = 1;
<   }
---
> 	my ($page) = @_;
> 	my ( @links, $link, %seen );
> 	
> 	@links = &GetPageLinks( $page, 1, 0, 0 );
> 	%seen = ();
> 	
> 	foreach $link (@links) {
> 		if ( defined( $LinkIndex{$link} ) ) {
> 			if ( !$seen{$link} ) {
> 				$LinkIndex{$link} .= " " . $page;
> 			}
> 		}
> 		else {
> 			$LinkIndex{$link} .= " " . $page;
> 		}
> 		$seen{$link} = 1;
> 	}
4535,4554c6339,6368
<   my ($commandList, $doRC, $doText);
< 
<   print &GetHeader("", T('Updating Links'), "");
<   if ($AdminDelete) {
<     return  if (!&UserIsAdminOrError());
<   } else {
<     return  if (!&UserIsEditorOrError());
<   }
<   $commandList = &GetParam("commandlist", "");
<   $doRC   = &GetParam("p_changerc", "0");
<   $doRC   = 1  if ($doRC eq "on");
<   $doText = &GetParam("p_changetext", "0");
<   $doText = 1  if ($doText eq "on");
<   if ($commandList eq "") {
<     print "<p>Empty command list or error.";
<   } else {
<     &UpdateLinksList($commandList, $doRC, $doText);
<     print "<p>Finished command list.";
<   }
<   print &GetCommonFooter();
---
> 	my ( $commandList, $doRC, $doText );
> 	
> 	print &GetHeader( "", "Updating Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$commandList = &GetParam( "commandlist", "" );
> 	$doRC        = &GetParam( "p_changerc",  "0" );
> 	$doRC = 1 if ( $doRC eq "on" );
> 	$doText = &GetParam( "p_changetext", "0" );
> 	$doText = 1 if ( $doText eq "on" );
> 	
> 	if ( $commandList eq "" ) {
> 		print "\n<p>Empty command list or error.</p>";
> 	}
> 	else {
> 		&UpdateLinksList( $commandList, $doRC, $doText );
> 		print "\n<p>Finished command list.</p>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4558,4561c6372,6375
<   my ($action, $old, $new) = @_;
< 
<   &EditRecentChangesFile($RcFile,    $action, $old, $new, 1);
<   &EditRecentChangesFile($RcOldFile, $action, $old, $new, 0);
---
> 	my ( $action, $old, $new ) = @_;
> 	
> 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
> 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
4565,4594c6379,6415
<   my ($fname, $action, $old, $new, $printError) = @_;
<   my ($status, $fileData, $errorText, $rcline, @rclist);
<   my ($outrc, $ts, $page, $junk);
< 
<   ($status, $fileData) = &ReadFile($fname);
<   if (!$status) {
<     # Save error text if needed.
<     $errorText = "<p><strong>Could not open $RCName log file:"
<                  . "</strong> $fname<p>Error was:\n<pre>$!</pre>\n";
<     print $errorText  if ($printError);
<     return;
<   }
<   $outrc = "";
<   @rclist = split(/\n/, $fileData);
<   foreach $rcline (@rclist) {
<     ($ts, $page, $junk) = split(/$FS3/, $rcline);
<     if ($page eq $old) {
<       if ($action == 1) {  # Delete
<         ; # Do nothing (don't add line to new RC)
<       } elsif ($action == 2) {
<         $junk = $rcline;
<         $junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
<         $outrc .= $junk . "\n";
<       }
<     } else {
<       $outrc .= $rcline . "\n";
<     }
<   }
<   &WriteStringToFile($fname . ".old", $fileData);  # Backup copy
<   &WriteStringToFile($fname, $outrc);
---
> 	my ( $fname, $action, $old, $new, $printError ) = @_;
> 	my ( $status, $fileData, $errorText, $rcline, @rclist );
> 	my ( $outrc, $ts, $page, $junk );
> 	
> 	( $status, $fileData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
> 		print $errorText if ($printError);
> 		
> 		return;
> 	}
> 	
> 	$outrc = "";
> 	@rclist = split( /\n/, $fileData );
> 	
> 	foreach $rcline (@rclist) {
> 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
> 		if ( $page eq $old ) {
> 			if ( $action == 1 ) {    # Delete
> 				;                    # Do nothing (don't add line to new RC)
> 			}
> 			elsif ( $action == 2 ) {
> 				$junk = $rcline;
> 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
> 				$outrc .= $junk . "\n";
> 			}
> 		}
> 		else {
> 			$outrc .= $rcline . "\n";
> 		}
> 	}
> 	
> 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
> 	&WriteStringToFile( $fname, $outrc );
4599,4616c6420,6439
<   my ($page, $doRC, $doText) = @_;
<   my ($fname, $status);
< 
<   $page =~ s/ /_/g;
<   $page =~ s/\[+//;
<   $page =~ s/\]+//;
<   $status = &ValidId($page);
<   if ($status ne "") {
<     print "Delete-Page: page $page is invalid, error is: $status<br>\n";
<     return;
<   }
<   $fname = &GetPageFile($page);
<   unlink($fname)  if (-f $fname);
<   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
<   unlink($fname)  if (-f $fname);
<   unlink($IndexFile)  if ($UseIndex);
<   &EditRecentChanges(1, $page, "")  if ($doRC);  # Delete page
<   # Currently don't do anything with page text
---
> 	my ( $page, $doRC, $doText ) = @_;
> 	my ( $fname, $status );
> 	
> 	$page =~ s/ /_/g;
> 	$page =~ s/\[+//;
> 	$page =~ s/\]+//;
> 	$status = &ValidId($page);
> 	
> 	if ( $status ne "" ) {
> 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$fname = &GetPageFile($page);
> 	unlink($fname) if ( -f $fname );
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	unlink($fname)     if ( -f $fname );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
> 	       # Currently don't do anything with page text
4621,4649c6444,6479
<   my ($old, $new, $text) = @_;
< 
<   # Much of this is taken from the common markup
<   %SaveUrl = ();
<   $SaveUrlIndex = 0;
<   $text =~ s/$FS(\d)/$1/g;              # Remove separators (paranoia)
<   if ($RawHtml) {
<     $text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
<   }
<   $text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
<   $text =~ s/(<code>((.|\n)*?)<\/code>)/&StoreRaw($1)/ige;
<   $text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
<   if ($FreeLinks) {
<     $text =~
<      s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
<     $text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
<   }
<   if ($BracketText) {  # Links like [URL text of link]
<     $text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
<     $text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
<   }
<   $text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
<   $text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
<   if ($WikiLinks) {
<     $text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
<   }
<   # Thanks to David Claughton for the following fix
<   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
<   return $text;
---
> 	my ( $old, $new, $text ) = @_;
> 
> 	# Much of this is taken from the common markup
> 	%SaveUrl      = ();
> 	$SaveUrlIndex = 0;
> 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
> 	
> 	if ($RawHtml) {
> 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
> 	}
> 	
> 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
> 	
> 	if ($FreeLinks) {
> 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
> 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
> 	}
> 	
> 	if ($BracketText) {         # Links like [URL text of link]
> 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 	}
> 	
> 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
> 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
> 	
> 	if ($WikiLinks) {
> 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
> 	}
> 
> 	# Thanks to David Claughton for the following fix
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
> 	
> 	return $text;
4653,4669c6483,6507
<   my ($link, $name, $old, $new) = @_;
<   my ($oldlink);
< 
<   $oldlink = $link;
<   $link =~ s/^\s+//;
<   $link =~ s/\s+$//;
<   if (($link eq $old) || (&FreeToNormal($old) eq &FreeToNormal($link))) {
<     $link = $new;
<   } else {
<     $link = $oldlink;  # Preserve spaces if no match
<   }
<   $link = "[[$link";
<   if ($name ne "") {
<     $link .= "|$name";
<   }
<   $link .= "]]";
<   return &StoreRaw($link);
---
> 	my ( $link, $name, $old, $new ) = @_;
> 	my ($oldlink);
> 	
> 	$oldlink = $link;
> 	$link =~ s/^\s+//;
> 	$link =~ s/\s+$//;
> 	
> 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
> 	{
> 		$link = $new;
> 	}
> 	
> 	else {
> 		$link = $oldlink;    # Preserve spaces if no match
> 	}
> 	
> 	$link = "[[$link";
> 	
> 	if ( $name ne "" ) {
> 		$link .= "|$name";
> 	}
> 	
> 	$link .= "]]";
> 	
> 	return &StoreRaw($link);
4673,4683c6511,6523
<   my ($link, $old, $new) = @_;
<   my ($newBracket);
< 
<   $newBracket = 0;
<   if ($link eq $old) {
<     $link = $new;
<     if (!($new =~ /^$LinkPattern$/)) {
<       $link = "[[$link]]";
<     }
<   }
<   return &StoreRaw($link);
---
> 	my ( $link, $old, $new ) = @_;
> 	my ($newBracket);
> 	
> 	$newBracket = 0;
> 	
> 	if ( $link eq $old ) {
> 		$link = $new;
> 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
> 			$link = "[[$link]]";
> 		}
> 	}
> 	
> 	return &StoreRaw($link);
4688,4730c6528,6576
<   my ($page, $old, $new) = @_;
<   my ($fname, $status, $data, @kplist, %tempSection, $changed);
<   my ($sectName, $newText);
< 
<   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
<   return  if (!(-f $fname));
<   ($status, $data) = &ReadFile($fname);
<   return  if (!$status);
<   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<   return  if (length(@kplist) < 1);  # Also empty
<   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
<   return  if (length(@kplist) < 1);  # Also empty
<   %tempSection = split(/$FS2/, $kplist[0], -1);
<   if (!defined($tempSection{'keepts'})) {
<     return;
<   }
<   # First pass: optimize for nothing changed
<   $changed = 0;
<   foreach (@kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     if ($sectName =~ /^(text_)/) {
<       %Text = split(/$FS3/, $tempSection{'data'}, -1);
<       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
<       $changed = 1  if ($Text{'text'} ne $newText);
<     }
<   }
<   return  if (!$changed);  # No sections changed
<   open (OUT, ">$fname") or return;
<   foreach (@kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     if ($sectName =~ /^(text_)/) {
<       %Text = split(/$FS3/, $tempSection{'data'}, -1);
<       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
<       $Text{'text'} = $newText;
<       $tempSection{'data'} = join($FS3, %Text);
<       print OUT $FS1, join($FS2, %tempSection);
<     } else {
<       print OUT $FS1, $_;
<     }
<   }
<   close(OUT);
---
> 	my ( $page, $old, $new ) = @_;
> 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
> 	my ( $sectName, $newText );
> 	
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	return if ( !( -f $fname ) );
> 	( $status, $data ) = &ReadFile($fname);
> 	return if ( !$status );
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;
> 	}
> 
> 	# First pass: optimize for nothing changed
> 	$changed = 0;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$changed = 1 if ( $Text{'text'} ne $newText );
> 		}
> 	}
> 	
> 	return if ( !$changed );    # No sections changed
> 	open( OUT, ">$fname" ) or return;
> 	
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$Text{'text'} = $newText;
> 			$tempSection{'data'} = join( $FS3, %Text );
> 			print OUT $FS1, join( $FS2, %tempSection );
> 		}
> 		else {
> 			print OUT $FS1, $_;
> 		}
> 	}
> 	close(OUT);
4734,4786c6580,6636
<   my ($old, $new) = @_;
<   my ($changed, $file, $page, $section, $oldText, $newText, $status);
<   my ($oldCanonical, @pageList);
< 
<   $old =~ s/ /_/g;
<   $oldCanonical = &FreeToNormal($old);
<   $new =~ s/ /_/g;
<   $status = &ValidId($old);
<   if ($status ne "") {
<     print "Rename-Text: old page $old is invalid, error is: $status<br>\n";
<     return;
<   }
<   $status = &ValidId($new);
<   if ($status ne "") {
<     print "Rename-Text: new page $new is invalid, error is: $status<br>\n";
<     return;
<   }
<   $old =~ s/_/ /g;
<   $new =~ s/_/ /g;
<   # Note: the LinkIndex must be built prior to this routine
<   return  if (!defined($LinkIndex{$oldCanonical}));
<   @pageList = split(' ', $LinkIndex{$oldCanonical});
<   foreach $page (@pageList) {
<     $changed = 0;
<     &OpenPage($page);
<     foreach $section (keys %Page) {
<       if ($section =~ /^text_/) {
<         &OpenSection($section);
<         %Text = split(/$FS3/, $Section{'data'}, -1);
<         $oldText = $Text{'text'};
<         $newText = &SubstituteTextLinks($old, $new, $oldText);
<         if ($oldText ne $newText) {
<           $Text{'text'} = $newText;
<           $Section{'data'} = join($FS3, %Text);
<           $Page{$section} = join($FS2, %Section);
<           $changed = 1;
<         }
<       } elsif ($section =~ /^cache_diff/) {
<         $oldText = $Page{$section};
<         $newText = &SubstituteTextLinks($old, $new, $oldText);
<         if ($oldText ne $newText) {
<           $Page{$section} = $newText;
<           $changed = 1;
<         }
<       }
<       # Add other text-sections (categories) here
<     }
<     if ($changed) {
<       $file = &GetPageFile($page);
<       &WriteStringToFile($file, join($FS1, %Page));
<     }
<     &RenameKeepText($page, $old, $new);
<   }
---
> 	my ( $old, $new ) = @_;
> 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
> 	my ( $oldCanonical, @pageList );
> 	$old =~ s/ /_/g;
> 	$oldCanonical = &FreeToNormal($old);
> 	$new =~ s/ /_/g;
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$old =~ s/_/ /g;
> 	$new =~ s/_/ /g;
> 
> 	# Note: the LinkIndex must be built prior to this routine
> 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
> 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
> 	foreach $page (@pageList) {
> 		$changed = 0;
> 		&OpenPage($page);
> 		foreach $section ( keys %Page ) {
> 			if ( $section =~ /^text_/ ) {
> 				&OpenSection($section);
> 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
> 				$oldText = $Text{'text'};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Text{'text'} = $newText;
> 					$Section{'data'} = join( $FS3, %Text );
> 					$Page{$section} = join( $FS2, %Section );
> 					$changed = 1;
> 				}
> 			}
> 			elsif ( $section =~ /^cache_diff/ ) {
> 				$oldText = $Page{$section};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Page{$section} = $newText;
> 					$changed = 1;
> 				}
> 			}
> 
> 			# Add other text-sections (categories) here
> 		}
> 		if ($changed) {
> 			$file = &GetPageFile($page);
> 			&WriteStringToFile( $file, join( $FS1, %Page ) );
> 		}
> 		&RenameKeepText( $page, $old, $new );
> 	}
4790,4827c6640,6680
<   my ($old, $new, $doRC, $doText) = @_;
<   my ($oldfname, $newfname, $oldkeep, $newkeep, $status);
< 
<   $old =~ s/ /_/g;
<   $new = &FreeToNormal($new);
<   $status = &ValidId($old);
<   if ($status ne "") {
<     print "Rename: old page $old is invalid, error is: $status<br>\n";
<     return;
<   }
<   $status = &ValidId($new);
<   if ($status ne "") {
<     print "Rename: new page $new is invalid, error is: $status<br>\n";
<     return;
<   }
<   $newfname = &GetPageFile($new);
<   if (-f $newfname) {
<     print "Rename: new page $new already exists--not renamed.<br>\n";
<     return;
<   }
<   $oldfname = &GetPageFile($old);
<   if (!(-f $oldfname)) {
<     print "Rename: old page $old does not exist--nothing done.<br>\n";
<     return;
<   }
<   &CreatePageDir($PageDir, $new);  # It might not exist yet
<   rename($oldfname, $newfname);
<   &CreatePageDir($KeepDir, $new);
<   $oldkeep = $KeepDir . "/" . &GetPageDirectory($old) .  "/$old.kp";
<   $newkeep = $KeepDir . "/" . &GetPageDirectory($new) .  "/$new.kp";
<   unlink($newkeep)  if (-f $newkeep);  # Clean up if needed.
<   rename($oldkeep,  $newkeep);
<   unlink($IndexFile)  if ($UseIndex);
<   &EditRecentChanges(2, $old, $new)  if ($doRC);
<   if ($doText) {
<     &BuildLinkIndexPage($new);  # Keep index up-to-date
<     &RenameTextLinks($old, $new);
<   }
---
> 	my ( $old, $new, $doRC, $doText ) = @_;
> 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
> 	
> 	$old =~ s/ /_/g;
> 	$new    = &FreeToNormal($new);
> 	$status = &ValidId($old);
> 	
> 	if ( $status ne "" ) {
> 		print "\nRename: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename: new page $new is invalid, error is: $status<br>";
> 		return;
> 	}
> 	$newfname = &GetPageFile($new);
> 	if ( -f $newfname ) {
> 		print "\nRename: new page $new already exists--not renamed.<br>";
> 		return;
> 	}
> 	$oldfname = &GetPageFile($old);
> 	if ( !( -f $oldfname ) ) {
> 		print "\nRename: old page $old does not exist--nothing done.<br>";
> 		return;
> 	}
> 	
> 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
> 	rename( $oldfname, $newfname );
> 	&CreatePageDir( $KeepDir, $new );
> 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
> 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
> 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
> 	rename( $oldkeep, $newkeep );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
> 
> 	if ($doText) {
> 		&BuildLinkIndexPage($new);          # Keep index up-to-date
> 		&RenameTextLinks( $old, $new );
> 	}
4831,4833c6684,6691
<   print &GetHeader("", "Displaying Wiki Version", "");
<   print "<p>UseModWiki version 1.0</p>\n";
<   print &GetCommonFooter();
---
> 	print &GetHeader( "", "Displaying Wiki Version", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>NobleWiki</h2>";
> 	print "\n<p>derived from UseModWiki version 1.0</p>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4835a6694,6717
> sub GetCssChoices {
> 	my $choices = "";
> 	my $result = "";
> 	my $current = &GetParam('stylesheet', "");
> 	my $selected = "";
> 	
> 	opendir( TEMP, $CssDir );
> 	my @files = readdir(TEMP);
> 	closedir(TEMP);		
> 
> 	foreach my $file(@files){
> 		next unless ($file =~ /^wiki.*?\.css$/);    # allow wiki.something.css and wiki.css
> 		
> 		if ($current eq "/css/$file"){ $choices .= "\n<option value='/css/$file' selected='selected'>$file</option>"; }
> 		else { 	$choices .= "\n<option value='/css/$file'>$file</option>"; }
> 	}
> 	
> 	$result .= "\n<select id='stylesheet' class='wikiselectbox' name='p_stylesheet'>";
> 	$result .= $choices;
> 	$result .= "\n</select>";
> 	
> 	return $result;
> }
> 
4838,4843c6720,6725
<   my ($id, $status, $name) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
<   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
---
> 	my ( $id, $status, $name ) = @_;
> 	
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
> 	}
> 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
4846,4866c6727,6789
< sub GetAdminBar {
<   my ($id) = @_;
<   my ($result);
< 
<   $result = T('Administration') . ': ';
<   if (-f &GetLockedPageFile($id))   { 
<     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
<   }
<   else  {
<     $result .= &GetPageLockLink($id, 1, T('Lock page'));
<   }
<   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
<   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
<   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
<   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
<   if (-f "$DataDir/noedit") {
<     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
<   } else {
<     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
<   }
<   return $result;
---
> sub GetGallery {
> 	my ($params) = @_;
> 	my @lines = split(/\r?\n/, $params);
> 	my $lineNum = 0;
> 	my $imageNum = 0;
> 	my %options;
> 	my $images = "";
> 	my $text = "";
> 	
> 	my $defaultImage = "image1.jpg";
> 	my $defaultThumb = "thumb_image1.jpg";
> 	my $image;
> 	my $thumb;
> 	my $title;
> 	my $header;
> 	my $caption;
> 	my $description;
> 	my $thumbWidth = 100;
> 	
> 	$GLOBAL_galleryCount++;
> 		
> 	foreach my $line (@lines){
> 		%options = &GetOptions($line);
> 		
> 		if ($lineNum == 0){
> 			$lineNum++;
> 			
> 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
> 			if ($options{'description'}){ $description = $options{'description'}; }
> 			if ($options{'header'}){ $header = $options{'header'}; }
> 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
> 			
> 			next;	
> 		}
> 		else {		
> 			if ($options{'image'}){ $image = $options{'image'}; }
> 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
> 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
> 			
> 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
> 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
> 			
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
> 				
> 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
> 		}
> 	}
> 	
> 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
> 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
> 	
> 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
> 	
> 	$text .= "\n	    <ul>";	
> 	$text .= $images;
> 	$text .= "\n	    </ul>";
> 	
> 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
> 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
> 	
> 	$text .= "\n	</div>";		
> 	
> 	return $text;
4869,4900c6792,6846
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
<   my ($id) = @_;
< 
<   return  if (!&ValidIdOrDie($id));
<   return  if (!&UserIsAdminOrError());
<   if ($ConfirmDel && !&GetParam('confirm', 0)) {
<     print &GetHeader('', Ts('Confirm Delete %s', $id), '');
<     print '<p>';
<     print Ts('Confirm deletion of %s by following this link:', $id);
<     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
<     print '</p>';
<     print &GetCommonFooter();
<     return;
<   }
<   print &GetHeader('', Ts('Delete %s', $id), '');
<   print '<p>';
<   if ($id eq $HomePage)  {
<     print Ts('%s can not be deleted.', $HomePage);
<   } else {
<     if (-f &GetLockedPageFile($id))   {
<       print Ts('%s can not be deleted because it is locked.', $id);
<     } else {
<       # Must lock because of RC-editing
<       &RequestLock() or die(T('Could not get editing lock'));
<       DeletePage($id, 1, 1);
<       &ReleaseLock();
<       print Ts('%s has been deleted.', $id);
<     }
<   }
<   print '</p>';
<   print &GetCommonFooter();
---
> sub GetFlash {
> 	my ($options) = @_;
> 	my %options = &GetOptions($options);	
> 	my $fpath = "$UploadUrl/";
> 	my $defaultSWF = 'ufo.swf';
> 	my $maxWidth = 400;
> 	my $maxHeight = 300;
> 	my $ratio = 1;
> 	
> 	my $text = "";
> 	
> 	my $fname;
> 	my $fwidth;
> 	my $fheight;
> 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
> 	my $idFO = "FO_$GLOBAL_flashCount";
> 
> 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
> 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
> 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
> 	
> 	if ($fwidth > $maxWidth){
> 		$ratio = $maxWidth / $fwidth;
> 		$fwidth = $maxWidth;
> 		$fheight = int ($ratio * $fheight);
> 	}
> 	elsif ($fheight > $maxHeight){
> 		$ratio = $maxHeight / $fheight;
> 		$fheight = $maxHeight;
> 		$fwidth = int ($ratio * $fwidth);
> 	}
> 			
> 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
> 	
> 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
> 	$text .= "\n<script type='text/javascript'>";
> 	$text .= "\n			var fpath = '$fpath';";
> 	$text .= "\n			var fname = '$fname';";
> 	$text .= "\n			var fwidth = $fwidth;";
> 	$text .= "\n			var fheight = $fheight;";
> 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
> 	$text .= "\n			\$(window).load(function () {";
> 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
> 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
> 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
> 	$text .= "\n		    });";
> 	$text .= "\n		</script>";		
> 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
> 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
> 	$text .= "\n		<p style='clear: both;'></p>";
> 	$text .= "\n	</div>";
> 
> 	$GLOBAL_flashCount++;
> 	
> 	return $text;		
4903,4918c6848,6881
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
<   print &GetHeader('', T('File Upload Page'), '');
<   if (!$AllUpload) {
<     return if (!&UserIsEditorOrError());
<   }
<   print '<p>' . Ts('The current upload size limit is %s.', $MaxPost) . ' '
<         . Ts('Change the %s variable to increase this limit.', '$MaxPost');
<   print '</p><br>';
<   print '<FORM METHOD="post" ACTION="' . $ScriptName
<         . '" ENCTYPE="multipart/form-data">';
<   print '<input type="hidden" name="upload" value="1" />';
<   print 'File to Upload: <INPUT TYPE="file" NAME="file"><br><BR>';
<   print '<INPUT TYPE="submit" NAME="Submit" VALUE="Upload">';
<   print '</FORM>';
<   print &GetCommonFooter(); 
---
> sub GetAdminBar {
> 	my ($id, $cssClass) = @_;
> 	my ($result);
> 
> 	$result .= "\n<div $cssClass>";
> 	$result .= "Administration: ";
> 	
> 	my ($notValid) = $id =~ /^\d*$/;
> 	
> 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
> 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
> 	} 
> 		
> 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
> 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
> 	
> 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
> 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
> 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
> 	$result .= " | " . &ScriptLink( "action=orphans", "List Orphans" );
> 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
> 			
> 	if ( -f "$DataDir/noedit" ) {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
> 	}
> 	else {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
> 	}
> 	
> 	$result .= "</div>";
> 	
> 	return $result;
4921,4943c6884,6928
< sub SaveUpload {
<   my ($filename, $printFilename, $uploadFilehandle);
<  
<   print &GetHeader('', T('Upload Finished'), '');
<   if (!$AllUpload) {
<     return  if (!&UserIsEditorOrError());
<   }
<   $UploadDir .= '/'  if (substr($UploadDir, -1, 1) ne '/');  # End with /
<   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
<   $filename = $q->param('file');
<   $filename =~ s/.*[\/\\](.*)/$1/;  # Only name after last \ or /
<   $uploadFilehandle = $q->upload('file');
<   open UPLOADFILE, ">$UploadDir$filename";
<   while (<$uploadFilehandle>) { print UPLOADFILE; }
<   close UPLOADFILE;
<   print T('The wiki link to your file is:') . "\n<br><BR>";
<   $printFilename = $filename;
<   $printFilename =~ s/ /\%20/g;  # Replace spaces with escaped spaces
<   print "upload:" . $printFilename . "<BR><BR>\n";
<   if ($filename =~ /${ImageExtensions}$/) {
<     print '<HR><img src="' . $UploadUrl . $filename . '">' . "\n";
<   }
<   print &GetCommonFooter();
---
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
> 	my ($id) = @_;
> 	
> 	return if ( !&ValidIdOrDie($id) );
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
> 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		print "\n<h2>Delete Page?</h2>";
> 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
> 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></div></body></html>";	
> 		
> 		return;
> 	}
> 	
> 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
> 	print &GetLeftNav("");	
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $id eq $HomePage ) {
> 		print Ts( '%s can not be deleted.', $HomePage );
> 	}
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) {
> 			print Ts( '%s can not be deleted because it is locked.', $id );
> 		}
> 		else {
> 
> 			# Must lock because of RC-editing
> 			&RequestLock() or die( "Could not get editing lock" );
> 			DeletePage( $id, 1, 1 );
> 			&ReleaseLock();
> 			print Ts( '%s has been deleted.', $id );
> 		}
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4946,4961c6931,6952
< sub ConvertFsFile {
<   my ($oldFS, $newFS, $fname) = @_;
<   my ($oldData, $newData, $status);
< 
<   return  if (!-f $fname);  # Convert only existing regular files
<   ($status, $oldData) = &ReadFile($fname);
<   if (!$status) {
<     print '<br><strong>' . Ts('Could not open file %s', $fname)
<           . ':</strong>' . T('Error was') . ":\n<pre>$!</pre>\n" . '<br>';
<     return;
<   }
<   $newData = $oldData;
<   $newData =~ s/$oldFS(\d)/$newFS . $1/ge;
<   return  if ($oldData eq $newData);  # Do not write if the same
<   &WriteStringToFile($fname, $newData);
< # print $fname . '<br>';    # progress report
---
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
> 	print &GetHeader( "", "File Upload Page", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	print "\n<h2>Select File</h2>";
> 	print "\nThe current upload size limit is $MaxPost.<br>";
> 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
> 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
> 	print "\n<input type='hidden' name='upload' value='1' />";
> 	print "\nFile to Upload: ";
> 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
> 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
4963a6955,7015
> sub SaveUpload {
> 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
> 	print &GetHeader( "", "Upload Finished", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
> 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$filename = $q->param('file');
> 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
> 	
> 	$uploadFilehandle = $filename;
> 	open UPLOADFILE, ">$UploadDir$filename";
> 	binmode(UPLOADFILE);	
> 	while (<$uploadFilehandle>) { print UPLOADFILE; }
> 	close UPLOADFILE;
> 	
> 
> 	print "\n<h2>Upload Completed</h2>";
> 	print "\nThe wiki link to your file is:<br><br>";
> 	
> 	$printFilename = $filename;
> 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
> 	$fileUrl = $UploadUrl . $printFilename;
> 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
> 
> 	if ( $filename =~ /${ImageExtensions}$/ ) {
> 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> sub ConvertFsFile {
> 	my ( $oldFS, $newFS, $fname ) = @_;
> 	my ( $oldData, $newData, $status );
> 	
> 	return if ( !-f $fname );           # Convert only existing regular files
> 	( $status, $oldData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
> 		
> 		return;
> 	}
> 	
> 	$newData = $oldData;
> 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
> 	
> 	return if ( $oldData eq $newData );    # Do not write if the same
> 	&WriteStringToFile( $fname, $newData );
> 
> 	# print $fname . '<br>';    # progress report
> }
> 
4967,5002c7019,7059
<   my ($oldFS, $newFS, $topDir) = @_;
<   my (@dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname);
< 
<   opendir(DIRLIST, $topDir);
<   @dirs = readdir(DIRLIST);
<   closedir(DIRLIST);
<   @dirs = sort(@dirs);
<   foreach $dir (@dirs) {
<     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
<     next  if (!-d "$topDir/$dir");          # Top level directories only
<     next  if (-f "$topDir/$dir.cvt");       # Skip if already converted
<     opendir(DIRLIST, "$topDir/$dir");
<     @files = readdir(DIRLIST);
<     closedir(DIRLIST);
<     foreach $file (@files) {
<       next  if (($file eq '.') || ($file eq '..'));
<       $fname = "$topDir/$dir/$file";
<       if (-f $fname) {
< #       print $fname . '<br>';   # progress
<         &ConvertFsFile($oldFS, $newFS, $fname);
<       } elsif (-d $fname) {
<         opendir(DIRLIST, $fname);
<         @subFiles = readdir(DIRLIST);
<         closedir(DIRLIST);
<         foreach $subFile (@subFiles) {
<           next  if (($subFile eq '.') || ($subFile eq '..'));
<           $subFname = "$fname/$subFile";
<           if (-f $subFname) {
< #           print $subFname . '<br>';   # progress
<             &ConvertFsFile($oldFS, $newFS, $subFname);
<           }
<         }
<       }
<     }
<   &WriteStringToFile("$topDir/$dir.cvt", 'converted');
<   }
---
> 	my ( $oldFS, $newFS, $topDir ) = @_;
> 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	@dirs = sort(@dirs);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$topDir/$dir" );             # Top level directories only
> 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
> 		
> 		opendir( DIRLIST, "$topDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
> 			$fname = "$topDir/$dir/$file";
> 			if ( -f $fname ) {
> 				# print $fname . '<br>';   # progress
> 				&ConvertFsFile( $oldFS, $newFS, $fname );
> 			}
> 			elsif ( -d $fname ) {
> 				opendir( DIRLIST, $fname );
> 				@subFiles = readdir(DIRLIST);
> 				closedir(DIRLIST);
> 				
> 				foreach $subFile (@subFiles) {
> 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
> 					$subFname = "$fname/$subFile";
> 					if ( -f $subFname ) {
> 						# print $subFname . '<br>';   # progress
> 						&ConvertFsFile( $oldFS, $newFS, $subFname );
> 					}
> 				}
> 			}
> 		}
> 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
> 	}
5006,5017c7063,7075
<   my ($topDir) = @_;
<   my (@dirs, $dir);
< 
<   opendir(DIRLIST, $topDir);
<   @dirs = readdir(DIRLIST);
<   closedir(DIRLIST);
<   foreach $dir (@dirs) {
<     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
<     next  if (!-f "$topDir/$dir");          # Remove only files...
<     next  unless ($dir =~ m/\.cvt$/);       # ...that end with .cvt
<     unlink "$topDir/$dir";
<   }
---
> 	my ($topDir) = @_;
> 	my ( @dirs, $dir );
> 	
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-f "$topDir/$dir" );             # Remove only files...
> 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
> 		unlink "$topDir/$dir";
> 	}
5021,5047c7079,7111
<   my $oldFS = "\xb3";
<   my $newFS = "\x1e\xff\xfe\x1e";
< 
<   print &GetHeader('', T('Convert wiki DB'), '');
<   return if (!&UserIsAdminOrError());
<   if ($FS ne $newFS) {
<     print Ts('You must change the %s option before converting the wiki DB.',
<              '$NewFS') . '<br>';
<     return;
<   }
<   &WriteStringToFile("$DataDir/noedit", 'editing locked.');
<   print T('Wiki DB locked for conversion.') . '<br>';
<   print T('Converting Wiki DB...') . '<br>';
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog");
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog.old");
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog");
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog.old");
<   &ConvertFsDir($oldFS, $newFS, $PageDir);
<   &ConvertFsDir($oldFS, $newFS, $KeepDir);
<   &ConvertFsDir($oldFS, $newFS, $UserDir);
<   &ConvertFsCleanup($PageDir);
<   &ConvertFsCleanup($KeepDir);
<   &ConvertFsCleanup($UserDir);
<   print T('Finished converting wiki DB.') . '<br>';
<   print Ts('Remove file %s to unlock wiki for editing.', "$DataDir/noedit")
<         . '<br>';
<   print &GetCommonFooter();
---
> 	my $oldFS = "\xb3";
> 	my $newFS = "\x1e\xff\xfe\x1e";
> 	
> 	print &GetHeader( "", "Convert wiki DB", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";	
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	if ( $FS ne $newFS ) {
> 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
> 		return;
> 	}
> 	
> 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
> 	print "\nWiki DB locked for conversion.<br>";
> 	print "\nConverting Wiki DB...<br>";
> 	
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
> 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
> 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
> 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
> 	&ConvertFsCleanup($PageDir);
> 	&ConvertFsCleanup($KeepDir);
> 	&ConvertFsCleanup($UserDir);
> 	
> 	print "\nFinished converting wiki DB.<br>";
> 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
5052,5091c7116,7170
<   my (%Data, $status, $data, $maxID, $id, $removed, $keep);
<   my (@dirs, @files, $dir, $file, $item);
< 
<   print &GetHeader('', T('Trim wiki users'), '');
<   return if (!&UserIsAdminOrError());
<   $removed = 0;
<   $maxID = 1001;
<   opendir(DIRLIST, $UserDir);
<   @dirs = readdir(DIRLIST);
<   closedir(DIRLIST);
<   foreach $dir (@dirs) {
<     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
<     next  if (!-d "$UserDir/$dir");         # Top level directories only
<     opendir(DIRLIST, "$UserDir/$dir");
<     @files = readdir(DIRLIST);
<     closedir(DIRLIST);
<     foreach $file (@files) {
<       if ($file =~ m/(\d+).db/) {  # Only numeric ID files
<         $id = $1;
<         $maxID = $id  if ($id > $maxID);
<         %Data = ();
<         ($status, $data) = &ReadFile("$UserDir/$dir/$file");
<         if ($status) {
<           %Data = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<           $keep = 0;
<           foreach $item (qw(username password adminpw stylesheet)) {
<             $keep = 1  if (defined($Data{$item}) && ($Data{$item} ne ''));
<           }
<           if (!$keep) {
<             unlink "$UserDir/$dir/$file";
< #           print "$UserDir/$dir/$file" . '<br>';  # progress
<             $removed += 1;
<           }
<         }
<       }
<     }
<   }
<   print Ts('Removed %s files.', $removed) . '<br>';
<   print Ts('Recommended $StartUID setting is %s.', $maxID + 100) . '<br>';
<   print &GetCommonFooter();
---
> 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
> 	my ( @dirs, @files, $dir, $file, $item );
> 	
> 	print &GetHeader( "", "Trim wiki users", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$removed = 0;
> 	$maxID   = 1001;
> 	opendir( DIRLIST, $UserDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
> 		
> 		opendir( DIRLIST, "$UserDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
> 				$id    = $1;
> 				$maxID = $id if ( $id > $maxID );
> 				%Data  = ();
> 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
> 				
> 				if ($status) {
> 					%Data =
> 					  split( /$FS1/, $data, -1 )
> 					  ;    # -1 keeps trailing null fields
> 					$keep = 0;
> 					
> 					foreach $item (qw(username password adminpw stylesheet)) {
> 						$keep = 1
> 						  if ( defined( $Data{$item} )
> 							&& ( $Data{$item} ne "" ) );
> 					}
> 					
> 					if ( !$keep ) {
> 						unlink "$UserDir/$dir/$file";
> 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
> 						$removed += 1;
> 					}
> 				}
> 			}
> 		}
> 	}
> 	print Ts( 'Removed %s files.', $removed ) . '<br>';
> 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
5092a7173,7374
> sub DoAssetsToc {
> 	## Check $DataDir and see if assets-toc exists
> 	## -- if not, then build TOC
> 	## -- if does, but is older than 1 minute, rebuild TOC
> 	## Return TOC	
> }
> sub DoFilterToc {
> 	## Given @filters, pageIndex, pageSize
> 	## Get TOC from DoAssetsTOC
> 	## Apply @filters; sort, apply pageIndex * pageSize as offset
> 	## Return FilteredTOC	
> }
> sub DoListFiles {
> 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
> 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
> 	my ( $id, $filter, $managedisabled ) = @_;
> 
> 	if ($managedisabled){ 
> 		$targetDir = "$DisabledDir";
> 	}
> 	else {
> 		$targetDir = "$UploadDir";
> 	}
> 
> 	# CREATE array of filters
> 	$filter = lc($filter);
> 	$filter =~ s/\s//go;
> 	if ($filter ne ""){ 
> 		if ($filter =~ m/,/){
> 			@filters = split(',', $filter);
> 			
> 		}
> 		else {
> 			push (@filters, $filter);
> 		}
> 		$term = "using '<em>$filter</em>'";
> 	}
> 		
> 	# READ DIRECTORY	
> 	opendir( DIRLIST, $targetDir );
> 	@list = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	
> 	# RUN INCLUSIVE FILTERS
> 	foreach $file (@list){		
> 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
> 		
> 		if ($filter eq ""){  push @includes, $file; next; }
> 		
> 		$qualifies = 0;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;
> 			$include = $item;
> 					
> 			if ($item =~ m/^\!/){ next; }
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
> 		}
> 		
> 		if ($qualifies){ push @includes, $file; }
> 	}
> 
> 	# RUN EXCLUSIVE FILTERS
> 
> 	foreach $file (@includes){
> 		if ($filter eq ""){  push @files, $file; next; }
> 				
> 		$qualifies = 1;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;					
> 			unless ($item =~ m/^\!/){ next; }
> 			$include = substr($item, 1);
> 
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
> 		}
> 		
> 		if ($qualifies){ push @files, $file; }
> 	}
> 	
> 	print &GetHeader( "", "Manage Assets", "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikidiff'>";
> 	
> 	#return if ( !&UserIsEditorOrError() );
> 		
> 	if ($managedisabled){
> 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
> 		
> 		# MOVE file to disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $keeppath){
> 				if (-w $UploadDir){
> 					if (rename($keeppath, $uploadpath)){
> 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 	else {
> 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
> 		
> 		# MOVE file from disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $uploadpath){
> 				if (-w $DisabledDir){
> 					if (rename($uploadpath, $keeppath)){
> 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
> 	
> 	foreach $file (@files) {
> 		$filecount++;
> 		$linkname = "upload:$file";
> 		
> 		@links = SearchTitleAndBody($file, "", "");
> 		$numlinks = scalar(@links);
> 
> 		$title = "";
> 		$action = "";
> 			
> 		if ($managedisabled){			
> 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td>$file</td>";
> 			print "\n<td>$size</td>";			
> 			
> 			if ( &UserIsEditorOrAdmin() ){
> 				$title = "Click to re-enable file.";
> 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
> 			}
> 		}
> 		else {		
> 			$uploadpath = "$UploadUrl/$file";
> 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
> 			print "\n<td>$size</td>";
> 			
> 			if ($numlinks > 0){
> 				$title = "Click to see what pages link to this file.";
> 				$action = "href='$ScriptName?back=$file'";
> 			}
> 			elsif ( &UserIsEditorOrAdmin() ){
> 				$numlinks = "0";
> 				$title = "Click to disable file.";
> 				$action = "href='$ScriptName?action=listfiles&id=$file'";
> 			}		
> 		}
> 
> 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
> 		print "\n</tr>";
> 	}
> 	
> 	if (scalar(@files) == 0){
> 		print "\n<td colspan='4'>No files available</td></tr>";
> 	}
> 	print "\n</table>";
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
> 	print "\n<input type='submit' value='Apply Filter'>";
> 	
> 	
> 	if ($managedisabled){
> 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
> 	}
> 	else {
> 		print "\n<input type='hidden' name='action' value='listfiles'>";
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
> 	}
> 	print "\nUse ! to exclude a term, separate terms with a comma";
> 	print "\n</form>";
> 	print "\n</div>";
> 
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";				
> }
> 
> 
5095,5096c7376,7378
< &DoWikiRequest()  if ($RunCGI && ($_ ne 'nocgi'));   # Do everything.
< 1; # In case we are loaded from elsewhere
---
> &DoWikiRequest() if ( $RunCGI && ( $_ ne 'nocgi' ) );    # Do everything.
> 1;    # In case we are loaded from elsewhere
> 
------
SandBox|1195947279
3c3
< # UseModWiki version 1.0 (September 12, 2003)
---
> # UseModWiki version 1.0.3 (September 12, 2007)
396c396
< 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg)";
---
> 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg|ico|tiff)";
443c443,444
< 	if ( defined( $Translate{$text} ) && ( $Translate{$text} ne "" ) ) {
---
> 	
> 	if (defined($Translate{$text}) && ($Translate{$text} ne ''))  {
450c451,453
< 	my ( $text, $string ) = @_;
---
> 	my ($text, $string, $noquote) = @_;
> 	
> 	$string = &QuoteHtml($string) unless $noquote;
452a456
> 	
457c461,464
< 	my $text = @_[0];
---
> 	my $text = $_[0];
> 	my @args = @_;
> 	
> 	@args = map { $_ = &QuoteHtml($_); } @args;
459c466,467
< 	$text =~ s/\%([1-9])/$_[$1]/ge;
---
> 	$text =~ s/\%([1-9])/$args[$1]/ge;
> 	
632a641
> 		
666,667c674
< 	$fullHtml .= $fragHtml;
< 	
---
> 	$fullHtml .= $fragHtml;	
669,671c676
< 	if ( $allDiff != 0 ) {
< 		$allDiff = &GetParam( 'defaultdiff', 1 );
< 	}
---
> 	if ( $allDiff != 0 ) { $allDiff = &GetParam( 'defaultdiff', 1 ); }
699a705
> 	
702a709,711
> 			
> 		# call: MakeSection( current page, magic module, line of parameters)
> 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
704,714c713,714
< 		#$magicDiv = "\n<hr>\n"; # Remove if using CSS.
< 		
< 		# call: MakeSection( current page, magic module, line of parameters)
< 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
< 		
< 		if (lc $magicpos eq "top"){
< 			$fullHtml .= $magicHTML . $magicDiv . $wikiHTML;
< 		}
< 		else {
< 			$fullHtml .= $wikiHTML . $magicDiv . $magicHTML;
< 		}
---
> 		if (lc $magicpos eq "top"){ $fullHtml .= $magicHTML . $magicDiv . $wikiHTML; }
> 		else { $fullHtml .= $wikiHTML . $magicDiv . $magicHTML; }
725,726c725
< 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) )
< 	{
---
> 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) ){
743d740
< 	print $fullHtml;
745c742
< 	return
---
> 	print $fullHtml;
746a744,745
> 	return
> 	
1133,1173c1132,1164
< sub GetRssRcLine {
< 	my (
< 		$pagename, $timestamp,  $host,   $userName,
< 		$userID,   $summary,    $isEdit, $pagecount,
< 		$revision, $diffPrefix, $historyPrefix
< 	  )
< 	  = @_;
< 	my (
< 		$itemID,     $description, $authorLink, $author, $status,
< 		$importance, $date,        $item,       $headItem
< 	);
< 
< 	# Add to list of items in the <channel/>
< 	$itemID = $FullUrl
< 	  . &ScriptLinkChar()
< 	  . &GetOldPageParameters( 'browse', $pagename, $revision );
< 	$itemID   = &QuoteHtml($itemID);
< 	$headItem = "                <rdf:li rdf:resource=\"$itemID\"/>";
< 
< 	# Add to list of items proper.
< 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$description = &QuoteHtml($summary);
< 	}
< 	$host = &QuoteHtml($host);
< 	if ($userName) {
< 		$author     = &QuoteHtml($userName);
< 		$authorLink = "link=\"$QuotedFullUrl?$author\"";
< 	}
< 	else {
< 		$author = $host;
< 	}
< 	$status     = ( 1 == $revision ) ? 'new'   : 'updated';
< 	$importance = $isEdit            ? 'minor' : 'major';
< 	$timestamp += $TimeZoneOffset;
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($timestamp);
< 	$year += 1900;
< 	$date = sprintf( "%4d-%02d-%02dT%02d:%02d:%02d+%02d:00", $year, $mon + 1, $mday, $hour, $min, $sec, $TimeZoneOffset / ( 60 * 60 ) );
< 	$pagename = &QuoteHtml($pagename);
< 
< 	# Write it out longhand
< 	$item = <<RSS ;
---
> sub GetRssRcLine{
>   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
>       $isEdit, $pagecount, $revision, $diffPrefix, $historyPrefix) = @_;
>   my ($pagenameEsc, $itemID, $description, $authorLink, $author, $status,
>       $importance, $date, $item, $headItem);
> 
>   $pagenameEsc = CGI::escape($pagename);
>   # Add to list of items in the <channel/>
>   $itemID = $FullUrl . &ScriptLinkChar()
>             . &GetOldPageParameters('browse', $pagenameEsc, $revision);
>   $itemID = &QuoteHtml($itemID);
>   $headItem = "                <rdf:li rdf:resource=\"$itemID\"/>\n";
>   # Add to list of items proper.
>   if (($summary ne "") && ($summary ne "*")) {
>     $description = &QuoteHtml($summary);
>   }
>   $host = &QuoteHtml($host);
>   if ($userName) {
>     $author = &QuoteHtml($userName);
>     $authorLink = "link=\"$QuotedFullUrl?$author\"";
>   } else {
>     $author = $host;
>   }
>   $status = (1 == $revision) ? 'new' : 'updated';
>   $importance = $isEdit ? 'minor' : 'major';
>   $timestamp += $TimeZoneOffset;
>   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($timestamp);
>   $year += 1900;
>   $date = sprintf("%4d-%02d-%02dT%02d:%02d:%02d+%02d:00",
>     $year, $mon+1, $mday, $hour, $min, $sec, $TimeZoneOffset/(60*60));
>   $pagename = &QuoteHtml($pagename);
>   # Write it out longhand
>   $item = <<RSS ;
1176c1167
<         <link>$QuotedFullUrl?$pagename</link>
---
>         <link>$QuotedFullUrl?$pagenameEsc</link>
1186c1177
<         <wiki:diff>$diffPrefix$pagename</wiki:diff>
---
>         <wiki:diff>$diffPrefix$pagenameEsc</wiki:diff>
1188c1179
<         <wiki:history>$historyPrefix$pagename</wiki:history>
---
>         <wiki:history>$historyPrefix$pagenameEsc</wiki:history>
1191c1182
< 	return ( $headItem, $item );
---
>   return ($headItem, $item);
1226c1217
<       print "\n<input type='hidden' name='id' value=\"$id\"/>";
---
>       print "\n<input type='hidden' name='id' value='$id'/>";
1344,1346c1335,1337
< 	my ( $action, $text ) = @_;
< 	
< 	return "<a href=\"$ScriptName" . &ScriptLinkChar() . "$action\" class='wikiscriptlink' title='Click to visit page'>$text</a>";
---
>   my ($action, $text) = @_;
> 
>   return "<a class='wikiscriptlink' title='Click to visit page' href='" . $ScriptName . &ScriptLinkChar() . &UriEscape($action) . "'>$text</a>";
1350,1354c1341,1343
< 	my ( $action, $text, $class, $title ) = @_;
< 	
< 	return "<a href='$ScriptName"
< 	  . &ScriptLinkChar()
< 	  . "$action' class='$class' title='$title'>$text</a>";
---
>   my ($action, $text, $class) = @_;
> 
>   return "<a href='" . $ScriptName . &ScriptLinkChar() . &UriEscape($action) . "' class='" . $class . "'>$text</a>";
1606,1611c1595,1598
< 	if ($FreeLinks) {
< 		$action =~ s/ /_/g;
< 	}
< 	return "<a href=\"$ScriptName"
< 	  . &ScriptLinkChar()
< 	  . "$action\" title=\"$title\" class='wikiscriptlinktitle'>$text</a>";
---
> 	
> 	if ($FreeLinks) { $action =~ s/ /_/g; }
> 	
> 	return "<a href='" . $ScriptName . &ScriptLinkChar() . &UriEscape($action) . "' title='$title' class='wikiscriptlinktitle'>$text</a>";
1661c1648
< 	$result .= "\n<div class='wikiheader'>";
---
> 	$result .= "\n<div class='wikiheader'>[$oldId]";
1669c1656
< 		$logoImage = "img class='wikilogo' src=\"$LogoUrl\" alt=\"$altText\" border=0";
---
> 		$logoImage = "img class='wikilogo' src='$LogoUrl' alt='$altText'";
1672c1659
< 			$logoImage .= " align=\"right\"";
---
> 			$logoImage .= " align='right'";
1751,1756c1738,1743
< 	if ( $SiteBase ne "" ) {
< 		$html .= qq(<base href="$SiteBase">);
< 	}
< 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
< 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
< 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
---
> 	#--------------------------------------------------------------------------
> 	# we don't want robots indexing our history or other admin pages
> 	# UNSURE ABOUT THIS ONE
> 	#--------------------------------------------------------------------------
> 	my $action = lc(&GetParam('action', ''));
> 	unless (!$action or $action eq "rc" or $action eq "index") { $html .= "<meta name='robots' content='noindex,nofollow'>\n"; }
1758,1766c1745
< 	if ( $stylesheet ne "" ) {
< 		$html .= qq(<link rel="stylesheet" href="$stylesheet">);
< 	}
< 
<    my $bots = "";
<    # actions and non-existant page views don't get indexed or followed by robots
<    if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
<    $bots = $bots . 'index,' . $bots . 'follow';
<    $html .= qq(<meta name="robots" content="$bots" />\n);
---
> 	if ( $SiteBase ne "" ) { $html .= qq(<base href="$SiteBase">); }
1768,1769c1747,1749
< 	$html .= $UserHeader;
< 	$bodyExtra = "";
---
> 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
> 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
> 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
1771,1772c1751,1755
< 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
< 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
---
> 	if ( $stylesheet ne "" ) { $html .= qq(<link rel="stylesheet" href="$stylesheet">); }
> 
> 	my $bots = "";
> 	# actions and non-existant page views don't get indexed or followed by robots
> 	if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
1773a1757,1765
> 	$bots = $bots . 'index,' . $bots . 'follow';
> 	$html .= qq(<meta name="robots" content="$bots" />\n);
> 	
> 	$html .= $UserHeader;
> 	$bodyExtra = "";
> 	
> 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
> 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
> 	
1778c1770
< 		
---
> 	
1870,1872c1862,1864
< 	if ( $rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
< 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?$id' class='wikiusemetalink'>Search MetaWiki</a>"; }
< 	
---
> 	if ($rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
> 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?" . &UriEscape($id) . "' class='wikiusemetalink'>". T("Search MetaWiki") . "</a>"; }
> 		
1887,1888c1879,1880
< 				
< 			if ($AuthorFooter) { $result .= " by " . &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}); }
---
> 			
> 			if ($AuthorFooter) { $result .= ' ' . Ts('by %s', &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}), 1); }
2166c2158
< 		s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
---
> 		s/\[\#(\w+)\]/&StoreHref(" name='$1'")/ge if $NamedAnchors;
2231,2234c2223,2224
< 		if ($UseUpload) {
< 			s/$UploadPattern/&StoreUpload($1)/geo;
< 		}
< 				
---
> 		if ($UseUpload) { s/$UploadPattern/&StoreUpload($1)/geo; }
>     
2291c2281
< 				s/((\|\|)+)/"<\/td><td $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;
---
> 				s/((\|\|)+)/"<\/td><td $cellOptions colspan='" . (length($1)\/2) . "'>"/e;
2304c2294
< 				s/((\!\!)+)/"<\/th><th $cellOptions colspan=\"" . (length($1)\/2) . "\">"/e;				
---
> 				s/((\!\!)+)/"<\/th><th $cellOptions colspan='" . (length($1)\/2) . "'>"/e;				
2371a2362,2370
> sub EmptyCellsToNbsp {
>   my ($row) = @_;
> 
>   $row =~ s/(?<=\|\|)\s+(?=\|\|)/&nbsp;/g;
>   $row =~ s/^\s+(?=\|\|)/&nbsp;/;
>   $row =~ s/(?<=\|\|)\s+$/&nbsp;/;
>   return $row;
> }
> 
2411c2410
< 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/th><\/tr>\n"/e;
---
> 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/th><\/tr>\n"/e;
2428c2427
< 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>$3<\/td><\/tr>\n"/e;
---
> 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/td><\/tr>\n"/e;
2512,2513c2510,2511
< sub QuoteHtml {
< 	my ($html) = @_;
---
> sub UriEscape {
> 	my ($uri) = @_;
2515,2518c2513,2514
< 	$html =~ s/&/&amp;/g;
< 	$html =~ s/</&lt;/g;
< 	$html =~ s/>/&gt;/g;
< 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
---
> 	$uri =~ s/([\x00-\x1f\x7f-\xff])/sprintf("%%%02X", ord($1))/ge;
> 	$uri =~ s/\&/\&amp;/g;
2520c2516
< 	return $html;
---
> 	return $uri;
2523,2524c2520,2521
< sub ParseParagraph {
< 	my ($text) = @_;
---
> sub QuoteHtml {
> 	my ($html) = @_;
2526,2527c2523,2526
< 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
< 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
---
> 	$html =~ s/&/&amp;/g;
> 	$html =~ s/</&lt;/g;
> 	$html =~ s/>/&gt;/g;
> 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
2529,2530c2528
< 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
< 	return "\n<p>$text</p>";
---
> 	return $html;
2533,2535c2531,2532
< sub StoreInterPage {
< 	my ( $id, $useImage ) = @_;
< 	my ( $link, $extra );
---
> sub ParseParagraph {
> 	my ($text) = @_;
2537,2540c2534,2535
< 	( $link, $extra ) = &InterPageLink( $id, $useImage );
< 
< 	# Next line ensures no empty links are stored
< 	$link = &StoreRaw($link) if ( $link ne "" );
---
> 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
> 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
2542c2537,2538
< 	return $link . $extra;
---
> 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
> 	return "\n<p>$text</p>";
2545c2541
< sub InterPageLink {
---
> sub StoreInterPage {
2547c2543
< 	my ( $name, $site, $remotePage, $url, $punct );
---
> 	my ( $link, $extra );
2549,2552c2545,2548
< 	( $id, $punct ) = &SplitUrlPunct($id);
< 	$name = $id;
< 	( $site, $remotePage ) = split( /:/, $id, 2 );
< 	$url = &GetSiteUrl($site);
---
> 	( $link, $extra ) = &InterPageLink( $id, $useImage );
> 
> 	# Next line ensures no empty links are stored
> 	$link = &StoreRaw($link) if ( $link ne "" );
2554c2550,2555
< 	return ( "", $id . $punct ) if ( $url eq "" );
---
> 	return $link . $extra;
> }
> 
> sub InterPageLink {
> 	my ( $id, $useImage ) = @_;
> 	my ( $name, $site, $remotePage, $url, $punct );
2556,2557c2557,2560
< 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
< 	$url .= $remotePage;
---
> 	( $id, $punct ) = &SplitUrlPunct($id);
> 	$name = $id;
> 	( $site, $remotePage ) = split( /:/, $id, 2 );
> 	$url = &GetSiteUrl($site);
2558a2562,2566
> 	return ( "", $id . $punct ) if ( $url eq "" );
> 	
> 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
> 	$url .= $remotePage;
> 	
2760c2768
< 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
---
> 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|ico|tiff|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/i );
2843a2851,2855
> 	elsif ($text =~ /^$InterLinkPattern$/) {
> 		my @interlink = split(/:/, $text, 2);
> 		$text = &GetSiteUrl($interlink[0]) . $interlink[1];
> 	}
> 
2934c2946
< 	return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\" class='wikirfclink'>RFC $num</a>";
---
> 	return "<a href='http://www.faqs.org/rfcs/rfc${num}.html' class='wikirfclink'>RFC $num</a>";
5151c5163
<                     $html .= "<a href=\"#letter".$thisInitial."\">".$thisInitial."</a> ";
---
>                     $html .= "<a href='#letter".$thisInitial."'>$thisInitial</a> ";
5162c5174
<                 $html .= "\n<br><br><h3 class='lettergroup'><a name=\"letter$thisInitial\"> $thisInitial </h3>\n$WikiLine\n";
---
>                 $html .= "\n<br><br><h3 class='lettergroup'><a name='letter$thisInitial'> $thisInitial </h3>$WikiLine";
5269c5281
< 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen);
---
> 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen, $main);
5280,5282c5292,5293
< 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) {
< 		$pagelink = 0;
< 	}
---
> 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) { $pagelink = 0; }
> 	
5285a5297,5299
> 	foreach $name (@pglist) { $pgExists{$name} = 1; }
> 	%seen = ();
> 	
5287,5291d5300
< 		$pgExists{$name} = 1;
< 	}
< 	%seen = ();
< 	
< 	foreach $name (@pglist) {
5293,5295c5302
< 		if ( $unique != 2 ) {
< 			%seen = ();
< 		}
---
> 		if ( $unique != 2 ) { %seen = (); }
5298c5305,5309
< 	
---
> 		
> 		##if ($UseSubpage) {
> 		##	$main = $name;
> 		##	$main =~ s/\/.*//; 
> 		##}	
5299a5311,5312
> 			##if ($UseSubpage && ($link =~ /^\//)) { $link = $main . $link; }
>       
5308,5310d5320
< 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) {
< 				next;
< 			}
5312,5314c5322,5325
< 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) {
< 				next;
< 			}
---
> 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) { next; }			
> 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) { next; }			
> 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) { next; }			
> 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) { next; }
5316,5322d5326
< 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) {
< 				next;
< 			}
< 			
< 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) {
< 				next;
< 			}
5327,5329c5331
< 		if ($sort) {
< 			@links = sort(@links);
< 		}
---
> 		if ($sort) { @links = sort(@links); }
5429,5434c5431,5432
< 	if ($id =~ /($LinkPattern)/){
< 		$id = $1;
< 	}
< 	else {
< 		die "The page name $id is not valid";
< 	}
---
> 	if ($id =~ /($LinkPattern)/){ $id = $1; }
> 	else { die "The page name $id is not valid"; }
5436,5438c5434
< 	if ($FreeLinks){
< 		$id = &FreeToNormal($id);
< 	}
---
> 	if ($FreeLinks){ $id = &FreeToNormal($id); }
5470,5472c5466
< 	if ($LockCrash) {
< 		&RequestLock() or die( "Could not get editing lock" );
< 	}
---
> 	if ($LockCrash) { &RequestLock() or die( "Could not get editing lock" ); }
5474,5476c5468
< 		if ( !&RequestLock() ) {
< 			&ForceReleaseLock('main');
< 		}
---
> 		if ( !&RequestLock() ) { &ForceReleaseLock('main'); }
5618,5630c5610,5624
< 	my ( $to, $from, $reply, $subject, $message ) = @_;
< 
< 	# sendmail options:
< 	#    -odq : send mail to queue (i.e. later when convenient)
< 	#    -oi  : do not wait for "." line to exit
< 	#    -t   : headers determine recipient.
< 	open( SENDMAIL, "| $SendMail -oi -t " ) or die "Can't send email: $!\n";
< 	print SENDMAIL "From: $from\n";
< 	print SENDMAIL "To: $to\n";
< 	print SENDMAIL "Reply-to: $reply\n";
< 	print SENDMAIL "Subject: $subject\n";
< 	print SENDMAIL "$message\n";
< 	close(SENDMAIL) or warn "sendmail didn't close nicely";
---
>   my ($to, $from, $reply, $subject, $message) = @_;
> 
>   # sendmail options:
>   #    -odq : send mail to queue (i.e. later when convenient)
>   #    -oi  : do not wait for "." line to exit
>   #    -t   : headers determine recipient.
>   open (SENDMAIL, "| $SendMail -oi -t ") or die "Can't send email: $!\n";
>   print SENDMAIL <<"EOF";
> From: $from
> To: $to
> Reply-to: $reply
> Subject: $subject\n
> $message
> EOF
>   close(SENDMAIL) or warn "sendmail didn't close nicely";
5634c5629,5675
< 	local $/ = "\n";    # don't slurp whole files in this sub.
---
>   local $/ = "\n";   # don't slurp whole files in this sub.
> 
>   if ($EmailNotify) {
>     my ($id, $user) = @_;
>     if ($user) {
>       $user = " by $user";
>     }
>     my $address;
>     return  if (!-f $EmailFile);  # No notifications yet
>     open(EMAIL, $EmailFile)
>       or die "Can't open $EmailFile: $!\n";
>     $address = join ",", <EMAIL>;
>     $address =~ s/\n//g;
>     close(EMAIL);
>     my $home_url = $q->url();
>     my $page_url = $home_url . &ScriptLinkChar() . &UriEscape($id);
>     my $editors_summary = $q->param("summary");
>     if (($editors_summary eq "*") or ($editors_summary eq "")){
>       $editors_summary = "";
>     }
>     else {
>       $editors_summary = "\n Summary: $editors_summary";
>     }
>     my $content = <<"END_MAIL_CONTENT";
> 
>  The $SiteName page $id at
>    $page_url
>  has been changed$user to revision $Page{revision}. $editors_summary
> 
>  (Replying to this notification will
>   send email to the entire mailing list,
>   so only do that if you mean to.
> 
>   To remove yourself from this list, visit
>   ${home_url}?action=editprefs .)
> END_MAIL_CONTENT
>     my $subject = "The $id page at $SiteName has been changed.";
>     # I'm setting the "reply-to" field to be the same as the "to:" field
>     # which seems appropriate for a mailing list, especially since the
>     # $EmailFrom string needn't be a real email address.
>     &SendEmail($address, $EmailFrom, $address, $subject, $content);
>   }
> }
> 
> sub SearchTitleAndBody {
> 	my ($term, $filter) = @_;
> 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
5636,5640c5677,5690
< 	if ($EmailNotify) {
< 		my ( $id, $user ) = @_;
< 		
< 		if ($user) {
< 			$user = " by $user";
---
> 	#If the search term has a !preceding it, strip it and set the exclusion flag
> 	if ($term =~ m/^\!/){ 
> 		$excludeTerm = 1;
> 		$term = substr($term, 1);	
> 	}
> 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
> 	if ($filter =~ m/^\!/){ 
> 		$excludeFilter = 1;
> 		$filter = substr($filter, 1);	
> 	}
> 
> 	foreach $name ( &AllPagesList() ) {
> 		if ($excludeFilter){
> 			if ($filter) { next if ($name =~ m/$filter/); }
5641a5692,5694
> 		else {
> 			if ($filter) { next unless ($name =~ m/$filter/); }
> 		}
5643c5696,5697
< 		my $address;
---
> 		&OpenPage($name);
> 		&OpenDefaultText();
5645,5658c5699,5710
< 		return if ( !-f $EmailFile );    # No notifications yet
< 		
< 		open( EMAIL, $EmailFile )
< 		  or die "Can't open $EmailFile: $!\n";
< 		$address = join ",", <EMAIL>;
< 		$address =~ s/\n//g;
< 		close(EMAIL);
< 		
< 		my $home_url        = $q->url();
< 		my $page_url        = $home_url . "?$id";
< 		my $editors_summary = $q->param("summary");
< 
< 		if ( ( $editors_summary eq "*" ) or ( $editors_summary eq "" ) ) {
< 			$editors_summary = "";
---
> 		if (!$excludeTerm){  
> 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( $freeName =~ /$term/i ) {
> 					push( @found, $name );
> 				}
> 			}
5660,5661c5712,5723
< 		else {
< 			$editors_summary = " Summary: $editors_summary";
---
> 		else { 
> 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
> 				push( @found, $name );
> 			}
> 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
> 				$freeName = $name;
> 				$freeName =~ s/_/ /g;
> 				
> 				if ( ! ($freeName =~ /$term/i) ) {
> 					push( @found, $name );
> 				}
> 			}			
5662a5725,5736
> 	}
> 	
> 	return @found;
> }
> 
> sub SearchBody {
> 	my ($string) = @_;
> 	my ( $name, @found );
> 	
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
5664,5682c5738,5740
< 		my $content = <<"END_MAIL_CONTENT";
< 
<  The $SiteName page $id at
<    $page_url
<  has been changed$user to revision $Page{revision}. $editors_summary
< 
<  (Replying to this notification will
<   send email to the entire mailing list,
<   so only do that if you mean to.
< 
<   To remove yourself from this list, visit
<   ${home_url}?action=editprefs .)
< END_MAIL_CONTENT
< 		my $subject = "The $id page at $SiteName has been changed.";
< 
< 		# I'm setting the "reply-to" field to be the same as the "to:" field
< 		# which seems appropriate for a mailing list, especially since the
< 		# $EmailFrom string needn't be a real email address.
< 		&SendEmail( $address, $EmailFrom, $address, $subject, $content );
---
> 		if ( $Text{'text'} =~ /$string/i ) {
> 			push( @found, $name );
> 		}
5683a5742,5743
> 	
> 	return @found;
5686,5688c5746,5748
< sub SearchTitleAndBody {
< 	my ($term, $filter) = @_;
< 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
---
> sub UnlinkHtmlCache {
> 	my ($id) = @_;
> 	my $idFile;
5690,5693c5750,5753
< 	#If the search term has a !preceding it, strip it and set the exclusion flag
< 	if ($term =~ m/^\!/){ 
< 		$excludeTerm = 1;
< 		$term = substr($term, 1);	
---
> 	$idFile = &GetHtmlCacheFile($id);
> 	
> 	if ( -f $idFile ) {
> 		unlink($idFile);
5695,5698c5755,5766
< 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
< 	if ($filter =~ m/^\!/){ 
< 		$excludeFilter = 1;
< 		$filter = substr($filter, 1);	
---
> }
> 
> sub NewPageCacheClear {
> 	my ($id) = @_;
> 	my $name;
> 	
> 	return if ( !$UseCache );
> 	
> 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
> 	                    # The following code used to search the body for the $id
> 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
> 		&UnlinkHtmlCache($name);
5701,5741d5767
< 	foreach $name ( &AllPagesList() ) {
< 		if ($excludeFilter){
< 			if ($filter) { next if ($name =~ m/$filter/); }
< 		}
< 		else {
< 			if ($filter) { next unless ($name =~ m/$filter/); }
< 
< 		}
< 		
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if (!$excludeTerm){  
< 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( $freeName =~ /$term/i ) {
< 					push( @found, $name );
< 				}
< 			}
< 		}
< 		else { 
< 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( ! ($freeName =~ /$term/i) ) {
< 					push( @found, $name );
< 				}
< 			}			
< 		}
< 	}
< 	
< 	return @found;
5744,5746c5770,5772
< sub SearchBody {
< 	my ($string) = @_;
< 	my ( $name, @found );
---
> # Note: all diff and recent-list operations should be done within locks.
> sub DoUnlock {
> 	my $LockMessage = "Normal Unlock.";
5748,5755c5774,5777
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if ( $Text{'text'} =~ /$string/i ) {
< 			push( @found, $name );
< 		}
< 	}
---
> 	print &GetHeader( "", "Removing edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>This operation may take several seconds...</h2>\n";
5757,5762c5779,5781
< 	return @found;
< }
< 
< sub UnlinkHtmlCache {
< 	my ($id) = @_;
< 	my $idFile;
---
> 	if ( &ForceReleaseLock('main') ) {
> 		$LockMessage = "Forced Unlock.";
> 	}
5764c5783,5785
< 	$idFile = &GetHtmlCacheFile($id);
---
> 	&ForceReleaseLock('cache');
> 	&ForceReleaseLock('diff');
> 	&ForceReleaseLock('index');
5766,5768c5787,5790
< 	if ( -f $idFile ) {
< 		unlink($idFile);
< 	}
---
> 	print "\n<br><h2>$LockMessage</h2>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
5771,5773c5793,5796
< sub NewPageCacheClear {
< 	my ($id) = @_;
< 	my $name;
---
> # Note: all diff and recent-list operations should be done within locks.
> sub WriteRcLog {
> 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
> 	my ( $extraTemp, %extra );
5775c5798,5805
< 	return if ( !$UseCache );
---
> 	%extra = ();
> 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
> 	$extra{'name'}     = $name     if ( $name ne "" );
> 	$extra{'revision'} = $revision if ( $revision ne "" );
> 	$extraTemp = join( $FS2, %extra );
> 
> 	# The two fields at the end of a line are kind and extension-hash
> 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
5777,5780c5807,5808
< 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
< 	                    # The following code used to search the body for the $id
< 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
< 		&UnlinkHtmlCache($name);
---
> 	if ( !open( OUT, ">>$RcFile" ) ) {
> 		die( Ts( '%s log error:', $RCName ) . " $!" );
5781a5810,5812
> 	
> 	print OUT $rc_line . "\n";
> 	close(OUT);
5784,5786c5815,5816
< # Note: all diff and recent-list operations should be done within locks.
< sub DoUnlock {
< 	my $LockMessage = "Normal Unlock.";
---
> sub WriteDiff {
> 	my ( $id, $editTime, $diffString ) = @_;
5788,5791c5818,5831
< 	print &GetHeader( "", "Removing edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>This operation may take several seconds...</h2>\n";
---
> 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
> 	print OUT "------\n" . $id . "|" . $editTime . "\n";
> 	print OUT $diffString;
> 	close(OUT);
> }
> 
> # Actions are vetoable if someone edits the page before
> # the keep expiry time. For example, page deletion. If
> # no one edits the page by the time the keep expiry time
> # elapses, then no one has vetoed the last action, and the
> # action is accepted.
> # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
> sub ProcessVetos {
> 	my ($expirets);
5793,5795c5833
< 	if ( &ForceReleaseLock('main') ) {
< 		$LockMessage = "Forced Unlock.";
< 	}
---
> 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
5797,5799c5835
< 	&ForceReleaseLock('cache');
< 	&ForceReleaseLock('diff');
< 	&ForceReleaseLock('index');
---
> 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
5801,5810c5837,5840
< 	print "\n<br><h2>$LockMessage</h2>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub WriteRcLog {
< 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
< 	my ( $extraTemp, %extra );
---
> 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
> 		&DeletePage( $OpenPageName, 1, 1 );
> 		return ( 1, "(deleted)" );
> 	}
5812,5822c5842,5857
< 	%extra = ();
< 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
< 	$extra{'name'}     = $name     if ( $name ne "" );
< 	$extra{'revision'} = $revision if ( $revision ne "" );
< 	$extraTemp = join( $FS2, %extra );
< 
< 	# The two fields at the end of a line are kind and extension-hash
< 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
< 	
< 	if ( !open( OUT, ">>$RcFile" ) ) {
< 		die( Ts( '%s log error:', $RCName ) . " $!" );
---
> 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
> 		my $fname = $1;
> 
> 		# Only replace an allowed, existing file.
> 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
> 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
> 				my $string = $1;
> 				
> 				$string =~ s/\r\n/\n/gms;
> 				open( OUT, ">$fname" ) or return 0;
> 				print OUT $string;
> 				close OUT;
> 				
> 				return ( 0, "(replaced)" );
> 			}
> 		}
5824,5826c5859
< 	
< 	print OUT $rc_line . "\n";
< 	close(OUT);
---
> 	return ( 0, "(done)" );
5829,5830c5862,5863
< sub WriteDiff {
< 	my ( $id, $editTime, $diffString ) = @_;
---
> sub DoMaintain {
> 	my ( $name, $fname, $data, $message, $status );
5832,5845c5865,5868
< 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
< 	print OUT "------\n" . $id . "|" . $editTime . "\n";
< 	print OUT $diffString;
< 	close(OUT);
< }
< 
< # Actions are vetoable if someone edits the page before
< # the keep expiry time. For example, page deletion. If
< # no one edits the page by the time the keep expiry time
< # elapses, then no one has vetoed the last action, and the
< # action is accepted.
< # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
< sub ProcessVetos {
< 	my ($expirets);
---
> 	print &GetHeader( "", "Maintenance on all pages", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	$fname = "$DataDir/maintain";
5847c5870,5881
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
---
> 	if ( !&UserIsAdmin() ) {
> 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
> 			print "\nMaintenance not done. ";
> 			print "\n(Maintenance can only be done once every 12 hours.)";
> 			print "\nRemove the 'maintain' file or wait.";
> 			print "\n</div>";
> 			print &GetCommonFooter();
> 			print "\n</div></div></div></div></body></html>";
> 			
> 			return;
> 		}
> 	}
5849,5853c5883,5894
< 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
< 	
< 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
< 		&DeletePage( $OpenPageName, 1, 1 );
< 		return ( 1, "(deleted)" );
---
> 	&RequestLock() or die( "Could not get maintain-lock" );
> 
> 	foreach $name ( &AllPagesList() ) {
> 		&OpenPage($name);
> 		&OpenDefaultText();
> 		
> 		( $status, $message ) = &ProcessVetos();
> 		&ExpireKeepFile() unless $status;
> 		
> 		print "\n.... " if ( $name =~ m|/| );
> 		print &GetPageLink($name);
> 		print "\n $message<br>";
5854a5897,5902
> 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
> 	&ReleaseLock();
> 
> 	# Do any rename/deletion commands
> 	# (Must be outside lock because it will grab its own lock)
> 	$fname = "$DataDir/editlinks";
5856,5871c5904,5909
< 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
< 		my $fname = $1;
< 
< 		# Only replace an allowed, existing file.
< 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
< 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
< 				my $string = $1;
< 				
< 				$string =~ s/\r\n/\n/gms;
< 				open( OUT, ">$fname" ) or return 0;
< 				print OUT $string;
< 				close OUT;
< 				
< 				return ( 0, "(replaced)" );
< 			}
< 		}
---
> 	if ( -f $fname ) {
> 		$data = &ReadFileOrDie($fname);
> 		print "\n<hr>Processing rename/delete commands:<br>";
> 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
> 		unlink("$fname.old");
> 		rename( $fname, "$fname.old" );
5873,5877d5910
< 	return ( 0, "(done)" );
< }
< 
< sub DoMaintain {
< 	my ( $name, $fname, $data, $message, $status );
5879,5882c5912,5916
< 	print &GetHeader( "", "Maintenance on all pages", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	$fname = "$DataDir/maintain";
---
> 	if ($MaintTrimRc) {
> 		&RequestLock() or die( "Could not get lock for RC maintenance" );
> 		$status = &TrimRc();                # Consider error messages?
> 		&ReleaseLock();
> 	}
5884,5895c5918,5929
< 	if ( !&UserIsAdmin() ) {
< 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
< 			print "\nMaintenance not done. ";
< 			print "\n(Maintenance can only be done once every 12 hours.)";
< 			print "\nRemove the 'maintain' file or wait.";
< 			print "\n</div>";
< 			print &GetCommonFooter();
< 			print "\n</div></div></div></div></body></html>";
< 			
< 			return;
< 		}
< 	}
---
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> # Must be called within a lock.
> # Thanks to Alex Schroeder for original code
> sub TrimRc {
> 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
> 
> 	# Determine the number of days to go back
> 	$days = 0;
5897,5901c5931,5939
< 	&RequestLock() or die( "Could not get maintain-lock" );
< 
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
---
> 	foreach (@RcDays) {
> 		$days = $_ if $_ > $days;
> 	}
> 	$starttime = $Now - $days * 24 * 60 * 60;
> 	return 1 if ( !-f $RcFile );    # No work if no file exists
> 	( $status, $data ) = &ReadFile($RcFile);
> 	
> 	if ( !$status ) {
> 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
5903,5908c5941
< 		( $status, $message ) = &ProcessVetos();
< 		&ExpireKeepFile() unless $status;
< 		
< 		print "\n.... " if ( $name =~ m|/| );
< 		print &GetPageLink($name);
< 		print "\n $message<br>";
---
> 		return 0;
5911,5916c5944,5945
< 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
< 	&ReleaseLock();
< 
< 	# Do any rename/deletion commands
< 	# (Must be outside lock because it will grab its own lock)
< 	$fname = "$DataDir/editlinks";
---
> 	# Move the old stuff from rc to temp
> 	@rc = split( /\n/, $data );
5918,5923c5947,5949
< 	if ( -f $fname ) {
< 		$data = &ReadFileOrDie($fname);
< 		print "\n<hr>Processing rename/delete commands:<br>";
< 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
< 		unlink("$fname.old");
< 		rename( $fname, "$fname.old" );
---
> 	for ( $i = 0 ; $i < @rc ; $i++ ) {
> 		($ts) = split( /$FS3/, $rc[$i] );
> 		last if ( $ts >= $starttime );
5926,5930c5952
< 	if ($MaintTrimRc) {
< 		&RequestLock() or die( "Could not get lock for RC maintenance" );
< 		$status = &TrimRc();                # Consider error messages?
< 		&ReleaseLock();
< 	}
---
> 	return 1 if ( $i < 1 );    # No lines to move from new to old
5932,5943c5954,5962
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # Must be called within a lock.
< # Thanks to Alex Schroeder for original code
< sub TrimRc {
< 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
< 
< 	# Determine the number of days to go back
< 	$days = 0;
---
> 	@temp = splice( @rc, 0, $i );
> 
> 	# Write new files and backups
> 	if ( !open( OUT, ">>$RcOldFile" ) ) {
> 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
> 		return 0;
> 	}
> 	print OUT join( "\n", @temp ) . "\n";
> 	close(OUT);
5945,5950c5964,5967
< 	foreach (@RcDays) {
< 		$days = $_ if $_ > $days;
< 	}
< 	$starttime = $Now - $days * 24 * 60 * 60;
< 	return 1 if ( !-f $RcFile );    # No work if no file exists
< 	( $status, $data ) = &ReadFile($RcFile);
---
> 	&WriteStringToFile( $RcFile . '.old', $data );
> 	$data = join( "\n", @rc );
> 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
> 	&WriteStringToFile( $RcFile, $data );
5952,5959c5969,5975
< 	if ( !$status ) {
< 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
< 		
< 		return 0;
< 	}
< 
< 	# Move the old stuff from rc to temp
< 	@rc = split( /\n/, $data );
---
> 	return 1;
> }
> 
> sub DoMaintainRc {
> 	print &GetHeader( "", "Maintaining RC log", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
5961,5964c5977,5978
< 	for ( $i = 0 ; $i < @rc ; $i++ ) {
< 		($ts) = split( /$FS3/, $rc[$i] );
< 		last if ( $ts >= $starttime );
< 	}
---
> 	return if ( !&UserIsAdminOrError() );
> 	&RequestLock() or die( "Could not get lock for RC maintenance" );
5966c5980,5986
< 	return 1 if ( $i < 1 );    # No lines to move from new to old
---
> 	if ( &TrimRc() ) {
> 		print "\n<br>RC maintenance done.<br>";
> 	}
> 	else {
> 		print "\n<br>RC maintenance not done.<br>";
> 	}
> 	&ReleaseLock();
5968,5972c5988,5999
< 	@temp = splice( @rc, 0, $i );
< 
< 	# Write new files and backups
< 	if ( !open( OUT, ">>$RcOldFile" ) ) {
< 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
---
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> sub UserIsEditorOrError {
> 	if ( !&UserIsEditor() ) {
> 		print "\n<h2>This operation is restricted to site editors only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></body></html>";
> 			
5975,5976d6001
< 	print OUT join( "\n", @temp ) . "\n";
< 	close(OUT);
5978,5982d6002
< 	&WriteStringToFile( $RcFile . '.old', $data );
< 	$data = join( "\n", @rc );
< 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
< 	&WriteStringToFile( $RcFile, $data );
< 	
5986,5989c6006,6013
< sub DoMaintainRc {
< 	print &GetHeader( "", "Maintaining RC log", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
---
> sub UserIsAdminOrError {
> 	if ( !&UserIsAdmin() ) {
> 		print "\n<h2>This operation is restricted to administrators only...</h2>";
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></body></html>";	
> 		return 0;
> 	}
5991,6004c6015
< 	return if ( !&UserIsAdminOrError() );
< 	&RequestLock() or die( "Could not get lock for RC maintenance" );
< 	
< 	if ( &TrimRc() ) {
< 		print "\n<br>RC maintenance done.<br>";
< 	}
< 	else {
< 		print "\n<br>RC maintenance not done.<br>";
< 	}
< 	&ReleaseLock();
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
---
> 	return 1;
6007,6012c6018,6034
< sub UserIsEditorOrError {
< 	if ( !&UserIsEditor() ) {
< 		print "\n<h2>This operation is restricted to site editors only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></body></html>";
---
> sub CheckIsAuthUser {
> 	my ($id) = @_;
> 	my $auth = ""; 
> 	my $found = 0;
> 	my $authtype;
> 	my $authname; 
> 	my $aname;
> 	my $afname;
> 	my $linecount = 0;
> 
> 	if (!(&UserIsAdmin())) {
> 		$aname = $id;
> 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
> 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
> 		
> 		if (-r $afname) {			
> 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
6014c6036,6058
< 		return 0;
---
> 			open (AFN,"<$afname");
> 			while (<AFN>) {
> 				if (/$FS1/) { next; }       	# skip header and footer
> 				if (/^>\s[^\w]/) { next; }  	# skip comments	
> 				if (/diff-/){ next; }		
> 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
> 					$authtype = $1;
> 					$authname = $2; 
> 					
> 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
> 					elsif ($authtype eq "r"){ $authtype = "1"; }
> 					else { $authtype = "1"; }
> 					
> 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
> 				}
> 			}
> 			close AFN;
> 			if ($linecount == 0){ $auth = "3"; }
> 			elsif ($found == 0) { $auth = ""; }
> 		}
> 		else {
> 			$auth = "3";
> 		}
6016,6017c6060,6063
< 	
< 	return 1;
---
> 	else {
> 		$auth = "3";
> 	}
> 	return $auth;
6020,6027c6066,6067
< sub UserIsAdminOrError {
< 	if ( !&UserIsAdmin() ) {
< 		print "\n<h2>This operation is restricted to administrators only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></body></html>";	
< 		return 0;
< 	}
---
> sub DoEditLock {
> 	my ($fname);
6029c6069,6092
< 	return 1;
---
> 	print &GetHeader( "", "Set or Remove global edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	return if ( !&UserIsAdminOrError() );
> 	$fname = "$DataDir/noedit";
> 
> 	if ( &GetParam( "set", 1 ) ) {
> 		&WriteStringToFile( $fname, "editing locked." );
> 	}
> 	else {
> 		unlink($fname);
> 	}
> 	
> 	if ( -f $fname ) {
> 		print "\n<h2>Edit lock created.</h2>";
> 	}
> 	else {
> 		print "\n<h2>Edit lock removed.</h2>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
6032,6045c6095,6103
< sub CheckIsAuthUser {
< 	my ($id) = @_;
< 	my $auth = ""; 
< 	my $found = 0;
< 	my $authtype;
< 	my $authname; 
< 	my $aname;
< 	my $afname;
< 	my $linecount = 0;
< 
< 	if (!(&UserIsAdmin())) {
< 		$aname = $id;
< 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
< 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
---
> sub DoPageLock {
> 	my ( $fname, $id );
> 	
> 	print &GetHeader( "", "Set or Remove page edit lock", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	
> 	# Consider allowing page lock/unlock at editor level?
> 	return if ( !&UserIsAdminOrError() );
6047,6072c6105,6109
< 		if (-r $afname) {			
< 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
< 			
< 			open (AFN,"<$afname");
< 			while (<AFN>) {
< 				if (/$FS1/) { next; }       	# skip header and footer
< 				if (/^>\s[^\w]/) { next; }  	# skip comments	
< 				if (/diff-/){ next; }		
< 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
< 					$authtype = $1;
< 					$authname = $2; 
< 					
< 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
< 					elsif ($authtype eq "r"){ $authtype = "1"; }
< 					else { $authtype = "1"; }
< 					
< 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
< 				}
< 			}
< 			close AFN;
< 			if ($linecount == 0){ $auth = "3"; }
< 			elsif ($found == 0) { $auth = ""; }
< 		}
< 		else {
< 			$auth = "3";
< 		}
---
> 	$id = &GetParam( "id", "" );
> 	if ( $id eq "" ) {
> 		print "\n<p>Missing page id to lock/unlock...</p>";
> 		
> 		return;
6074,6081d6110
< 	else {
< 		$auth = "3";
< 	}
< 	return $auth;
< }
< 
< sub DoEditLock {
< 	my ($fname);
6083,6085c6112,6113
< 	print &GetHeader( "", "Set or Remove global edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
---
> 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
> 	$fname = &GetLockedPageFile($id);
6087,6089d6114
< 	return if ( !&UserIsAdminOrError() );
< 	$fname = "$DataDir/noedit";
< 
6096d6121
< 	
6098c6123
< 		print "\n<h2>Edit lock created.</h2>";
---
> 		print "\n<h2>Lock for '$id' created.</h2>";
6101c6126
< 		print "\n<h2>Edit lock removed.</h2>";
---
> 		print "\n<h2>Lock for '$id' removed.</h2>";
6103d6127
< 	
6109,6110c6133,6134
< sub DoPageLock {
< 	my ( $fname, $id );
---
> sub DoEditBanned {
> 	my ( $banList, $status );
6112c6136
< 	print &GetHeader( "", "Set or Remove page edit lock", "" );
---
> 	print &GetHeader( "", "Editing Banned list", "" );
6115,6116c6139
< 	
< 	# Consider allowing page lock/unlock at editor level?
---
> 		
6118,6124c6141,6142
< 		
< 	$id = &GetParam( "id", "" );
< 	if ( $id eq "" ) {
< 		print "\n<p>Missing page id to lock/unlock...</p>";
< 		
< 		return;
< 	}
---
> 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
> 	$banList = "" if ( !$status );
6126,6127c6144,6168
< 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
< 	$fname = &GetLockedPageFile($id);
---
> 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
> 	print GetHiddenValue( "edit_ban", 1 );
> 	print "\n<h2> Banned IP/network/host list:</h2>";
> 	print "\nEach entry is either a commented line (starting with #), ";
> 	print "\nor a Perl regular expression (matching either an IP address or ";
> 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
> 	print "\ngive up your admin access (remove password in Preferences).";
> 	print "\n<p><br><b>Example:</b><br><br>";
> 	print "\n# blocks hosts ending with .foocorp.com<br>";
> 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
> 	print "\n# blocks exact IP address<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
> 	print "\n# blocks whole 123.21.3.* IP network<br>";
> 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
> 	print &GetTextArea( 'banlist', $banList, 12, 50 );
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Save' );
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	;
> }
> 
> sub DoUpdateBanned {
> 	my ( $newList, $fname );
6129,6130c6170,6180
< 	if ( &GetParam( "set", 1 ) ) {
< 		&WriteStringToFile( $fname, "editing locked." );
---
> 	print &GetHeader( "", "Updating Banned list", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	return if ( !&UserIsAdminOrError() );
> 	
> 	$fname = "$DataDir/banlist";
> 	$newList = &GetParam( "banlist", "#Empty file" );
> 	
> 	if ( $newList eq "" ) {
> 		print "\n<p>Empty banned list or error.</p>";
> 		print "\n<p>Resubmit with at least one space character to remove.</p>";
6132c6182
< 	else {
---
> 	elsif ( $newList =~ /^\s*$/s ) {
6133a6184
> 		print "\n<p>Removed banned list</p>";
6136,6138d6185
< 	if ( -f $fname ) {
< 		print "\n<h2>Lock for '$id' created.</h2>";
< 	}
6140c6187,6188
< 		print "\n<h2>Lock for '$id' removed.</h2>";
---
> 		&WriteStringToFile( $fname, $newList );
> 		print "\n<p>Updated banned list</p>";
6147,6150c6195,6197
< sub DoEditBanned {
< 	my ( $banList, $status );
< 	
< 	print &GetHeader( "", "Editing Banned list", "" );
---
> # ==== Editing/Deleting pages and links ====
> sub DoEditLinks {
> 	print &GetHeader( "", "Editing Links", "" );
6153,6156d6199
< 		
< 	return if ( !&UserIsAdminOrError() );
< 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
< 	$banList = "" if ( !$status );
6157a6201,6207
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
> 	}
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
> 	
6159,6172c6209,6217
< 	print GetHiddenValue( "edit_ban", 1 );
< 	print "\n<h2> Banned IP/network/host list:</h2>";
< 	print "\nEach entry is either a commented line (starting with #), ";
< 	print "\nor a Perl regular expression (matching either an IP address or ";
< 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
< 	print "\ngive up your admin access (remove password in Preferences).";
< 	print "\n<p><br><b>Example:</b><br><br>";
< 	print "\n# blocks hosts ending with .foocorp.com<br>";
< 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
< 	print "\n# blocks exact IP address<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
< 	print "\n# blocks whole 123.21.3.* IP network<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
< 	print &GetTextArea( 'banlist', $banList, 12, 50 );
---
> 	print GetHiddenValue( "edit_links", 1 );
> 	print "\n<h2>Editing/Deleting page titles:</h2>";
> 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
> 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
> 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
> 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
> 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
> 	print &GetTextArea( 'commandlist', "", 12, 50 );
6174c6219,6233
< 	print $q->submit( -name => 'Save' );
---
> 	print $q->checkbox(
> 		-name     => "p_changerc",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Edit $RCName"
> 	);
> 	print "\n<br>";
> 	print $q->checkbox(
> 		-name     => "p_changetext",
> 		-override => 1,
> 		-checked  => 1,
> 		-label    => "Substitute text for rename"
> 	);
> 	print "\n<br><br>";
> 	print $q->submit( -name => 'Process Command' );
6176a6236
> 	
6178c6238
< 	print "\n</div></div></div></div></body></html>";	;
---
> 	print "\n</div></div></div></div></body></html>";	
6181,6182c6241,6242
< sub DoUpdateBanned {
< 	my ( $newList, $fname );
---
> sub UpdateLinksList {
> 	my ( $commandList, $doRC, $doText ) = @_;
6184,6187c6244,6248
< 	print &GetHeader( "", "Updating Banned list", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
---
> 	if ($doText) {
> 		&BuildLinkIndex();
> 	}
> 	&RequestLock() or die "UpdateLinksList could not get main lock";
> 	unlink($IndexFile) if ($UseIndex);
6189,6190c6250,6286
< 	$fname = "$DataDir/banlist";
< 	$newList = &GetParam( "banlist", "#Empty file" );
---
> 	foreach ( split( /\n/, $commandList ) ) {
> 		s/\s+$//g;
> 		
> 		next if ( !(/^[=!|?]/) );    # Only valid commands.
> 		print "\nProcessing $_<br>\n";
> 		
> 		if (/^\!(.+)/) {
> 			&DeletePage( $1, $doRC, $doText );
> 		}
> 		elsif (/^\?(.+)/){
> 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
> 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
> 			print "\n<br><br>";
> 		}
> 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
>       		my $GivenPage = $1;
>       		my $GivenNewName = $2;
>       
>       		if ($GivenPage =~ s[\/\*][]) {
>        			print "\nRenaming subpages of $GivenPage too...<br>";
>         
>         		foreach (&AllSubPagesList($GivenPage)) {
> 					my $NewSubName = $_;
> 					
> 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
> 					print "\nrenaming $_ to $NewSubName<br>";
> 					&RenamePage($_, $NewSubName, $doRC, $doText);
> 		        }
>       		}
> 		      # rename the page itself
> 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
> 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
> 		}
> 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
> 			&RenameTextLinks( $1, $2 );
> 		}
> 	}
6192,6194c6288,6300
< 	if ( $newList eq "" ) {
< 		print "\n<p>Empty banned list or error.</p>";
< 		print "\n<p>Resubmit with at least one space character to remove.</p>";
---
> 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
> 	unlink($IndexFile) if ($UseIndex);
> 	&ReleaseLock();
> }
> 
> sub BuildLinkIndex {
> 	my ( @pglist, $page, @links, $link, %seen );
> 	
> 	@pglist    = &AllPagesList();
> 	%LinkIndex = ();
> 	
> 	foreach $page (@pglist) {
> 		&BuildLinkIndexPage($page);
6196,6206d6301
< 	elsif ( $newList =~ /^\s*$/s ) {
< 		unlink($fname);
< 		print "\n<p>Removed banned list</p>";
< 	}
< 	else {
< 		&WriteStringToFile( $fname, $newList );
< 		print "\n<p>Updated banned list</p>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
6209,6213c6304,6306
< # ==== Editing/Deleting pages and links ====
< sub DoEditLinks {
< 	print &GetHeader( "", "Editing Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
---
> sub BuildLinkIndexPage {
> 	my ($page) = @_;
> 	my ( @links, $link, %seen );
6215,6220c6308,6309
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
< 	}
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
---
> 	@links = &GetPageLinks( $page, 1, 0, 0 );
> 	%seen = ();
6222,6249c6311,6325
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print GetHiddenValue( "edit_links", 1 );
< 	print "\n<h2>Editing/Deleting page titles:</h2>";
< 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
< 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
< 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
< 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
< 	print &GetTextArea( 'commandlist', "", 12, 50 );
< 	print "\n<br><br>";
< 	print $q->checkbox(
< 		-name     => "p_changerc",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Edit $RCName"
< 	);
< 	print "\n<br>";
< 	print $q->checkbox(
< 		-name     => "p_changetext",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Substitute text for rename"
< 	);
< 	print "\n<br><br>";
< 	print $q->submit( -name => 'Process Command' );
< 	print "\n</form>";
< 	print "\n</div>";
---
> 	foreach $link (@links) {
> 		if ( defined( $LinkIndex{$link} ) ) {
> 			if ( !$seen{$link} ) {
> 				$LinkIndex{$link} .= " " . $page;
> 			}
> 		}
> 		else {
> 			$LinkIndex{$link} .= " " . $page;
> 		}
> 		$seen{$link} = 1;
> 	}
> }
> 
> sub DoUpdateLinks {
> 	my ( $commandList, $doRC, $doText );
6251,6259c6327,6332
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub UpdateLinksList {
< 	my ( $commandList, $doRC, $doText ) = @_;
< 	
< 	if ($doText) {
< 		&BuildLinkIndex();
---
> 	print &GetHeader( "", "Updating Links", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ($AdminDelete) {
> 		return if ( !&UserIsAdminOrError() );
6261,6262c6334,6336
< 	&RequestLock() or die "UpdateLinksList could not get main lock";
< 	unlink($IndexFile) if ($UseIndex);
---
> 	else {
> 		return if ( !&UserIsEditorOrError() );
> 	}
6264,6265c6338,6375
< 	foreach ( split( /\n/, $commandList ) ) {
< 		s/\s+$//g;
---
> 	$commandList = &GetParam( "commandlist", "" );
> 	$doRC        = &GetParam( "p_changerc",  "0" );
> 	$doRC = 1 if ( $doRC eq "on" );
> 	$doText = &GetParam( "p_changetext", "0" );
> 	$doText = 1 if ( $doText eq "on" );
> 	
> 	if ( $commandList eq "" ) {
> 		print "\n<p>Empty command list or error.</p>";
> 	}
> 	else {
> 		&UpdateLinksList( $commandList, $doRC, $doText );
> 		print "\n<p>Finished command list.</p>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> sub EditRecentChanges {
> 	my ( $action, $old, $new ) = @_;
> 	
> 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
> 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
> }
> 
> sub EditRecentChangesFile {
> 	my ( $fname, $action, $old, $new, $printError ) = @_;
> 	my ( $status, $fileData, $errorText, $rcline, @rclist );
> 	my ( $outrc, $ts, $page, $junk );
> 	
> 	( $status, $fileData ) = &ReadFile($fname);
> 	
> 	if ( !$status ) {
> 
> 		# Save error text if needed.
> 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
> 		print $errorText if ($printError);
6267,6271c6377,6393
< 		next if ( !(/^[=!|?]/) );    # Only valid commands.
< 		print "\nProcessing $_<br>\n";
< 		
< 		if (/^\!(.+)/) {
< 			&DeletePage( $1, $doRC, $doText );
---
> 		return;
> 	}
> 	
> 	$outrc = "";
> 	@rclist = split( /\n/, $fileData );
> 	
> 	foreach $rcline (@rclist) {
> 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
> 		if ( $page eq $old ) {
> 			if ( $action == 1 ) {    # Delete
> 				;                    # Do nothing (don't add line to new RC)
> 			}
> 			elsif ( $action == 2 ) {
> 				$junk = $rcline;
> 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
> 				$outrc .= $junk . "\n";
> 			}
6273,6276c6395,6396
< 		elsif (/^\?(.+)/){
< 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
< 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
< 			print "\n<br><br>";
---
> 		else {
> 			$outrc .= $rcline . "\n";
6278,6299d6397
< 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
<       		my $GivenPage = $1;
<       		my $GivenNewName = $2;
<       
<       		if ($GivenPage =~ s[\/\*][]) {
<        			print "\nRenaming subpages of $GivenPage too...<br>";
<         
<         		foreach (&AllSubPagesList($GivenPage)) {
< 					my $NewSubName = $_;
< 					
< 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
< 					print "\nrenaming $_ to $NewSubName<br>";
< 					&RenamePage($_, $NewSubName, $doRC, $doText);
< 		        }
<       		}
< 		      # rename the page itself
< 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
< 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
< 		}
< 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
< 			&RenameTextLinks( $1, $2 );
< 		}
6302,6304c6400,6401
< 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
< 	unlink($IndexFile) if ($UseIndex);
< 	&ReleaseLock();
---
> 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
> 	&WriteStringToFile( $fname, $outrc );
6307,6308c6404,6407
< sub BuildLinkIndex {
< 	my ( @pglist, $page, @links, $link, %seen );
---
> # Delete and rename must be done inside locks.
> sub DeletePage {
> 	my ( $page, $doRC, $doText ) = @_;
> 	my ( $fname, $status );
6310,6311c6409,6412
< 	@pglist    = &AllPagesList();
< 	%LinkIndex = ();
---
> 	$page =~ s/ /_/g;
> 	$page =~ s/\[+//;
> 	$page =~ s/\]+//;
> 	$status = &ValidId($page);
6313,6314c6414,6416
< 	foreach $page (@pglist) {
< 		&BuildLinkIndexPage($page);
---
> 	if ( $status ne "" ) {
> 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
> 		return;
6316,6320d6417
< }
< 
< sub BuildLinkIndexPage {
< 	my ($page) = @_;
< 	my ( @links, $link, %seen );
6322,6323c6419,6435
< 	@links = &GetPageLinks( $page, 1, 0, 0 );
< 	%seen = ();
---
> 	$fname = &GetPageFile($page);
> 	unlink($fname) if ( -f $fname );
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	unlink($fname)     if ( -f $fname );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
> 	       # Currently don't do anything with page text
> }
> 
> # Given text, returns substituted text
> sub SubstituteTextLinks {
> 	my ( $old, $new, $text ) = @_;
> 
> 	# Much of this is taken from the common markup
> 	%SaveUrl      = ();
> 	$SaveUrlIndex = 0;
> 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
6325,6334c6437,6438
< 	foreach $link (@links) {
< 		if ( defined( $LinkIndex{$link} ) ) {
< 			if ( !$seen{$link} ) {
< 				$LinkIndex{$link} .= " " . $page;
< 			}
< 		}
< 		else {
< 			$LinkIndex{$link} .= " " . $page;
< 		}
< 		$seen{$link} = 1;
---
> 	if ($RawHtml) {
> 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
6336,6339d6439
< }
< 
< sub DoUpdateLinks {
< 	my ( $commandList, $doRC, $doText );
6341,6346c6441,6447
< 	print &GetHeader( "", "Updating Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
---
> 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
> 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
> 	
> 	if ($FreeLinks) {
> 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
> 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
6348,6350d6448
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
6352,6356c6450,6453
< 	$commandList = &GetParam( "commandlist", "" );
< 	$doRC        = &GetParam( "p_changerc",  "0" );
< 	$doRC = 1 if ( $doRC eq "on" );
< 	$doText = &GetParam( "p_changetext", "0" );
< 	$doText = 1 if ( $doText eq "on" );
---
> 	if ($BracketText) {         # Links like [URL text of link]
> 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
> 	}
6358,6359c6455,6459
< 	if ( $commandList eq "" ) {
< 		print "\n<p>Empty command list or error.</p>";
---
> 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
> 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
> 	
> 	if ($WikiLinks) {
> 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
6361,6364c6462,6463
< 	else {
< 		&UpdateLinksList( $commandList, $doRC, $doText );
< 		print "\n<p>Finished command list.</p>";
< 	}
---
> 	# Thanks to David Claughton for the following fix
> 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
6366,6368c6465
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
---
> 	return $text;
6371,6372c6468,6470
< sub EditRecentChanges {
< 	my ( $action, $old, $new ) = @_;
---
> sub SubFreeLink {
> 	my ( $link, $name, $old, $new ) = @_;
> 	my ($oldlink);
6374,6381c6472,6474
< 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
< 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
< }
< 
< sub EditRecentChangesFile {
< 	my ( $fname, $action, $old, $new, $printError ) = @_;
< 	my ( $status, $fileData, $errorText, $rcline, @rclist );
< 	my ( $outrc, $ts, $page, $junk );
---
> 	$oldlink = $link;
> 	$link =~ s/^\s+//;
> 	$link =~ s/\s+$//;
6383c6476,6479
< 	( $status, $fileData ) = &ReadFile($fname);
---
> 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
> 	{
> 		$link = $new;
> 	}
6385,6391c6481,6482
< 	if ( !$status ) {
< 
< 		# Save error text if needed.
< 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
< 		print $errorText if ($printError);
< 		
< 		return;
---
> 	else {
> 		$link = $oldlink;    # Preserve spaces if no match
6394,6395c6485
< 	$outrc = "";
< 	@rclist = split( /\n/, $fileData );
---
> 	$link = "[[$link";
6397,6411c6487,6488
< 	foreach $rcline (@rclist) {
< 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
< 		if ( $page eq $old ) {
< 			if ( $action == 1 ) {    # Delete
< 				;                    # Do nothing (don't add line to new RC)
< 			}
< 			elsif ( $action == 2 ) {
< 				$junk = $rcline;
< 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
< 				$outrc .= $junk . "\n";
< 			}
< 		}
< 		else {
< 			$outrc .= $rcline . "\n";
< 		}
---
> 	if ( $name ne "" ) {
> 		$link .= "|$name";
6414,6415c6491,6493
< 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
< 	&WriteStringToFile( $fname, $outrc );
---
> 	$link .= "]]";
> 	
> 	return &StoreRaw($link);
6418,6421c6496,6498
< # Delete and rename must be done inside locks.
< sub DeletePage {
< 	my ( $page, $doRC, $doText ) = @_;
< 	my ( $fname, $status );
---
> sub SubWikiLink {
> 	my ( $link, $old, $new ) = @_;
> 	my ($newBracket);
6423,6426c6500
< 	$page =~ s/ /_/g;
< 	$page =~ s/\[+//;
< 	$page =~ s/\]+//;
< 	$status = &ValidId($page);
---
> 	$newBracket = 0;
6428,6430c6502,6506
< 	if ( $status ne "" ) {
< 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
< 		return;
---
> 	if ( $link eq $old ) {
> 		$link = $new;
> 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
> 			$link = "[[$link]]";
> 		}
6433,6439c6509
< 	$fname = &GetPageFile($page);
< 	unlink($fname) if ( -f $fname );
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	unlink($fname)     if ( -f $fname );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
< 	       # Currently don't do anything with page text
---
> 	return &StoreRaw($link);
6442,6449c6512,6516
< # Given text, returns substituted text
< sub SubstituteTextLinks {
< 	my ( $old, $new, $text ) = @_;
< 
< 	# Much of this is taken from the common markup
< 	%SaveUrl      = ();
< 	$SaveUrlIndex = 0;
< 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
---
> # Rename is mostly copied from expire
> sub RenameKeepText {
> 	my ( $page, $old, $new ) = @_;
> 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
> 	my ( $sectName, $newText );
6451,6452c6518,6529
< 	if ($RawHtml) {
< 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
---
> 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
> 	return if ( !( -f $fname ) );
> 	( $status, $data ) = &ReadFile($fname);
> 	return if ( !$status );
> 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
> 	return if ( length(@kplist) < 1 );       # Also empty
> 	%tempSection = split( /$FS2/, $kplist[0], -1 );
> 
> 	if ( !defined( $tempSection{'keepts'} ) ) {
> 		return;
6453a6532,6533
> 	# First pass: optimize for nothing changed
> 	$changed = 0;
6455,6457c6535,6543
< 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
---
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$changed = 1 if ( $Text{'text'} ne $newText );
> 		}
> 	}
6459,6462c6545,6546
< 	if ($FreeLinks) {
< 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
< 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
< 	}
---
> 	return if ( !$changed );    # No sections changed
> 	open( OUT, ">$fname" ) or return;
6464,6466c6548,6560
< 	if ($BracketText) {         # Links like [URL text of link]
< 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
< 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
---
> 	foreach (@kplist) {
> 		%tempSection = split( /$FS2/, $_, -1 );
> 		$sectName = $tempSection{'name'};
> 		if ( $sectName =~ /^(text_)/ ) {
> 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
> 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
> 			$Text{'text'} = $newText;
> 			$tempSection{'data'} = join( $FS3, %Text );
> 			print OUT $FS1, join( $FS2, %tempSection );
> 		}
> 		else {
> 			print OUT $FS1, $_;
> 		}
6467a6562,6572
> 	close(OUT);
> }
> 
> sub RenameTextLinks {
> 	my ( $old, $new ) = @_;
> 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
> 	my ( $oldCanonical, @pageList );
> 	$old =~ s/ /_/g;
> 	$oldCanonical = &FreeToNormal($old);
> 	$new =~ s/ /_/g;
> 	$status = &ValidId($old);
6469,6470c6574,6577
< 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
< 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
---
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
> 		return;
> 	}
6472,6473c6579,6582
< 	if ($WikiLinks) {
< 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
---
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
> 		return;
6476,6479c6584,6622
< 	# Thanks to David Claughton for the following fix
< 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
< 	
< 	return $text;
---
> 	$old =~ s/_/ /g;
> 	$new =~ s/_/ /g;
> 
> 	# Note: the LinkIndex must be built prior to this routine
> 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
> 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
> 	foreach $page (@pageList) {
> 		$changed = 0;
> 		&OpenPage($page);
> 		foreach $section ( keys %Page ) {
> 			if ( $section =~ /^text_/ ) {
> 				&OpenSection($section);
> 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
> 				$oldText = $Text{'text'};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Text{'text'} = $newText;
> 					$Section{'data'} = join( $FS3, %Text );
> 					$Page{$section} = join( $FS2, %Section );
> 					$changed = 1;
> 				}
> 			}
> 			elsif ( $section =~ /^cache_diff/ ) {
> 				$oldText = $Page{$section};
> 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
> 				if ( $oldText ne $newText ) {
> 					$Page{$section} = $newText;
> 					$changed = 1;
> 				}
> 			}
> 
> 			# Add other text-sections (categories) here
> 		}
> 		if ($changed) {
> 			$file = &GetPageFile($page);
> 			&WriteStringToFile( $file, join( $FS1, %Page ) );
> 		}
> 		&RenameKeepText( $page, $old, $new );
> 	}
6482,6484c6625,6627
< sub SubFreeLink {
< 	my ( $link, $name, $old, $new ) = @_;
< 	my ($oldlink);
---
> sub RenamePage {
> 	my ( $old, $new, $doRC, $doText ) = @_;
> 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
6486,6488c6629,6631
< 	$oldlink = $link;
< 	$link =~ s/^\s+//;
< 	$link =~ s/\s+$//;
---
> 	$old =~ s/ /_/g;
> 	$new    = &FreeToNormal($new);
> 	$status = &ValidId($old);
6490,6492c6633,6635
< 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
< 	{
< 		$link = $new;
---
> 	if ( $status ne "" ) {
> 		print "\nRename: old page $old is invalid, error is: $status<br>";
> 		return;
6494,6496c6637,6640
< 	
< 	else {
< 		$link = $oldlink;    # Preserve spaces if no match
---
> 	$status = &ValidId($new);
> 	if ( $status ne "" ) {
> 		print "\nRename: new page $new is invalid, error is: $status<br>";
> 		return;
6498,6502c6642,6645
< 	
< 	$link = "[[$link";
< 	
< 	if ( $name ne "" ) {
< 		$link .= "|$name";
---
> 	$newfname = &GetPageFile($new);
> 	if ( -f $newfname ) {
> 		print "\nRename: new page $new already exists--not renamed.<br>";
> 		return;
6503a6647,6651
> 	$oldfname = &GetPageFile($old);
> 	if ( !( -f $oldfname ) ) {
> 		print "\nRename: old page $old does not exist--nothing done.<br>";
> 		return;
> 	}
6505,6507c6653,6666
< 	$link .= "]]";
< 	
< 	return &StoreRaw($link);
---
> 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
> 	rename( $oldfname, $newfname );
> 	&CreatePageDir( $KeepDir, $new );
> 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
> 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
> 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
> 	rename( $oldkeep, $newkeep );
> 	unlink($IndexFile) if ($UseIndex);
> 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
> 
> 	if ($doText) {
> 		&BuildLinkIndexPage($new);          # Keep index up-to-date
> 		&RenameTextLinks( $old, $new );
> 	}
6510,6512c6669,6684
< sub SubWikiLink {
< 	my ( $link, $old, $new ) = @_;
< 	my ($newBracket);
---
> sub DoShowVersion {
> 	print &GetHeader( "", "Displaying Wiki Version", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 	print "\n<h2>NobleWiki</h2>";
> 	print "\n<p>derived from UseModWiki version 1.0</p>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> sub GetCssChoices {
> 	my $choices = "";
> 	my $result = "";
> 	my $current = &GetParam('stylesheet', "");
> 	my $selected = "";
6514c6686,6695
< 	$newBracket = 0;
---
> 	opendir( TEMP, $CssDir );
> 	my @files = readdir(TEMP);
> 	closedir(TEMP);		
> 
> 	foreach my $file(@files){
> 		next unless ($file =~ /^wiki.*?\.css$/);    # allow wiki.something.css and wiki.css
> 		
> 		if ($current eq "/css/$file"){ $choices .= "\n<option value='/css/$file' selected='selected'>$file</option>"; }
> 		else { 	$choices .= "\n<option value='/css/$file'>$file</option>"; }
> 	}
6516,6521c6697,6699
< 	if ( $link eq $old ) {
< 		$link = $new;
< 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
< 			$link = "[[$link]]";
< 		}
< 	}
---
> 	$result .= "\n<select id='stylesheet' class='wikiselectbox' name='p_stylesheet'>";
> 	$result .= $choices;
> 	$result .= "\n</select>";
6523c6701
< 	return &StoreRaw($link);
---
> 	return $result;
6526,6530c6704,6706
< # Rename is mostly copied from expire
< sub RenameKeepText {
< 	my ( $page, $old, $new ) = @_;
< 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
< 	my ( $sectName, $newText );
---
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
> 	my ( $id, $status, $name ) = @_;
6532,6543c6708,6709
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	return if ( !( -f $fname ) );
< 	( $status, $data ) = &ReadFile($fname);
< 	return if ( !$status );
< 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	%tempSection = split( /$FS2/, $kplist[0], -1 );
< 
< 	if ( !defined( $tempSection{'keepts'} ) ) {
< 		return;
---
> 	if ($FreeLinks) {
> 		$id = &FreeToNormal($id);
6546,6547c6711,6720
< 	# First pass: optimize for nothing changed
< 	$changed = 0;
---
> 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
> }
> sub GetGallery {
> 	my ($params) = @_;
> 	my @lines = split(/\r?\n/, $params);
> 	my $lineNum = 0;
> 	my $imageNum = 0;
> 	my %options;
> 	my $images = "";
> 	my $text = "";
6549,6557c6722,6730
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$changed = 1 if ( $Text{'text'} ne $newText );
< 		}
< 	}
---
> 	my $defaultImage = "image1.jpg";
> 	my $defaultThumb = "thumb_image1.jpg";
> 	my $image;
> 	my $thumb;
> 	my $title;
> 	my $header;
> 	my $caption;
> 	my $description;
> 	my $thumbWidth = 100;
6559,6570c6732,6745
< 	return if ( !$changed );    # No sections changed
< 	open( OUT, ">$fname" ) or return;
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$Text{'text'} = $newText;
< 			$tempSection{'data'} = join( $FS3, %Text );
< 			print OUT $FS1, join( $FS2, %tempSection );
---
> 	$GLOBAL_galleryCount++;
> 		
> 	foreach my $line (@lines){
> 		%options = &GetOptions($line);
> 		
> 		if ($lineNum == 0){
> 			$lineNum++;
> 			
> 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
> 			if ($options{'description'}){ $description = $options{'description'}; }
> 			if ($options{'header'}){ $header = $options{'header'}; }
> 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
> 			
> 			next;	
6572,6573c6747,6757
< 		else {
< 			print OUT $FS1, $_;
---
> 		else {		
> 			if ($options{'image'}){ $image = $options{'image'}; }
> 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
> 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
> 			
> 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
> 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
> 			
> 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
> 				
> 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
6576,6586d6759
< 	close(OUT);
< }
< 
< sub RenameTextLinks {
< 	my ( $old, $new ) = @_;
< 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
< 	my ( $oldCanonical, @pageList );
< 	$old =~ s/ /_/g;
< 	$oldCanonical = &FreeToNormal($old);
< 	$new =~ s/ /_/g;
< 	$status = &ValidId($old);
6588,6591c6761,6762
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
---
> 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
> 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
6593,6596c6764,6802
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
< 		return;
---
> 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
> 	
> 	$text .= "\n	    <ul>";	
> 	$text .= $images;
> 	$text .= "\n	    </ul>";
> 	
> 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
> 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
> 	
> 	$text .= "\n	</div>";		
> 	
> 	return $text;
> }
> 
> sub GetFlash {
> 	my ($options) = @_;
> 	my %options = &GetOptions($options);	
> 	my $fpath = "$UploadUrl/";
> 	my $defaultSWF = 'ufo.swf';
> 	my $maxWidth = 400;
> 	my $maxHeight = 300;
> 	my $ratio = 1;
> 	
> 	my $text = "";
> 	
> 	my $fname;
> 	my $fwidth;
> 	my $fheight;
> 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
> 	my $idFO = "FO_$GLOBAL_flashCount";
> 
> 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
> 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
> 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
> 	
> 	if ($fwidth > $maxWidth){
> 		$ratio = $maxWidth / $fwidth;
> 		$fwidth = $maxWidth;
> 		$fheight = int ($ratio * $fheight);
6598,6635c6804,6807
< 	$old =~ s/_/ /g;
< 	$new =~ s/_/ /g;
< 
< 	# Note: the LinkIndex must be built prior to this routine
< 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
< 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
< 	foreach $page (@pageList) {
< 		$changed = 0;
< 		&OpenPage($page);
< 		foreach $section ( keys %Page ) {
< 			if ( $section =~ /^text_/ ) {
< 				&OpenSection($section);
< 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
< 				$oldText = $Text{'text'};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Text{'text'} = $newText;
< 					$Section{'data'} = join( $FS3, %Text );
< 					$Page{$section} = join( $FS2, %Section );
< 					$changed = 1;
< 				}
< 			}
< 			elsif ( $section =~ /^cache_diff/ ) {
< 				$oldText = $Page{$section};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Page{$section} = $newText;
< 					$changed = 1;
< 				}
< 			}
< 
< 			# Add other text-sections (categories) here
< 		}
< 		if ($changed) {
< 			$file = &GetPageFile($page);
< 			&WriteStringToFile( $file, join( $FS1, %Page ) );
< 		}
< 		&RenameKeepText( $page, $old, $new );
---
> 	elsif ($fheight > $maxHeight){
> 		$ratio = $maxHeight / $fheight;
> 		$fheight = $maxHeight;
> 		$fwidth = int ($ratio * $fwidth);
6637,6641c6809,6810
< }
< 
< sub RenamePage {
< 	my ( $old, $new, $doRC, $doText ) = @_;
< 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
---
> 			
> 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
6643,6645c6812,6830
< 	$old =~ s/ /_/g;
< 	$new    = &FreeToNormal($new);
< 	$status = &ValidId($old);
---
> 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
> 	$text .= "\n<script type='text/javascript'>";
> 	$text .= "\n			var fpath = '$fpath';";
> 	$text .= "\n			var fname = '$fname';";
> 	$text .= "\n			var fwidth = $fwidth;";
> 	$text .= "\n			var fheight = $fheight;";
> 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
> 	$text .= "\n			\$(window).load(function () {";
> 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
> 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
> 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
> 	$text .= "\n		    });";
> 	$text .= "\n		</script>";		
> 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
> 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
> 	$text .= "\n		<p style='clear: both;'></p>";
> 	$text .= "\n	</div>";
> 
> 	$GLOBAL_flashCount++;
6647,6665c6832,6839
< 	if ( $status ne "" ) {
< 		print "\nRename: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename: new page $new is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$newfname = &GetPageFile($new);
< 	if ( -f $newfname ) {
< 		print "\nRename: new page $new already exists--not renamed.<br>";
< 		return;
< 	}
< 	$oldfname = &GetPageFile($old);
< 	if ( !( -f $oldfname ) ) {
< 		print "\nRename: old page $old does not exist--nothing done.<br>";
< 		return;
< 	}
---
> 	return $text;		
> }
> sub GetAdminBar {
> 	my ($id, $cssClass) = @_;
> 	my ($result);
> 
> 	$result .= "\n<div $cssClass>";
> 	$result .= "Administration: ";
6667,6698c6841
< 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
< 	rename( $oldfname, $newfname );
< 	&CreatePageDir( $KeepDir, $new );
< 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
< 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
< 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
< 	rename( $oldkeep, $newkeep );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
< 
< 	if ($doText) {
< 		&BuildLinkIndexPage($new);          # Keep index up-to-date
< 		&RenameTextLinks( $old, $new );
< 	}
< }
< 
< sub DoShowVersion {
< 	print &GetHeader( "", "Displaying Wiki Version", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>NobleWiki</h2>";
< 	print "\n<p>derived from UseModWiki version 1.0</p>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub GetCssChoices {
< 	my $choices = "";
< 	my $result = "";
< 	my $current = &GetParam('stylesheet', "");
< 	my $selected = "";
---
> 	my ($notValid) = $id =~ /^\d*$/;
6700,6705c6843,6847
< 	opendir( TEMP, $CssDir );
< 	my @files = readdir(TEMP);
< 	closedir(TEMP);		
< 
< 	foreach my $file(@files){
< 		next unless ($file =~ /^wiki.*?\.css$/);    # allow wiki.something.css and wiki.css
---
> 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
> 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
> 	} 
6707,6709c6849,6850
< 		if ($current eq "/css/$file"){ $choices .= "\n<option value='/css/$file' selected='selected'>$file</option>"; }
< 		else { 	$choices .= "\n<option value='/css/$file'>$file</option>"; }
< 	}
---
> 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
> 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
6711,6713c6852,6863
< 	$result .= "\n<select id='stylesheet' class='wikiselectbox' name='p_stylesheet'>";
< 	$result .= $choices;
< 	$result .= "\n</select>";
---
> 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
> 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
> 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
> 	$result .= " | " . &ScriptLink( "action=orphans", "List Orphans" );
> 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
> 			
> 	if ( -f "$DataDir/noedit" ) {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
> 	}
> 	else {
> 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
> 	}
6714a6865,6866
> 	$result .= "</div>";
> 	
6718,6720c6870,6872
< # Admin bar contributed by ElMoro (with some changes)
< sub GetPageLockLink {
< 	my ( $id, $status, $name ) = @_;
---
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
> 	my ($id) = @_;
6722,6734c6874,6875
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 	}
< 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
< }
< sub GetGallery {
< 	my ($params) = @_;
< 	my @lines = split(/\r?\n/, $params);
< 	my $lineNum = 0;
< 	my $imageNum = 0;
< 	my %options;
< 	my $images = "";
< 	my $text = "";
---
> 	return if ( !&ValidIdOrDie($id) );
> 	return if ( !&UserIsAdminOrError() );
6736,6746c6877,6886
< 	my $defaultImage = "image1.jpg";
< 	my $defaultThumb = "thumb_image1.jpg";
< 	my $image;
< 	my $thumb;
< 	my $title;
< 	my $header;
< 	my $caption;
< 	my $description;
< 	my $thumbWidth = 100;
< 	
< 	$GLOBAL_galleryCount++;
---
> 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
> 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
> 		print &GetLeftNav("");
> 		print "\n<div class='wikiadmin'>";
> 		print "\n<h2>Delete Page?</h2>";
> 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
> 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
> 		print "\n</div>";
> 		print &GetCommonFooter();
> 		print "\n</div></div></div></div></body></html>";	
6748,6759c6888,6900
< 	foreach my $line (@lines){
< 		%options = &GetOptions($line);
< 		
< 		if ($lineNum == 0){
< 			$lineNum++;
< 			
< 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
< 			if ($options{'description'}){ $description = $options{'description'}; }
< 			if ($options{'header'}){ $header = $options{'header'}; }
< 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
< 			
< 			next;	
---
> 		return;
> 	}
> 	
> 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
> 	print &GetLeftNav("");	
> 	print "\n<div class='wikiadmin'>";
> 	
> 	if ( $id eq $HomePage ) {
> 		print Ts( '%s can not be deleted.', $HomePage );
> 	}
> 	else {
> 		if ( -f &GetLockedPageFile($id) ) {
> 			print Ts( '%s can not be deleted because it is locked.', $id );
6761,6771c6902,6908
< 		else {		
< 			if ($options{'image'}){ $image = $options{'image'}; }
< 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
< 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
< 			
< 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
< 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
< 			
< 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
< 				
< 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
---
> 		else {
> 
> 			# Must lock because of RC-editing
> 			&RequestLock() or die( "Could not get editing lock" );
> 			DeletePage( $id, 1, 1 );
> 			&ReleaseLock();
> 			print Ts( '%s has been deleted.', $id );
6775,6776c6912,6925
< 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
< 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
---
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
> 	print &GetHeader( "", "File Upload Page", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
6778c6927,6949
< 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
---
> 	print "\n<h2>Select File</h2>";
> 	print "\nThe current upload size limit is $MaxPost.<br>";
> 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
> 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
> 	print "\n<input type='hidden' name='upload' value='1' />";
> 	print "\nFile to Upload: ";
> 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
> 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
> 	print "\n</form>";
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
> }
> 
> sub SaveUpload {
> 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
> 	print &GetHeader( "", "Upload Finished", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";
> 		
> 	if ( !$AllUpload ) {
> 		return if ( !&UserIsEditorOrError() );
> 	}
6780,6782c6951,6954
< 	$text .= "\n	    <ul>";	
< 	$text .= $images;
< 	$text .= "\n	    </ul>";
---
> 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
> 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
> 	$filename = $q->param('file');
> 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
6784,6785c6956,6960
< 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
< 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
---
> 	$uploadFilehandle = $filename;
> 	open UPLOADFILE, ">$UploadDir$filename";
> 	binmode(UPLOADFILE);	
> 	while (<$uploadFilehandle>) { print UPLOADFILE; }
> 	close UPLOADFILE;
6787c6963,6964
< 	$text .= "\n	</div>";		
---
> 	print "\n<h2>Upload Completed</h2>";
> 	print "\nThe wiki link to your file is:<br><br>";
6789c6966,6977
< 	return $text;
---
> 	$printFilename = $filename;
> 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
> 	$fileUrl = $UploadUrl . $printFilename;
> 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
> 
> 	if ( $filename =~ /${ImageExtensions}$/ ) {
> 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
> 	}
> 	
> 	print "\n</div>";
> 	print &GetCommonFooter();
> 	print "\n</div></div></div></div></body></html>";	
6792,6799c6980,6982
< sub GetFlash {
< 	my ($options) = @_;
< 	my %options = &GetOptions($options);	
< 	my $fpath = "$UploadUrl/";
< 	my $defaultSWF = 'ufo.swf';
< 	my $maxWidth = 400;
< 	my $maxHeight = 300;
< 	my $ratio = 1;
---
> sub ConvertFsFile {
> 	my ( $oldFS, $newFS, $fname ) = @_;
> 	my ( $oldData, $newData, $status );
6801c6984,6985
< 	my $text = "";
---
> 	return if ( !-f $fname );           # Convert only existing regular files
> 	( $status, $oldData ) = &ReadFile($fname);
6803,6811c6987,6991
< 	my $fname;
< 	my $fwidth;
< 	my $fheight;
< 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
< 	my $idFO = "FO_$GLOBAL_flashCount";
< 
< 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
< 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
< 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
---
> 	if ( !$status ) {
> 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
> 		
> 		return;
> 	}
6813,6824c6993,6994
< 	if ($fwidth > $maxWidth){
< 		$ratio = $maxWidth / $fwidth;
< 		$fwidth = $maxWidth;
< 		$fheight = int ($ratio * $fheight);
< 	}
< 	elsif ($fheight > $maxHeight){
< 		$ratio = $maxHeight / $fheight;
< 		$fheight = $maxHeight;
< 		$fwidth = int ($ratio * $fwidth);
< 	}
< 			
< 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
---
> 	$newData = $oldData;
> 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
6826,6846c6996,6999
< 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
< 	$text .= "\n<script type='text/javascript'>";
< 	$text .= "\n			var fpath = '$fpath';";
< 	$text .= "\n			var fname = '$fname';";
< 	$text .= "\n			var fwidth = $fwidth;";
< 	$text .= "\n			var fheight = $fheight;";
< 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
< 	$text .= "\n			\$(window).load(function () {";
< 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
< 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
< 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
< 	$text .= "\n		    });";
< 	$text .= "\n		</script>";		
< 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
< 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
< 	$text .= "\n		<p style='clear: both;'></p>";
< 	$text .= "\n	</div>";
< 
< 	$GLOBAL_flashCount++;
< 	
< 	return $text;		
---
> 	return if ( $oldData eq $newData );    # Do not write if the same
> 	&WriteStringToFile( $fname, $newData );
> 
> 	# print $fname . '<br>';    # progress report
6848,6853c7002,7006
< sub GetAdminBar {
< 	my ($id, $cssClass) = @_;
< 	my ($result);
< 
< 	$result .= "\n<div $cssClass>";
< 	$result .= "Administration: ";
---
> # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
> # Note that top level directory (page/keep/user) contains only dirs
> sub ConvertFsDir {
> 	my ( $oldFS, $newFS, $topDir ) = @_;
> 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
6855c7008,7011
< 	my ($notValid) = $id =~ /^\d*$/;
---
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 	@dirs = sort(@dirs);
6857,6861c7013,7016
< 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
< 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
< 	} 
---
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$topDir/$dir" );             # Top level directories only
> 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
6863,6864c7018,7050
< 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
< 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
---
> 		opendir( DIRLIST, "$topDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
> 			$fname = "$topDir/$dir/$file";
> 			if ( -f $fname ) {
> 				# print $fname . '<br>';   # progress
> 				&ConvertFsFile( $oldFS, $newFS, $fname );
> 			}
> 			elsif ( -d $fname ) {
> 				opendir( DIRLIST, $fname );
> 				@subFiles = readdir(DIRLIST);
> 				closedir(DIRLIST);
> 				
> 				foreach $subFile (@subFiles) {
> 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
> 					$subFname = "$fname/$subFile";
> 					if ( -f $subFname ) {
> 						# print $subFname . '<br>';   # progress
> 						&ConvertFsFile( $oldFS, $newFS, $subFname );
> 					}
> 				}
> 			}
> 		}
> 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
> 	}
> }
> 
> sub ConvertFsCleanup {
> 	my ($topDir) = @_;
> 	my ( @dirs, $dir );
6866,6877c7052,7054
< 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
< 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
< 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
< 	$result .= " | " . &ScriptLink( "action=orphans", "List Orphans" );
< 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
< 			
< 	if ( -f "$DataDir/noedit" ) {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
< 	}
< 	else {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
< 	}
---
> 	opendir( DIRLIST, $topDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
6879,6881c7056,7061
< 	$result .= "</div>";
< 	
< 	return $result;
---
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-f "$topDir/$dir" );             # Remove only files...
> 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
> 		unlink "$topDir/$dir";
> 	}
6884,6886c7064,7066
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
< 	my ($id) = @_;
---
> sub DoConvert {
> 	my $oldFS = "\xb3";
> 	my $newFS = "\x1e\xff\xfe\x1e";
6888c7068,7070
< 	return if ( !&ValidIdOrDie($id) );
---
> 	print &GetHeader( "", "Convert wiki DB", "" );
> 	print &GetLeftNav("");
> 	print "\n<div class='wikiadmin'>";	
6891,6901c7073,7074
< 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
< 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
< 		print &GetLeftNav("");
< 		print "\n<div class='wikiadmin'>";
< 		print "\n<h2>Delete Page?</h2>";
< 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
< 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></div></body></html>";	
< 		
---
> 	if ( $FS ne $newFS ) {
> 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
6905,6907c7078,7080
< 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
< 	print &GetLeftNav("");	
< 	print "\n<div class='wikiadmin'>";
---
> 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
> 	print "\nWiki DB locked for conversion.<br>";
> 	print "\nConverting Wiki DB...<br>";
6909,6924c7082,7091
< 	if ( $id eq $HomePage ) {
< 		print Ts( '%s can not be deleted.', $HomePage );
< 	}
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) {
< 			print Ts( '%s can not be deleted because it is locked.', $id );
< 		}
< 		else {
< 
< 			# Must lock because of RC-editing
< 			&RequestLock() or die( "Could not get editing lock" );
< 			DeletePage( $id, 1, 1 );
< 			&ReleaseLock();
< 			print Ts( '%s has been deleted.', $id );
< 		}
< 	}
---
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
> 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
> 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
> 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
> 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
> 	&ConvertFsCleanup($PageDir);
> 	&ConvertFsCleanup($KeepDir);
> 	&ConvertFsCleanup($UserDir);
6925a7093,7094
> 	print "\nFinished converting wiki DB.<br>";
> 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
6931,6933c7100,7105
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
< 	print &GetHeader( "", "File Upload Page", "" );
---
> # Remove user-id files if no useful preferences set
> sub DoTrimUsers {
> 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
> 	my ( @dirs, @files, $dir, $file, $item );
> 	
> 	print &GetHeader( "", "Trim wiki users", "" );
6936,6939c7108
< 		
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
< 	}
---
> 	return if ( !&UserIsAdminOrError() );
6941,6959c7110,7118
< 	print "\n<h2>Select File</h2>";
< 	print "\nThe current upload size limit is $MaxPost.<br>";
< 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
< 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
< 	print "\n<input type='hidden' name='upload' value='1' />";
< 	print "\nFile to Upload: ";
< 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
< 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub SaveUpload {
< 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
< 	print &GetHeader( "", "Upload Finished", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
---
> 	$removed = 0;
> 	$maxID   = 1001;
> 	opendir( DIRLIST, $UserDir );
> 	@dirs = readdir(DIRLIST);
> 	closedir(DIRLIST);
> 
> 	foreach $dir (@dirs) {
> 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
6961,6962c7120,7150
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
---
> 		opendir( DIRLIST, "$UserDir/$dir" );
> 		@files = readdir(DIRLIST);
> 		closedir(DIRLIST);
> 		
> 		foreach $file (@files) {
> 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
> 				$id    = $1;
> 				$maxID = $id if ( $id > $maxID );
> 				%Data  = ();
> 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
> 				
> 				if ($status) {
> 					%Data =
> 					  split( /$FS1/, $data, -1 )
> 					  ;    # -1 keeps trailing null fields
> 					$keep = 0;
> 					
> 					foreach $item (qw(username password adminpw stylesheet)) {
> 						$keep = 1
> 						  if ( defined( $Data{$item} )
> 							&& ( $Data{$item} ne "" ) );
> 					}
> 					
> 					if ( !$keep ) {
> 						unlink "$UserDir/$dir/$file";
> 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
> 						$removed += 1;
> 					}
> 				}
> 			}
> 		}
6964,6988c7152,7153
< 	
< 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
< 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
< 	$filename = $q->param('file');
< 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
< 	
< 	$uploadFilehandle = $filename;
< 	open UPLOADFILE, ">$UploadDir$filename";
< 	binmode(UPLOADFILE);	
< 	while (<$uploadFilehandle>) { print UPLOADFILE; }
< 	close UPLOADFILE;
< 	
< 
< 	print "\n<h2>Upload Completed</h2>";
< 	print "\nThe wiki link to your file is:<br><br>";
< 	
< 	$printFilename = $filename;
< 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
< 	$fileUrl = $UploadUrl . $printFilename;
< 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
< 
< 	if ( $filename =~ /${ImageExtensions}$/ ) {
< 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
< 	}
< 	
---
> 	print Ts( 'Removed %s files.', $removed ) . '<br>';
> 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
6994,7013c7159,7163
< sub ConvertFsFile {
< 	my ( $oldFS, $newFS, $fname ) = @_;
< 	my ( $oldData, $newData, $status );
< 	
< 	return if ( !-f $fname );           # Convert only existing regular files
< 	( $status, $oldData ) = &ReadFile($fname);
< 	
< 	if ( !$status ) {
< 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
< 		
< 		return;
< 	}
< 	
< 	$newData = $oldData;
< 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
< 	
< 	return if ( $oldData eq $newData );    # Do not write if the same
< 	&WriteStringToFile( $fname, $newData );
< 
< 	# print $fname . '<br>';    # progress report
---
> sub DoAssetsToc {
> 	## Check $DataDir and see if assets-toc exists
> 	## -- if not, then build TOC
> 	## -- if does, but is older than 1 minute, rebuild TOC
> 	## Return TOC	
7016,7020c7165,7200
< # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
< # Note that top level directory (page/keep/user) contains only dirs
< sub ConvertFsDir {
< 	my ( $oldFS, $newFS, $topDir ) = @_;
< 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
---
> sub DoFilterToc {
> 	## Given @filters, pageIndex, pageSize
> 	## Get TOC from DoAssetsTOC
> 	## Apply @filters; sort, apply pageIndex * pageSize as offset
> 	## Return FilteredTOC	
> }
> sub DoListFiles {
> 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
> 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
> 	my ( $id, $filter, $managedisabled ) = @_;
> 
> 	if ($managedisabled){ 
> 		$targetDir = "$DisabledDir";
> 	}
> 	else {
> 		$targetDir = "$UploadDir";
> 	}
> 
> 	# CREATE array of filters
> 	$filter = lc($filter);
> 	$filter =~ s/\s//go;
> 	if ($filter ne ""){ 
> 		if ($filter =~ m/,/){
> 			@filters = split(',', $filter);
> 			
> 		}
> 		else {
> 			push (@filters, $filter);
> 		}
> 		$term = "using '<em>$filter</em>'";
> 	}
> 		
> 	# READ DIRECTORY	
> 	opendir( DIRLIST, $targetDir );
> 	@list = readdir(DIRLIST);
> 	closedir(DIRLIST);
7022,7030c7202,7205
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	@dirs = sort(@dirs);
< 	
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$topDir/$dir" );             # Top level directories only
< 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
---
> 	# RUN INCLUSIVE FILTERS
> 	foreach $file (@list){		
> 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
> 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
7032,7034c7207
< 		opendir( DIRLIST, "$topDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
---
> 		if ($filter eq ""){  push @includes, $file; next; }
7036,7046c7209,7224
< 		foreach $file (@files) {
< 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
< 			$fname = "$topDir/$dir/$file";
< 			if ( -f $fname ) {
< 				# print $fname . '<br>';   # progress
< 				&ConvertFsFile( $oldFS, $newFS, $fname );
< 			}
< 			elsif ( -d $fname ) {
< 				opendir( DIRLIST, $fname );
< 				@subFiles = readdir(DIRLIST);
< 				closedir(DIRLIST);
---
> 		$qualifies = 0;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;
> 			$include = $item;
> 					
> 			if ($item =~ m/^\!/){ next; }
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
> 		}
> 		
> 		if ($qualifies){ push @includes, $file; }
> 	}
> 
> 	# RUN EXCLUSIVE FILTERS
> 
> 	foreach $file (@includes){
> 		if ($filter eq ""){  push @files, $file; next; }
7048,7056c7226,7232
< 				foreach $subFile (@subFiles) {
< 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
< 					$subFname = "$fname/$subFile";
< 					if ( -f $subFname ) {
< 						# print $subFname . '<br>';   # progress
< 						&ConvertFsFile( $oldFS, $newFS, $subFname );
< 					}
< 				}
< 			}
---
> 		$qualifies = 1;						
> 		foreach $item (@filters){
> 			$item =~ s/\s//go;					
> 			unless ($item =~ m/^\!/){ next; }
> 			$include = substr($item, 1);
> 
> 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
7058c7234,7235
< 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
---
> 		
> 		if ($qualifies){ push @files, $file; }
7060,7064d7236
< }
< 
< sub ConvertFsCleanup {
< 	my ($topDir) = @_;
< 	my ( @dirs, $dir );
7066,7068c7238,7240
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
---
> 	print &GetHeader( "", "Manage Assets", "" );
> 	print &GetLeftNav($id);
> 	print "\n<div class='wikidiff'>";
7070,7074c7242,7262
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-f "$topDir/$dir" );             # Remove only files...
< 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
< 		unlink "$topDir/$dir";
---
> 	#return if ( !&UserIsEditorOrError() );
> 		
> 	if ($managedisabled){
> 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
> 		
> 		# MOVE file to disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $keeppath){
> 				if (-w $UploadDir){
> 					if (rename($keeppath, $uploadpath)){
> 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
7076,7080c7264,7286
< }
< 
< sub DoConvert {
< 	my $oldFS = "\xb3";
< 	my $newFS = "\x1e\xff\xfe\x1e";
---
> 	else {
> 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
> 		
> 		# MOVE file from disabled directory
> 		if ($id ne ""){
> 			$uploadpath = "$UploadDir/$id";
> 			$keeppath = "$DisabledDir/$id";
> 			
> 			if (-e $uploadpath){
> 				if (-w $DisabledDir){
> 					if (rename($uploadpath, $keeppath)){
> 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
> 					}
> 					else {
> 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	print "\n<table class='wikilargelist'>";
> 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
7082,7085c7288,7333
< 	print &GetHeader( "", "Convert wiki DB", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";	
< 	return if ( !&UserIsAdminOrError() );
---
> 	foreach $file (@files) {
> 		$filecount++;
> 		$linkname = "upload:$file";
> 		
> 		@links = SearchTitleAndBody($file, "", "");
> 		$numlinks = scalar(@links);
> 
> 		$title = "";
> 		$action = "";
> 			
> 		if ($managedisabled){			
> 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td>$file</td>";
> 			print "\n<td>$size</td>";			
> 			
> 			if ( &UserIsEditorOrAdmin() ){
> 				$title = "Click to re-enable file.";
> 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
> 			}
> 		}
> 		else {		
> 			$uploadpath = "$UploadUrl/$file";
> 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
> 			
> 			print "\n<tr>";
> 			print "\n<td><tt>$linkname</tt></td>";
> 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
> 			print "\n<td>$size</td>";
> 			
> 			if ($numlinks > 0){
> 				$title = "Click to see what pages link to this file.";
> 				$action = "href='$ScriptName?back=$file'";
> 			}
> 			elsif ( &UserIsEditorOrAdmin() ){
> 				$numlinks = "0";
> 				$title = "Click to disable file.";
> 				$action = "href='$ScriptName?action=listfiles&id=$file'";
> 			}		
> 		}
> 
> 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
> 		print "\n</tr>";
> 	}
7087,7089c7335,7336
< 	if ( $FS ne $newFS ) {
< 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
< 		return;
---
> 	if (scalar(@files) == 0){
> 		print "\n<td colspan='4'>No files available</td></tr>";
7090a7338,7341
> 	print "\n</table>";
> 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
> 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
> 	print "\n<input type='submit' value='Apply Filter'>";
7092,7094d7342
< 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
< 	print "\nWiki DB locked for conversion.<br>";
< 	print "\nConverting Wiki DB...<br>";
7096,7108c7344,7353
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
< 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
< 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
< 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
< 	&ConvertFsCleanup($PageDir);
< 	&ConvertFsCleanup($KeepDir);
< 	&ConvertFsCleanup($UserDir);
< 	
< 	print "\nFinished converting wiki DB.<br>";
< 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
---
> 	if ($managedisabled){
> 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
> 	}
> 	else {
> 		print "\n<input type='hidden' name='action' value='listfiles'>";
> 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
> 	}
> 	print "\nUse ! to exclude a term, separate terms with a comma";
> 	print "\n</form>";
7111c7357
< 	print "\n</div></div></div></div></body></html>";	
---
> 	print "\n</div></div></div></div></body></html>";				
7114,7374d7360
< # Remove user-id files if no useful preferences set
< sub DoTrimUsers {
< 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
< 	my ( @dirs, @files, $dir, $file, $item );
< 	
< 	print &GetHeader( "", "Trim wiki users", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	$removed = 0;
< 	$maxID   = 1001;
< 	opendir( DIRLIST, $UserDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
< 		
< 		opendir( DIRLIST, "$UserDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
< 		
< 		foreach $file (@files) {
< 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
< 				$id    = $1;
< 				$maxID = $id if ( $id > $maxID );
< 				%Data  = ();
< 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
< 				
< 				if ($status) {
< 					%Data =
< 					  split( /$FS1/, $data, -1 )
< 					  ;    # -1 keeps trailing null fields
< 					$keep = 0;
< 					
< 					foreach $item (qw(username password adminpw stylesheet)) {
< 						$keep = 1
< 						  if ( defined( $Data{$item} )
< 							&& ( $Data{$item} ne "" ) );
< 					}
< 					
< 					if ( !$keep ) {
< 						unlink "$UserDir/$dir/$file";
< 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
< 						$removed += 1;
< 					}
< 				}
< 			}
< 		}
< 	}
< 	print Ts( 'Removed %s files.', $removed ) . '<br>';
< 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub DoAssetsToc {
< 	## Check $DataDir and see if assets-toc exists
< 	## -- if not, then build TOC
< 	## -- if does, but is older than 1 minute, rebuild TOC
< 	## Return TOC	
< }
< sub DoFilterToc {
< 	## Given @filters, pageIndex, pageSize
< 	## Get TOC from DoAssetsTOC
< 	## Apply @filters; sort, apply pageIndex * pageSize as offset
< 	## Return FilteredTOC	
< }
< sub DoListFiles {
< 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
< 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
< 	my ( $id, $filter, $managedisabled ) = @_;
< 
< 	if ($managedisabled){ 
< 		$targetDir = "$DisabledDir";
< 	}
< 	else {
< 		$targetDir = "$UploadDir";
< 	}
< 
< 	# CREATE array of filters
< 	$filter = lc($filter);
< 	$filter =~ s/\s//go;
< 	if ($filter ne ""){ 
< 		if ($filter =~ m/,/){
< 			@filters = split(',', $filter);
< 			
< 		}
< 		else {
< 			push (@filters, $filter);
< 		}
< 		$term = "using '<em>$filter</em>'";
< 	}
< 		
< 	# READ DIRECTORY	
< 	opendir( DIRLIST, $targetDir );
< 	@list = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	
< 	# RUN INCLUSIVE FILTERS
< 	foreach $file (@list){		
< 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
< 		
< 		if ($filter eq ""){  push @includes, $file; next; }
< 		
< 		$qualifies = 0;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;
< 			$include = $item;
< 					
< 			if ($item =~ m/^\!/){ next; }
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
< 		}
< 		
< 		if ($qualifies){ push @includes, $file; }
< 	}
< 
< 	# RUN EXCLUSIVE FILTERS
< 
< 	foreach $file (@includes){
< 		if ($filter eq ""){  push @files, $file; next; }
< 				
< 		$qualifies = 1;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;					
< 			unless ($item =~ m/^\!/){ next; }
< 			$include = substr($item, 1);
< 
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
< 		}
< 		
< 		if ($qualifies){ push @files, $file; }
< 	}
< 	
< 	print &GetHeader( "", "Manage Assets", "" );
< 	print &GetLeftNav($id);
< 	print "\n<div class='wikidiff'>";
< 	
< 	#return if ( !&UserIsEditorOrError() );
< 		
< 	if ($managedisabled){
< 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
< 		
< 		# MOVE file to disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $keeppath){
< 				if (-w $UploadDir){
< 					if (rename($keeppath, $uploadpath)){
< 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 	else {
< 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
< 		
< 		# MOVE file from disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $uploadpath){
< 				if (-w $DisabledDir){
< 					if (rename($uploadpath, $keeppath)){
< 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 
< 	print "\n<table class='wikilargelist'>";
< 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
< 	
< 	foreach $file (@files) {
< 		$filecount++;
< 		$linkname = "upload:$file";
< 		
< 		@links = SearchTitleAndBody($file, "", "");
< 		$numlinks = scalar(@links);
< 
< 		$title = "";
< 		$action = "";
< 			
< 		if ($managedisabled){			
< 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td>$file</td>";
< 			print "\n<td>$size</td>";			
< 			
< 			if ( &UserIsEditorOrAdmin() ){
< 				$title = "Click to re-enable file.";
< 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
< 			}
< 		}
< 		else {		
< 			$uploadpath = "$UploadUrl/$file";
< 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
< 			print "\n<td>$size</td>";
< 			
< 			if ($numlinks > 0){
< 				$title = "Click to see what pages link to this file.";
< 				$action = "href='$ScriptName?back=$file'";
< 			}
< 			elsif ( &UserIsEditorOrAdmin() ){
< 				$numlinks = "0";
< 				$title = "Click to disable file.";
< 				$action = "href='$ScriptName?action=listfiles&id=$file'";
< 			}		
< 		}
< 
< 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
< 		print "\n</tr>";
< 	}
< 	
< 	if (scalar(@files) == 0){
< 		print "\n<td colspan='4'>No files available</td></tr>";
< 	}
< 	print "\n</table>";
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
< 	print "\n<input type='submit' value='Apply Filter'>";
< 	
< 	
< 	if ($managedisabled){
< 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
< 	}
< 	else {
< 		print "\n<input type='hidden' name='action' value='listfiles'>";
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
< 	}
< 	print "\nUse ! to exclude a term, separate terms with a comma";
< 	print "\n</form>";
< 	print "\n</div>";
< 
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";				
< }
< 
< 
------
NobleMission|1195948574
3a4,5
> <toc 250>
> 
7c9
< == How to Contribute =
---
> == Acquire and Account =
9a12,14
> == How to Contribute =
> There are several parallel projects in development.  Contribute to one or more projects later; pick a single project for now and focus on one or more of its tasks.  For example, for the [GRoWWII Giant Robots of World War II] project there's need for history, [GRoWWII/TOandE Tables of Organization and Equipment], and rules documentation.
> 
------
HomePage/RalphMorgan|1195985582
5c5
< UPLOADIMAGE = upload:homepage-RalphMorgan.jpg
---
> UPLOADIMAGE = upload:HomePage/homepage-RalphMorgan.jpg
------
HomePage/RobertKurcina|1195985810
4c4
< UPLOADIMAGE = upload:homepage-RobertKurcina.jpg
---
> UPLOADIMAGE = upload:HomePage/RobertKurcina.jpg
------
ImageGallery/ExampleGallery|1195986002
4,21c4,21
< thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip1
< thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip2
< thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip3
< thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip4
< thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip5
< thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip6
< thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip7
< thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip8
< thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip9
< thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip10
< thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip11
< thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip12
< thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip13
< thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip14
< thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip15
< thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip16
< thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip17
< thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip18
---
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip1
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip2
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip3
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip4
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip5
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip6
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip7
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip8
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip9
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip10
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip11
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip12
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip13
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip14
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip15
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip16
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip17
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip18
------
WikiGallery|1195986219
8,11c8,11
< thumb=thumb_image1.jpg|image=image1.jpg|title=pity caption for tooltip1
< thumb=thumb_image2.jpg|image=image2.jpg|title=pity caption for tooltip2
< thumb=thumb_image3.jpg|image=image3.jpg|title=pity caption for tooltip3
< thumb=thumb_image4.jpg|image=image4.jpg|title=pity caption for tooltip4
---
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip1
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip2
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip3
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip4
18,21c18,21
< thumb=thumb_image1.jpg|image=image1.jpg
< thumb=thumb_image2.jpg|image=image2.jpg
< thumb=thumb_image3.jpg|image=image3.jpg
< thumb=thumb_image4.jpg|image=image4.jpg
---
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg
29,32c29,32
< thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
< thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
< thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
< thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
---
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip1
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip2
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip3
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip4
38,41c38,41
< thumb=thumb_image12.jpg|image=image4.jpg|title=pity caption for tooltip1
< thumb=thumb_image2.jpg|image=image3.jpg|title=pity caption for tooltip2
< thumb=thumb_image3.jpg|image=image22.jpg|title=pity caption for tooltip3
< thumb=thumb_image14.jpg|image=image1.jpg|title=pity caption for tooltip4
---
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip1
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip2
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip3
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip4
------
FlashSWF/ExampleDiceRoller|1195986303
1c1
< #MAGIC Flash name=CDieD6.swf height=250 width=200
---
> #MAGIC Flash name=FlashSWF/CDieD6.swf height=250 width=200
------
FlashSWF/ExampleDiceland|1195986318
1c1
< #MAGIC Flash name=diceland.swf height=200 width=270
---
> #MAGIC Flash name=FlashSWF/diceland.swf height=200 width=270
------
FlashSWF/ExampleTimeNow|1195986332
1c1
< #MAGIC Flash name=TimeNow.swf height=200 width=270
---
> #MAGIC Flash name=FlashSWF/TimeNow.swf height=200 width=270
------
WikiFlash|1195986376
7c7
< {{flash:name=diceland.swf|width=400|height=300}}
---
> {{flash:name=FlashSWF/diceland.swf|width=400|height=300}}
12c12
< {{flash:name=diceland.swf|width=400|height=300}}
---
> {{flash:name=FlashSWF/diceland.swf|width=400|height=300}}
27c27
<   #MAGIC Flash name=diceland.swf height=300 width=200
---
>   #MAGIC Flash name=FlashSWF/diceland.swf height=300 width=200
------
GRoWWII|1195986477
4c4
< [LocalWiki:upload:nations.at.war.jpg upload:nations.at.war.jpg|width=400|boxwidth=410|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
---
> [LocalWiki:upload:nations.at.war.jpg upload:GRoWWII/nations.at.war.jpg|width=400|boxwidth=410|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
------
HomePage/RalphMorgan|1195986675
5c5
< UPLOADIMAGE = upload:HomePage/homepage-RalphMorgan.jpg
---
> UPLOADIMAGE = upload:HomePage/RalphMorgan.jpg
------
NobleWiki|1196352120
13c13
< ||Manage Assets||Files uploaded go into the uploads directory as active assets, and can be moved between the uploaded and disabled directories. Supports the naming filter.||
---
> ||Manage Assets||Files uploaded go into the uploads directory as active assets, and can be moved between the uploaded and disabled directories. Supports a naming filter, folder creation, and asset deletion.  See WikiUploads for more information.||
14a15,16
> ||CSS Selection||All CSS files named using the pattern <tt>wiki.*</tt> such as <tt>wiki.css</tt> or <tt>wiki.gray</tt> are made available automatically for selection via the Preferences interface.||
> ||Edit Box||The edit box and other textareas are always 100% width in every browser implementation.||
21c23
< ||Full Tables||Implemented UseMod:WikiPatches/WikiTemplate with a twist; specify alignment and cell width.  See WikiTables for more information||
---
> ||Full Tables||Revised UseMod:WikiPatches/WikiTemplate to allow option switches to control class, style, alignment, width, etc.  See WikiTables for more information||
24a26,28
> ||Expanded Config||Added a number of configuration variables.||
> ||Windows Config||Set <tt><nowiki>$Windows = 1</nowiki></tt> to remove CGITemp files after uploading assets.||
> 
------
NobleWiki|1196352341
81,82c81
< ||<tt><nowiki>@@CSS|media|StyleSheet</nowiki></tt>||Added at top of an editor's home-page to alter CSS used before rendering any wiki page.||
< ||<tt><nowiki>@@HTML|Template</nowiki></tt>||Added at top of page of an editor's home-page to use force wiki to render pages using a different HTML template.  Would require a rewrite so that NobleWiki uses a simple templating engine||
---
> ||<tt><nowiki>{{CSS|media|stylesheet}}</nowiki></tt>||Added at top of an editor's home-page to alter CSS used before rendering any wiki page.||
85d83
< ||<tt><nowiki>TOC Modification</nowiki></tt>||Allow just a single Table of Contents, and have it create entries based upon headers, numbered or otherwise.||
------
NobleWiki|1196352379
5c5
< This wiki for Noble Pursuit Games is derived from the freely available [Wiki:UseModWIki UseMod 1.0] wiki engine available as the Wiki:UseModWiki site.
---
> This wiki for Noble Pursuit Games is derived from the freely available [Wiki:UseModWIki UseMod 1.03] wiki engine available as the Wiki:UseModWiki site.
------
WikiMinimums|1196356883
1,2c1,73
< ====== Describe the new page here. =
< 
---
> = Minimum Wiki Elements =
> These are the minimum elements that come with a standard deployment of NobleWiki
> <toc>
> 
> == Pages =
> === Single Pages =
> **TourBusStop
> **HomePage
> **PageNotFound
> **AuthError
> **[MagicContent MagicContent.pm]
> **LoremIpsum
> **SandBox
> **InterMap
> **ExampleTemplate
> **FeaturedContent
> **ReallyLongPage
> **PrivateUserGroups
> **WikiMinimums
> === Collections =
> Each of these contain sub-pages or have numerous pages associated
> **ImageGallery
> **WikiTemplates
> **WikiEditing
> **WikiAdmin
> **FlashSWF
> **RelatedEntries
> 
> == Assets =
> === Standard Assets =
> These are within the file system and can only be updated by the site owner.
> **img/
> ***img/lightbox/*
> ***img/ufo/*
> ***img/wiki.default/*
> ***img/wiki.gray/*
> ***img/wiki.greyness/*
> ***img/wiki.purple/*
> **css/
> ***css/jquery.lightbox-0.4.css
> ***css/wiki.css
> ***css/wiki.default.css
> ***css/wiki.gray.css
> ***css/wiki.greyness.css
> ***css/wiki.purple.css
> **js/
> ***js/jquery-1.2.1.js
> ***js/jquery.lightbox-0.4.js
> ***js/ufo.js
> 
> === Upload Assets =
> These are set as default and can be modified, moved, or deleted via the Manage Assets interface.
> **attachments/
> ***attachments/sample_files*
> ***attachments/[ImageGallery ImageGallery]/*
> ***attachments/[FlashSWF FlashSWF]/*
> **disabled/*
> 
> == File System =
> *wiki/
> **wiki/includes-data
> **wiki/keep-data
> **wiki/page-data
> **wiki/temp-files
> **wiki/user-data
> 
> == Modules =
> *cgi-bin/
> **cgi-bin/diff.pm
> **cgi-bin/[MagicContent MagicContent.pm]
> **cgi-bin/utilities/trans.pl
> **cgi-bin/utilities/wiki-update-diff.cgi
> **cgi-bin/utilities/umtrans.pl
------
NobleWiki|1196385718
26,28d26
< ||Expanded Config||Added a number of configuration variables.||
< ||Windows Config||Set <tt><nowiki>$Windows = 1</nowiki></tt> to remove CGITemp files after uploading assets.||
< 
36a34,36
> ||Expanded Config||Added a number of configuration variables.||
> ||Windows Config||Set <tt><nowiki>$Windows = 1</nowiki></tt> to remove CGITemp files after uploading assets.||
> 
------
StarterPages|1196386291
1c1
< ====== Describe the new page here. =
---
> #REDIRECT WikiMinimums
------
FrontPage|1196386424
1c1
< ====== Describe the new page here. =
---
> #REDIRECT Homepage
------
SandBox|1196392239
1,7368c1,3
< <pre><nowiki>
< #!E:/Program Files/perl/bin/perl.exe
< # UseModWiki version 1.0.3 (September 12, 2007)
< # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
< # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
< # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
< #    <marcus@ira.uka.de>
< # ...which was based on
< #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
< #    and The Original WikiWikiWeb  (C) Ward Cunningham
< #        <ward@c2.com> (code reused with permission)
< # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
< #
< # This program is free software; you can redistribute it and/or modify
< # it under the terms of the GNU General Public License as published by
< # the Free Software Foundation; either version 2 of the License, or
< # (at your option) any later version.
< #
< # This program is distributed in the hope that it will be useful,
< # but WITHOUT ANY WARRANTY; without even the implied warranty of
< # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< # GNU General Public License for more details.
< #
< # You should have received a copy of the GNU General Public License
< # along with this program; if not, write to the
< #    Free Software Foundation, Inc.
< #    59 Temple Place, Suite 330
< #    Boston, MA 02111-1307 USA
< use Diff;
< use MagicContent;
< use Image::Size;
< 
< package UseModWiki;
< use strict;
< local $| = 1;    # Do not buffer output (localized for mod_perl)
< 
< # Configuration/constant variables:
< use vars qw(@RcDays @HtmlPairs @HtmlSingle
<   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
<   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
<   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
<   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
<   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
<   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
<   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
<   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
<   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
<   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
<   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
<   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
<   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
<   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
<   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
<   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
<   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
<   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine
<   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
<   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
<   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton $HomePagePrefix
<   $EditNameLink $UseMetaWiki @ImageSites $BracketImg $DisabledDir
<   $AllowInclusion $InclusionDir $NumberDatesDelim);
<   
< # Note: $NotifyDefault is kept because it was a config variable in 0.90
< # Other global variables:
< use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
<   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
<   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
<   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
<   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
<   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
<   $ConfigError $UploadPattern $WikiLineHeader $WikiLineHeaderPreview $WikiLineFooter $WikiLineDiff
<   $WikiLine $WikiLine1 $WikiLine2 $WikiLinePref $AutoMailto
<   $GLOBAL_imageCount $GLOBAL_flashCount $GLOBAL_galleryCount
<   $WikiLeftNav %TableCellDefaults $DownloadExtensions $CssDir $HomeDir
<   );
< 
< # == Configuration =====================================================
< $HomeDir 		  = "F:/ASSETS - Development/export/www/http/content/wiki.kurcina.org";
< $DataDir 		  = $HomeDir . "/wiki";    # Main wiki directory
< $CssDir	          = $HomeDir . "/docs/css";
< $DisabledDir      = $HomeDir . "/docs/disabled";
< $UploadDir        = $HomeDir . "/docs/attachments";
< 								  
< 
< $UseConfig = 0;    # 1 = use config file,    0 = do not look for config
< $ConfigFile = "$DataDir/config";    # Configuration file
< 
< # Default configuration (used if UseConfig is 0)
< $CookieName = "NobleWiki";          # Name for this wiki (for multi-wiki sites)
< $SiteName   = "Noble Pursuit Games Wiki";          # Name of site (used for titles)
< $HomePage   = "HomePage";           # Home page (change space to _)
< $HomePagePrefix = "HomePage/";      # Which page will be linked when a valid $username is clicked in the RC history; end with slash if using Sub pages
< $RCName     = "RecentChanges";      # Name of changes page (change space to _)
< $LogoUrl    = "";                   # URL for site logo ("" for no logo)
< $ENV{PATH}  = "/usr/bin/";          # Path used to find "diff"
< $ScriptTZ   = "";                   # Local time zone ("" means do not print)
< $RcDefault  = 7;                    # Default number of RecentChanges days
< @RcDays     = qw(1 3 7 30 90 180);  # Days for links on RecentChanges
< $KeepDays   = 14;                   # Days to keep old revisions
< $SiteBase   = "";                   # Full URL for <BASE> header
< 
< 								    # Set if the auto-detected URL is wrong
< $FullUrl    = "http://wiki.kurcina.org/cgi-bin/index.cgi";
< 									# Full URL (like http://foo.com/uploads)
< $UploadUrl  = "http://wiki.kurcina.org/attachments"; #
< $RedirType  = 1;                    # 1 = CGI.pm, 2 = script, 3 = no redirect
< $AdminPass  = "linhson";            # Set to non-blank to enable password(s)
< $EditPass   = "emerald";            # Like AdminPass, but for editing only
< $StyleSheet = "/css/wiki.default.css";   # URL for CSS stylesheet (like "/wiki.css")
< $NotFoundPg = "PageNotFound";       # Page for not-found links ("" for blank pg)
< $EmailFrom  = "NobleWiki";          # Text for "From: " field of email notes.
< $SendMail   = "/usr/sbin/sendmail"; # Full path to sendmail executable
< $AutoMailto = 1;					# 0 = off; 1 = convert email address automatically to mailTo:<address>
< 									# HTML for bottom of every page
< $FooterNote = "<a href='?action=editprefs'><div id='anylogo' title='access username'>&nbsp;</div></a>";                   
< 
< $EditNote   = "";                 # HTML notice above buttons on edit page
< $MaxPost    = 1024 * 5000;        # Maximum 210K posts (about 200K for pages)
< 								  # New page text ("" for default message)
< $NewText    = "====== Describe the new page here. =\n\n";                   
< $HttpCharset      = "";           # Charset for pages, like "iso-8859-2"
< 
< $InterWikiMoniker = "NobleWiki";  # InterWiki moniker for this wiki. (for RSS)
< $SiteDescription  = $SiteName;    # Description of this wiki. (for RSS)
< $RssLogoUrl       = "";           # Optional image for RSS feed
< $EarlyRules       = "";           # Local syntax rules for wiki->html (evaled)
< $LateRules        = "";           # Local syntax rules for wiki->html (evaled)
< $KeepSize         = 0;            # If non-zero, maximum size of keep file
< $BGColor          = "";           # Background color ('' to disable)
< $DiffColor1       = "#ffffaf";    # Background color of old/deleted text
< $DiffColor2       = "#cfffcf";    # Background color of new/added text
< $FavIcon          = "";           # URL of bookmark/favorites icon, or ''
< $RssDays          = 7;            # Default number of days in RSS feed
< $UserGotoBar      = "";           # HTML added to end of goto bar
< $UserGotoBar     .= "<a href='$ScriptName?WikiHelp'>Help</a>";
< 
< $UserHeader       = "";           # Optional HTML header additional content
< $UserHeader		 .= "\n<link rel='stylesheet' type='text/css' media='screen' href='/css/jquery.lightbox-0.4.css'/>";
< $UserHeader      .= "\n<script src='/js/jquery-1.2.1.js'></script>";
< $UserHeader      .= "\n<script src='/js/ufo.js'></script>";
< $UserHeader		 .= "\n<script src='/js/jquery.lightbox-0.4.js'></script>";
< 
< $UserBody         = "";           # Optional <BODY> tag additional content
< $StartUID         = 1001;         # Starting number for user IDs
< 								  # Full path (like /foo/www/uploads) for files
< 
< 
<       
< @ImageSites       = qw();         # Url prefixes of good image sites: ()=all
< 
< # Major options:
< $UseSubpage  = 1;             # 1 = use subpages,       0 = do not use subpages
< $UseCache    = 0;             # 1 = cache HTML pages,   0 = generate every page
< $EditAllowed = 1;             # 1 = editing allowed,    0 = read-only
< $RawHtml     = 0;             # 1 = allow <HTML> tag,   0 = no raw HTML in pages
< $HtmlTags    = 1;             # 1 = "unsafe" HTML tags, 0 = only minimal tags
< $UseDiff     = 1;             # 1 = use diff features,  0 = do not use diff
< $FreeLinks   = 1;             # 1 = use [[word]] links, 0 = LinkPattern only
< $WikiLinks   = 1;             # 1 = use LinkPattern,    0 = use [[word]] only
< $AdminDelete = 1;             # 1 = Admin only deletes, 0 = Editor can delete
< $RunCGI      = 1;             # 1 = Run script as CGI,  0 = Load but do not run
< $EmailNotify = 0;             # 1 = use email notices,  0 = no email on changes
< $EmbedWiki   = 0;             # 1 = no headers/footers, 0 = normal wiki pages
< $DeletedPage = "DeletedPage"; # 0 = disable, 'PageName' = tag to delete page
< $ReplaceFile = "ReplaceFile"; # 0 = disable, 'PageName' = indicator tag
< @ReplaceableFiles = ();       # List of allowed server files to replace
< $TableSyntax      = 1;        # 1 = wiki syntax tables, 0 = no table syntax
< $NewFS            = 1;        # 1 = new multibyte $FS,  0 = old $FS
< $UseUpload        = 1;        # 1 = allow uploads,      0 = no uploads
< $AllowInclusion = 1;          # 1 = files (*.txt,*.html) may be included by include:file.html,
< 	                          # 0 = files will not be included
< 	                          # from where shall the files be included?
< $InclusionDir = "$DataDir/includes-data"; 
<   
< # Minor options:
< $LogoLeft     = 1;    # 1 = logo on left,       0 = logo on right
< $RecentTop    = 1;    # 1 = recent on top,      0 = recent on bottom
< $UseDiffLog   = 1;    # 1 = save diffs to log,  0 = do not save diffs
< $KeepMajor    = 1;    # 1 = keep major rev,     0 = expire all revisions
< $KeepAuthor   = 1;    # 1 = keep author rev,    0 = expire all revisions
< $ShowEdits    = 0;    # 1 = show minor edits,   0 = hide edits by default
< $HtmlLinks    = 1;    # 1 = allow A HREF links, 0 = no raw HTML links
< $SimpleLinks  = 0;    # 1 = only letters,       0 = allow _ and numbers
< $NonEnglish   = 0;    # 1 = extra link chars,   0 = only A-Za-z chars
< $ThinLine     = 0;    # 1 = fancy <hr> tags,    0 = classic wiki <hr>
< $BracketText  = 1;    # 1 = allow [URL text],   0 = no link descriptions
< $UseAmPm      = 0;    # 1 = use am/pm in times, 0 = use 24-hour times
< $UseIndex     = 0;    # 1 = use index file,     0 = slow/reliable method
< $UseHeadings  = 1;    # 1 = allow = h1 text =,  0 = no header formatting
< $NetworkFile  = 1;    # 1 = allow remote file:, 0 = no file:// links
< $BracketWiki  = 1;    # 1 = [WikiLnk txt] link, 0 = no local descriptions
< $UseLookup    = 1;    # 1 = lookup host names,  0 = skip lookup (IP only)
< $FreeUpper    = 1;    # 1 = force upper case,   0 = do not force case
< $FastGlob     = 1;    # 1 = new faster code,    0 = old compatible code
< $MetaKeywords = 1;    # 1 = Google-friendly,    0 = search-engine averse
< $NamedAnchors = 1;    # 0 = no anchors, 1 = enable anchors,
<                       # 2 = enable but suppress display
< $SlashLinks   = 0;    # 1 = use script/action links, 0 = script?action
< $UpperFirst   = 1;    # 1 = free links start uppercase, 0 = no ucfirst
< $AdminBar     = 1;    # 1 = admins see admin links, 0 = no admin bar
< $RepInterMap  = 0;    # 1 = intermap is replacable, 0 = not replacable
< $ConfirmDel   = 1;    # 1 = delete link confirm page, 0 = immediate delete
< $MaskHosts    = 0;    # 1 = mask hosts/IPs,      0 = no masking
< $LockCrash    = 0;    # 1 = crash if lock stuck, 0 = auto clear locks
< $HistoryEdit  = 0;    # 1 = edit links on history page, 0 = no edit links
< $OldThinLine  = 0;    # 1 = old ==== thick line, 0 = ------ for thick line
< $NumberDates  = 1;    # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
< $NumberDatesDelim = "-"; # If $NumberDates is 1, this character separate the year, month, day
< $ParseParas   = 1;    # 1 = new paragraph markup, 0 = old markup
< $AuthorFooter = 1;    # 1 = show last author in footer, 0 = do not show
< $AllUpload    = 0;    # 1 = anyone can upload,   0 = only editor/admins
< $LimitFileUrl = 1;    # 1 = limited use of file: URLs, 0 = no limits
< $MaintTrimRc  = 1;    # 1 = maintain action trims RC, 0 = only maintainrc
< $SearchButton = 1;    # 1 = search button on page, 0 = old behavior
< $EditNameLink = 0;    # 1 = edit links use name (CSS), 0 = '?' links
< $UseMetaWiki  = 0;    # 1 = add MetaWiki search links, 0 = no MW links
< $BracketImg   = 1;    # 1 = [url url.gif] becomes image link, 0 = no img
< 
< $WikiLineHeader = "\n<div class='wikilineheader'></div>";
< $WikiLineHeaderPreview = "\n<div class='wikilineheaderpreview'></div>";
< $WikiLineFooter = "\n<div class='wikilinefooter'></div>";
< $WikiLineDiff   = "\n<div class='wikilinediff'></div>";
< $WikiLinePref   = "\n<div class='wikilinepref'></div>";
< $WikiLine       = "\n<div class='wikiline'>&nbsp;</div>";
< $WikiLine1      = "\n<div class='wikiline1'></div>";
< $WikiLine2      = "\n<div class='wikiline2'></div>";
< 
< # Names of sites.  (The first entry is used for the number link.)
< @IsbnNames = ( 'bn.com', 'amazon.com', 'search' );
< 
< # Full URL of each site before the ISBN
< @IsbnPre = (
< 	"http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=",
< 	"http://www.amazon.com/exec/obidos/ISBN=",
< 	"http://www.pricescan.com/books/BookDetail.asp?isbn="
< );
< 
< # Rest of URL of each site after the ISBN (usually '')
< @IsbnPost = ( "", "", "" );
< 
< # HTML tag lists, enabled if $HtmlTags is set.
< # Scripting is currently possible with these tags,
< # so they are *not* particularly "safe".
< # Tags that must be in <tag> ... </tag> pairs:
< @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
<   em s strike strong tt var div center blockquote ol ul dl caption);
< 
< # Single tags (that do not require a closing /tag)
< @HtmlSingle = qw(br p hr li dt dd tr td th);
< @HtmlPairs  = ( @HtmlPairs, @HtmlSingle );     # All singles can also be pairs
< 
< # == You should not have to change anything below this line. =============
< $IndentLimit = 20;                             # Maximum depth of nested lists
< $PageDir     = "$DataDir/page-data";           # Stores page data
< $HtmlDir     = "$DataDir/html-version";        # Stores HTML versions
< $UserDir     = "$DataDir/user-data";           # Stores user data
< $KeepDir     = "$DataDir/keep-data";           # Stores kept (old) page data
< $TempDir     = "$DataDir/temp-files";          # Temporary files and locks
< $LockDir     = "$TempDir/lock-dir";            # DB is locked if this exists
< $InterFile   = "$DataDir/intermap";            # Interwiki site->url map
< $RcFile      = "$DataDir/recent-log";          # New RecentChanges logfile
< $RcOldFile   = "$DataDir/oldrecent-log";       # Old RecentChanges logfile
< $IndexFile   = "$DataDir/page-index";          # List of all pages
< $EmailFile   = "$DataDir/email-list";          # Email notification lists
< 
< if ($RepInterMap) { push @ReplaceableFiles, $InterFile; }
< 
< # The "main" program, called at the end of this script file.
< sub DoWikiRequest {
< 	if ( $UseConfig && ( -f $ConfigFile ) ) {
< 		$ConfigError = "";
< 		if ( !do $ConfigFile ) {               # Some error occurred
< 			$ConfigError = $@;
< 			if ( $ConfigError eq "" ) {
< 
< 			  # Unfortunately, if the last expr returns 0, one will get a false
< 			  # error above.  To remain compatible with existing installs the
< 			  # wiki must not report an error unless there is error text in $@.
< 			  # (Errors in "use strict" may not have error text.)
< 			  # Uncomment the line below if you want to catch use strict errors.
< 			  #       $ConfigError = "Unknown Error (no error text)";
< 			}
< 		}
< 	}
< 	&InitLinkPatterns();
< 	if ( !&DoCacheBrowse() ) {
< 		eval $BrowseCode;
< 		&InitRequest() or return;
< 		if ( !&DoBrowseRequest() ) {
< 			eval $OtherCode;
< 			&DoOtherRequest();
< 		}
< 	}
< }
< 
< # == Common and cache-browsing code ====================================
< sub InitLinkPatterns {
< 	my ( $UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim );
< 
< 	# Field separators are used in the URL-style patterns below.
< 	if ($NewFS) {
< 		$FS = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
< 	}
< 	else {
< 		$FS = "\xb3";                # The FS character is a superscript "3"
< 	}
< 	$FS1         = $FS . "1";  # The FS values are used to separate fields
< 	$FS2         = $FS . "2";  # in stored hashtables and other data structures.
< 	$FS3         = $FS . "3";  # The FS character is not allowed in user data.
< 	$UpperLetter = "[A-Z";
< 	$LowerLetter = "[a-z";
< 	$AnyLetter   = "[A-Za-z";
< 	
< 	if ($NonEnglish) {
< 		$UpperLetter .= "\xc0-\xde";
< 		$LowerLetter .= "\xdf-\xff";
< 		if ($NewFS) {
< 			$AnyLetter .= "\x80-\xff";
< 		}
< 		else {
< 			$AnyLetter .= "\xc0-\xff";
< 		}
< 	}
< 	if ( !$SimpleLinks ) {
< 		$AnyLetter .= "_0-9";
< 	}
< 	$UpperLetter .= "]";
< 	$LowerLetter .= "]";
< 	$AnyLetter   .= "]";
< 
< 	# Main link pattern: lowercase between uppercase, then anything
< 	$LpA =
< 	  $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter . $AnyLetter . "*";
< 
< 	# Optional subpage link pattern: uppercase, lowercase, then anything
< 	$LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
< 	if ($UseSubpage) {
< 
< 		# Loose pattern: If subpage is used, subpage may be simple name
< 		$LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
< 
< 		# Strict pattern: both sides must be the main LinkPattern
< 		# $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
< 	}
< 	else {
< 		$LinkPattern = "($LpA)";
< 	}
< 	$QDelim = '(?:"")?';    # Optional quote delimiter (not in output)
< 	$AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
< 	$LinkPattern .= $QDelim;
< 
< 	# Inter-site convention: sites must start with uppercase letter
< 	# (Uppercase letter avoids confusion with URLs)
< 	$InterSitePattern = $UpperLetter . $AnyLetter . "+";
< 	$InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
< 	if ($FreeLinks) {
< 
< 		# Note: the - character must be first in $AnyLetter definition
< 		if ($NonEnglish) {
< 			if ($NewFS) {
< 				$AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
< 			}
< 			else {
< 				$AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
< 			}
< 		}
< 		else {
< 			$AnyLetter = "[-,.()' _0-9A-Za-z]";
< 		}
< 	}
< 	$FreeLinkPattern = "($AnyLetter+";
< 	if ($UseSubpage) {
< 		$FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+";
< 	}
< 	
< 	if ($NamedAnchors){
< 		$FreeLinkPattern .= "(?:#(?:\\w+))?)";
< 	}
< 	else {
< 		$FreeLinkPattern .= ")";
< 	}
< 	
< 	$FreeLinkPattern .= $QDelim;
< 
< 	# Url-style links are delimited by one of:
< 	#   1.  Whitespace                           (kept in output)
< 	#   2.  Left or right angle-bracket (< or >) (kept in output)
< 	#   3.  Right square-bracket (])             (kept in output)
< 	#   4.  A single double-quote (")            (kept in output)
< 	#   5.  A $FS (field separator) character    (kept in output)
< 	#   6.  A double double-quote ("")           (removed from output)
< 	$UrlProtocols    = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|prospero|telnet|gopher";
< 	$UrlProtocols   .= '|file' if ( $NetworkFile || !$LimitFileUrl );
< 	
< 	$UrlPattern      = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
< 	$ImageExtensions = "(gif|jpg|png|bmp|jpeg|ico|tiff)";
< 	$DownloadExtensions = "(pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)";
< 	$RFCPattern      = "RFC\\s?(\\d+)";
< 	$ISBNPattern     = "ISBN:?([0-9- xX]{10,})";
< 	$UploadPattern   = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
< }
< 
< # Simple HTML cache
< sub DoCacheBrowse {
< 	my ( $query, $idFile, $text );
< 	return 0 if ( !$UseCache );
< 	$query = $ENV{'QUERY_STRING'};
< 	if ( ( $query eq "" ) && ( $ENV{'REQUEST_METHOD'} eq "GET" ) ) {
< 		$query = $HomePage;    # Allow caching of home page.
< 	}
< 	if ( !( $query =~ /^$LinkPattern$/ ) ) {
< 		if ( !( $FreeLinks && ( $query =~ /^$FreeLinkPattern$/ ) ) ) {
< 			return 0;          # Only use cache for simple links
< 		}
< 	}
< 	$idFile = &GetHtmlCacheFile($query);
< 	if ( -f $idFile ) {
< 		local $/ = undef;      # Read complete files
< 		open( INFILE, "<$idFile" ) or return 0;
< 		$text = <INFILE>;
< 		close INFILE;
< 		print $text;
< 		return 1;
< 	}
< 	return 0;
< }
< 
< sub GetHtmlCacheFile {
< 	my ($id) = @_;
< 	return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
< }
< 
< sub GetPageDirectory {
< 	my ($id) = @_;
< 	if ( $id =~ /^([a-zA-Z])/ ) {
< 		return uc($1);
< 	}
< 	return "other";
< }
< 
< sub T {
< 	my ($text) = @_;
< 	
< 	if (defined($Translate{$text}) && ($Translate{$text} ne ''))  {
< 		return $Translate{$text};
< 	}
< 	return $text;
< }
< 
< sub Ts {
< 	my ($text, $string, $noquote) = @_;
< 	
< 	$string = &QuoteHtml($string) unless $noquote;
< 	$text = T($text);
< 	$text =~ s/\%s/$string/;
< 	
< 	return $text;
< }
< 
< sub Tss {
< 	my $text = $_[0];
< 	my @args = @_;
< 	
< 	@args = map { $_ = &QuoteHtml($_); } @args;
< 	$text = T($text);
< 	$text =~ s/\%([1-9])/$args[$1]/ge;
< 	
< 	return $text;
< }
< 
< # == Normal page-browsing and RecentChanges code =======================
< $BrowseCode = "";    # Comment next line to always compile (slower)
< 
< #$BrowseCode = <<'#END_OF_BROWSE_CODE';
< use CGI;
< use CGI::Carp qw(fatalsToBrowser);
< 
< sub InitRequest {
< 	my @ScriptPath = split( '/', "$ENV{SCRIPT_NAME}" );
< 	$CGI::POST_MAX = $MaxPost;
< 	
< 	if ($UseUpload) {
< 		$CGI::DISABLE_UPLOADS = 0;    # allow uploads
< 	}
< 	else {
< 		$CGI::DISABLE_UPLOADS = 1;    # no uploads
< 	}
< 	
< 	if ($SlashLinks && length($ENV{'PATH_INFO'}>1)){
< 		$ENV{'QUERY_STRING'} .= '&' if($ENV{'QUERY_STRING'});
< 		$ENV{'QUERY_STRING'} .= substr($ENV{'PATH_INFO'},1);
< 	}
< 	
< 	$q = new CGI();
< 	
< 	if ($SlashLinks){
< 		my $numberOfSlashes = ($ENV{'PATH_INFO'} = tr[/][/]);
< 		$ScriptName = ('../' x $numberOfSlashes) . $ScriptName;
< 	}
< 
< 	# Fix some issues with editing UTF8 pages (if charset specified)
< 	if ( $HttpCharset ne "" ) {
< 		$q->charset($HttpCharset);
< 	}
< 	$Now           = time;                # Reset in case script is persistent
< 	$ScriptName    = pop(@ScriptPath);    # Name used in links
< 		
< 	$IndexInit     = 0;                   # Must be reset for each request
< 	$InterSiteInit = 0;
< 	%InterSite     = ();
< 	$MainPage     = ".";    # For subpages only, the name of the top-level page
< 	$OpenPageName = "";     # Currently open page
< 	&CreateDir($DataDir);   # Create directory if it doesn't exist
< 
< 	if ( !-d $DataDir ) {
< 		&ReportError( "Could not create $DataDir : $!" );
< 		return 0;
< 	}
< 	&InitCookie();          # Reads in user data
< 	return 1;
< }
< 
< sub InitCookie {
< 	%SetCookie      = ();
< 	$TimeZoneOffset = 0;
< 	undef $q->{'.cookies'};    # Clear cache if it exists (for SpeedyCGI)
< 	%UserData   = ();                        # Fix for persistent environments.
< 	%UserCookie = $q->cookie($CookieName);
< 	$UserID     = $UserCookie{'id'};
< 	$UserID =~ s/\D//g;                      # Numeric only
< 	if ( $UserID < 200 ) {
< 		$UserID = 111;
< 	}
< 	else {
< 		&LoadUserData($UserID);
< 	}
< 	if ( $UserID > 199 ) {
< 		if (   ( $UserData{'id'} != $UserCookie{'id'} )
< 			|| ( $UserData{'randkey'} != $UserCookie{'randkey'} ) )
< 		{
< 			$UserID   = 113;
< 			%UserData = ();    # Invalid.  Consider warning message.
< 		}
< 	}
< 	if ( $UserData{'tzoffset'} != 0 ) {
< 		$TimeZoneOffset = $UserData{'tzoffset'} * ( 60 * 60 );
< 	}
< }
< 
< sub DoBrowseRequest {
< 	my ( $id, $action, $text );
< 	if ( !$q->param ) {        # No parameter
< 		&BrowsePage($HomePage);
< 		return 1;
< 	}
< 	$id = &GetParam( 'keywords', "" );
< 	if ($id) {                 # Just script?PageName
< 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
< 			$id = &FreeToNormal($id);
< 		}
< 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
< 			$id = $NotFoundPg;
< 		}
< 		&BrowsePage($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	$action = lc( &GetParam( 'action', "" ) );
< 	$id = &GetParam( 'id', "" );
< 	if ( $action eq 'browse' ) {
< 		if ( $FreeLinks && ( !-f &GetPageFile($id) ) ) {
< 			$id = &FreeToNormal($id);
< 		}
< 		if ( ( $NotFoundPg ne "" ) && ( !-f &GetPageFile($id) ) ) {
< 			$id = $NotFoundPg;
< 		}
< 		&BrowsePage($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	elsif ( $action eq 'rc' ) {
< 		&BrowsePage($RCName);
< 		return 1;
< 	}
< 	elsif ( $action eq 'random' ) {
< 		&DoRandom();
< 		return 1;
< 	}
< 	elsif ($action eq 'orphans') {
< 		&DoOrphanList();
< 		return 1;
< 	} 
< 	elsif ($action eq 'history') {
< 		&DoHistory($id) if &ValidIdOrDie($id);
< 		return 1;
< 	}
< 	return 0;    # Request not handled
< }
< 
< sub BrowsePage {
< 	my ($id) = @_;
< 	my ( $fullHtml, $oldId, $allDiff, $showDiff, $openKept );
< 	my ( $revision, $goodRevision, $diffRevision, $newText );
< 	my ( $fragHtml );
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$openKept = 0;
< 	$revision = &GetParam( 'revision', "" );
< 	$revision =~ s/\D//g;    # Remove non-numeric chars
< 	$goodRevision = $revision;    # Non-blank only if exists
< 
< 	if ( $revision ne "" ) {
< 		&OpenKeptRevisions('text_default');
< 		$openKept = 1;
< 		if ( !defined( $KeptRevisions{$revision} ) ) {
< 			$goodRevision = "";
< 		}
< 		else {
< 			&OpenKeptRevision($revision);
< 		}
< 	}
< 
< 	# Raw mode: just untranslated wiki text
< 	if ( &GetParam( 'raw', 0 ) ) {
< 		print &GetHttpHeader('text/plain');
< 		print $Text{'text'};
< 		return;
< 	}
< 	$newText = $Text{'text'};              # For differences
< 	                                       # Handle a single-level redirect
< 	$oldId   = &GetParam( 'oldid', "" );
< 	if (   ( $oldId eq "" )
< 		&& ( substr( $Text{'text'}, 0, 10 ) eq '#REDIRECT ' ) )
< 	{
< 		$oldId = $id;
< 		if ( ($FreeLinks) && ( $Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/ ) ) {
< 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/ );
< 			$id = &FreeToNormal($id);
< 		}
< 		else {
< 			($id) = ( $Text{'text'} =~ /\#REDIRECT\s+(\S+)/ );
< 		}
< 		
< 		if ( &ValidId($id) eq "" ) {
< 			# Consider revision in rebrowse?
< 			&ReBrowsePage( $id, $oldId, 0 );
< 			return;
< 		}
< 		else {    # Not a valid target, so continue as normal page
< 			$id    = $oldId;
< 			$oldId = "";
< 		}
< 	}
< 	$MainPage = $id;
< 	$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
< 	$fullHtml = &GetHeader( $id, &QuoteHtml($id), $oldId );
< 
< 	unless( $id eq $RCName ){ $fullHtml .= &GetLeftNav($id); }
< 	if ( $UseDiff && $showDiff ) {
< 		$fullHtml .= "\n<div class='wikiadmin'>";
< 	}
< 	else {
< 		unless ($id eq $RCName){ $fullHtml .= "\n<div class='wikitext'>"; }
< 		else { $fullHtml .= "\n<div class='wikiadmin'>"; }
< 	}
< 	
< 		if ( $revision ne "" ) {
< 		if ( ( $revision eq $Page{'revision'} ) || ( $goodRevision ne "" ) ) {
< 			$fragHtml = "\n<div class='wikidifftexttitle'>Showing revision $revision.</div>";
< 		}
< 		else {
< 			$fragHtml = "\n<div class='wikidifftexttitle'>Revision $revision not available, showing current revision instead.</div>";
< 		}
< 	}
< 	
< 	$fullHtml .= $fragHtml;	
< 	$allDiff = &GetParam( 'alldiff', 0 );
< 	if ( $allDiff != 0 ) { $allDiff = &GetParam( 'defaultdiff', 1 ); }
< 	
< 	if (
< 		(
< 			( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName )
< 		)
< 		&& &GetParam( 'norcdiff', 1 )
< 	  )
< 	{
< 		$allDiff = 0;    # Only show if specifically requested
< 	}
< 	
< 	$showDiff = &GetParam( 'diff', $allDiff );
< 	
< 	if ( $UseDiff && $showDiff ) {
< 		$diffRevision = $goodRevision;
< 		$diffRevision = &GetParam( 'diffrevision', $diffRevision );
< 
< 		# Eventually try to avoid the following keep-loading if possible?
< 		&OpenKeptRevisions('text_default') if ( !$openKept );
< 		$fullHtml .= &GetDiffHTML( $showDiff, $id, $diffRevision, $revision, $newText );
< 		$fullHtml .= $fragHtml;
< 
< 	}
< 
< 	# magiccontent patch - tarquin
< 	# Refactored and added position functionality --DavidClaughton.
< 	my ($magiccommand, $magicpos, $magicparams);
< 	my ($magicHTML, $magicDiv, $wikiHTML) = ("", "", "");
< 	
< 	if ( ($magicpos, $magiccommand, $magicparams) = $Text{'text'} =~ m[^\#MAGIC\s*(?:\@(top|bottom))?\s*(\w*)\s*(.*)\n] ){
< 		$Text{'text'} =~ s/^\#MAGIC.*\n//; # kill the magic command line in source
< 		$wikiHTML = &WikiToHTML($Text{'text'});
< 			
< 		# call: MakeSection( current page, magic module, line of parameters)
< 		$magicHTML .= (MagicContentMaker->MakeSection( $id, $magiccommand, $magicparams ) || "");
< 		
< 		if (lc $magicpos eq "top"){ $fullHtml .= $magicHTML . $magicDiv . $wikiHTML; }
< 		else { $fullHtml .= $wikiHTML . $magicDiv . $magicHTML; }
< 	}
< 	else {
< 		$fullHtml .= &WikiToHTML($Text{'text'});
< 	}
< 	
< 	if ( !&GetParam( 'embed', $EmbedWiki ) ) {
< 		$fullHtml .= "</div>";
< 		$fullHtml .= $WikiLineFooter;
< 	}
< 
< 	if ( ( $id eq $RCName ) || ( $RCName eq $id ) || ( $id eq $RCName ) ){
< 		print $fullHtml;
< 		print $WikiLineDiff;
< 		print &GetLeftNav($id);
< 		print "\n<div class='wikidiff'>";
< 		&DoRc(1);
< 		print "\n</div>";
< 		print "\n$WikiLineFooter" if ( !&GetParam( 'embed', $EmbedWiki ) );
< 		print &GetFooterText( $id, $goodRevision );
< 		print "\n</div></div></div></div></body></html>";
< 		
< 		return;
< 	}
< 	
< 	$fullHtml .= &GetFooterText( $id, $goodRevision );
< 	$fullHtml .= "</div></div></div></div></body></html>";
< 	
< 	print $fullHtml;
< 	
< 	return
< 	
< 	if ( $showDiff || ( $revision ne "" ) );    # Don't cache special version
< 	&UpdateHtmlCache( $id, $fullHtml ) if ( $UseCache && ( $oldId eq "" ) );
< }
< 
< sub ReBrowsePage {
< 	my ( $id, $oldId, $isEdit ) = @_;
< 	if ( $oldId ne "" ) {    
< 		# Target of #REDIRECT (loop breaking)
< 		print &GetRedirectPage( "action=browse&id=$id&oldid=$oldId", $id, $isEdit );
< 	}
< 	else {
< 		print &GetRedirectPage( $id, $id, $isEdit );
< 	}
< }
< 
< sub DoRc {
< 	my ($rcType) = @_;       # 0 = RSS, 1 = HTML
< 	my ( $fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly );
< 	my ( @fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML );
< 	my $starttime = 0;
< 	my $showbar   = 0;
< 	if ( 0 == $rcType ) {
< 		$showHTML = 0;
< 	}
< 	else {
< 		$showHTML = 1;
< 	}
< 	if ( &GetParam( "from", 0 ) ) {
< 		$starttime = &GetParam( "from", 0 );
< 		if ($showHTML) {
< 			print "\n<h2>";
< 			print "\nUpdates since " . &TimeToText($starttime);
< 			print "\n</h2>";
< 		}
< 	}
< 	else {
< 		$daysago = &GetParam( "days", 0 );
< 		$daysago = &GetParam( "rcdays", 0 ) if ( $daysago == 0 );
< 		if ($daysago) {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $daysago );
< 			if ($showHTML) {
< 				print "\n<h2>";
< 				print Ts( 'Updates in the last %s day' . ( ( $daysago != 1 ) ? "s" : "" ), $daysago );
< 				print "\n</h2>";
< 			}
< 
< 			# Note: must have two translations (for "day" and "days")
< 			# Following comment line is for translation helper script
< 			# Ts('Updates in the last %s days', '');
< 		}
< 	}
< 	if ( $starttime == 0 ) {
< 		if ( 0 == $rcType ) {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RssDays );
< 		}
< 		else {
< 			$starttime = $Now - ( ( 24 * 60 * 60 ) * $RcDefault );
< 		}
< 		if ($showHTML) {
< 			print "\n<h2>";
< 			print Ts('Updates in the last %s day'. ( ( $RcDefault != 1 ) ? "s" : "" ),$RcDefault );
< 			print "\n</h2>";
< 		}
< 
< 		# Translation of above line is identical to previous version
< 	}
< 
< 	# Read rclog data (and oldrclog data if needed)
< 	( $status, $fileData ) = &ReadFile($RcFile);
< 	$errorText = "";
< 	if ( !$status ) {
< 
< 		# Save error text if needed.
< 		$errorText = "\n<p><strong>";
< 		$errorText .= "Could not open $RCName log file";
< 		$errorText .= ":</strong> $RcFile</p>";
< 		$errorText .= "Error was ";
< 		$errorText .= ":<pre>$!</pre><p>";
< 		$errorText .= "Note: This error is normal if no changes have been made.";
< 
< 	}
< 	@fullrc = split( /\n/, $fileData );
< 	$firstTs = 0;
< 	if ( @fullrc > 0 ) {    # Only false if no lines in file
< 		($firstTs) = split( /$FS3/, $fullrc[0] );
< 	}
< 	if ( ( $firstTs == 0 ) || ( $starttime <= $firstTs ) ) {
< 		( $status, $oldFileData ) = &ReadFile($RcOldFile);
< 		if ($status) {
< 			@fullrc = split( /\n/, $oldFileData . $fileData );
< 		}
< 		else {
< 			if ( $errorText ne "" ) {    
< 			
< 				# could not open either rclog file
< 				print $errorText;
< 				print "\n<p><strong>";
< 				print "\nCould not open old $RCName log file";
< 				print "\n:</strong> $RcOldFile</p>";
< 				print "\nError was";
< 				print "\n:<pre>$!</pre>";
< 				
< 				return;
< 			}
< 		}
< 	}
< 	$lastTs = 0;
< 	if ( @fullrc > 0 ) {                 
< 		# Only false if no lines in file
< 		($lastTs) = split( /$FS3/, $fullrc[$#fullrc] );
< 	}
< 	$lastTs++ if ( ( $Now - $lastTs ) > 5 );    # Skip last unless very recent
< 	$idOnly = &GetParam( "rcidonly", "" );
< 	if ( $idOnly && $showHTML ) {
< 		print "\n<b>(";
< 		print "\nfor ";
< 		print &ScriptLink( $idOnly, $idOnly );
< 		print "\n only";
< 		print "\n)</b><br>";
< 	}
< 	if ($showHTML) {
< 		foreach $i (@RcDays) {
< 			print "\n | " if $showbar;
< 			$showbar = 1;
< 			print &ScriptLink( "action=rc&days=$i",
< 				Ts( '%s day' . ( ( $i != 1 ) ? 's' : '' ), $i ) );
< 
< 			# Note: must have two translations (for "day" and "days")
< 			# Following comment line is for translation helper script
< 			# Ts('%s days', '');
< 		}
< 		print "\n<br><br>";
< 		print &ScriptLink( "action=rc&from=$lastTs", "List new changes starting from" );
< 		print "\n " . &TimeToText($lastTs);
< 		print "\n<br><br>";
< 	}
< 	
< 	$i = 0;
< 	while ( $i < @fullrc ) {    
< 		# Optimization: skip old entries quickly
< 		($ts) = split( /\W/, $fullrc[$i] );
< 		if ( $ts >= $starttime ) {
< 			$i -= 1000 if ( $i > 0 );
< 			last;
< 		}
< 		$i += 1000;
< 	}
< 	
< 	$i -= 1000 if ( ( $i > 0 ) && ( $i >= @fullrc ) );
< 	for ( ; $i < @fullrc ; $i++ ) {
< 		($ts) = split( /\W/, $fullrc[$i] );
< 		last if ( $ts >= $starttime );
< 	}
< 	if ( $i == @fullrc && $showHTML ) {
< 		print "\n<br><strong>";
< 		print "\nNo updates since ";
< 		print &TimeToText($starttime);
< 		print "\n</strong><br>";
< 	}
< 	else {
< 		splice( @fullrc, 0, $i );    # Remove items before index $i
< 		
< 		# Consider an end-time limit (items older than X)
< 		if ( 0 == $rcType ) {
< 			print &GetRcRss(@fullrc);
< 		}
< 		else {
< 			print &GetRcHtml(@fullrc);
< 		}
< 	}
< 	if ($showHTML) {
< 		print "\nPage generated ";
< 		print &TimeToText($Now);
< 		print "\n<br>";
< 	}
< }
< 
< sub GetRc {
< 	my $rcType = shift;
< 	my @outrc  = @_;
< 	my ( $rcline,   $date, $newtop, $author, $inlist,   $result );
< 	my ( $showedit, $link, $all,    $idOnly, $headItem, $item );
< 	my ( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp );
< 	my ( $rcchangehist, $tEdit, $tChanges, $tDiff );
< 	my ( $headList, $historyPrefix, $diffPrefix );
< 	my %extra      = ();
< 	my %changetime = ();
< 	my %pagecount  = ();
< 
< 	# Slice minor edits
< 	$showedit = &GetParam( "rcshowedit", $ShowEdits );
< 	$showedit = &GetParam( "showedit",   $showedit );
< 	if ( $showedit != 1 ) {
< 		my @temprc = ();
< 		foreach $rcline (@outrc) {
< 			( $ts, $pagename, $summary, $isEdit, $host ) =
< 			  split( /$FS3/, $rcline );
< 			if ( $showedit == 0 ) {    # 0 = No edits
< 				push( @temprc, $rcline ) if ( !$isEdit );
< 			}
< 			else {                     # 2 = Only edits
< 				push( @temprc, $rcline ) if ($isEdit);
< 			}
< 		}
< 		@outrc = @temprc;
< 	}
< 
< 	# Optimize param fetches out of main loop
< 	$rcchangehist = &GetParam( "rcchangehist", 1 );
< 
< 	# Optimize translations out of main loop
< 	$tEdit         = "(edit)";
< 	$tDiff         = "(diff)";
< 	$tChanges      = "changes";
< 	$diffPrefix    = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
< 	$historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
< 	
< 	foreach $rcline (@outrc) {
< 		( $ts, $pagename ) = split( /$FS3/, $rcline );
< 		$pagecount{$pagename}++;
< 		$changetime{$pagename} = $ts;
< 	}
< 	
< 	$date     = "";
< 	$all      = &GetParam( "rcall", 0 );
< 	$all      = &GetParam( "all", $all );
< 	$newtop   = &GetParam( "rcnewtop", $RecentTop );
< 	$newtop   = &GetParam( "newtop", $newtop );
< 	$idOnly   = &GetParam( "rcidonly", "" );
< 	$inlist   = 0;
< 	$headList = "";
< 	$result   = "";
< 	@outrc    = reverse @outrc if ($newtop);
< 
< 	foreach $rcline (@outrc) {
< 		( $ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp ) =
< 		  split( /$FS3/, $rcline );
< 		next if ( ( !$all ) && ( $ts < $changetime{$pagename} ) );
< 		next if ( ( $idOnly ne "" ) && ( $idOnly ne $pagename ) );
< 		%extra = split( /$FS2/, $extraTemp, -1 );
< 		if ( $date ne &CalcDay($ts) ) {
< 			$date = &CalcDay($ts);
< 			if ( 1 == $rcType ) {    # HTML
< 				                     # add date, properly closing lists first
< 				if ($inlist) {
< 					$result .= "</ul>";
< 					$inlist = 0;
< 				}
< 				$result .= "\n<p><strong>" . $date . "</strong></p>";
< 				if ( !$inlist ) {
< 					$result .= "\n<ul>";
< 					$inlist = 1;
< 				}
< 			}
< 		}
< 		if ( 0 == $rcType ) {        # RSS
< 			( $headItem, $item ) = &GetRssRcLine(
< 				$pagename,          $ts,
< 				$host,              $extra{'name'},
< 				$extra{'id'},       $summary,
< 				$isEdit,            $pagecount{$pagename},
< 				$extra{'revision'}, $diffPrefix,
< 				$historyPrefix
< 			);
< 			$headList .= $headItem;
< 			$result   .= $item;
< 		}
< 		else {                       # HTML
< 			$result .= &GetHtmlRcLine(
< 				$pagename,          $ts,
< 				$host,              $extra{'name'},
< 				$extra{'id'},       $summary,
< 				$isEdit,            $pagecount{$pagename},
< 				$extra{'revision'}, $tEdit,
< 				$tDiff,             $tChanges,
< 				$all,               $rcchangehist
< 			);
< 		}
< 	}
< 	if ( 1 == $rcType ) {
< 		$result .= "</ul>" if ($inlist);    # Close final tag
< 	}
< 	return ( $headList, $result );            # Just ignore headList for HTML
< }
< 
< sub GetRcHtml {
< 	my ( $html, $extra );
< 	( $extra, $html ) = &GetRc( 1, @_ );
< 	return $html;
< }
< 
< sub GetHtmlRcLine {
< 	my (
< 		$pagename, $timestamp, $host,      $userName, $userID,
< 		$summary,  $isEdit,    $pagecount, $revision, $tEdit,
< 		$tDiff,    $tChanges,  $all,       $rcchangehist
< 	  )
< 	  = @_;
< 	my ( $author, $sum, $edit, $count, $link, $html );
< 	
< 	$html = "";
< 	$host = &QuoteHtml($host);
< 	if ( defined($userName) && defined($userID) ) {
< 		$author = &GetAuthorLink( $host, $userName, $userID );
< 	}
< 	else {
< 		$author = &GetAuthorLink( $host, "", 0 );
< 	}
< 	
< 	$sum = "";
< 	if ( ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$summary = &QuoteHtml($summary);
< 		$sum     = "<strong>[$summary]</strong> ";
< 	}
< 	
< 	$edit  = "";
< 	$edit  = "<em>$tEdit</em> " if ($isEdit);
< 	$count = "";	
< 	if ( ( !$all ) && ( $pagecount > 1 ) ) {
< 		$count = "($pagecount ";
< 		if ($rcchangehist) {
< 			$count .= &GetHistoryLink( $pagename, $tChanges, "Click to view revision history" );
< 		}
< 		else {
< 			$count .= $tChanges;
< 		}
< 		$count .= ") ";
< 	}
< 	
< 	$link = "";
< 	if ( $UseDiff && &GetParam( "diffrclink", 1 ) ) {
< 		$link .= &ScriptLinkDiff( 4, $pagename, $tDiff, "" ) . "  ";
< 	}
< 	$link .= &GetPageLink($pagename);
< 	$html .= "\n<li>$link ";
< 	$html .= &CalcTime($timestamp) . " : $count$edit" . " $sum";
< 	$html .= ". . . . . $author";
< 	return $html;
< }
< 
< sub GetRcRss {
< 	my ( $rssHeader, $headList, $items );
< 
< 	# Normally get URL from script, but allow override
< 	$FullUrl         = $q->url( -full => 1 ) if ( $FullUrl eq "" );
< 	$QuotedFullUrl   = &QuoteHtml($FullUrl);
< 	$SiteDescription = &QuoteHtml($SiteDescription);
< 	my $ChannelAbout =
< 	  &QuoteHtml( $FullUrl . &ScriptLinkChar() . $ENV{QUERY_STRING} );
< 	$rssHeader = <<RSS ;
< <?xml version="1.0" encoding="ISO-8859-1"?>
< <rdf:RDF
<     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
<     xmlns="http://purl.org/rss/1.0/"
<     xmlns:dc="http://purl.org/dc/elements/1.1/"
<     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
< >
<     <channel rdf:about="$ChannelAbout">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
<         <description>${\(&QuoteHtml($SiteDescription))}</description>
<         <wiki:interwiki>
<             <rdf:Description link="$QuotedFullUrl">
<                 <rdf:value>$InterWikiMoniker</rdf:value>
<             </rdf:Description>
<         </wiki:interwiki>
<         <items>
<             <rdf:Seq>
< RSS
< 	( $headList, $items ) = &GetRc( 0, @_ );
< 	$rssHeader .= $headList;
< 	return <<RSS ;
< $rssHeader
<             </rdf:Seq>
<         </items>
<     </channel>
<     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <url>$RssLogoUrl</url>
<         <link>$QuotedFullUrl</link>
<     </image>
< $items
< </rdf:RDF>
< RSS
< }
< 
< sub GetRssRcLine{
<   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
<       $isEdit, $pagecount, $revision, $diffPrefix, $historyPrefix) = @_;
<   my ($pagenameEsc, $itemID, $description, $authorLink, $author, $status,
<       $importance, $date, $item, $headItem);
< 
<   $pagenameEsc = CGI::escape($pagename);
<   # Add to list of items in the <channel/>
<   $itemID = $FullUrl . &ScriptLinkChar()
<             . &GetOldPageParameters('browse', $pagenameEsc, $revision);
<   $itemID = &QuoteHtml($itemID);
<   $headItem = "                <rdf:li rdf:resource=\"$itemID\"/>\n";
<   # Add to list of items proper.
<   if (($summary ne "") && ($summary ne "*")) {
<     $description = &QuoteHtml($summary);
<   }
<   $host = &QuoteHtml($host);
<   if ($userName) {
<     $author = &QuoteHtml($userName);
<     $authorLink = "link=\"$QuotedFullUrl?$author\"";
<   } else {
<     $author = $host;
<   }
<   $status = (1 == $revision) ? 'new' : 'updated';
<   $importance = $isEdit ? 'minor' : 'major';
<   $timestamp += $TimeZoneOffset;
<   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($timestamp);
<   $year += 1900;
<   $date = sprintf("%4d-%02d-%02dT%02d:%02d:%02d+%02d:00",
<     $year, $mon+1, $mday, $hour, $min, $sec, $TimeZoneOffset/(60*60));
<   $pagename = &QuoteHtml($pagename);
<   # Write it out longhand
<   $item = <<RSS ;
<     <item rdf:about="$itemID">
<         <title>$pagename</title>
<         <link>$QuotedFullUrl?$pagenameEsc</link>
<         <description>$description</description>
<         <dc:date>$date</dc:date>
<         <dc:contributor>
<             <rdf:Description wiki:host="$host" $authorLink>
<                 <rdf:value>$author</rdf:value>
<             </rdf:Description>
<         </dc:contributor>
<         <wiki:status>$status</wiki:status>
<         <wiki:importance>$importance</wiki:importance>
<         <wiki:diff>$diffPrefix$pagenameEsc</wiki:diff>
<         <wiki:version>$revision</wiki:version>
<         <wiki:history>$historyPrefix$pagenameEsc</wiki:history>
<     </item>
< RSS
<   return ($headItem, $item);
< }
< 
< sub DoRss {
< 	print "\nContent-type: text/xml\n\n";
< 	&DoRc(0);
< }
< 
< sub DoRandom {
< 	my ( $id, @pageList );
< 	
< 	@pageList = &AllPagesList();                              # Optimize?
< 	$id       = $pageList[ int( rand( $#pageList + 1 ) ) ];
< 	
< 	&ReBrowsePage( $id, "", 0 );
< }
<    
< sub DoHistory {
< 	my ($id) = @_;
< 	my ( $html, $canEdit, $row, $newText );
< 
< 	print &GetHeader( "", Ts( 'History of %s', $id ), "" );
< 	print &GetLeftNav($id);
< 	print "\n<div class='wikiadmin'>";
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$newText = $Text{'text'};
< 	$canEdit = 0;
< 	$canEdit = &UserCanEdit($id) if ($HistoryEdit);
< 		
< 	if ($UseDiff) {
<       print "\n<form id='wikiform' action='$ScriptName' method='get'>";
<       print "\n<input type='hidden' name='action' value='browse'/>";
<       print "\n<input type='hidden' name='diff' value='1'/>";
<       print "\n<input type='hidden' name='id' value='$id'/>";
<       print "\n<table class='wikihistory' border='0'>";
< 	}
< 	
< 	$html = &GetHistoryLine( $id, $Page{'text_default'}, $canEdit, $row++ );
< 	&OpenKeptRevisions('text_default');
< 	
< 	foreach ( reverse sort { $a <=> $b } keys %KeptRevisions ) {
< 		next if ( $_ eq "" );    # (needed?)
< 		$html .= &GetHistoryLine( $id, $KeptRevisions{$_}, $canEdit, $row++ );
< 	}
< 	
< 	print $html;
< 	
< 	if ($UseDiff) {
< 		my $label = "Compare";
< 		
< 		print "\n<tr><td colspan='5' align='left'><br>";
< 		print "\n<input type='submit' value='$label'/>&nbsp;&nbsp;</td></tr></table></form>";
< 		print &GetDiffHTML( &GetParam( 'defaultdiff', 1 ), $id, "", "", $newText );
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub GetMaskedHost {
< 	my ($text) = @_;
< 	my ($logText);
< 	if ( !$MaskHosts ) {
< 		return $text;
< 	}
< 	$logText = "(logged)";
< 	if ( !( $text =~ s/\d+$/$logText/ ) ) { # IP address (ending numbers masked)
< 		$text =~ s/^[^\.\(]+/$logText/;     # Host name: mask until first .
< 	}
< 	return $text;
< }
< 
< sub GetHistoryLine {
< 	my ( $id, $section, $canEdit, $row ) = @_;
< 	my ( $html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor );
< 	my ( %sect, %revtext );
< 	
< 	%sect = split( /$FS2/, $section, -1 );
< 	%revtext = split( /$FS3/, $sect{'data'} );
< 	$rev     = $sect{'revision'};
< 	$summary = $revtext{'summary'};
< 	
< 	if ( ( defined( $sect{'host'} ) ) && ( $sect{'host'} ne "" ) ) {
< 		$host = $sect{'host'};
< 	}
< 	else {
< 		$host = $sect{'ip'};
< 	}
< 	
< 	$host     = &GetMaskedHost($host);
< 	$user     = $sect{'username'};
< 	$uid      = $sect{'id'};
< 	$ts       = $sect{'ts'};
< 	$minor    = "";
< 	$minor    = "<i>(edited) </i>" if ( $revtext{'minor'} );
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 
< 	if ($UseDiff) {
< 		my ( $c1, $c2 );
< 		
< 		$c1 = "checked='checked'" if 1 == $row;
< 		$c2 = "checked='checked'" if 0 == $row;
< 		$html .= "\n<tr>";
< 		$html .= "\n<td style='width: 50px; text-align: center;' nowrap valign='top'>";
< 		$html .= "\n<input style='_margin-right: -10px;' type='radio' name='diffrevision' value='$rev' $c1/>";
< 		$html .= "\n<input type='radio' name='revision' value='$rev' $c2/>";
< 		$html .= "</td>";
< 		$html .= "\n<td  valign='top' style='width: 120px;'>";
< 	}
< 	
< 	if ( 0 == $row ) {    
< 		# current revision
< 		$html .= &GetPageLinkText( $id, Ts( 'RevisionB %s', $rev ) ) . ' ';
< 		
< 		if ($canEdit) {
< 			$html .= &GetEditLink( $id, "Edit" ) . ' ';
< 		}
< 	}
< 	else {
< 		$html .= &GetOldPageLink( 'browse', $id, $rev, Ts( 'RevisionA %s', $rev ) ) . ' ';
< 		
< 		if ($canEdit) {
< 			$html .= &GetOldPageLink( 'edit', $id, $rev, "Edit" ) . ' ';
< 		}
< 	}
< 	$html .= "\n<td  valign='top'style='width: 125px'  nowrap>" . &TimeToText($ts) . "</td>";
< 	$html .= "\n<td  valign='top'style='width: 200px'> by " . &GetAuthorLink( $host, $user, $uid ) . " $minor</td>";
< 	
< 	if ( defined($summary) && ( $summary ne "" ) && ( $summary ne "*" ) ) {
< 		$summary = &QuoteHtml($summary);    # Thanks Sunir! :-)
< 		$html .= "\n<td valign='top'>[$summary]</td>";
< 	}
< 	else {
< 		$html .= "\n<td>_</td>";
< 	}
< 	
< 	$html .= $UseDiff ? "</tr>" : "\n<br>";
< 	
< 	return $html;
< }
< 
< # ==== HTML and page-oriented functions ====
< sub ScriptLinkChar {
< 	if ($SlashLinks) {
< 		return '/';
< 	}
< 	return '?';
< }
< 
< sub ScriptLink {
<   my ($action, $text) = @_;
< 
<   return "<a class='wikiscriptlink' title='Click to visit page' href='" . $ScriptName . &ScriptLinkChar() . &UriEscape($action) . "'>$text</a>";
< }
< 
< sub ScriptLinkClass {
<   my ($action, $text, $class) = @_;
< 
<   return "<a href='" . $ScriptName . &ScriptLinkChar() . &UriEscape($action) . "' class='" . $class . "'>$text</a>";
< }
< 
< sub ScriptLinkLeftNav {
< 	my ($id, $action, $target, $label, $type) = @_;
< 	my $html;
< 	my $title;
< 	my $class;	
< 	
< 	if ($type eq "1"){
< 		if ($action eq $target){ $html .= "\n<li class='disabled'>$label</li>"; }
< 		else { $html .= "\n<li><a class='wikipagelink' title='Click to visit this page.' href='\?action=$target'>$label</a></li>"; }	
< 		
< 	}
< 	else {
< 		my $authtype = &CheckIsAuthUser($target);
< 		
< 		if ($authtype eq ""){
< 			$title = "This page is private.";
< 			$class = "wikipagelink private";
< 			$label .= "!";
< 		}
< 		elsif ( $authtype eq "1"){
< 			$title = "Click to visit this locked page.";
< 			$class = "wikipagelink locked";
< 			$label .= "&not;";
< 		}
< 		else {
< 			$title = "Click to visit this page.";
< 			$class = "wikipagelink";		
< 		}
< 		
< 		if ($id eq $target){ $html .= "\n<li class='selected'>$label</li>"; }
< 		else { $html .= "\n<li><a class='$class' title='$title' href='\?$target'>$label</a></li>"; }		
< 	}
< }
< 
< sub GetOrphanLink {
< 	return &ScriptLink("action=orphans", T('Orphans'));
< }
< 
< sub DoOrphanList {
< 	print &GetHeader("", &QuoteHtml(T('Full Orphan List')), "");
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print &PrintPageList( "", &GetOrphanList() );
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub GetOrphanList {
< 	my @found;	
< 	my %seen = ();
< 	my @pglist = &AllPagesList();
< 	
< 	foreach my $name (@pglist) {
< 		$seen{$name} = 0;
< 	}
< 	
< 	# pages linked from menu bar aren't orphans
< 	$seen{$HomePage} = 1;
< 	$seen{$RCName} = 1;
< 	
< 	foreach my $name (@pglist) {
< 		my @links = &GetPageLinks($name, 1, 0, 0, 0);
< 		
< 		foreach my $link (@links) {
< 			#don't include self links
< 			unless ($link eq $name) {
< 				$seen{$link}++ if exists $seen{$link};
< 			}
< 		}
< 	}
< 	
< 	foreach my $name (sort keys %seen) {
< 		push(@found, $name) if $seen{$name} < 1;
< 	}
< 	return @found;
< }
< 
< 
< sub GetPageLinkText {
< 	my ( $id, $name ) = @_;
< 	$id =~ s|^/|$MainPage/|;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	my $authtype = &CheckIsAuthUser($id);
< 
< 	if ($authtype eq ""){
< 		return &ScriptLinkClass( $id, "$name!", 'wikipagelink private', 'This page is private.' );
< 	}
< 		
< 	if ( -f &GetLockedPageFile($id) || $authtype eq "1"){
< 		return &ScriptLinkClass( $id, "$name&not;", 'wikipagelink locked', 'Click to visit this locked page' );
< 	}
< 	
< 	return &ScriptLinkClass( $id, $name, 'wikipagelink', 'Click to visit page' );
< }
< 
< sub GetPageLink {
< 	my ($id) = @_;
< 	return &GetPageLinkText( $id, $id );
< }
< 
< sub GetEditLink {
< 	my ( $id, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	return &ScriptLinkClass( "action=edit&id=$id", $name, 'wikipageedit', 'Click to edit page' );
< }
< 
< sub GetCreateNewLink {
< 	my ( $id, $name ) = @_;
< 	my ( $html );
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	
< 	$html  = "<a href='$ScriptName";
< 	$html .= &ScriptLinkChar();
< 	$html .= "action=edit&id=$id' class='wikicreatepagelink' title='Create this entry'>";
< 	$html .= $name;
< 	$html .= "<span class='wikilinkicon'>&nbsp;</span>";
< 	$html .= "</a>";
< 	
< 	return $html;
< }
< 
< sub GetDeleteLink {
< 	my ( $id, $name, $confirm ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 		$name =~ s/_/ /g;
< 	}
< 	return &ScriptLink( "action=delete&id=$id&confirm=$confirm", $name );
< }
< 
< sub GetOldPageParameters {
< 	my ( $kind, $id, $revision ) = @_;
< 	$id = &FreeToNormal($id) if $FreeLinks;
< 	return "action=$kind&id=$id&revision=$revision";
< }
< 
< sub GetOldPageLink {
< 	my ( $kind, $id, $revision, $name ) = @_;
< 	$name =~ s/_/ /g if $FreeLinks;
< 	return &ScriptLink( &GetOldPageParameters( $kind, $id, $revision ), $name );
< }
< 
< sub GetPageOrEditAnchoredLink {
< 	my ( $id, $anchor, $name ) = @_;
< 	my ( @temp, $exists );
< 	my $NamedFreeLink = 0;
< 	
< 	if ( $name eq "" ) {
< 		$name = $id;
< 		if ($FreeLinks) {
< 			$name =~ s/_/ /g;
< 		}
< 	}
< 	else {
< 		$NamedFreeLink = 1;
< 	}
< 	
< 	$id =~ s|^/|$MainPage/|;
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 	}
< 	$exists = 0;
< 	
< 	if ($UseIndex) {
< 		if ( !$IndexInit ) {
< 			@temp = &AllPagesList();    # Also initializes hash
< 		}
< 		$exists = 1 if ( $IndexHash{$id} );
< 	}
< 	elsif ( -f &GetPageFile($id) ) {    # Page file exists
< 		$exists = 1;
< 	}
< 	
< 	if ($exists) {
< 		$id = "$id#$anchor" if $anchor;
< 		$name = "$name#$anchor"  if $anchor && $NamedAnchors != 2 && !$NamedFreeLink;
< 		
< 		return &GetPageLinkText( $id, $name );
< 	}
< 	if ( $FreeLinks && !$EditNameLink ) {
< 		if ( $name =~ m| | ) {          # Not a single word
< 			$name = "[$name]";          # Add brackets so boundaries are obvious
< 		}
< 	}
< 	if ($EditNameLink) {
< 		return &GetEditLink( $id, $name );
< 	}
< 	else {
< 		return &GetCreateNewLink( $id, $name );
< 	}
< }
< 
< sub GetPageOrEditLink {
< 	my ( $id, $name ) = @_;
< 	my ($link, $anchor) = split( /#/, $id, 2);
< 	
< 	return &GetPageOrEditAnchoredLink($link, $anchor, $name);
< }
< 
< sub GetBackLinksSearchLink {
< 	my ($id) = @_;
< 	my $name = $id;
< 	$id =~ s|.+/|/|;    # Subpage match: search for just /SubName
< 	
< 	if ($FreeLinks) {
< 		$name =~ s/_/ /g;    # Display with spaces
< 		$id   =~ s/_/+/g;    # Search for url-escaped spaces
< 	}
< 	return &ScriptLinkTitle( "back=$id", $name, "Click to see which pages link to this one" );
< }
< 
< sub GetPrefsLink {
< 	return &ScriptLink( "action=editprefs", "Preferences" );
< }
< 
< sub GetRandomLink {
< 	return &ScriptLink( "action=random", "Random Page" );
< }
< 
< sub ScriptLinkDiff {
< 	my ( $diff, $id, $text, $rev ) = @_;
< 	
< 	$rev = "&revision=$rev" if ( $rev ne "" );
< 	$diff = &GetParam( "defaultdiff", 1 ) if ( $diff == 4 );
< 	
< 	return &ScriptLinkTitle( "action=browse&diff=$diff&id=$id$rev", $text, "Click to view last revision" );
< }
< 
< sub GetUploadLink {
< 	return &ScriptLink( 'action=upload', "Upload" );
< }
< 
< sub ScriptLinkTitle {
< 	my ( $action, $text, $title ) = @_;
< 	
< 	if ($FreeLinks) { $action =~ s/ /_/g; }
< 	
< 	return "<a href='" . $ScriptName . &ScriptLinkChar() . &UriEscape($action) . "' title='$title' class='wikiscriptlinktitle'>$text</a>";
< }
< 
< sub GetAuthorLink {
< 	my ( $host, $userName, $uid ) = @_;
< 	my ( $html, $title, $userNameShow );
< 	$userNameShow = $userName;
< 	
< 	if ($FreeLinks) {
< 		$userName     =~ s/ /_/g;
< 		$userNameShow =~ s/_/ /g;
< 	}
< 	if ( &ValidId($userName) ne "" ) {    # Invalid under current rules
< 		$userName = "";                   # Just pretend it isn't there.
< 	}
< 	if ( ( $uid > 0 ) && ( $userName ne "" ) ) {
< 		$html = &ScriptLinkTitle( "$HomePagePrefix$userName", $userNameShow, Ts( 'ID %s', $uid ) . ' ' . Ts( 'from %s', $host ) );
< 	}
< 	else {
< 		$html = $host;
< 	}
< 	return $html;
< }
< 
< sub GetHistoryLink {
< 	my ( $id, $text, $title ) = @_;
< 	if ($FreeLinks) {
< 		$id =~ s/ /_/g;
< 	}
< 	return &ScriptLinkTitle( "action=history&id=$id", $text, $title );
< }
< 
< sub GetHeader {
< 	my ( $id, $title, $oldId ) = @_;
< 	my $header    = "";
< 	my $logoImage = "";
< 	my $result    = "";
< 	my $embed     = &GetParam( 'embed', $EmbedWiki );
< 	my $altText   = "[Home]";
< 	my $temp      = "";
< 	
< 	$result = &GetHttpHeader("");
< 	
< 	if ($FreeLinks) {
< 		$title =~ s/_/ /g;    # Display as spaces
< 	}
< 	
< 	$result .= &GetHtmlHeader("$SiteName: $title", $id);
< 	
< 	return $result if ($embed);
< 	$result .= "\n<div class='wikiheader'>[$oldId]";
< 	
< 	if ( $oldId ne "" ) {
< 		$result .= $q->h3( '(' . Ts( 'redirected from %s', &GetEditLink( $oldId, $oldId ) )  . ')' );
< 	}
< 	else { $result .= "<h3>&nbsp;</h3>"; }
< 	
< 	if ( ( !$embed ) && ( $LogoUrl ne "" ) ) {
< 		$logoImage = "img class='wikilogo' src='$LogoUrl' alt='$altText'";
< 		
< 		if ( !$LogoLeft ) {
< 			$logoImage .= " align='right'";
< 		}
< 		$header = &ScriptLink( $HomePage, "\n<$logoImage>" );
< 	}
< 	
< 	if ( $id ne "" ) {
< 		my $authtype = &CheckIsAuthUser($id);
< 		if (&PageIsLocked($id, 1) || $authtype eq "1"){
< 			$temp = "<span class='wikilockicon' title='This page is locked.'>&nbsp;</span>";
< 		}
< 		else {	
< 			if ( -f &GetLockedPageFile($id) ) {
< 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='This page locked for others. Click to edit page'><span class='wikiediticon'>&nbsp;</span></a>";
< 			}
< 			else {
< 				$temp = "<a href='$ScriptName?action=edit&id=$id' title='Click to edit this page'><span class='wikiediticon'>&nbsp;</span></a>";
< 			}
< 		}		
< 		$result .= $q->h1( $header . &GetBackLinksSearchLink($id) . $temp );
< 	}
< 	else {
< 		$result .= $q->h1( $header . $title );
< 	}
< 	
< 
< 	if ( &GetParam( "toplinkbar", 1 ) ) {		
< 		$result .= &GetGotoBar($id);
< 		$result .= $WikiLineHeader;
< 	}
< 	$result .= "</div>";	
< 	return $result;
< }
< 
< sub GetHttpHeader {
< 	my ($type) = @_;
< 	my $cookie;
< 	$type = "text/html" if ( $type eq "" );
< 	if ( defined( $SetCookie{'id'} ) ) {
< 		$cookie =
< 		   "$CookieName=" . "rev&"
< 		  . $SetCookie{'rev'} . "&id&"
< 		  . $SetCookie{'id'}
< 		  . "&randkey&"
< 		  . $SetCookie{'randkey'};
< 		$cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
< 		if ( $HttpCharset ne "" ) {
< 			return $q->header(
< 				-cookie => $cookie,
< 				-type   => "$type; charset=$HttpCharset"
< 			);
< 		}
< 		return $q->header( -cookie => $cookie );
< 	}
< 	if ( $HttpCharset ne "" ) {
< 		return $q->header( -type => "$type; charset=$HttpCharset" );
< 	}
< 	return $q->header( -type => $type );
< }
< 
< sub GetHtmlHeader {
< 	my ($title, $id) = @_;
< 	my ( $dtd, $html, $bodyExtra, $stylesheet );
< 	
< 	$html  = "";
< 	$dtd   = "-//IETF//DTD HTML//EN";
< 	$html  = qq(<!DOCTYPE HTML PUBLIC "$dtd">);
< 	$title = $q->escapeHTML($title);
< 	$html .= "\n<html><head><title>$title</title>";
< 	
< 	if ( $FavIcon ne "" ) {
< 		$html .= "\n<link rel='SHORTCUT ICON' href='$FavIcon'>";
< 	}
< 	
< 	if ($MetaKeywords) {
< 		my $keywords = $OpenPageName;
< 		$keywords =~ s/([a-z])([A-Z])/$1, $2/g;
< 		$html .= "\n<meta name='keywords' content='$keywords'/>" if $keywords;
< 	}
< 	
< 	#--------------------------------------------------------------------------
< 	# we don't want robots indexing our history or other admin pages
< 	# UNSURE ABOUT THIS ONE
< 	#--------------------------------------------------------------------------
< 	my $action = lc(&GetParam('action', ''));
< 	unless (!$action or $action eq "rc" or $action eq "index") { $html .= "<meta name='robots' content='noindex,nofollow'>\n"; }
< 	
< 	if ( $SiteBase ne "" ) { $html .= qq(<base href="$SiteBase">); }
< 	
< 	$stylesheet = &GetParam( 'stylesheet', $StyleSheet );
< 	$stylesheet = $StyleSheet if ( $stylesheet eq "" );
< 	$stylesheet = "" if ( $stylesheet eq '*' );    # Allow removing override
< 	
< 	if ( $stylesheet ne "" ) { $html .= qq(<link rel="stylesheet" href="$stylesheet">); }
< 
< 	my $bots = "";
< 	# actions and non-existant page views don't get indexed or followed by robots
< 	if ( ($id eq "") || ( $id && !-f &GetPageFile($id) ) ) { $bots = "no"; }
< 	
< 	$bots = $bots . 'index,' . $bots . 'follow';
< 	$html .= qq(<meta name="robots" content="$bots" />\n);
< 	
< 	$html .= $UserHeader;
< 	$bodyExtra = "";
< 	
< 	if ( $UserBody ne "" ) { $bodyExtra = " $UserBody"; }	
< 	if ( $BGColor ne "" ) { $bodyExtra .= "BGCOLOR='$BGColor'"; }
< 	
< 	$html .= "</head><body$bodyExtra>";
< 	$html .= "\n<div id='wikicontainer-outer'>";
< 	$html .= "\n<div id='wikicontainer-inner'>";
< 	$html .= "\n<div id='wikicontainer'>";
< 	
< 	return $html;
< }
< 
< sub GetLeftNav {
< 	my $id = shift;
< 	my $action = &GetParam( "action", "" );
< 	my $html = "";
< 	
< 	$html .= "\n<div class='wikileftnav'>";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'HomePage', 'Home page', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'NobleWiki', 'Wiki Info', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'CategoryCategory', 'Contents', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'FeaturedContent', 'Featured', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'random', 'Random Article', "1");	
< 	
< 	$html .= "\n		</ul>";
< 	$html .= "\n	</div>	";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'RecentChanges', 'Recent changes', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'ListOfWantedPages', 'Wanted Pages', "");
< 					
< 	if ($id ne ""){
< 		unless ($id eq 'ListOfWantedPages' or $id eq 'RecentChanges' or $id =~ /^\d/){	
< 			if (&UserCanEdit( $id, 0 )){ $html .= "\n<li><a href='?action=edit&id=$id'>Edit this Page</a></li>";	}
< 			else { $html .= "\n<li class='disabled'>Edit this Page</li>"; }
< 							
< 			if ($action eq 'history'){ $html .= "\n<li class='disabled'>Version History</li>"; }
< 			else { $html .= "\n<li><a href='?action=history&id=$id'>Version History</a></li>"; }
< 		}
< 		else {
< 			$html .= "\n<li class='disabled'>Edit this Page</li>"; 
< 			$html .= "\n<li class='disabled'>Version History</li>"; 
< 		}
< 	}
< 	
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'SandBox', 'SandBox', "");
< 	
< 	$html .= "\n	</ul></div>";
< 	$html .= "\n	<div class='wikileftnavbox'>";
< 	$html .= "\n		<ul>";
< 
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'editprefs', 'Preferences', "1");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiContacts', 'Contact Us', "");
< 	$html .= "\n" . &ScriptLinkLeftNav($id, $action, 'WikiHelp', 'Help', "");
< 		
< 	$html .= "\n		</ul>";
< 	$html .= "\n	</div>";
< 	$html .= "\n	<div class='wikileftnavsearch' style='text-align:right;'>";
< 	$html .= "\n		<form>";
< 	$html .= "\n			<div class='wikisearchlabel' style='text-align:left;'><b>Search</b></div>";
< 	$html .= "\n			<input type='text' title='Enter ! before search term for exclusion' name='search' id='searchterm' />";
< 	$html .= "\n			<input type='submit' value='Go!' name='dosearch' title='Click to perform your search request.' />";
< 	$html .= "\n		</form></div>";
< 	$html .= "\n</div>";
< 	
< 	return $html;	
< }
< 
< sub GetFooterText {
< 	my ( $id, $rev ) = @_;
< 	my $result;
< 	
< 	if ( &GetParam( 'embed', $EmbedWiki ) ) {
< 		return "";
< 	}
< 	
< 	$result = "\n<div class='wikifooter'>";
< 	$result .= &GetGotoBar($id);
< 	$result .= "\n<div class='wikirevision'>";
< 	
< 	if ($id ne ""){
< 		if ( &UserCanEdit( $id, 0 )) {
< 			if ( $rev ne "" ) {
< 				$result .=
< 				  &GetOldPageLink( 'edit', $id, $rev, Ts( 'Edit revision %s of this page', $rev ) );
< 			}
< 			else {
< 				$result .= &GetEditLink( $id, "Edit text of this page" );
< 			}
< 		}
< 		else {
< 			$result .= "This page is read-only";
< 		}
< 	}
< 	
< 	if ($id ne ""){ $result .= " | " . &GetHistoryLink( $id, "View other revisions", "Click to view revision history" ); }	
< 	if ($rev ne "" && $id ne "") { $result .= " | " . &GetPageLinkText( $id, "View current revision" ); }	
< 	if ($UseMetaWiki) { $result .= " | <a href='http://sunir.org/apps/meta.pl?" . &UriEscape($id) . "' class='wikiusemetalink'>". T("Search MetaWiki") . "</a>"; }
< 		
< 	$result .= "</div>";
< 	
< 	if ($id ne ""){ 
< 		if ( $Section{'revision'} > 0 ) {
< 			$result .= "\n<div class='wikirevision'>";		
< 			$result .= "Created " . &TimeToText($Page{'tscreate'});
< 			
< 			if ($Page{'authorcreate'}) { $result .= " by " . $Page{'authorcreate'}; } 
< 			
< 			$result .= " | ";	
< 			if ( $rev eq "" ) { $result .= "Last edited"; }
< 			else { $result .= "Edited"; }
< 			
< 			$result .= " " . &TimeToText( $Section{ts} );
< 			
< 			if ($AuthorFooter) { $result .= ' ' . Ts('by %s', &GetAuthorLink($Section{'host'}, $Section{'username'}, $Section{'id'}), 1); }
< 		}
< 		
< 		if ($UseDiff) { $result .= " " . &ScriptLinkDiff( 4, $id, "(diff)", $rev ); }
< 	}
< 	
< 	$result .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	$result .= &GetSearchForm();	
< 	if ( $DataDir =~ m|/tmp/| ) {
< 		$result .= "\n<br><b>";
< 		$result .= "Warning";
< 		$result .= ":</b> ";
< 		$result .= "Database is stored in temporary directory $DataDir";
< 		$result .= "\n<br>";
< 	}
< 	
< 	if ( $ConfigError ne "" ) {
< 		$result .= "\n<br>";
< 		$result .= "\n<b>Config file error:</b>";
< 		$result .= "$ConfigError <br>";
< 	}
< 	
< 	$result .= "</form>";
< 	$result .= &getFooterNote();
< 	if ( $AdminBar && &UserIsAdmin() ) { $result .= &GetAdminBar($id, ""); }
< 	$result .= "</div>";
< 		
< 	return $result;
< }
< 
< sub getFooterNote {
< 	my $html;
< 	my $userid = &GetParam("username", "");
< 	my $access = "Guest ";
< 	my $username = "Anonymous";
< 
< 	if (UserIsAdmin()){
< 		$access = "Admin ";
< 	}
< 	elsif (UserIsEditor()){
< 		$access = "Editor ";
< 	}
< 	
< 	if ($userid ne ""){
< 		$username = $userid;
< 	}
< 	
< 	if ($FooterNote ne ""){
< 		$html = $FooterNote;
< 		$html =~ s/access/$access/;
< 		$html =~ s/username/$userid/;
< 	}
< 	
< 	return $html;
< }
< 
< sub GetCommonFooter {
< 	my ($html);
< 	my $id = &GetParam( "id",     "" );
< 	
< 	$html = $WikiLineFooter;
< 	$html .= "\n<div class='wikifooter'>";
< 	$html .= "\n<form id='wikifooterform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	$html .= &GetGotoBar("");
< 	$html .= &GetSearchForm();
< 	$html .= "</form>";	
< 	$html .= &getFooterNote();
< 	
< 	if ( $AdminBar && &UserIsAdmin() ) { $html .= &GetAdminBar($id, "class='wikirevision'"); }
< 	$html .= "\n<div>"; ## ??NEEDED ??
< 	
< 	return $html;
< }
< 
< sub GetGotoBar {
< 	my ($id) = @_;
< 	my ( $main, $bartext );
< 	
< 	$bartext = "\n<div class='wikigotobar'>";
< 	$bartext .= &GetPageLink($HomePage);
< 	
< 	if ( $id =~ m|/| ) {
< 		$main = $id;
< 		$main =~ s|/.*||;    # Only the main page name (remove subpage)
< 		
< 		unless ($main eq $HomePage){
< 			$bartext .= " | " . &GetPageLink($main);
< 		}
< 	}
< 	
< 	$bartext .= " | " . &GetPageLink($RCName);
< 	$bartext .= " | " . &GetPrefsLink();
< 	
< 	if ( $UseUpload && &UserCanUpload() ) {
< 		$bartext .= " | " . &GetUploadLink();
< 	}
< 	
< 	$bartext .= " | " . &ScriptLink( "action=listfiles&filter=sample", "List Assets" );
< 	
< 	if ( &GetParam( "linkrandom", 0 ) ) {
< 		$bartext .= " | " . &GetRandomLink();
< 	}
< 	
< 	if ( $UserGotoBar ne "" ) {
< 		$bartext .= " | " . $UserGotoBar;
< 	}
< 	
< 	$bartext .= "</div>";
< 	
< 	return $bartext;
< }
< 
< sub GetSearchForm {
< 	my ($html);
< 	
< 	$html =  "\n<div class='wikisearch'>";
< 	$html .= "\n<div class='wikisearchlabel'>Search:</div>";
< 	$html .= "\n<input type='text' id='searchterm' name='search' title='Enter ! before search term for exclusion'>";	
< 	if ($SearchButton) {
< 		$html .= " " . $q->submit( 'dosearch', "Go!" );
< 	}
< 	else {
< 		$html .= &GetHiddenValue( "dosearch", 1 );
< 	}
< 	
< 	$html .= "</div>";
< 	return $html;
< }
< 
< sub GetRedirectPage {
< 	my ( $newid, $name, $isEdit ) = @_;
< 	my ( $url, $html );
< 	my ($nameLink);
< 
< 	# Normally get URL from script, but allow override.
< 	$FullUrl  = $q->url( -full => 1 ) if ( $FullUrl eq "" );
< 	$url      = $FullUrl . &ScriptLinkChar() . $newid;
< 	$nameLink = "<a href='$url' class='wikiredirect'>$name</a>";
< 	
< 	if ( $RedirType < 3 ) {
< 		if ( $RedirType == 1 ) {    # Use CGI.pm
< 			 # NOTE: do NOT use -method (does not work with old CGI.pm versions)
< 			 # Thanks to Daniel Neri for fixing this problem.
< 			$html = $q->redirect( -uri => $url );
< 		}
< 		else {    # Minimal header
< 			$html = "Status: 302 Moved\n";
< 			$html .= "Location: $url\n";
< 			$html .= "Content-Type: text/html\n";   # Needed for browser failure
< 		}
< 		$html .= " Your browser should go to the $newid page.";
< 		$html .= " If it does not, click $nameLink to continue.";
< 	}
< 	else {
< 		if ($isEdit) {
< 			$html  = &GetHeader( "", "Thanks for editing...", "" );
< 			$html .= &GetLeftNav("");
< 			$html .= "\n<div class='wikiadmin'>";
<  			$html .= "Thank you for editing $nameLink ";
< 		}
< 		else {
< 			$html = &GetHeader( "", "Link to another page...", "" );
< 			$html .= &GetLeftNav("");
< 			$html .= "\n<div class='wikiadmin'>";
< 		}
< 		
< 		$html .= "Follow the $nameLink link to continue.";
< 		$html .= "</div>";
< 		$html .= "</div></div></div></div></body></html>";	
< 	}
< 	
< 	return $html;
< }
< 
< # ==== Common wiki markup ====
< sub RestoreSavedText {
< 	my ($text) = @_;
< 	
< 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
< 	
< 	return $text;
< }
< 
< sub RemoveFS {
< 	my ($text) = @_;
< 
< 	# Note: must remove all $FS, and $FS may be multi-byte/char separator
< 	$text =~ s/($FS)+(\d)/$2/g;
< 	
< 	return $text;
< }
< 
< sub WikiToHTML {
< 	my ($pageText) = @_;
< 	
< 	$TableMode       = 0;
< 	%SaveUrl         = ();
< 	%SaveNumUrl      = ();
< 	$SaveUrlIndex    = 0;
< 	$SaveNumUrlIndex = 0;
< 	$pageText        = &RemoveFS($pageText);
< 	
< 	if ($RawHtml) {
< 		$pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
< 	}
< 	
< 	$pageText = &QuoteHtml($pageText);
< 	$pageText =~ s/\\ *\r?\n/ /g;    # Join lines with backslash at end
< 		
< 	if ($ParseParas) {
< 
< 		# Note: The following 3 rules may span paragraphs, so they are
< 		#       copied from CommonMarkup
< 		$pageText =~ s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
< 		$pageText =~ s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
< 		$pageText =~ s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
< 		$pageText =~ s/\{{template:(\w+\s*.*?)}}/&StoreTemplate($1)/iges;
< 		$pageText =~ s/\{{flash:\s*(.*?)}}/&StoreRaw(&GetFlash($1))/iges;
< 		$pageText =~ s/\{{gallery:\s*(.*?)}}/&StoreRaw(&GetGallery($1))/iges;
< 		
< 		$pageText =~ s/((.|\n)+?\n)\s*\n/&ParseParagraph($1)/geo;
< 		$pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
< 		
< 	}
< 	else {
< 		$pageText = &WikiLinesToHtml($pageText);         # Line-oriented markup
< 		$pageText = &CommonMarkup( $pageText, 1, 0 );    # Multi-line markup
< 
< 	}
< 	
< 	while (@HeadingNumbers) {
< 		pop @HeadingNumbers;
< 		$TableOfContents .= "</dd></dl>";
< 	}
< 	
< 	$pageText =~ s/&lt;toc&gt;/<div class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
< 	$pageText =~ s/&lt;toc ((\d)+)?&gt;/<div style='width: $1;' class='wikitoc'><div class='wikitoctitle'>Table of Contents<\/div>$TableOfContents<\/div>/gi;
< 	$pageText =~ s/\#SUBPAGES\s+(\w+.*?)/&StoreRaw("\n<h6>" . Ts('Subpages of: %s', &QuoteHtml($1)) . "<\/h6>" . &GetPageList(&GetSubpages($1)))/ige;
< 	$pageText =~ s/\#SUBPAGES/&StoreRaw("\n<h6>" . Ts('Subpages for %s', $MainPage) . "<\/h6>" . &GetPageList(&GetSubpages($MainPage)))/ige;
< 	
< 	if ( $LateRules ne "" ) {
< 		$pageText = &EvalLocalRules( $LateRules, $pageText, 0 );
< 	}
< 	
< 	return &RestoreSavedText($pageText);
< }
< 
< sub CommonMarkup {
< 	my ( $text, $useImage, $doLines ) = @_;
< 	local $_ = $text;
< 	
< 	if ( $doLines < 2 ) {    # 2 = do line-oriented only
< 		
< 		while ( m!\#INCLUDE\s*((\w+\.?\w*|/)+)!gi and $AllowInclusion ) {		
< 			my $FileName = $1;
< 			
< 			open FILE, "$InclusionDir/$FileName"
< 			or &ReportError(T("Cannot open $FileName: $!"));
< 			
< 			local $/;			
< 			my $FileContent = <FILE>;
< 			
< 			close FILE
< 			or &ReportError(T("Cannot close $FileName: $!"));
< 			s!\#INCLUDE\s*$FileName!$FileContent!i unless $FileName !~ /(html?|txt)$/i;
< 		}
<   
< 		# The <nowiki> tag stores text with no markup (except quoting HTML)
< 		s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
< 
< 		# The <pre> tag wraps the stored text with the HTML <pre> tag
< 		s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
< 		s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
< 		
< 		if ( $EarlyRules ne "" ) {
< 			$_ = &EvalLocalRules( $EarlyRules, $_, !$useImage );
< 		}
< 		
< 		s/\[\#(\w+)\]/&StoreHref(" name='$1'")/ge if $NamedAnchors;
< 		
< 		if ($HtmlTags) {
< 			my ($t);
< 			foreach $t (@HtmlPairs) {
< 				s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
< 			}
< 			foreach $t (@HtmlSingle) {
< 				s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
< 			}
< 		}
< 		else {
< 
< 			# Note that these tags are restricted to a single line
< 			s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
< 			s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
< 			s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
< 			s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
< 		}
< 
< 		# Auto signature if use ~~~~ ; useful for quick comments
< 	    my $id = &GetParam("username", "");
< 		my $idLink = "$HomePagePrefix$id";
< 		my $timestamp = &TimeToText($Now);
< 		my $finalText = "";
< 		
< 		$id =~ s/ /_/g;
< 
< 		if ($id){
< 			$finalText = &StorePageOrEditLink($idLink, $id);
< 			s/\~\~\~\~/<i>\[$finalText]<\/i>/gi;
< 			s/\$\$\$\$/<i>\[$finalText at $timestamp]<\/i>/gi;
< 		}
< 		else {
< 			$id = "Guest";			
< 			s/\~\~\~\~/<i>\[$id at $timestamp]<\/i>/gi;
< 			s/\$\$\$\$/<i>\[$id at $timestamp]<\/i>/gi;
< 		}
< 		
< 		s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;    # <tt> (MeatBall)
< 		s/\&lt;br\&gt;/<br>/gi;    # Allow simple line break anywhere
< 		
< 		if ($HtmlLinks) {
< 			s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
< 		}
< 		
< 		if ($FreeLinks) {
< 
< 			# Consider: should local free-link descriptions be conditional?
< 			# Also, consider that one could write [[Bad Page|Good Page]]?
< 			s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
< 			s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
< 		}
< 		
< 		if ($BracketText) {        
< 			# Links like [URL text of link]
< 			s/\[$UrlPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketUrl($1, $2, $useImage, $3)/geos;
< 			s/\[$InterLinkPattern\s+([^\]]+?)(\|(.*))?\]/&StoreBracketInterPage($1, $2, $useImage, $3)/geos;
< 			
< 			if ( $WikiLinks && $BracketWiki ) {    # Local bracket-links
< 				s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
< 				s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1, $2, $3)/geos if $NamedAnchors;
< 			}
< 		}
< 		
< 		if ($UseUpload) { s/$UploadPattern/&StoreUpload($1)/geo; }
<     
< 		s/\[$UrlPattern(\|(.*))?\]/&StoreBracketUrl($1, "", 0, "")/geo;
< 		s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0, "")/geo;
< 		s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
< 		s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
< 		
< 		if ($WikiLinks) {
< 			s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1, $2, ""))/geo if $NamedAnchors;
< 
< 			# CAA: Putting \b in front of $LinkPattern breaks /SubPage links
< 			#      (subpage links without the main page)
< 			s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
< 		}
< 		s/\b$RFCPattern/&StoreRFC($1)/geo;
< 		s/\b$ISBNPattern/&StoreISBN($1)/geo;
< 		
< 		if ($ThinLine) {
< 			if ($OldThinLine) {   
< 				# Backwards compatible, conflicts with headers
< 				s/====+/$WikiLine2/g;
< 			}
< 			else {                
< 				# New behavior--no conflict
< 				s/------+/$WikiLine2/g;
< 			}
< 			s/----+/$WikiLine1/g;
< 		}
< 		else {
< 			s/----+/$WikiLine/g;
< 		}
< 		
< 		if ($AutoMailto) {
< 			s/([A-z0-9-_]+(?:\.[A-z0-9-_]+)*)\@([A-z0-9-_]+(?:\.[A-z0-9-_]+)*(?:\.[A-z]{2,})+)/<a href="mailto:$1\@$2">$1\@$2<\/a>/g;
< 		}
< 	}
< 	
< 	if ($doLines) {    
< 			# 0 = no line-oriented, 1 or 2 = do line-oriented
< 		    # The quote markup patterns avoid overlapping tags (with 5 quotes)
< 		    # by matching the inner quotes for the strong pattern.
< 		s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g; #'REMARK
< 		s/''(.*?)''/<em>$1<\/em>/g;
< 		
< 		if ($UseHeadings) {
< 		 ## s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
< 			s/(^|\n)\s*(\=+)\s*(#)?\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $4, $3)/geo;
< 		}
< 		
< 		if ($TableMode == 1) {
< 			my @cells = split(/\|\|/);
< 			my $cellIndex = 0;
< 			
< 			while (/(\|\|)+([^\|<]+)/) {	
< 				my $switches = @cells->[++$cellIndex];
< 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
< 				my $cellOptions = "$class $style $width $align";
< 				
< 				s/((\|\|)+)/"<\/td><td $cellOptions colspan='" . (length($1)\/2) . "'>"/e;
< 			} 
< 			s/(\|\w*=\w*)+([^\|<]+)//g;   
< 		}
< 		elsif  ($TableMode == 2) {
< 			my @cells = split(/\!\!/);
< 			my $cellIndex = 0;
< 			
< 			while (/(\!\!)+([^\!<]+)/) {			
< 				my $switches = @cells->[++$cellIndex];
< 				my ($class, $style, $width, $align, $DUMMY) = &GetTableCellModifiers($switches, "", $cellIndex);
< 				my $cellOptions = "$class $style $width $align";
< 				
< 				s/((\!\!)+)/"<\/th><th $cellOptions colspan='" . (length($1)\/2) . "'>"/e;				
< 			}
< 			s/(\|\w*=\w*)+([^\!<]+)//g;
< 		}
< 	}
< 	
< 	return $_;
< }
< 
< sub GetTableCellModifiers {
< 	my ($given, $initialCell, $cellIndex) = @_;	
< 	my ($options) = $given;
< 
< 	/^(\s*(\w+)\s*)\|/;
< 	my $align = $2;
< 	if ($initialCell ne ""){ $align = $initialCell; }
< 		
< 	$align = $align =~ /^  / ? ($align =~ /  $/ ? 'center' : 'right') : 'left';
< 	$align = "align='$align'";
< 	
< 	my ($options) = $options =~ /(\|\S*=\S*)+/g;
< 	my %options = &GetOptions($options);
< 
< 	my $class;
< 	my $style;
< 	my $width;	
< 	my $rowclass;
< 	my $rowstyle;
< 	my $rowalign;
< 	my $tablewidth;
< 	my $tableclass;
< 	my $tablestyle;
< 		
< 	if ($TableCellDefaults{"rowclass"} =~ /clear/){ $TableCellDefaults{"rowclass"} = ""; }
< 	if ($TableCellDefaults{"rowstyle"} =~ /clear/){ $TableCellDefaults{"rowstyle"} = ""; }
< 	if ($TableCellDefaults{"rowalign"} =~ /clear/){ $TableCellDefaults{"rowalign"} = ""; }
< 				
< 	if ($TableCellDefaults{"rowclass"}){ $rowclass = $TableCellDefaults{"rowclass"}; }
< 	if ($TableCellDefaults{"rowstyle"}){ $rowstyle = $TableCellDefaults{"rowstyle"}; }
< 	if ($TableCellDefaults{"rowalign"}){ $rowalign = $TableCellDefaults{"rowalign"}; }
< 		
< 	if ($options{'rowclass'}){ $rowclass = "class='" . $options{'rowclass'} . "'"; $TableCellDefaults{"rowclass"} = $rowclass; }
< 	if ($options{'rowstyle'}){ $rowstyle = "style='" . $options{'rowstyle'} . "'"; $TableCellDefaults{"rowstyle"} = $rowstyle; }
< 	if ($options{'rowalign'}){ $rowalign = "align='" . $options{'rowalign'} . "'"; $TableCellDefaults{"rowalign"} = $rowalign; }
< 	
< 	if ($rowclass){ $class = $rowclass; }
< 	if ($rowstyle){ $style = $rowstyle; }
< 	if ($rowalign){ $align = $rowalign; }
< 
< 	if ($TableCellDefaults{"class$cellIndex"} =~ /clear/){ $TableCellDefaults{"class$cellIndex"} = ""; }
< 	if ($TableCellDefaults{"style$cellIndex"} =~ /clear/){ $TableCellDefaults{"style$cellIndex"} = ""; }
< 	if ($TableCellDefaults{"align$cellIndex"} =~ /clear/){ $TableCellDefaults{"align$cellIndex"} = ""; }
< 			
< 	if ($TableCellDefaults{"class$cellIndex"}){ $class = $TableCellDefaults{"class$cellIndex"}; }
< 	if ($TableCellDefaults{"style$cellIndex"}){ $style = $TableCellDefaults{"style$cellIndex"}; }
< 	if ($TableCellDefaults{"align$cellIndex"}){ $align = $TableCellDefaults{"align$cellIndex"}; }
< 
< 	if ($options{'class'}){ $class = "class='" . $options{'class'} . "'"; $TableCellDefaults{"class$cellIndex"} = $class; }
< 	if ($options{'style'}){ $style = "style='" . $options{'style'} . "'"; $TableCellDefaults{"style$cellIndex"} = $style; }
< 	if ($options{'align'}){ $align = "align='" . $options{'align'} . "'"; $TableCellDefaults{"align$cellIndex"} = $align; }
< 	if ($options{'width'}){ $width = "width='" . $options{'width'} . "'"; }
< 	if ($options{'tablewidth'}){ $tablewidth = "width='" . $options{'tablewidth'} . "'"; }
< 	if ($options{'tablestyle'}){ $tablestyle = "style='" . $options{'tablestyle'} . "'"; }
< 	if ($options{'tableclass'}){ $tableclass = "class='" . $options{'tableclass'} . "'"; } else { $tableclass = "class='wikilargelist'"; }
< 					
< 	return ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass);				
< }
< 
< sub EmptyCellsToNbsp {
<   my ($row) = @_;
< 
<   $row =~ s/(?<=\|\|)\s+(?=\|\|)/&nbsp;/g;
<   $row =~ s/^\s+(?=\|\|)/&nbsp;/;
<   $row =~ s/(?<=\|\|)\s+$/&nbsp;/;
<   return $row;
< }
< 
< sub WikiLinesToHtml {
< 	my ($pageText) = @_;
< 	my ( $pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode );
< 	
< 	@htmlStack = ();
< 	$depth     = 0;
< 	$pageHtml  = "";
< 	
< 	foreach ( split( /\r?\n/, $pageText ) ) {    # Process lines one-at-a-time
< 		$code           = "";
< 		$codeAttributes = "";
< 		$TableMode      = 0;
< 		$_ .= "\n";
< 		
< 		if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
< 			$code  = "dl";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\:+)/<dt><dd>/) {
< 			$code  = "dl";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\*+)/<li>/) {
< 			$code  = "ul";
< 			$depth = length $1;
< 		}
< 		elsif (s/^(\#+)/<li>/) {
< 			$code  = "ol";
< 			$depth = length $1;
< 		}
< 		elsif ($TableSyntax && /^(\!\!)+.*\!\!\s*$/) {
< 			/^(\!\!)+([^\!]+)/;
< 			
< 			%TableCellDefaults = {};
< 			
< 			my $switches = $2;
< 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, "", 0);
< 			my $cellOptions = "$class $style $width $align";
< 			
< 			s/^((\!\!)+)(.*)\!\!\s*$/"\n<tr><th $cellOptions colspan='" . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/th><\/tr>\n"/e;
< 			
< 			$code = "table";
< 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
< 			$TableMode = 2;
< 			$depth = 1;
< 		}
< 		elsif ($TableSyntax && /^(\|\|)+.*\|\|\s*$/) {
< 			/^((\|\|)+)(.*?)\|\|/;	
< 	
< 			my ($alignInitial) = $3;
< 			my $switches = $3;
< 			($alignInitial) = $alignInitial =~ /(.*)\|/;	
< 
< 			my ($class, $style, $width, $align, $tablewidth, $tablestyle, $tableclass) = &GetTableCellModifiers($switches, $alignInitial, 0);
< 			my $cellOptions = "$class $style $width $align";
< 			
< 			s/^((\|\|)+)(.*)\|\|\s*$/"\n<tr><td $cellOptions colspan='" . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/td><\/tr>\n"/e;
< 			
< 			$code = "table";
< 			$codeAttributes = "$tablewidth  $tablestyle  $tableclass";
< 			$TableMode = 1;
< 			$depth = 1;
< 		}
< 		elsif (/^[ \t].*\S/) {
< 			$code  = "pre";
< 			$depth = 1;
< 		}
< 		else {
< 			$depth = 0;
< 		}
< 		
< 		while ( @htmlStack > $depth ) {    
< 			# Close tags as needed
< 			$pageHtml .= "</" . pop(@htmlStack) . ">";
< 		}
< 		
< 		if ( $depth > 0 ) {
< 			$depth = $IndentLimit if ( $depth > $IndentLimit );
< 			if (@htmlStack) {              
< 				# Non-empty stack
< 				$oldCode = pop(@htmlStack);
< 				
< 				if ( $oldCode ne $code ) {
< 					$pageHtml .= "</$oldCode><$code>";
< 				}
< 				push( @htmlStack, $code );
< 			}
< 			
< 			while ( @htmlStack < $depth ) {
< 				push( @htmlStack, $code );
< 				$pageHtml .= "\n<$code $codeAttributes>";
< 			}
< 		}
< 		
< 		if ( !$ParseParas ) {
< 			s/^\s*$/<p>\n/;    # Blank lines become <p> tags
< 		}
< 		$pageHtml .= &CommonMarkup( $_, 1, 2 );    # Line-oriented common markup
< 	}
< 	
< 	while ( @htmlStack > 0 ) {                     
< 		# Clear stack
< 		$pageHtml .= "</" . pop(@htmlStack) . ">";
< 	}
< 	
< 	return $pageHtml;
< }
< 
< sub EvalLocalRules {
< 	my ( $rules, $origText, $isDiff ) = @_;
< 	my ( $text, $reportError, $errorText );
< 	
< 	$text        = $origText;
< 	$reportError = 1;
< 
< 	# Basic idea: the $rules should change $text, possibly with different
< 	# behavior if $isDiff is true (no images or color changes?)
< 	# Note: for fun, the $rules could also change $reportError and $origText
< 	if ( !eval $rules ) {
< 		$errorText = $@;
< 		
< 		if ( $errorText eq "" ) {
< 
< 		  # Search for "Unknown Error" for the reason the next line is commented
< 		  #     $errorText = "Unknown Error (no error text)";
< 		}
< 		if ( $errorText ne "" ) {
< 			$text = $origText;    # Consider: should partial results be kept?
< 			
< 			if ($reportError) {
< 				$text .= "\n<hr>";
< 				$text .= "<b>Local rule error:</b><br>";
< 				$text .= &QuoteHtml($errorText);
< 			}
< 		}
< 	}
< 	
< 	return $text;
< }
< sub UriEscape {
< 	my ($uri) = @_;
< 	
< 	$uri =~ s/([\x00-\x1f\x7f-\xff])/sprintf("%%%02X", ord($1))/ge;
< 	$uri =~ s/\&/\&amp;/g;
< 	
< 	return $uri;
< }
< 
< 
< sub QuoteHtml {
< 	my ($html) = @_;
< 	
< 	$html =~ s/&/&amp;/g;
< 	$html =~ s/</&lt;/g;
< 	$html =~ s/>/&gt;/g;
< 	$html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;    # Allow character references
< 	
< 	return $html;
< }
< 
< sub ParseParagraph {
< 	my ($text) = @_;
< 	
< 	$text = &WikiLinesToHtml($text);            # Line-oriented markup	
< 	$text = &CommonMarkup( $text, 1, 0 );       # Multi-line markup
< 	
< 	if ($text =~ /^\<h[1|2|3|4|5|6]>.*<\\h[1|2|3|4|5|6]>$/){ return "<nowiki>$text</nowiki>"; }
< 	return "\n<p>$text</p>";
< }
< 
< sub StoreInterPage {
< 	my ( $id, $useImage ) = @_;
< 	my ( $link, $extra );
< 	
< 	( $link, $extra ) = &InterPageLink( $id, $useImage );
< 
< 	# Next line ensures no empty links are stored
< 	$link = &StoreRaw($link) if ( $link ne "" );
< 	
< 	return $link . $extra;
< }
< 
< sub InterPageLink {
< 	my ( $id, $useImage ) = @_;
< 	my ( $name, $site, $remotePage, $url, $punct );
< 	
< 	( $id, $punct ) = &SplitUrlPunct($id);
< 	$name = $id;
< 	( $site, $remotePage ) = split( /:/, $id, 2 );
< 	$url = &GetSiteUrl($site);
< 	
< 	return ( "", $id . $punct ) if ( $url eq "" );
< 	
< 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
< 	$url .= $remotePage;
< 	
< 	return ( &UrlLinkOrImage( $url, $name, $useImage ), $punct );
< }
< 
< sub StoreBracketInterPage {
< 	my ( $id, $text, $useImage, $options ) = @_;
< 	my ( $site, $remotePage, $url, $index );
< 	
< 	( $site, $remotePage ) = split( /:/, $id, 2 );
< 	$remotePage =~ s/&amp;/&/g;    # Unquote common URL HTML
< 	$url = &GetSiteUrl($site);
< 	
< 	if ( $text ne "" ) {
< 		return "[$id $text]" if ( $url eq "" );
< 	}
< 	else {
< 		return "[$id]" if ( $url eq "" );
< 		$text = &GetBracketUrlIndex($id);
< 	}
< 	
< 	$url .= $remotePage;
< 	
< 	$text = StoreBracketUrl( $url, $text, $useImage, $options);
< 	
< 	return $text;
< }
< 
< sub GetBracketUrlIndex {
< 	my ($id) = @_;
< 	my ( $index, $key );
< 
< 	# Consider plain array?
< 	if ( $SaveNumUrl{$id} > 0 ) {
< 		return $SaveNumUrl{$id};
< 	}
< 	
< 	$SaveNumUrlIndex++;    # Start with 1
< 	$SaveNumUrl{$id} = $SaveNumUrlIndex;
< 	
< 	return $SaveNumUrlIndex;
< }
< 
< sub GetSiteUrl {
< 	my ($site) = @_;
< 	my ( $data, $status );
< 	
< 	if ( !$InterSiteInit ) {
< 		( $status, $data ) = &ReadFile($InterFile);
< 		
< 		if ($status) {
< 			%InterSite = split( /\s+/, $data );    # Consider defensive code
< 		}
< 
< 		# Check for definitions to allow file to override automatic settings
< 		if ( !defined( $InterSite{'LocalWiki'} ) ) {
< 			$InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
< 		}
< 		
< 		if ( !defined( $InterSite{'Local'} ) ) {
< 			$InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
< 		}
< 		
< 		$InterSiteInit = 1;                        # Init only once per request
< 	}
< 	
< 	return $InterSite{$site} if ( defined( $InterSite{$site} ) );
< 	return "";
< }
< 
< sub StoreRaw {
< 	my ($html) = @_;
< 	
< 	$SaveUrl{$SaveUrlIndex} = $html;
< 	
< 	return $FS . $SaveUrlIndex++ . $FS;
< }
< 
< sub StorePre {
< 	my ( $html, $tag ) = @_;
< 	
< 	return &StoreRaw( "<$tag>" . $html . "</$tag>" );
< }
< 
< sub ReadWikiFile {
< 	my ($fileName) = @_;
< 	my ($fileData, %tempPage, %tempSection, %tempText);
< 	
< 	return unless -f $fileName;
< 	
< 	$fileData = &ReadFileOrDie($fileName);
< 	%tempPage = split(/$FS1/, $fileData, -1);
< 	%tempSection = split(/$FS2/, $tempPage{'text_default'}, -1);
< 	%tempText = split(/$FS3/, $tempSection{'data'}, -1);
< 	
< 	return $tempText{'text'};
< }
< 
< sub WikiFileToHTML {
< 	my ($text) = @_;
< 	my ($output);
< 	my ($mySaveUrlIndex, $mySaveNumUrlIndex, $myTableMode, %mySaveUrl, %mySaveNumUrl);
< 	
< 	return unless $text;
< 	
< 	# Global variables do not help this code. Nasty, but easiest solution.
< 	%mySaveUrl= %SaveUrl;
< 	%mySaveNumUrl= %SaveNumUrl;
< 	$mySaveUrlIndex= $SaveUrlIndex;
< 	$mySaveNumUrlIndex = $SaveNumUrlIndex;
< 	$myTableMode= $TableMode;
< 	
< 	$output = &WikiToHTML($text);
< 	
< 	%SaveUrl = %mySaveUrl;
< 	%SaveNumUrl = %mySaveNumUrl;
< 	$SaveUrlIndex = $mySaveUrlIndex;
< 	$SaveNumUrlIndex = $mySaveNumUrlIndex;
< 	$TableMode = $myTableMode;
< 	
< 	return $output;
< }
< 
< sub StoreTemplate {
< 	my ($params) = @_;	
< 	my $id = &GetParam( "id",     "" );
< 	my ($templateId, $templateFile, $templateText, $output, %substitutes);
< 	
< 	$params =~ s/^\s*(\S+)\s*/$templateId=$1,''/e;
< 	return &StoreRaw(T('No template name')) unless $templateId;
< 	
< 	$templateFile = &GetPageFile($templateId);
< 	return &StoreRaw(Ts('Template %s not found', $templateId)) unless -f $templateFile;
< 	
< 	while ($params =~ /^(\S+)\s*=(.*)$/gm) {
< 		$substitutes{$1} = $2;
< 	}
< 
< 	$substitutes{'PID'} = '/RalphMorgan';
< 	
< 	$templateText = &ReadWikiFile($templateFile);
< 	$templateText =~ s/\$(\S+)\$/$substitutes{$1}/gi;
< 	$templateText =~ s/{{//g; # Avoid nesting.
< 	$output = &WikiFileToHTML($templateText);
< 	
< 	return &StoreRaw($output);
< }
< 
< sub StoreHref {
< 	my ( $anchor, $text ) = @_;
< 	
< 	return "<a" . &StoreRaw($anchor) . ">$text</a>";
< }
< 
< sub StoreUrl {
< 	my ( $name, $useImage ) = @_;
< 	my ( $link, $extra );
< 	
< 	( $link, $extra ) = &UrlLink( $name, $useImage );
< 
< 	# Next line ensures no empty links are stored
< 	$link = &StoreRaw($link) if ( $link ne "" );
< 	
< 	return $link . $extra;
< }
< 
< sub UrlLink {
< 	my ( $rawname, $useImage ) = @_;
< 	my ( $name, $punct );
< 	
< 	( $name, $punct ) = &SplitUrlPunct($rawname);
< 	
< 	if ( $LimitFileUrl && ( $NetworkFile && $name =~ m|^file:| ) ) {
< 
< 		# Only do remote file:// links. No file:///c|/windows.
< 		if ( $name =~ m|^file://[^/]| ) {
< 			return ( "<a href='$name' class='wikiurllink'>$name</a>", $punct );
< 		}
< 		
< 		return ( $rawname, "" );
< 	}
< 	
< 	return ( &UrlLinkOrImage( $name, $name, $useImage ), $punct );
< }
< 
< sub UrlLinkOrImage {
< 	my ( $url, $name, $useImage ) = @_;
< 	
< 	# Restricted image URLs so that mailto:foo@bar.gif is not an image
< 	if ( $useImage && &ImageAllowed($url) ) {
< 		return "<a href='$url' class='wikiurlorimage' target='_blank'><img class='wikiurlorimage' src='$url'></a>";
< 	}
< 	
< 	return "<a href='$url' class='wikiurlorimage'>$name</a>";
< }
< 
< sub ImageAllowed {
< 	my ($url) = @_;
< 	my ( $site, $imagePrefixes );
< 	
< 	$imagePrefixes = 'http:|https:|ftp:|upload:';
< 	$imagePrefixes .= '|file:' if ( !$LimitFileUrl );
< 	
< 	return 0 unless ( $url =~ /^($imagePrefixes).+\.(gif|jpg|png|bmp|jpeg|ico|tiff|pdf|psd|ai|xls|ppt|js|css|doc|txt|swf)$/i );
< 	return 0 if ( $url =~ /"/ );    #" No HTML-breaking quotes allowed
< 	return 1 if ( @ImageSites < 1 );    # Most common case: () means all allowed
< 	return 0 if ( $ImageSites[0] eq 'none' );    # Special case: none allowed
< 
< 	foreach $site (@ImageSites) {
< 		return 1
< 		  if ( $site eq substr( $url, 0, length($site) ) );    # Match prefix
< 	}
< 	
< 	return 0;
< }
< 
< sub ExtensionAllowed {
< 	my ($file) = @_;
< 	
< 	return 1 if ( $file =~ m/\.(jpg|bmp|pdf|gif|psd|ai|xls|ppt|js|css|doc|txt|swf)$/ );
< 	
< 	return 0;	
< }
< 
< sub GetUploadUrl {
< 	my ($url) = @_;
< 	
< 	&StoreRaw($url);
< }
< 
< sub GetOptions {
< 	my ($text) = @_;
< 	my %options;
< 	
< 	foreach my $pair (split(/\|/, $text)){
< 		my @keyvalues = split (/=/, $pair);
< 		$options{$keyvalues[0]} = $keyvalues[1];
< 	}
< 	
< 	return %options;	
< }
< 
< sub ComputeImageRatio {
< 	my ($imageName, $desiredWidth, $desiredHeight, $okayLarger) = @_;
< 	my $filepath = "$UploadDir/$imageName";
< 	my ($imageWidth, $imageHeight) = Image::Size::imgsize($filepath);
< 	
< 	my $ratioWidth = 1;
< 	my $ratioHeight = 1;
< 	my $ratioFinal = 1;
< 	
< 	if ($desiredWidth){ $ratioWidth = $desiredWidth/$imageWidth; }
< 	if ($desiredHeight){ $ratioHeight = $desiredHeight/$imageHeight; }
< 	
< 	if ($okayLarger){
< 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioWidth; }
< 		else { $ratioFinal = $ratioHeight; }
< 	}
< 	else {
< 		if ($ratioWidth > $ratioHeight){ $ratioFinal = $ratioHeight; }
< 		else { $ratioFinal = $ratioWidth; }
< 	
< 	}
< 	
< 	my $finalWidth = int($ratioFinal * $imageWidth);
< 	my $finalHeight = int($ratioFinal * $imageHeight);
< 	
< 	return ($finalWidth, $finalHeight);
< }
< 
< sub StoreBracketUrl {
< 	my ( $url, $text, $useImage, $options ) = @_;
< 	my %options = &GetOptions($options);
< 	my $imageFloat;
< 	my $imageClear = "\n<br class='clear$options{clear}'/>";
< 	my $boxFloat = " float" . $options{'boxfloat'};
< 	my $boxClear = "\n<br class='clear$options{boxclear}'/>";
< 	my $width;
< 	my $height;
< 	my $title;
< 	my $caption;
< 	my $description;
< 	my $imageLink;
< 	my $boxWidth = "style='width: 300px !important;'";
< 
< 	if ( $text eq "" ) { $text = &GetBracketUrlIndex($url); }
< 	elsif ($text =~ /^$InterLinkPattern$/) {
< 		my @interlink = split(/:/, $text, 2);
< 		$text = &GetSiteUrl($interlink[0]) . $interlink[1];
< 	}
< 
< 	if ($options{'float'}){ $imageFloat = "float" . $options{'float'}; }
< 	if ($options{'clear'}){ $imageClear = "\n<br class='clear$options{clear}'/>"; }
< 	if ($options{'title'}){ $title = $options{title}; } else { $title = $text; }
< 	if ($options{'width'}){ $width = $options{'width'}; }
< 	if ($options{'height'}){ $height = $options{'height'}; }
< 			
< 	if ($options{'boxfloat'}){ $boxFloat = "float" . $options{'boxfloat'}; }
< 	if ($options{'boxclear'}){ $boxClear = "\n<br class='clear$options{boxclear}'/>"; }
< 	if ($options{'boxwidth'}){ $boxWidth = "style='width: $options{boxwidth} !important;'"; }
< 	if ($options{'caption'}){ 
< 		if ($options{'description'}){ $description = $options{description}; } 
< 		else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
< 		
< 		$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div><div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
< 	}
< 	
< 	if ($url =~ /$UploadPattern/){ $url = "$UploadUrl/$1"; }	
< 	if ( $BracketImg && $useImage && &ImageAllowed($text) ) {		
< 		if ($text =~ /$UploadPattern/){
< 			my $imageName = $1;
< 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($imageName, $width, $height, "");
< 			my $imageStyle = "style='width: $imageWidth; height: $imageHeight;'";
< 			
< 			$imageLink = "$UploadUrl/" . &GetUploadUrl($1);			
< 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' $imageStyle src='$imageLink'></a>";
< 		}
< 		else {
< 			$imageLink = $text;
< 			$text = "<a href='$url' title='$title' class='wikibracketurl'><img class='wikibracketurl $imageFloat' src='$imageLink'></a>";
< 		}
< 		my $expandlink =  "<a target='_blank' class='wikiexpandimageicon' href='$imageLink' title='View source image'>&nbsp;</a>";
< 		
< 		if ($options{'caption'}){ 
< 			if ($options{'description'}){ $description = $options{description}; } 
< 			else { $description = "FIGURE " . (++$GLOBAL_imageCount); }
< 			
< 			$caption =  "\n<div class='wikibracketboxtitle image$imageFloat clearfix'>$description</div>$expandlink<div class='wikibracketboxdescription clearfix'>$options{caption}</div>"; 
< 		}
< 			
< 		if ($imageClear){ $text .= $imageClear; }		
< 					
< 		if ($caption){
< 			$text = "\n<div title='$title' class='wikibracketbox $boxFloat' $boxWidth>$text$caption</div>";		
< 		}
< 		else {
< 			$text = "\n<div title='$title' class='$boxFloat'>$text</div>";	
< 		}
< 		
< 		if ($boxClear){ $text .= $boxClear; }
< 	}
< 	else {
< 		$text = "<a href='$url' title='$title' class='wikibracketurl'>[$text]</a>";
< 	}
< 	
< 	return &StoreRaw($text);
< }
< 
< sub StoreBracketLink {
< 	my ( $name, $text ) = @_;
< 	
< 	return &StoreRaw( &GetPageLinkText( $name, "[$text]" ) );
< }
< 
< sub StoreBracketAnchoredLink {
< 	my ( $name, $anchor, $text ) = @_;
< 	
< 	return &StoreRaw( &GetPageLinkText( "$name#$anchor", "[$text]" ) );
< }
< 
< sub StorePageOrEditLink {
< 	my ( $page, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$page =~ s/^\s+//;        # Trim extra spaces
< 		$page =~ s/\s+$//;
< 		$page =~ s|\s*/\s*|/|;    # ...also before/after subpages
< 	}
< 	$name =~ s/^\s+//;
< 	$name =~ s/\s+$//;
< 	
< 	return &StoreRaw( &GetPageOrEditLink( $page, $name ) );
< }
< 
< sub StoreRFC {
< 	my ($num) = @_;
< 	return &StoreRaw( &RFCLink($num) );
< }
< 
< sub RFCLink {
< 	my ($num) = @_;
< 	return "<a href='http://www.faqs.org/rfcs/rfc${num}.html' class='wikirfclink'>RFC $num</a>";
< }
< 
< sub StoreUpload {
< 	my ($url) = @_;
< 	
< 	return &StoreRaw( &UploadLink($url) );
< }
< 
< sub UploadLink {
< 	my ($filename) = @_;
< 	my ( $html, $url );
< 	
< 	return $filename if ( $UploadUrl eq "" );    # No bad links if misconfigured
< 	
< 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
< 	$url  = $UploadUrl . $filename;
< 	$html = "<a href='$url' class='wikiuploadlink' target='_blank'>";
< 	
< 	if ( &ImageAllowed($url) ) {
< 		$html .= "<img class='wikiuploadlink' src='$url' alt='upload:$filename'>";
< 	}
< 	else {
< 		$html .= "upload:$filename";
< 	}
< 	$html .= "</a>";
< 	
< 	return $html;
< }
< 
< sub StoreISBN {
< 	my ($num) = @_;
< 	
< 	return &StoreRaw( &ISBNLink($num) );
< }
< 
< sub ISBNALink {
< 	my ( $num, $pre, $post, $text ) = @_;
< 	
< 	return "<a href='$pre$num$post' class='wikiisbnalink'>$text</a>";
< }
< 
< sub ISBNLink {
< 	my ($rawnum) = @_;
< 	my ( $rawprint, $html, $num, $numSites, $i );
< 	
< 	$num      = $rawnum;
< 	$rawprint = $rawnum;
< 	$rawprint =~ s/ +$//;
< 	$num      =~ s/[- ]//g;
< 	$numSites = scalar @IsbnNames;    # Number of entries
< 	
< 	if ( ( length($num) != 10 ) || ( $numSites < 1 ) ) {
< 		return "ISBN $rawnum";
< 	}
< 	
< 	$html = &ISBNALink( $num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint );
< 	
< 	if ( $numSites > 1 ) {
< 		$html .= " (";
< 		$i = 1;
< 		while ( $i < $numSites ) {
< 			$html .=
< 			  &ISBNALink( $num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i] );
< 			if ( $i < ( $numSites - 1 ) ) {    # Not the last site
< 				$html .= ", ";
< 			}
< 			$i++;
< 		}
< 		$html .= ")";
< 	}
< 	
< 	$html .= " " if ( $rawnum =~ / $/ );    # Add space if old ISBN had space.
< 	
< 	return $html;
< }
< 
< sub SplitUrlPunct {
< 	my ($url) = @_;
< 	my ($punct);
< 	
< 	if ( $url =~ s/\"\"$// ) {  #"REMARK
< 		return ( $url, "" );    # Delete double-quote delimiters here
< 	}
< 	
< 	$punct = "";
< 	if ($NewFS) {
< 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/ );
< 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
< 	}
< 	else {
< 		($punct) = ( $url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/ );
< 		$url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
< 	}
< 	
< 	return ( $url, $punct );
< }
< 
< sub StripUrlPunct {
< 	my ($url) = @_;
< 	my ($junk);
< 	
< 	( $url, $junk ) = &SplitUrlPunct($url);
< 	
< 	return $url;
< }
< 
< sub WikiHeadingNumber {
< 	my ( $depth, $text, $useNumber) = @_;
< 	#my ( $depth, $text ) = @_;
< 	my ( $anchor, $number );
< 	
< 	return "" unless --$depth > 0;    # Don't number H1s because it looks stupid
< 		
< 	while ( scalar @HeadingNumbers < ( $depth - 1 ) ) {
< 		push @HeadingNumbers, 1;
< 		$TableOfContents .= "\n<dl><dt></dt><dd>";
< 	}
< 	
< 	if ( scalar @HeadingNumbers < $depth ) {
< 		push @HeadingNumbers, 0;
< 		$TableOfContents .= "\n<dl><dt></dt><dd>";
< 	}
< 	
< 	while ( scalar @HeadingNumbers > $depth ) {
< 		pop @HeadingNumbers;
< 		$TableOfContents .= "</dd></dl>";
< 	}
< 	
< 	$HeadingNumbers[$#HeadingNumbers]++;
< 	$number = ( join '.', @HeadingNumbers ) . '. ';
< 
< 	# Remove embedded links. THIS IS FRAGILE!
< 	$text = &RestoreSavedText($text);
< 	$text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si;        # No such page syntax
< 	$text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
< 
< 	# Cook anchor by canonicalizing $text.
< 	$anchor = $text;
< 	$anchor =~ s/\<.*?\>//g;
< 	$anchor =~ s/\W/_/g;
< 	$anchor =~ s/__+/_/g;
< 	$anchor =~ s/^_//;
< 	$anchor =~ s/_$//;
< 
< 	# Last ditch effort
< 	$anchor = "_" . ( join '_', @HeadingNumbers ) unless $anchor;
< 	$TableOfContents .= ('&nbsp;' x (2 * $depth)) . $number;
< 	$TableOfContents .= &ScriptLink( "$OpenPageName#$anchor", $text );
< 	$TableOfContents .= "</dd><dt>";
< 	$TableOfContents .= "</dt><dd>";
< 	  
< 	## return &StoreHref(" name='$anchor'") . $number;
< 	if ($useNumber) {
< 		return &StoreHref(" name='$anchor'") . $number;
< 	} else {
< 		return &StoreHref(" name='$anchor'");
< 	}
< }
< 
< sub WikiHeading {
< 	## my ( $pre, $depth, $text ) = @_;
< 	my ($pre, $depth, $text, $useNumber) = @_;
< 	$depth = length($depth);
< 	$depth = 6 if ( $depth > 6 );
< 	##$text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e;    # $' == $POSTMATCH
< 	if ($useNumber) {
< 		$text = &WikiHeadingNumber($depth,$text, 1) . $text;
< 	} else {
< 		$text = &WikiHeadingNumber($depth,$text, 0) . $text;
< 	}	
< 	return $pre . "<h$depth>$text</h$depth>";
< }
< 
< # ==== Difference markup and HTML ====
< sub GetDiffHTML {
< 	my ( $diffType, $id, $revOld, $revNew, $newText ) = @_;
< 	my ( $html, $diffText, $diffTextTwo, $priorName, $links, $usecomma );
< 	my ( $major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName );
< 	
< 	$links     = " (";
< 	$usecomma  = 0;
< 	$major     = &ScriptLinkDiff( 1, $id, "major diff", "" );
< 	$minor     = &ScriptLinkDiff( 2, $id, "minor diff", "" );
< 	$author    = &ScriptLinkDiff( 3, $id, "author diff", "" );
< 	$useMajor  = 1;
< 	$useMinor  = 1;
< 	$useAuthor = 1;
< 	$diffType  = &GetParam( "defaultdiff", 1 ) if ( $diffType == 4 );
< 	
< 	if ( $diffType == 1 ) {
< 		$priorName = "major";
< 		$cacheName = "major";
< 		$useMajor  = 0;
< 	}
< 	elsif ( $diffType == 2 ) {
< 		$priorName = "minor";
< 		$cacheName = "minor";
< 		$useMinor  = 0;
< 	}
< 	elsif ( $diffType == 3 ) {
< 		$priorName = "author";
< 		$cacheName = "author";
< 		$useAuthor = 0;
< 	}
< 	
< 	if ( $revOld ne "" ) {
< 
< 		# Note: OpenKeptRevisions must have been done by caller.
< 		# Eventually optimize if same as cached revision
< 		$diffText = &GetKeptDiff( $newText, $revOld, 1 );    # 1 = get lock
< 		if ( $diffText eq "" ) {
< 			$diffText = "(The revisions are identical or unavailable.)";
< 		}
< 	}
< 	else {
< 		$diffText = &GetCacheDiff($cacheName);
< 	}
< 	
< 	$useMajor = 0 if ( $useMajor && ( $diffText eq &GetCacheDiff("major") ) );
< 	$useMinor = 0 if ( $useMinor && ( $diffText eq &GetCacheDiff("minor") ) );
< 	$useAuthor = 0 if ( $useAuthor && ( $diffText eq &GetCacheDiff("author") ) );
< 	$useMajor = 0 if ( ( !defined( &GetPageCache('oldmajor') ) ) || ( &GetPageCache("oldmajor") < 1 ) );
< 	$useAuthor = 0 if ( ( !defined( &GetPageCache('oldauthor') ) ) || ( &GetPageCache("oldauthor") < 1 ) );
< 	
< 	if ($useMajor) {
< 		$links .= $major;
< 		$usecomma = 1;
< 	}
< 	
< 	if ($useMinor) {
< 		$links .= ", " if ($usecomma);
< 		$links .= $minor;
< 		$usecomma = 1;
< 	}
< 	
< 	if ($useAuthor) {
< 		$links .= ", " if ($usecomma);
< 		$links .= $author;
< 	}
< 	
< 	if ( !( $useMajor || $useMinor || $useAuthor ) ) {
< 		$links .= "no other diffs";
< 	}
< 	$links .= ")";
< 	
< 	if ( ( !defined($diffText) ) || ( $diffText eq "" ) ) {
< 		$diffText = "No diff available.";
< 	}
< 	
< 	if ( $revOld ne "" ) {
< 		my $currentRevision = "current revision";
< 		
< 		$currentRevision = "revision $revNew " if $revNew;
< 		$html .= "<h4>Difference (from revision $revOld to $currentRevision)</h4>";
< 		$html .= "$links<br><br>";
< 		$html .= &DiffToHTML($diffText);
< 	}
< 	else {
< 		if (
< 			( $diffType != 2 )
< 			&& (   ( !defined( &GetPageCache("old$cacheName") ) )
< 				|| ( &GetPageCache("old$cacheName") < 1 ) )
< 		  )
< 		{
< 			$html .= "<h4>No diff available -- this is the first $priorName revision.</h4>";
< 			$html .= "$links<br><br>";
< 		}
< 		else {
< 			$html .= "<h4>Difference from prior $priorName revision</h4>";
< 			$html .= "$links<br><br>";
< 			$html .= &DiffToHTML($diffText);
< 		}
< 	}
< 	@HeadingNumbers  = ();
< 	$TableOfContents = "";
< 		
< 	return $html;
< }
< 
< sub GetCacheDiff {
< 	my ($type) = @_;
< 	my ($diffText);
< 	$diffText = &GetPageCache("diff_default_$type");
< 	$diffText = &GetCacheDiff('minor') if ( $diffText eq "1" );
< 	$diffText = &GetCacheDiff('major') if ( $diffText eq "2" );
< 	return $diffText;
< }
< 
< # Must be done after minor diff is set and OpenKeptRevisions called
< sub GetKeptDiff {
< 	my ( $newText, $oldRevision, $lock ) = @_;
< 	my ( %sect, %data, $oldText );
< 	$oldText = "";
< 	if ( defined( $KeptRevisions{$oldRevision} ) ) {
< 		%sect = split( /$FS2/, $KeptRevisions{$oldRevision}, -1 );
< 		%data = split( /$FS3/, $sect{'data'}, -1 );
< 		$oldText = $data{'text'};
< 	}
< 	return "" if ( $oldText eq "" );    # Old revision not found
< 	return &GetDiff( $oldText, $newText, $lock );
< }
< 
< sub GetDiff {
<   my $textOld = shift;
<   my $textNew = shift;
< 
<   my %format = (
<     paraIdent     => '<tr valign=top><td class="diff-para-ident">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident">%text%</td></tr>',
<     paraAdded     => '<tr valign=top><td class="diff-para-ident"></td><td class="diff-vertical"></td><td class="diff-para-added">%text%</td></tr>',
<     paraDeleted   => '<tr valign=top><td class="diff-para-deleted">%text%</td><td class="diff-vertical"></td><td class="diff-para-ident"></td></tr>',
<     paraChanged   => '<tr valign=top><td class="diff-para-changed-old">%text%</td><td class="diff-vertical"></td><td class="diff-para-changed-new">%text%</td></tr>',
<     paraReplaced  => '<tr valign=top><td class="diff-para-deleted">%textDeleted%</td><td class="diff-vertical"></td><td class="diff-para-added">%textAdded%</td></tr>',
<   
<     changeContext => 1,
<     changeHeader  => '<tr valign=top><td class="diff-header">Paragraph %oldFrom%</td><td class="diff-vertical">&nbsp;</td><td class="diff-header">Paragraph %newFrom%</td></tr>',
<   
<     spanIdent     => '<span class="diff-span-ident">%text%</span>',
<     spanAdded     => '<span class="diff-span-added">%text%</span>',
<     spanDeleted   => '<span class="diff-span-deleted">%text%</span>',
< 
<     processText => sub {
< 
<       my $text = shift;
< 
<       $text =~ s[&]               [&amp;]g;
<       $text =~ s[<]               [&lt;]g;
<       $text =~ s[>]               [&gt;]g;
<       $text =~ s[\n]              [<br>\n]g;
<       $text =~ s[\r]              []g;
<       $text =~ s[([\t ]+)([\t ])] [('&nbsp;' x length($1)) . $2]ge;
<       $text =~ s[^[\t ]]          [&nbsp;];
< 
<       return $text;
<     }
<   );
< 
<   my $diff = Diff::diffText($textOld, $textNew, %format);
<   
<   if ($diff ne "") {
<     $diff =~ s[<td class="diff-para-changed-old">(.*?)</td>] [
<       my $textChanged = $1;
<       $textChanged =~ s[<span class="diff-span-added">.*?</span>] []gs;
<       qq[<td class="diff-para-changed">$textChanged</td>];
<     ]ges;
<     
<     $diff =~ s[<td class="diff-para-changed-new">(.*?)</td>] [
<       my $textChanged = $1;
<       $textChanged =~ s[<span class="diff-span-deleted">.*?</span>] []gs;
<       qq[<td class="diff-para-changed">$textChanged</td>];
<     ]ges;
<   
<     $diff = qq[<div id=wikidiffdiv><table id=wikidifftable>$diff</table></div>];
<   }
< 
<   return $diff;
< }
< 
< sub DiffToHTML { shift }
< 
< 
< 
< # ==== Database (Page, Section, Text, Kept, User) functions ====
< sub OpenNewPage {
< 	my ($id) = @_;
< 	%Page             = ();
< 	$Page{'version'}  = 3;       # Data format version
< 	$Page{'revision'} = 0;       # Number of edited times
< 	$Page{'tscreate'} = $Now;    # Set once at creation
< 	$Page{'ts'}       = $Now;    # Updated every edit
< 	$Page{'authorcreate'} = GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
< }
< 
< sub OpenNewSection {
< 	my ( $name, $data ) = @_;
< 	%Section             = ();
< 	$Section{'name'}     = $name;
< 	$Section{'version'}  = 1;                   # Data format version
< 	$Section{'revision'} = 0;                   # Number of edited times
< 	$Section{'tscreate'} = $Now;                # Set once at creation
< 	$Section{'ts'}       = $Now;                # Updated every edit
< 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
< 	$Section{'host'} 	 = "";        # Updated only for real edits (can be slow)
< 	$Section{'id'}   	 = $UserID;
< 	$Section{'username'} = &GetParam( "username", "" );
< 	$Section{'data'}     = $data;
< 	$Page{$name} 		 = join( $FS2, %Section );    # Replace with save?
< 	$Page{'authorcreate'}= GetParam('username',"") unless $Page{'authorcreate'} or $Page{revision}; # Set once at creation
< }
< 
< sub OpenNewText {
< 	my ($name) = @_;                          # Name of text (usually "default")
< 	%Text = ();
< 	
< 	if ( $NewText ne "" ) {
< 		$Text{'text'} = $NewText;
< 	}
< 	else {
< 		$Text{'text'} = "Describe the new page here.";
< 	}
< 	
< 	$Text{'text'} .= "\n" if ( substr( $Text{'text'}, -1, 1 ) ne "\n" );
< 	$Text{'minor'}     = 0;                   # Default as major edit
< 	$Text{'newauthor'} = 1;                   # Default as new author
< 	$Text{'summary'}   = "";
< 	
< 	&OpenNewSection( "text_$name", join( $FS3, %Text ) );
< }
< 
< sub GetPageFile {
< 	my ($id) = @_;
< 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
< }
< 
< sub OpenPage {
< 	my ($id) = @_;
< 	my ( $fname, $data );
< 	
< 	if (!CheckIsAuthUser($id)) { $id = "AuthError"; } #auth patch
< 	if ( $OpenPageName eq $id ) { return; }
< 	if ( $id eq ""){ return; }
< 		
< 	%Section = ();
< 	%Text    = ();
< 	$fname   = &GetPageFile($id);
< 	
< 	if ( -f $fname ) {
< 		$data = &ReadFileOrDie($fname);
< 		%Page = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	}
< 	else {
< 		&OpenNewPage($id);
< 	}
< 	
< 	if ( $Page{'version'} != 3 ) {
< 		&UpdatePageVersion();
< 	}
< 	
< 	$OpenPageName = $id;
< }
< 
< sub OpenSection {
< 	my ($name) = @_;
< 	if ( !defined( $Page{$name} ) ) {
< 		&OpenNewSection( $name, "" );
< 	}
< 	else {
< 		%Section = split( /$FS2/, $Page{$name}, -1 );
< 	}
< }
< 
< sub OpenText {
< 	my ($name) = @_;
< 	if ( !defined( $Page{"text_$name"} ) ) {
< 		&OpenNewText($name);
< 	}
< 	else {
< 		&OpenSection("text_$name");
< 		%Text = split( /$FS3/, $Section{'data'}, -1 );
< 	}
< }
< 
< sub OpenDefaultText {
< 	&OpenText('default');
< }
< 
< # Called after OpenKeptRevisions
< sub OpenKeptRevision {
< 	my ($revision) = @_;
< 	%Section = split( /$FS2/, $KeptRevisions{$revision}, -1 );
< 	%Text = split( /$FS3/, $Section{'data'}, -1 );
< }
< 
< sub GetPageCache {
< 	my ($name) = @_;
< 	return $Page{"cache_$name"};
< }
< 
< # Always call SavePage within a lock.
< sub SavePage {
< 	my $file = &GetPageFile($OpenPageName);
< 	$Page{'revision'} += 1;    # Number of edited times
< 	$Page{'ts'} = $Now;        # Updated every edit
< 	&CreatePageDir( $PageDir, $OpenPageName );
< 	&WriteStringToFile( $file, join( $FS1, %Page ) );
< }
< 
< sub SaveSection {
< 	my ( $name, $data ) = @_;
< 	$Section{'revision'} += 1;    # Number of edited times
< 	$Section{'ts'}       = $Now;                          # Updated every edit
< 	$Section{'ip'}       = $ENV{REMOTE_ADDR};
< 	$Section{'id'}       = $UserID;
< 	$Section{'username'} = &GetParam( "username", "" );
< 	$Section{'data'}     = $data;
< 	$Page{$name} = join( $FS2, %Section );
< }
< 
< sub SaveText {
< 	my ($name) = @_;
< 	&SaveSection( "text_$name", join( $FS3, %Text ) );
< }
< 
< sub SaveDefaultText {
< 	&SaveText('default');
< }
< 
< sub SetPageCache {
< 	my ( $name, $data ) = @_;
< 	$Page{"cache_$name"} = $data;
< }
< 
< sub UpdatePageVersion {
< 	&ReportError( "Bad page version (or corrupt page)." );
< }
< 
< sub KeepFileName {
< 	return $KeepDir . "/"
< 	  . &GetPageDirectory($OpenPageName)
< 	  . "/$OpenPageName.kp";
< }
< 
< sub SaveKeepSection {
< 	my $file = &KeepFileName();
< 	my $data;
< 	return if ( $Section{'revision'} < 1 );    # Don't keep "empty" revision
< 	$Section{'keepts'} = $Now;
< 	$data = $FS1 . join( $FS2, %Section );
< 	&CreatePageDir( $KeepDir, $OpenPageName );
< 	&AppendStringToFileLimited( $file, $data, $KeepSize );
< }
< 
< sub ExpireKeepFile {
< 	my ( $fname, $data, @kplist, %tempSection, $expirets );
< 	my ( $anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev );
< 	my ( $oldMajor, $oldAuthor );
< 	$fname = &KeepFileName();
< 	return if ( !( -f $fname ) );
< 	
< 	$data = &ReadFileOrDie($fname);
< 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	return if ( length(@kplist) < 1 );    # Also empty
< 	
< 	shift(@kplist) if ( $kplist[0] eq "" );    # First can be empty
< 	return if ( length(@kplist) < 1 );         # Also empty
< 	
< 	%tempSection = split( /$FS2/, $kplist[0], -1 );
< 
< 	if ( !defined( $tempSection{'keepts'} ) ) {
< 		return;                                # Bad keep file
< 	}
< 	
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 	return if ( $tempSection{'keepts'} >= $expirets );    # Nothing old enough
< 	
< 	$anyExpire = 0;
< 	$anyKeep   = 0;
< 	%keepFlag  = ();
< 	$oldMajor  = &GetPageCache('oldmajor');
< 	$oldAuthor = &GetPageCache('oldauthor');
< 	
< 	foreach ( reverse @kplist ) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName    = $tempSection{'name'};
< 		$sectRev     = $tempSection{'revision'};
< 		$expire      = 0;
< 		
< 		if ( $sectName eq "text_default" ) {
< 			if (   ( $KeepMajor && ( $sectRev == $oldMajor ) )
< 				|| ( $KeepAuthor && ( $sectRev == $oldAuthor ) ) )
< 			{
< 				$expire = 0;
< 			}
< 			elsif ( $tempSection{'keepts'} < $expirets ) {
< 				$expire = 1;
< 			}
< 		}
< 		else {
< 			if ( $tempSection{'keepts'} < $expirets ) {
< 				$expire = 1;
< 			}
< 		}
< 		if ( !$expire ) {
< 			$keepFlag{ $sectRev . "," . $sectName } = 1;
< 			$anyKeep = 1;
< 		}
< 		else {
< 			$anyExpire = 1;
< 		}
< 	}
< 	if ( !$anyKeep ) {    # Empty, so remove file
< 		unlink($fname);
< 		return;
< 	}
< 	return if ( !$anyExpire );    # No sections expired
< 	
< 	open( OUT, ">$fname" ) or die( Ts( 'cant write %s', $fname ) . ": $!" );
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName    = $tempSection{'name'};
< 		$sectRev     = $tempSection{'revision'};
< 		
< 		if ( $keepFlag{ $sectRev . "," . $sectName } ) {
< 			print OUT $FS1, $_;
< 		}
< 	}
< 	close(OUT);
< }
< 
< sub OpenKeptList {
< 	my ( $fname, $data );
< 	@KeptList = ();
< 	$fname    = &KeepFileName();
< 	return if ( !( -f $fname ) );
< 	
< 	$data = &ReadFileOrDie($fname);
< 	@KeptList = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< }
< 
< sub OpenKeptRevisions {
< 	my ($name) = @_;    # Name of section
< 	my ( $fname, $data, %tempSection );
< 	
< 	%KeptRevisions = ();
< 	&OpenKeptList();
< 	
< 	foreach (@KeptList) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		next if ( $tempSection{'name'} ne $name );
< 		$KeptRevisions{ $tempSection{'revision'} } = $_;
< 	}
< }
< 
< sub LoadUserData {
< 	my ( $data, $status );
< 	%UserData = ();
< 	( $status, $data ) = &ReadFile( &UserDataFilename($UserID) );
< 	
< 	if ( !$status ) {
< 		$UserID = 112;    # Could not open file.  Consider warning message?
< 		return;
< 	}
< 	%UserData = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< }
< 
< sub UserDataFilename {
< 	my ($id) = @_;
< 	if ($id =~ /(\d+)/){
< 		$id = $1;
< 	}
< 	else { die "The userid must be a positive integer"; }
< 	
< 	return "" if ( $id < 1 );
< 	return $UserDir . "/" . ( $id % 10 ) . "/$id.db";
< }
< 
< # ==== Misc. functions ====
< sub ReportError {
< 	my ($errmsg) = @_;
< 	
< 	print &GetHeader( "", "ERROR!", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>$errmsg</h2>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub ValidId {
< 	my ($id) = @_;
< 	if ( length($id) > 120 ) {
< 		return Ts( 'Page name is too long: %s', $id );
< 	}
< 	
< 	if ( $id =~ m| | ) {
< 		return Ts( 'Page name may not contain space characters: %s', $id );
< 	}
< 	
< 	if ($UseSubpage) {
< 		if ( $id =~ m|.*/.*/| ) {
< 			return Ts( 'Too many / characters in page %s', $id );
< 		}
< 		if ( $id =~ /^\// ) {
< 			return Ts( 'Invalid Page %s (subpage without main page)', $id );
< 		}
< 		if ( $id =~ /\/$/ ) {
< 			return Ts( 'Invalid Page %s (missing subpage name)', $id );
< 		}
< 	}
< 	
< 	if ($FreeLinks) {
< 		$id =~ s/ /_/g;
< 		if ( !$UseSubpage ) {
< 			if ( $id =~ /\// ) {
< 				return Ts( 'Invalid Page %s (/ not allowed)', $id );
< 			}
< 		}
< 		if ( !( $id =~ m|^$FreeLinkPattern$| ) ) {
< 			return Ts( 'Invalid Page %s', $id );
< 		}
< 		if ( $id =~ m|\.db$| ) {
< 			return Ts( 'Invalid Page %s (must not end with .db)', $id );
< 		}
< 		if ( $id =~ m|\.lck$| ) {
< 			return Ts( 'Invalid Page %s (must not end with .lck)', $id );
< 		}
< 		return "";
< 	}
< 	else {
< 		if ( !( $id =~ /^$LinkPattern$/ ) ) {
< 			return Ts( 'Invalid Page %s', $id );
< 		}
< 	}
< 	
< 	return "";
< }
< 
< sub ValidIdOrDie {
< 	my ($id) = @_;
< 	my $error;
< 	
< 	$error = &ValidId($id);
< 	
< 	if ( $error ne "" ) {
< 		&ReportError($error);
< 		return 0;
< 	}
< 	return 1;
< }
< 
< sub UserCanEdit {
< 	my ( $id, $deepCheck ) = @_;
< 	my $authtype = &CheckIsAuthUser($id);
< 	
< 	# Optimized for the "everyone can edit" case (don't check passwords)
< 	if ( ( $id ne "" ) && ( -f &GetLockedPageFile($id) ) ) {
< 		return 1 if ( &UserIsAdmin() );    # Requires more privledges
< 		     # Consider option for editor-level to edit these pages?
< 		return 0;
< 	}
< 	if ( !$EditAllowed ) {
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0;
< 	}
< 	if ( -f "$DataDir/noedit" ) {
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0;
< 	}
< 	if ($deepCheck) {    # Deeper but slower checks (not every page)
< 		return 1 if ( $authtype eq "2" || $authtype eq "3");
< 		return 1 if ( &UserIsEditor() );
< 		return 0 if ( &UserIsBanned() );
< 	}
< 	return 1;
< }
< 
< sub UserIsBanned {
< 	my ( $host, $ip, $data, $status );
< 	( $status, $data ) = &ReadFile("$DataDir/banlist");
< 	return 0 if ( !$status );    # No file exists, so no ban
< 	$data =~ s/\r//g;
< 	$ip   = $ENV{'REMOTE_ADDR'};
< 	$host = &GetRemoteHost(0);
< 	
< 	foreach ( split( /\n/, $data ) ) {
< 		next if ( (/^\s*$/) || (/^#/) );    # Skip empty, spaces, or comments
< 		return 1 if ( $ip   =~ /$_/i );
< 		return 1 if ( $host =~ /$_/i );
< 	}
< 	return 0;
< }
< 
< sub UserIsAdmin {
< 	my ( @pwlist, $userPassword );
< 	
< 	return 0 if ( $AdminPass eq "" );
< 	$userPassword = &GetParam( "adminpw", "" );
< 	return 0 if ( $userPassword eq "" );
< 	
< 	foreach ( split( /\s+/, $AdminPass ) ) {
< 		next     if ( $_            eq "" );
< 		return 1 if ( $userPassword eq $_ );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsEditor {
< 	my ( @pwlist, $userPassword );
< 	
< 	return 1 if ( &UserIsAdmin() );    # Admin includes editor
< 	return 0 if ( $EditPass eq "" );
< 	$userPassword = &GetParam( "password", "" );    # Used for both
< 	return 0 if ( $userPassword eq "" );
< 	
< 	foreach ( split( /\s+/, $EditPass ) ) {
< 		next     if ( $_            eq "" );
< 		return 1 if ( $userPassword eq $_ );
< 	}
< 	
< 	return 0;
< }
< 
< sub UserIsEditorOrAdmin {
< 	return (UserIsEditor || UserIsAdmin);	
< }
< 
< sub UserCanUpload {
< 	return 1 if ( &UserIsEditor() );
< 	return $AllUpload;
< }
< 
< sub GetLockedPageFile {
< 	my ($id) = @_;
< 	return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
< }
< 
< sub RequestLockDir {
< 	my ( $name, $tries, $wait, $errorDie ) = @_;
< 	my ( $lockName, $n );
< 	&CreateDir($TempDir);
< 	$lockName = $LockDir . $name;
< 	$n        = 0;
< 	while ( mkdir( $lockName, 0555 ) == 0 ) {
< 		if ( $! != 17 ) {
< 			die( Ts( 'can not make %s', $LockDir ) . ": $!\n" ) if $errorDie;
< 			return 0;
< 		}
< 		return 0 if ( $n++ >= $tries );
< 		sleep($wait);
< 	}
< 	return 1;
< }
< 
< sub ReleaseLockDir {
< 	my ($name) = @_;
< 	rmdir( $LockDir . $name );
< }
< 
< sub RequestLock {
< 
< 	# 10 tries, 3 second wait, possibly die on error
< 	return &RequestLockDir( "main", 10, 3, $LockCrash );
< }
< 
< sub ReleaseLock {
< 	&ReleaseLockDir('main');
< }
< 
< sub ForceReleaseLock {
< 	my ($name) = @_;
< 	my $forced;
< 
< 	# First try to obtain lock (in case of normal edit lock)
< 	# 5 tries, 3 second wait, do not die on error
< 	$forced = !&RequestLockDir( $name, 5, 3, 0 );
< 	&ReleaseLockDir($name);    # Release the lock, even if we didn't get it.
< 	return $forced;
< }
< 
< sub RequestCacheLock {
< 
< 	# 4 tries, 2 second wait, do not die on error
< 	return &RequestLockDir( 'cache', 4, 2, 0 );
< }
< 
< sub ReleaseCacheLock {
< 	&ReleaseLockDir('cache');
< }
< 
< sub RequestDiffLock {
< 
< 	# 4 tries, 2 second wait, do not die on error
< 	return &RequestLockDir( 'diff', 4, 2, 0 );
< }
< 
< sub ReleaseDiffLock {
< 	&ReleaseLockDir('diff');
< }
< 
< # Index lock is not very important--just return error if not available
< sub RequestIndexLock {
< 
< 	# 1 try, 2 second wait, do not die on error
< 	return &RequestLockDir( 'index', 1, 2, 0 );
< }
< 
< sub ReleaseIndexLock {
< 	&ReleaseLockDir('index');
< }
< 
< sub ReadFile {
< 	my ($fileName) = @_;
< 	my ($data);
< 	local $/ = undef;    # Read complete files
< 	if ( open( IN, "<$fileName" ) ) {
< 		$data = <IN>;
< 		close IN;
< 		return ( 1, $data );
< 	}
< 	return ( 0, "" );
< }
< 
< sub ReadFileOrDie {
< 	my ($fileName) = @_;
< 	my ( $status, $data );
< 	( $status, $data ) = &ReadFile($fileName);
< 	if ( !$status ) {
< 		die( Ts( 'Can not open %s', $fileName ) . ": $!" );
< 	}
< 	return $data;
< }
< 
< sub WriteStringToFile {
< 	my ( $file, $string ) = @_;
< 	open( OUT, ">$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
< 	print OUT $string;
< 	close(OUT);
< }
< 
< sub AppendStringToFile {
< 	my ( $file, $string ) = @_;
< 	open( OUT, ">>$file" ) or die( Ts( 'cant write %s', $file ) . ": $!" );
< 	print OUT $string;
< 	close(OUT);
< }
< 
< sub AppendStringToFileLimited {
< 	my ( $file, $string, $limit ) = @_;
< 	if ( ( $limit < 1 ) || ( ( ( -s $file ) + length($string) ) <= $limit ) ) {
< 		&AppendStringToFile( $file, $string );
< 	}
< }
< 
< sub CreateDir {
< 	my ($newdir) = @_;
< 	mkdir( $newdir, 0775 ) if ( !( -d $newdir ) );
< }
< 
< sub CreatePageDir {
< 	my ( $dir, $id ) = @_;
< 	my $subdir;
< 	&CreateDir($dir);    # Make sure main page exists
< 	$subdir = $dir . "/" . &GetPageDirectory($id);
< 	&CreateDir($subdir);
< 	if ( $id =~ m|([^/]+)/| ) {
< 		$subdir = $subdir . "/" . $1;
< 		&CreateDir($subdir);
< 	}
< }
< 
< sub UpdateHtmlCache {
< 	my ( $id, $html ) = @_;
< 	my $idFile;
< 	$idFile = &GetHtmlCacheFile($id);
< 	&CreatePageDir( $HtmlDir, $id );
< 	if ( &RequestCacheLock() ) {
< 		&WriteStringToFile( $idFile, $html );
< 		&ReleaseCacheLock();
< 	}
< }
< 
< sub GenerateAllPagesList {
< 	my ( @pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId );
< 	@pages = ();
< 	if ($FastGlob) {
< 
< 		# The following was inspired by the FastGlob code by Marc W. Mengel.
< 		# Thanks to Bob Showalter for pointing out the improvement.
< 		opendir( PAGELIST, $PageDir );
< 		@dirs = readdir(PAGELIST);
< 		closedir(PAGELIST);
< 		@dirs = sort(@dirs);
< 		foreach $dir (@dirs) {
< 			next
< 			  if ( substr( $dir, 0, 1 ) eq '.' );  # No ., .., or .dirs or files
< 			opendir( PAGELIST, "$PageDir/$dir" );
< 			@pageFiles = readdir(PAGELIST);
< 			closedir(PAGELIST);
< 			foreach $id (@pageFiles) {
< 				next if ( ( $id eq '.' ) || ( $id eq '..' ) );
< 				if ( substr( $id, -3 ) eq '.db' ) {
< 					push( @pages, substr( $id, 0, -3 ) );
< 				}
< 				elsif ( substr( $id, -4 ) ne '.lck' ) {
< 					opendir( PAGELIST, "$PageDir/$dir/$id" );
< 					@subpageFiles = readdir(PAGELIST);
< 					closedir(PAGELIST);
< 					foreach $subId (@subpageFiles) {
< 						if ( substr( $subId, -3 ) eq '.db' ) {
< 							push( @pages, "$id/" . substr( $subId, 0, -3 ) );
< 						}
< 					}
< 				}
< 			}
< 		}
< 	}
< 	else {
< 		# Old slow/compatible method.
< 		@dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
< 		
< 		foreach $dir (@dirs) {
< 			if ( -e "$PageDir/$dir" ) {    # Thanks to Tim Holt
< 				while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
< 					s|^$PageDir/||;
< 					m|^[^/]+/(\S*).db|;
< 					$id = $1;
< 					push( @pages, $id );
< 				}
< 			}
< 		}
< 	}
< 	
< 	return sort(@pages);
< }
< 
< sub AllPagesList {
< 	my ( $rawIndex, $refresh, $status );
< 	
< 	if ( !$UseIndex ) {
< 		return &GenerateAllPagesList();
< 	}
< 	
< 	$refresh = &GetParam( "refresh", 0 );
< 	if ( $IndexInit && !$refresh ) {
< 
< 		# Note for mod_perl: $IndexInit is reset for each query
< 		# Eventually consider some timestamp-solution to keep cache?
< 		return @IndexList;
< 	}
< 	
< 	if ( ( !$refresh ) && ( -f $IndexFile ) ) {
< 		( $status, $rawIndex ) = &ReadFile($IndexFile);
< 		
< 		if ($status) {
< 			%IndexHash = split( /\s+/, $rawIndex );
< 			@IndexList = sort( keys %IndexHash );
< 			$IndexInit = 1;
< 			
< 			return @IndexList;
< 		}
< 
< 		# If open fails just refresh the index
< 	}
< 	@IndexList = ();
< 	%IndexHash = ();
< 	@IndexList = &GenerateAllPagesList();
< 	
< 	foreach (@IndexList) {
< 		$IndexHash{$_} = 1;
< 	}
< 	$IndexInit = 1;    # Initialized for this run of the script
< 	                   # Try to write out the list for future runs
< 	&RequestIndexLock() or return @IndexList;
< 	&WriteStringToFile( $IndexFile, join( " ", %IndexHash ) );
< 	&ReleaseIndexLock();
< 	
< 	return @IndexList;
< }
< 
< sub AllSubPagesList {
< 	my $GivenPage = shift;
< 	my @PageList = &AllPagesList();
< 	my @Results;
< 	
< 	foreach (@PageList){
< 		if (/^$GivenPage\//i){
< 			push @Results, $_;	
< 		}
< 	}
< 	
< 	return @Results;
< }
< 
< sub CalcDay {
< 	my ($ts) = @_;
< 	
< 	$ts += $TimeZoneOffset;
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
< 	
< 	if ($NumberDates) {
< 		$year = $year + 1900;
< 		$mon = $mon + 1;
< 		if ($mon < 10){ $mon = "0$mon"; }
< 		if ($mday < 10){ $mday = "0$mday"; }
< 		
< 		return "$year$NumberDatesDelim$mon$NumberDatesDelim$mday";
< 	}
< 	
< 	return (
< 		"January",   "February", "March",    "April",
< 		"May",       "June",     "July",     "August",
< 		"September", "October",  "November", "December"
< 	  )[$mon]
< 	  . " "
< 	  . $mday . ", "
< 	  . ( $year + 1900 );
< }
< 
< sub CalcTime {
< 	my ($ts) = @_;
< 	my ( $ampm, $mytz );
< 	
< 	$ts += $TimeZoneOffset;
< 	
< 	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($ts);
< 	$mytz = "";
< 	
< 	if ( ( $TimeZoneOffset == 0 ) && ( $ScriptTZ ne "" ) ) {
< 		$mytz = " " . $ScriptTZ;
< 	}
< 	$ampm = "";
< 	
< 	if ($UseAmPm) {
< 		$ampm = " am";
< 		if ( $hour > 11 ) {
< 			$ampm = " pm";
< 			$hour = $hour - 12;
< 		}
< 		$hour = 12 if ( $hour == 0 );
< 	}
< 	
< 	$min = "0" . $min if ( $min < 10 );
< 	
< 	return $hour . ":" . $min . $ampm . $mytz;
< }
< 
< sub TimeToText {
< 	my ($t) = @_;
< 	
< 	return &CalcDay($t) . " " . &CalcTime($t);
< }
< 
< sub GetParam {
< 	my ( $name, $default ) = @_;
< 	my $result;
< 	
< 	$result = $q->param($name);
< 	
< 	if ( !defined($result) ) {
< 		if ( defined( $UserData{$name} ) ) {
< 			$result = $UserData{$name};
< 		}
< 		else {
< 			$result = $default;
< 		}
< 	}
< 	
< 	return $result;
< }
< 
< sub GetHiddenValue {
< 	my ( $name, $value ) = @_;
< 	
< 	$q->param( $name, $value );
< 	
< 	return $q->hidden($name);
< }
< 
< sub GetRemoteHost {
< 	my ($doMask) = @_;
< 	my ( $rhost, $iaddr );
< 	
< 	$rhost = $ENV{REMOTE_HOST};
< 	
< 	if ( $UseLookup && ( $rhost eq "" ) ) {
< 
< 		# Catch errors (including bad input) without aborting the script
< 		eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
< 		  . '$rhost = gethostbyaddr($iaddr, AF_INET)';
< 	}
< 	
< 	if ( $rhost eq "" ) {
< 		$rhost = $ENV{REMOTE_ADDR};
< 	}
< 	
< 	$rhost = &GetMaskedHost($rhost) if ($doMask);
< 	
< 	return $rhost;
< }
< 
< sub FreeToNormal {
< 	my ($id) = @_;
< 	
< 	$id =~ s/ /_/g;
< 	$id = ucfirst($id) if ( $UpperFirst || $FreeUpper );
< 	
< 	if ( index( $id, '_' ) > -1 ) {    # Quick check for any space/underscores
< 		$id =~ s/__+/_/g;
< 		$id =~ s/^_//;
< 		$id =~ s/_$//;
< 		
< 		if ($UseSubpage) {
< 			$id =~ s|_/|/|g;
< 			$id =~ s|/_|/|g;
< 		}
< 	}
< 	
< 	if ($FreeUpper) {
< 
< 		# Note that letters after ' are *not* capitalized
< 		if ( $id =~ m|[-_.,\(\)/][a-z]| ) { # Quick check for non-canonical case
< 			$id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
< 		}
< 	}
< 	
< 	return $id;
< }
< 
< #END_OF_BROWSE_CODE
< # == Page-editing and other special-action code ========================
< $OtherCode = "";    # Comment next line to always compile (slower)
< 
< #$OtherCode = <<'#END_OF_OTHER_CODE';
< sub DoOtherRequest {
< 	my ( $id, $action, $filter, $text, $search );
< 	
< 	$action = &GetParam( "action", "" );
< 	$id     = &GetParam( "id",     "" );
< 	$filter = &GetParam( "filter", "" );
< 	
< 	if ( $action ne "" ) {
< 		$action = lc($action);
< 		
< 		if ( $action eq "edit" ) {
< 			&DoEdit( $id, 0, 0, "", 0 ) if &ValidIdOrDie($id);
< 		}
< 		elsif ( $action eq "unlock" ) {
< 			&DoUnlock();
< 		}
< 		elsif ( $action eq "index" ) {
< 			&DoIndex();
< 		}
< 		elsif ( $action eq "links" ) {
< 			&DoLinks();
< 		}
< 		elsif ( $action eq "maintain" ) {
< 			&DoMaintain();
< 		}
< 		elsif ( $action eq "pagelock" ) {
< 			&DoPageLock();
< 		}
< 		elsif ( $action eq "editlock" ) {
< 			&DoEditLock();
< 		}
< 		elsif ( $action eq "editprefs" ) {
< 			&DoEditPrefs();
< 		}
< 		elsif ( $action eq "editbanned" ) {
< 			&DoEditBanned();
< 		}
< 		elsif ( $action eq "editlinks" ) {
< 			&DoEditLinks();
< 		}
< 		elsif ( $action eq "login" ) {
< 			&DoEnterLogin();
< 		}
< 		elsif ( $action eq "newlogin" ) {
< 			$UserID = 0;
< 			&DoEditPrefs();    # Also creates new ID
< 		}
< 		elsif ( $action eq "version" ) {
< 			&DoShowVersion();
< 		}
< 		elsif ( $action eq "rss" ) {
< 			&DoRss();
< 		}
< 		elsif ( $action eq "delete" ) {
< 			&DoDeletePage($id);
< 		}
< 		elsif ( $UseUpload && ( $action eq "upload" ) ) {
< 			&DoUpload();
< 		}
< 		elsif ( $action eq "maintainrc" ) {
< 			&DoMaintainRc();
< 		}
< 		elsif ( $action eq "convert" ) {
< 			&DoConvert();
< 		}
< 		elsif ( $action eq "trimusers" ) {
< 			&DoTrimUsers();
< 		}
< 		elsif ( $action eq "listfiles" ) {
< 			&DoListFiles($id, $filter, 0);	
< 		}
< 		elsif ( $action eq "listdisabled" ) {
< 			&DoListFiles($id, $filter, 1);	
< 		}
< 		else {
< 			&ReportError( Ts( 'Invalid action parameter %s', $action ) );
< 		}
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_prefs", 0 ) ) {
< 		&DoUpdatePrefs();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_ban", 0 ) ) {
< 		&DoUpdateBanned();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "enter_login", 0 ) ) {
< 		&DoLogin();
< 		return;
< 	}
< 	
< 	if ( &GetParam( "edit_links", 0 ) ) {
< 		&DoUpdateLinks();
< 		return;
< 	}
< 	
< 	if ( $UseUpload && ( &GetParam( "upload", 0 ) ) ) {
< 		&SaveUpload();
< 		return;
< 	}
< 	
< 	$search = &GetParam( "search", "" );
< 	
< 	if ( ( $search ne "" ) || ( &GetParam( "dosearch", "" ) ne "" ) ) {
< 		&DoSearch($search, $filter);
< 		return;
< 	}
< 	else {
< 		$search = &GetParam( "back", "" );
< 		if ( $search ne "" ) {
< 			&DoBackLinks($search, $filter);
< 			
< 			return;
< 		}
< 	}
< 
< 	# Handle posted pages
< 	if ( &GetParam( "oldtime", "" ) ne "" ) {
< 		$id = &GetParam( "title", "" );
< 		&DoPost() if &ValidIdOrDie($id);
< 		
< 		return;
< 	}
< 	
< 	&ReportError( "Invalid URL." );
< }
< 
< sub PageIsLocked {
< 	my ($id, $deepedit) = @_;
< 	my ($result) = 0;
< 	
< 	if ( !&UserCanEdit( $id, $deepedit ) ) {
< 			$result = 1;
< 		if ( &UserIsBanned() ) {
< 			$result = 2;
< 		}
< 		else {
< 			$result = 3;
< 		}
< 	}
< 	
< 	return $result;
< }
< 
< sub DoEdit {
< 	my ( $id, $isConflict, $oldTime, $newText, $preview ) = @_;
< 	my ( $header, $editRows, $editCols, $userName, $revision, $oldText );
< 	my ( $summary, $isEdit, $pageTime, $isLocked );
< 	
< 	my $authtype = &CheckIsAuthUser($id);
< 	if (!$authtype) { $id = "AuthError"; } #auth patch	
< 	if ($FreeLinks) { $id = &FreeToNormal($id); }   # Take care of users like Markus Lude :-)	
< 	
< 	$isLocked = &PageIsLocked( $id, 1 );
< 	
< 	if ( $isLocked > 0 or $authtype eq "" || $authtype eq "1") {
< 		print &GetHeader( "", "Editing Denied", "" );
< 		print &GetLeftNav("");
< 		print "\n<div class='wikiadmin'>";
< 		
< 		if ( $isLocked == 2 ) {
< 			print "\n<h2>Editing not allowed: user, ip, or network is blocked.</h2>";
< 			print "\nContact the wiki administrator for more information.";
< 		}
< 		else {
< 			print "\n<h2>Editing not allowed: $id is read-only.</h2>";
< 		}
< 		
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></div></body></html>";
< 			
< 		return;
< 	}
< 
< 	# Consider sending a new user-ID cookie if user does not have one
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$pageTime = $Section{'ts'};
< 	$header   = Ts( 'Editing %s', $id );
< 
< 	# Old revision handling
< 	$revision = &GetParam( 'revision', "" );
< 	$revision =~ s/\D//g;    # Remove non-numeric chars
< 	
< 	if ( $revision ne "" ) {
< 		&OpenKeptRevisions('text_default');
< 		
< 		if ( !defined( $KeptRevisions{$revision} ) ) {
< 			$revision = "";
< 
< 			# Consider better solution like error message?
< 		}
< 		else {
< 			&OpenKeptRevision($revision);
< 			$header = Ts( 'Editing revision %s of ', $revision ) . $id;
< 		}
< 	}
< 	
< 	$oldText = $Text{'text'};
< 	
< 	if ( $preview && !$isConflict ) {
< 		$oldText = $newText;
< 	}
< 	
< 	$editRows = &GetParam( "editrows", 20 );
< 	$editCols = &GetParam( "editcols", 65 );
< 	print &GetHeader( "", &QuoteHtml($header), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $revision ne "" ) {
< 		print "\n<b>Editing old revision $revision. Saving this page will replace the latest revision with this text.</b><br>";
< 	}
< 	
< 	if ($isConflict) {
< 		$editRows -= 10 if ( $editRows > 19 );
< 		print "\n<H1>Edit Conflict!</H1>";
< 		
< 		if ( $isConflict > 1 ) {
< 
< 			# The main purpose of a new warning is to display more text
< 			# and move the save button down from its old location.
< 			print "\n<h2>(This is a new conflict)</h2>";
< 		}
< 		
< 		print "\n<p><strong>";
< 		print "\nSomeone saved this page after you started editing. ";
< 		print "\nThe top textbox contains the saved text. ";
< 		print "\nOnly the text in the top textbox will be saved.";
< 		print "\n</strong></p><br>";
< 		print "\nScroll down to see your edited text.";
< 		print "\n<br>";
< 		print "\nLast save time: ";
< 		print &TimeToText($oldTime);
< 		print "\n(Current time is: ";
< 		print &TimeToText($Now);
< 		print "\n)<br>";
< 	}
< 	print "\n<div id='wikieditbar'>";
< 	print "<a href='$ScriptName?WikiStyleGuide'>WikiStyleGuide</a> | ";
< 	print "<a href='$ScriptName?WikiHeadings'>WikiHeadings</a> | ";
< 	print "<a href='$ScriptName?WikiGallery'>WikiGallery</a>| ";
< 	print "<a href='$ScriptName?WikiFlash'>WikiFlash</a>| ";
< 	print "<a href='$ScriptName?WikiTOCs'>WikiTOCs</a> | ";
< 	print "<a href='$ScriptName?WikiURLs'>WikiURLs</a> | ";
< 	print "<a href='$ScriptName?WikiImages'>WikiImages</a> | ";
< 	print "<a href='$ScriptName?WikiTables'>WikiTables</a> | ";
< 	print "<a href='$ScriptName?WikiLists'>WikiLists</a> | ";
< 	print "<a href='$ScriptName?WikiMarkup'>WikiMarkup</a>";
< 	print "\n</div>";
< 	
< 	print "\n<br>";
< 	print "\n<form id='wikiform' action='$ScriptName#preview-anchor' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( "title",   $id );
< 	print &GetHiddenValue( "oldtime",     $pageTime );
< 	print &GetHiddenValue( "oldconflict", $isConflict );
< 	  
< 	if ( $revision ne "" ) {
< 		print &GetHiddenValue( "revision", $revision );
< 	}
< 	
< 	print &GetTextArea( 'text', $oldText, $editRows, $editCols );
< 	$summary = &GetParam( "summary", "*" );
< 	
< 	print "\n<br><br><div id='wikisaveedit'>Summary:";
< 	print
< 	  $q->textfield(
< 		-name      => 'summary',
< 		-id		   => 'summarytext',
< 		-default   => $summary,
< 		-override  => 1,
< 		-size      => 60,
< 		-maxlength => 200
< 	  );
< 	  
< 	if ( &GetParam("recent_edit") eq "on" ) {
< 		print "\n<br>",
< 		  $q->checkbox(
< 			-name    => 'recent_edit',
< 			-checked => 1,
< 			-label   => "This change is a minor edit."
< 		  );
< 		print "\n<br>";
< 	}
< 	else {
< 		print "\n<br>",
< 		  $q->checkbox(
< 			-name  => 'recent_edit',
< 			-checked => 0,
< 			-label => "This change is a minor edit."
< 		  );
< 		print "\n<br>";
< 	}
< 	
< 	if ($EmailNotify) {
< 		print "\n&nbsp;&nbsp;&nbsp;"
< 		  . $q->checkbox(
< 			-name  => 'do_email_notify',
< 			-label =>
< 			  Ts( 'Send email notification that %s has been changed.', $id )
< 		  );
< 	}
< 	
< 	print "\n<br>";
< 	
< 	if ( $EditNote ne "" ) {
< 		print $EditNote . '<br>';
< 	}
< 	$userName = &GetParam( "username", "" );
< 	print $q->submit( -name => 'Preview', -value => 'Preview' );
< 	print $q->button( -name => 'Cancel', -value => 'Cancel', -onclick => 'window.location="' . $ScriptName . '?' . $id . '";' );
< 	print $q->submit( -name => 'Save', -value => "Save" );	
< 	
< 	if ( $userName ne "" ) {
< 		print "\n (Your user name is ";
< 		print &GetPageLinkText("$HomePagePrefix$userName", $userName);
< 		print "\n )";
< 	}
< 	else {
< 		print ' (', Ts( 'Visit %s to set your user name.', &GetPrefsLink() ), ') ';
< 	}
< 
< 	if ($isConflict) {
< 		print "\n<br><hr><p><strong>";
< 		print "\nThis is the text you submitted:";
< 		print  "</strong><p>";
< 		print &GetTextArea( 'newtext', $newText, $editRows, $editCols );
< 	}
< 	
< 	print "\n</div>";
< 	print "\n</form>";
< 	print "<a name='preview-anchor'></a>";
< 	print "\n</div>";			
< 	print "\n$WikiLineFooter";
< 	
< 	if ($preview) {
< 		
< 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
< 		print $WikiLineHeaderPreview;
< 		print "\n<div id='wikipreview' class='wikipreview'>";				
< 		if ($isConflict) {
< 			print "\n<b>NOTE: This preview shows the revision of the other author.</b><hr>";
< 		}
< 		
< 		$MainPage = $id;
< 		$MainPage =~ s|/.*||;    # Only the main page name (remove subpage)
< 		
< 		print &WikiToHTML($oldText);
< 		print "\n</div>";
< 		print "\n$WikiLineFooter";
< 		print "\n<div class='wikipreviewtitle'>Preview only, not yet saved</div>";
< 		print "\n<div id='wikibar'>&nbsp</div>";
< 	}
< 
< 	print "\n<div class='wikifooter'>";	
< 	print "\n<div class='wikirevision'>";
< 	print &GetHistoryLink( $id, "View other revisions<br>", "Click to view revision history");
< 	print "</div>";
< 	print &GetGotoBar($id);
< 	print &getFooterNote();
< 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }		
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub GetTextArea {
< 	my ( $name, $text, $rows, $cols ) = @_;
< 	my ( $html );
< 	
< 	$html = "\n<div style='width: 100%;'>";
< 	if ( &GetParam( "editwide", 1 ) ) {
< 		$html .= $q->textarea(
< 			-name     => $name,
< 			-default  => $text,
< 			-id       => 'wikitextarea' . $name,
< 			-rows     => $rows,
< 			-columns  => $cols,
< 			-override => 1,
< 			-style    => 'width:100%',
< 			-wrap     => 'virtual'
< 		);
< 	}
< 	else {
< 		$html .= $q->textarea(
< 			-name     => $name,
< 			-default  => $text,
< 			-id       => 'wikitextarea' . $name,
< 			-rows     => $rows,
< 			-columns  => $cols,
< 			-override => 1,
< 			-wrap     => 'virtual'
< 		);
< 	}
< 	
< 	$html .= "</div>";
< 	
< 	return $html;
< }
< 
< sub DoEditPrefs {
< 	my ( $check, $recentName, %labels );
< 	
< 	$recentName = $RCName;
< 	$recentName =~ s/_/ /g;
< 	
< 	&DoNewLogin() if ( $UserID < 400 );
< 	
< 	print &GetHeader( "", "Editing Preferences", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikidiff'>";
< 	print "\n<h2>Access Controls</h2>";
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( "edit_prefs", 1 );
< 	print "\n<table class='wikilargelist'>";
< 	print "\n<tr><th colspan='2'><b>User Information </b></th></tr>";
< 	print "\n<tr><td>Your User ID number </td><td>$UserID</td></tr>";
< 	print "\n<tr><td>UserName</td>";
< 	print "\n<td>" . &GetFormText( 'username', "", 30, 50 );
< 	print "\n<br>(blank to remove, or valid page name)</td></tr>";
< 	print "\n<tr><td>Set Password </td>";
< 	print "\n<td>";
< 	print
< 	  $q->password_field(
< 		-name      => 'p_password',
< 		-value     => '*',
< 		-size      => 30,
< 		-maxlength => 50
< 	  );
< 	 print "\n<br>(blank to remove password)";
< 	 print "\n<br>Passwords allow sharing preferences between multiple systems. Passwords are completely optional. ";
< 	 print "\n</td></tr>";
< 
< 
< 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
< 		print "\n<tr><td>Administrator Password </td>";
< 		print "\n<td>";
< 		print
< 		  $q->password_field(
< 			-name      => 'p_adminpw',
< 			-value     => '*',
< 			-size      => 30,
< 			-maxlength => 50
< 		  );
< 		print "\n<br>(blank to remove password)";
< 		print "\n<br>(Administrator passwords are used for special maintenance.)";
< 		print "\n</td></tr>";
< 	}
< 	
< 	if ($EmailNotify) {
< 		print "\n<tr><td>Email Address</td>";
< 		print "\n<td>" . &GetFormText( 'email', "", 30, 60 );
< 		print "\n<br>" . &GetFormCheck( 'notify', 1, "Include this address in the site email list." );
< 		print "\n<br>(Uncheck the box to remove the address.) ";
< 		
< 		print "\n</td></tr>";
< 	}
< 	
< 	print "\n</table>";
< 	
< 	print "\n$WikiLinePref<b>$recentName:</b>";
< 	print "\n<br>Default days to display: ";
< 	print &GetFormText( 'rcdays', $RcDefault, 4, 9 );
< 	print "\n<br>", &GetFormCheck( 'rcnewtop', $RecentTop, "Most recent changes on top" );
< 	print "\n<br>", &GetFormCheck( 'rcall', 0, "Show all changes (not just most recent)" );
< 	
< 	%labels = (
< 		0 => "Hide minor edits",
< 		1 => "Show minor edits",
< 		2 => "Show only minor edits"
< 	);
< 	
< 	print "\n<br>Minor edit display: ";
< 	print $q->popup_menu(
< 		-name   => 'p_rcshowedit',
< 		-values => [ 0, 1, 2 ],
< 		-labels => \%labels,
< 		-default => &GetParam( "rcshowedit", $ShowEdits )
< 	);
< 	
< 	print "\n<br>", &GetFormCheck( 'rcchangehist', 1, "Use 'changes' as link to history" );
< 
< 	if ($UseDiff) {
< 		print "\n$WikiLinePref<b>Differences:</b>";
< 		print "\n<br>", &GetFormCheck( 'diffrclink', 1, "Show (diff) links on $recentName " );
< 		print "\n<br>", &GetFormCheck( 'alldiff', 0, "Show differences on all pages" );
< 		print "\n  (", &GetFormCheck( 'norcdiff', 1, "No differences on $recentName " ), ")";
< 		%labels = ( 1 => "Major", 2 => "Minor", 3 => "Author" );
< 		print "\n<br>Default difference type: ";
< 		print $q->popup_menu(
< 			-name   => 'p_defaultdiff',
< 			-values => [ 1, 2, 3 ],
< 			-labels => \%labels,
< 			-default => &GetParam( "defaultdiff", 1 )
< 		);
< 	}
< 	
< 	print "\n$WikiLinePref<b>Misc:</b>";
< 
< 	# Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
< 	print "\n<br>";
< 	print "\nServer time: ";
< 	print &TimeToText( $Now - $TimeZoneOffset );
< 	print &GetFormText( 'tzoffset', 0, 4, 9 );
< 	print "\n<br>";
< 	print &GetFormCheck( 'editwide', 1, "Use 100% wide edit area (if supported)" );
< 	print "\n<br>";
< 	print "\nEdit area rows: ";
< 	print &GetFormText( 'editrows', 20, 4, 4 );
< 	print "\n columns: ";
< 	print &GetFormText( 'editcols', 65, 4, 4 );
< 	print "\n<br>";
< 	print &GetFormCheck( 'toplinkbar', 1, "Show link bar on top" );
< 	print "\n<br>";
< 	print &GetFormCheck( 'linkrandom', 0, "Add 'Random Page' link to link bar" );
< 	print "\n<br>";
< 	print "\nStyleSheet URL: ";
< 
< 	print &GetCssChoices();	
< 	
< 	print "\n<br><br>";
< 	print "\n<input type='button' name='Cancel' value='Cancel' onclick='history.go(-1);' style='margin-right: 20px;'>";
< 	print "\n<input type='reset' name='Reset'> ";
< 	print $q->submit( -name => 'Save', -value => "Save" );
< 	print "\n</form>";
< 	print "\n</div>";
< 	print "\n$WikiLineFooter";
< 	print "\n<div class='wikifooter'>";
< 	print &GetGotoBar("");
< 
< 	print &getFooterNote();
< 	if ( $AdminBar && &UserIsAdmin() ) { print &GetAdminBar("", "class='wikirevision'"); }
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub GetFormText {
< 	my ( $name, $default, $size, $max ) = @_;
< 	my $text = &GetParam( $name, $default );
< 	
< 	return $q->textfield(
< 		-name      => "p_$name",
< 		-default   => $text,
< 		-override  => 1,
< 		-size      => $size,
< 		-maxlength => $max
< 	);
< }
< 
< sub GetFormCheck {
< 	my ( $name, $default, $label ) = @_;
< 	my $checked = ( &GetParam( $name, $default ) > 0 );
< 	
< 	return $q->checkbox(
< 		-name     => "p_$name",
< 		-override => 1,
< 		-checked  => $checked,
< 		-label    => $label
< 	);
< }
< 
< sub DoUpdatePrefs {
< 	my ( $username, $password, $stylesheet );
< 
< 	# All link bar settings should be updated before printing the header
< 	&UpdatePrefCheckbox("toplinkbar");
< 	&UpdatePrefCheckbox("linkrandom");
< 	
< 	print &GetHeader( "", "Saving Preferences" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $UserID < 1001 ) {
< 		print "\n<h2>Invalid UserID $UserID, preferences not saved.</h2>";
< 		
< 		if ( $UserID == 111 ) {
< 			print "\n<br>(Preferences require cookies, but no cookie was sent.)";
< 		}
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></div></body></html>";
< 		
< 		return;
< 	}
< 	
< 	$username = &GetParam( "p_username", "" );
< 	
< 	if ($FreeLinks) {
< 		$username =~ s/^\[\[(.+)\]\]/$1/;    # Remove [[ and ]] if added
< 		$username = &FreeToNormal($username);
< 		$username =~ s/_/ /g;
< 	}
< 	
< 	if ( $username eq "" ) {
< 		print "\n<h2>UserName removed.</h2>";
< 		undef $UserData{'username'};
< 	}
< 	elsif ( ( !$FreeLinks ) && ( !( $username =~ /^$LinkPattern$/ ) ) ) {
< 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
< 	}
< 	elsif ( $FreeLinks && ( !( $username =~ /^$FreeLinkPattern$/ ) ) ) {
< 		print Ts( '<h2>Invalid UserName %s: not saved.', $username ), "</h2>";
< 	}
< 	elsif ( length($username) > 50 ) {    # Too long
< 		print "\n<h2>UserName must be 50 characters or less. (not saved)</h2>";
< 	}
< 	else {
< 		print "\n<h2>UserName $username saved.</h2>";
< 		$UserData{'username'} = $username;
< 	}
< 	
< 	$password = &GetParam( "p_password", "" );
< 	
< 	if ( $password eq "" ) {
< 		print "\nPassword removed.<br>";
< 		undef $UserData{'password'};
< 	}
< 	elsif ( $password ne "*" ) {
< 		print "\nPassword changed.<br>";
< 		$UserData{'password'} = $password;
< 	}
< 	
< 	if ( ( $AdminPass ne "" ) || ( $EditPass ne "" ) ) {
< 		$password = &GetParam( "p_adminpw", "" );
< 		if ( $password eq "" ) {
< 			print "\nAdministrator password removed.<br>";
< 			undef $UserData{'adminpw'};
< 		}
< 		elsif ( $password ne "*" ) {
< 			print "\nAdministrator password changed.<br>";
< 			$UserData{'adminpw'} = $password;
< 			
< 			if ( &UserIsAdmin() ) {
< 				print "\nUser has administrative abilities.<br>";
< 			}
< 			elsif ( &UserIsEditor() ) {
< 				print "\nUser has editor abilities.<br>";
< 			}
< 			else {
< 				print "\nUser does not have administrative abilities. (Password does not match administrative password(s).) <br>";
< 			}
< 		}
< 	}
< 	if ($EmailNotify) {
< 		&UpdatePrefCheckbox("notify");
< 		&UpdateEmailList();
< 	}
< 	
< 	&UpdatePrefNumber( "rcdays", 0, 0, 999999 );
< 	&UpdatePrefCheckbox("rcnewtop");
< 	&UpdatePrefCheckbox("rcall");
< 	&UpdatePrefCheckbox("rcchangehist");
< 	&UpdatePrefCheckbox("editwide");
< 	
< 	if ($UseDiff) {
< 		&UpdatePrefCheckbox("norcdiff");
< 		&UpdatePrefCheckbox("diffrclink");
< 		&UpdatePrefCheckbox("alldiff");
< 		&UpdatePrefNumber( "defaultdiff", 1, 1, 3 );
< 	}
< 	
< 	&UpdatePrefNumber( "rcshowedit", 1, 0,    2 );
< 	&UpdatePrefNumber( "tzoffset",   0, -999, 999 );
< 	&UpdatePrefNumber( "editrows",   1, 1,    999 );
< 	&UpdatePrefNumber( "editcols",   1, 1,    999 );
< 	
< 	print "\n<br>Server time: ";
< 	print &TimeToText( $Now - $TimeZoneOffset );
< 	print "\n<br>";
< 	$TimeZoneOffset = &GetParam( "tzoffset", 0 ) * ( 60 * 60 );
< 	
< 	print"Local time: ";
< 	print &TimeToText($Now);
< 	print "\n<br>";
< 	$stylesheet = &GetParam( 'p_stylesheet', "" );
< 
< 	if ( $stylesheet eq "" ) {
< 		if ( &GetParam( 'stylesheet', "" ) ne "" ) {
< 			print "\nStyleSheet URL removed.<br>";
< 		}
< 		undef $UserData{'stylesheet'};
< 	}
< 	else {
< 		$stylesheet =~ s/[">]//g;  # Remove characters that would cause problems"
< 		$UserData{'stylesheet'} = $stylesheet;
< 		print "\nStyleSheet setting saved.<br>";
< 	}
< 	
< 	&SaveUserData();
< 	
< 	print "\n<br><b>Preferences saved.</b>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # add or remove email address from preferences to $EmailFile
< sub UpdateEmailList {
< 	my (@old_emails);
< 	local $/ = "\n";               # don't slurp whole files in this sub.
< 	
< 	if ( my $new_email = $UserData{'email'} = &GetParam( "p_email", "" ) ) {
< 		my $notify = $UserData{'notify'};
< 		if ( -f $EmailFile ) {
< 			open( NOTIFY, $EmailFile ) or die( Ts( 'Could not read from %s:', $EmailFile ) . " $!\n" );
< 			@old_emails = <NOTIFY>;
< 			close(NOTIFY);
< 		}
< 		else {
< 			@old_emails = ();
< 		}
< 		
< 		my $already_in_list = grep /$new_email/, @old_emails;
< 		
< 		if ( $notify and ( not $already_in_list ) ) {
< 			&RequestLock() or die( "Could not get mail lock" );
< 			if ( !open( NOTIFY, ">>$EmailFile" ) ) {
< 				&ReleaseLock();    # Don't leave hangling locks
< 				die( "Could not append to $EmailFile : $!\n" );
< 			}
< 			
< 			print NOTIFY $new_email, "\n";
< 			close(NOTIFY);
< 			&ReleaseLock();
< 		}
< 		elsif ( ( not $notify ) and $already_in_list ) {
< 			&RequestLock() or die( "Could not get mail lock" );
< 			if ( !open( NOTIFY, ">$EmailFile" ) ) {
< 				&ReleaseLock();
< 				die( "Could not overwrite $EmailFile : $!\n" );
< 			}
< 			foreach (@old_emails) {
< 				print NOTIFY "$_" unless /$new_email/;
< 			}
< 			
< 			close(NOTIFY);
< 			&ReleaseLock();
< 		}
< 	}
< }
< 
< sub UpdatePrefCheckbox {
< 	my ($param) = @_;
< 	my $temp = &GetParam( "p_$param", "*" );
< 	
< 	$UserData{$param} = 1 if ( $temp eq "on" );
< 	$UserData{$param} = 0 if ( $temp eq "*" );
< 
< 	# It is possible to skip updating by using another value, like "2"
< }
< 
< sub UpdatePrefNumber {
< 	my ( $param, $integer, $min, $max ) = @_;
< 	my $temp = &GetParam( "p_$param", "*" );
< 	
< 	return if ( $temp eq "*" );
< 	
< 	$temp =~ s/[^-\d\.]//g;
< 	$temp =~ s/\..*// if ($integer);
< 	
< 	return if ( $temp eq "" );
< 	return if ( ( $temp < $min ) || ( $temp > $max ) );
< 	
< 	$UserData{$param} = $temp;
< }
< 
< sub DoIndex {
< 	print &GetHeader( "", "Index of all pages", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print PrintPageList( "", &AllPagesList() );
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # Create a new user file/cookie pair
< sub DoNewLogin {
< 
< 	# Consider warning if cookie already exists
< 	# (maybe use "replace=1" parameter)
< 	&CreateUserDir();
< 	$SetCookie{'id'}      = &GetNewUserId();
< 	$SetCookie{'randkey'} = int( rand(1000000000) );
< 	$SetCookie{'rev'}     = 1;
< 	%UserCookie           = %SetCookie;
< 	$UserID               = $SetCookie{'id'};
< 
< 	# The cookie will be transmitted in the next header
< 	%UserData               = %UserCookie;
< 	$UserData{'createtime'} = $Now;
< 	$UserData{'createip'}   = $ENV{REMOTE_ADDR};
< 	&SaveUserData();
< }
< 
< sub DoEnterLogin {
< 	print &GetHeader( "", "Login", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>Enter UserID</h2>";
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print &GetHiddenValue( 'enter_login', 1 );
< 	print "\n<table><tr>";
< 	print "\n<td>User ID number &nbsp;</td>";
< 	print "\n<td>";
< 	print
< 	  $q->textfield(
< 		-name      => 'p_userid',
< 		-value     => "",
< 		-size      => 15,
< 		-maxlength => 50
< 	  );
< 	print "\n</td>";
< 	print "\n<tr>";
< 	print "\n<td>Password  &nbsp;</td>";
< 	print "\n<td>";
< 	print
< 	  $q->password_field(
< 		-name      => 'p_password',
< 		-value     => "",
< 		-size      => 15,
< 		-maxlength => 50
< 	  );
< 	print "\n</td>";
< 	print "\n</tr></table><br>";
< 	print $q->submit( -name => 'Login', -value => 'Login' );
< 	print "\n<br></form></div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></body></html>";	
< }
< 
< sub DoLogin {
< 	my ( $uid, $password, $success );
< 	
< 	$success = 0;
< 	$uid = &GetParam( "p_userid", "" );
< 	$uid =~ s/\D//g;
< 	$password = &GetParam( "p_password", "" );
< 	
< 	print &GetHeader( "", "Login Results", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( ( $uid > 199 ) && ( $password ne "" ) && ( $password ne "*" ) ) {
< 		$UserID = $uid;
< 		&LoadUserData();
< 		if ( $UserID > 199 ) {
< 			if ( defined( $UserData{'password'} ) && ( $UserData{'password'} eq $password ) ) {
< 				$SetCookie{'id'}      = $uid;
< 				$SetCookie{'randkey'} = $UserData{'randkey'};
< 				$SetCookie{'rev'}     = 1;
< 				$success              = 1;
< 			}
< 			else {
< 				print "\nUserID Account Undefined<br>";
< 			}
< 		}
< 		else {
< 			print "\nUserID must be above 199<br>";
< 		}
< 	}
< 	
< 	
< 	if ($success) {
< 		print "\n<h2>Login for user ID $uid complete.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Login for user ID $uid failed.</h2>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter;
< 	print "\n</div></div></div></body></html>";	
< }
< 
< sub GetNewUserId {
< 	my ($id);
< 	
< 	$id = $StartUID;
< 	
< 	while ( -f &UserDataFilename( $id + 1000 ) ) {
< 		$id += 1000;
< 	}
< 	
< 	while ( -f &UserDataFilename( $id + 100 ) ) {
< 		$id += 100;
< 	}
< 	
< 	while ( -f &UserDataFilename( $id + 10 ) ) {
< 		$id += 10;
< 	}
< 	
< 	&RequestLock() or die( "Could not get user-ID lock" );
< 	while ( -f &UserDataFilename($id) ) {
< 		$id++;
< 	}
< 	
< 	&WriteStringToFile( &UserDataFilename($id), "lock" );    # reserve the ID
< 	&ReleaseLock();
< 	
< 	return $id;
< }
< 
< # Consider user-level lock?
< sub SaveUserData {
< 	my ( $userFile, $data );
< 	
< 	&CreateUserDir();
< 	$userFile = &UserDataFilename($UserID);
< 	$data = join( $FS1, %UserData );
< 	&WriteStringToFile( $userFile, $data );
< }
< 
< sub CreateUserDir {
< 	my ( $n, $subdir );
< 	
< 	if ( !( -d "$UserDir/0" ) ) {
< 		&CreateDir($UserDir);
< 		foreach $n ( 0 .. 9 ) {
< 			$subdir = "$UserDir/$n";
< 			&CreateDir($subdir);
< 		}
< 	}
< }
< 
< sub DoSearch {
< 	my ($string, $filter) = @_;
< 	my ( $title );
< 	if ( $string eq "" ) {
< 		&DoIndex();
< 		return;
< 	}
< 	
< 	print &GetHeader( "", &QuoteHtml( Ts( "Search for: $title %s", $string ) ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print PrintPageList( $filter, &SearchTitleAndBody($string, $filter) );
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
< 	print "\n<input type='hidden' name='search' value='$string'>";
< 	print "\n<input type='hidden' name='dosearch' value='1'>";	
< 	print "\n<input type='submit' value='Apply Filter'>";	
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub DoBackLinks {
< 	my ($string, $filter) = @_;
< 	my ($title);
< 	
< 	$title = $string;
< 	
< 	print &GetHeader( "", &QuoteHtml( Ts( 'Backlinks for: %s', $string ) ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	# At this time the backlinks are mostly a renamed search.
< 	# An initial attempt to match links only failed on subpages and free links.
< 	# Escape some possibly problematic characters:
< 	
< 	$string =~ s/([_ ])/( |_)/g;
< 	$string =~ s/([-'(),])/\\$1/g; #'REMARK
< 	$string =~ m,/, ? "\\b$string\\b" : "$string\\b";
< 	
< 	print PrintPageList( grep($_ !~ $title, $filter, &SearchTitleAndBody($string, $filter, "")) );
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter' title='Enter ! before search term for exclusion'>&nbsp;";
< 	print "\n<input type='hidden' name='back' value='$string'>";
< 	print "\n<input type='submit' value='Apply Filter'>";	
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub PrintPageList {
< 	my ($filter, @results) = @_;
< 	my $term;
<     my $pagename;
<     my $html = "";
<     my $pagecount = scalar(@results);
<     my $currentInitial = "";
<     my $thisInitial;
<     my $lastInitial;
<     my $letterGrouping = ($pagecount > 25);
<     my $currentParent = "";
<     my $linktext = "";
<     my $notFirst;
< 
< 	if ($filter ne ""){ $term = " using filter '<em>$filter</em>'"; }
< 	$html .= "<h2>" . ( scalar(@results) ) . " pages found: $term</h2>";
<     
<     if ($letterGrouping) {
<         $html .= "<h3 class='lettergroup'>";
<         foreach $pagename (@results) {
<             $thisInitial = substr($pagename,0,1);
<             if ($thisInitial ne $lastInitial) {
<                     $html .= "<a href='#letter".$thisInitial."'>$thisInitial</a> ";
<                     $lastInitial = $thisInitial;
<             }
<         }
<         $html .= "</h3>";
<     }
<     
<     foreach $pagename (@results) {
<         if ($letterGrouping) {
<             $thisInitial = substr($pagename,0,1);
<             if ($currentInitial ne $thisInitial) {
<                 $html .= "\n<br><br><h3 class='lettergroup'><a name='letter$thisInitial'> $thisInitial </h3>$WikiLine";
<                 $currentInitial = $thisInitial; 
<                 $notFirst = 0;
<             }
<         }
<         $html .= "   ";
<         if (not($pagename =~ m|(.*)/(.*)|)) {
<             $currentParent = $pagename;
<             $linktext = $pagename;
<         } 
<         else {
<             if ($1 eq $currentParent) {
<                 if ($letterGrouping){  $linktext = "$currentParent/$2";}
<                 else { $html .= "... "; $linktext = "/$2";}                
<             } 
<             else {
<                 $linktext = $pagename;
<             }
<         }
<         if ($notFirst){ $notFirst = 1; $linktext = ", $linktext"; }
<         $html .= &GetPageLinkText($pagename,$linktext);
< 
<         if ($letterGrouping){ $html .= ", "; }
<         else { $html .= "\n<br>"; }
<     }
<     #$html .= "</ol>\n"; # commented to keep a 'original' usemod look
<     $html .= "\n<br>";
<     
<     return $html;
< }
< 
< sub DoLinks {	
< 	print &GetHeader( "", &QuoteHtml( "Full Link List" ), "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<hr><pre>\n\n\n\n";    # Extra lines to get below the logo
< 
< 	print &PrintLinkList(&GetFullLinkList(
< 		&GetParam("unique", 1),
< 		&GetParam("sort", 1),
< 		&GetParam("page", 1),
< 		&GetParam("inter", 0),
< 		&GetParam("url", 0),
< 		&GetParam("exists", 2),
< 		&GetParam("empty", 0),
< 		&GetParam("search", "")
< 	));
< 	
< 	print "\n</pre>";
< 	print "\n</div>";
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub PrintLinkList {
< 	my ( $pagelines, $page,  $names, $editlink );
< 	my ( $link, $text, $extra, @links, %pgExists );
< 	
< 	%pgExists = ();
< 	
< 	foreach $page ( &AllPagesList() ) {
< 		$pgExists{$page} = 1;
< 	}
< 	
< 	$names    = &GetParam( "names",    1 );
< 	$editlink = &GetParam( "editlink", 0 );
< 	
< 	foreach $pagelines (@_) {
< 		@links = ();
< 		
< 		foreach $page ( split( ' ', $pagelines ) ) {
< 			if ( $page =~ /\:/ ) {    # URL or InterWiki form
< 				if ( $page =~ /$UrlPattern/ ) {
< 					( $link, $extra ) = &UrlLink( $page, 0 );    # No images
< 				}
< 				else {
< 					( $link, $extra ) = &InterPageLink( $page, 0 );  # No images
< 				}
< 			}
< 			else {
< 				if ( $pgExists{$page} ) {
< 					$link = &GetPageLink($page);
< 				}
< 				else {
< 					$link = $page;
< 					if ($editlink) {
< 						$link .= &GetEditLink( $page, "?" );
< 					}
< 				}
< 			}
< 			
< 			push( @links, $link );
< 		}
< 		if ( !$names ) {
< 			shift(@links);
< 		}
< 		
< 		$text .= join(' ', @links) . "\n";
< 	}
< 	
< 	return $text;
< }
< 
< sub GetFullLinkList {
< 	my ($unique, $sort, $pagelink, $interlink, $urllink, $exists, $empty, $search, $listWantedPages )= @_ ;
< 	my ($name, $link ); # foreach iterators (though why not use $_ ?)
< 	#my ($name, $unique, $sort, $exists, $empty, $link, $search);
< 	#my ($pagelink, $interlink, $urllink);
< 	my (@found, @links, @newlinks, @pglist, %pgExists, %seen, $main);
< 	
< 	#$unique = &GetParam("unique", 1);
< 	#$sort = &GetParam("sort", 1);
< 	#$pagelink = &GetParam("page", 1);
< 	#$interlink = &GetParam("inter", 0);
< 	#$urllink = &GetParam("url", 0);
< 	#$exists = &GetParam("exists", 2);
< 	#$empty = &GetParam("empty", 0);
< 	#$search = &GetParam("search", "");
< 	
< 	if ( ( $interlink == 2 ) || ( $urllink == 2 ) ) { $pagelink = 0; }
< 	
< 	%pgExists = ();
< 	@pglist   = &AllPagesList();
< 	
< 	foreach $name (@pglist) { $pgExists{$name} = 1; }
< 	%seen = ();
< 	
< 	foreach $name (@pglist) {
< 		@newlinks = ();
< 		if ( $unique != 2 ) { %seen = (); }
< 		
< 		@links = &GetPageLinks($name, $pagelink, $interlink, $urllink, $listWantedPages);
< 		
< 		##if ($UseSubpage) {
< 		##	$main = $name;
< 		##	$main =~ s/\/.*//; 
< 		##}	
< 	    foreach $link (@links) {
< 			##if ($UseSubpage && ($link =~ /^\//)) { $link = $main . $link; }
<       
< 			if ($link =~ m/^\//){
< 				$name =~ m/(.*)\//;
< 				
< 				if ($1){ $link = $1 . $link; }
< 				else { $link = $name . $link; }
< 			}
< 			
< 			$seen{$link}++;
< 			
< 			if ( ( $unique > 0 ) && ( $seen{$link} != 1 ) ) { next; }			
< 			if ( ( $exists == 0 ) && ( $pgExists{$link} == 1 ) ) { next; }			
< 			if ( ( $exists == 1 ) && ( $pgExists{$link} != 1 ) ) { next; }			
< 			if ( ( $search ne "" ) && !( $link =~ /$search/ ) ) { next; }
< 			
< 			push( @newlinks, $link );
< 		}
< 		
< 		@links = @newlinks;
< 		if ($sort) { @links = sort(@links); }
< 		unshift( @links, $name );
< 		
< 		if ( $empty || ( $#links > 0 ) ) {    # If only one item, list is empty.
< 			push( @found, join( ' ', @links ) );
< 		}
< 	}
< 	return @found;
< }
< 
< sub GetSubpages {
< 	my ($parentPage) = @_;
< 	my ($dir, @subpageFiles, @pages, $subId);
< 	
< 	return "" unless $parentPage;
< 	$dir = GetPageDirectory($parentPage);
< 	
< 	opendir(PAGELIST, "$PageDir/$dir/$parentPage") or return "";
< 	@subpageFiles = readdir(PAGELIST);
< 	closedir(PAGELIST);
< 	
< 	foreach $subId (@subpageFiles) {
< 		if (substr($subId, -3) eq '.db') {
< 		  push(@pages, "$parentPage/" . substr($subId, 0, -3));
< 		}
< 	}
< 	return @pages;
< }
< 
< sub GetPageList {
< 	my ($pagename, $retval);
< 	my (@list) = @_;
< 
< 	foreach $pagename (@list) {
< 	##	$retval .= ".... " if ($pagename =~ m|/|);
< 		$retval .= "&nbsp;" . &GetPageLink($pagename) . "<br>";
< 	}
< 
< 	return $retval;
< }
< 
< sub GetPageLinks {
< 	my ( $name, $pagelink, $interlink, $urllink, $listWantedPages ) = @_;
< 	my ( $text, @links );
< 	
< 	@links = ();
< 	&OpenPage($name);
< 	&OpenDefaultText();
< 	
< 	$text = $Text{'text'};
< 	$text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
< 	$text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
< 	$text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
< 	$text =~ s/<tt>(.|\n)*?\<\/tt>/ /ig;
< 	
< 	if ($interlink) {
< 		$text =~ s/''+/ /g;    # Quotes can adjacent to inter-site links
< 		$text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 	}
< 	else {
< 		$text =~ s/$InterLinkPattern/ /g;
< 	}
< 	
< 	if ($urllink) {
< 		$text =~ s/''+/ /g;    # Quotes can adjacent to URLs
< 		$text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 	}
< 	else {
< 		$text =~ s/$UrlPattern/ /g;
< 	}
< 	
< 	if ($pagelink) {
< 		if ($FreeLinks) {
< 			my $f2 = $FreeLinkPattern;
< 			
< 			$text =~ s/\[\[$f2\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
< 			$text =~ s/\[\[$f2\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
< 		}
< 		
< 		if ($listWantedPages){ $text =~ s/\[((.|\n)*?)\]/ /ig; }
< 			
< 		if ($WikiLinks) {
< 			$text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
< 		}
< 	}
< 	
< 	return @links;
< }
< 
< sub DoPost {
< 	my ( $editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user );
< 	my $string      = &GetParam( "text",        undef );
< 	my $id          = &GetParam( "title",       "" );
< 	my $summary     = &GetParam( "summary",     "" );
< 	my $oldtime     = &GetParam( "oldtime",     "" );
< 	my $oldconflict = &GetParam( "oldconflict", "" );
< 	my $isEdit      = 0;
< 	my $editTime    = $Now;
< 	my $authorAddr  = $ENV{REMOTE_ADDR};
< 	
< 	if ($id =~ /($LinkPattern)/){ $id = $1; }
< 	else { die "The page name $id is not valid"; }
< 	
< 	if ($FreeLinks){ $id = &FreeToNormal($id); }
< 	
< 	if ( !&UserCanEdit( $id, 1 ) ) {
< 		# This is an internal interface--we don't need to explain
< 		&ReportError( Ts( 'Editing not allowed for %s.', $id ) );
< 		return;
< 	}
< 	
< 	if (   ( $id eq 'SampleUndefinedPage' )
< 		|| ( $id eq 'SampleUndefinedPage' )
< 		|| ( $id eq 'Sample_Undefined_Page' )
< 		|| ( $id eq 'Sample_Undefined_Page' ) )
< 	{
< 		&ReportError( " $id cannot be defined." );
< 		return;
< 	}
< 	
< 	$string  = &RemoveFS($string);
< 	$summary = &RemoveFS($summary);
< 	$summary =~ s/[\r\n]//g;
< 	
< 	if ( length($summary) > 300 ) {    # Too long (longer than form allows)
< 		$summary = substr( $summary, 0, 300 );
< 	}
< 
< 	# Add a newline to the end of the string (if it doesn't have one)
< 	$string .= "\n" if ( !( $string =~ /\n$/ ) );
< 
< 
< 	# Lock before getting old page to prevent races
< 	# Consider extracting lock section into sub, and eval-wrap it?
< 	# (A few called routines can die, leaving locks.)
< 	if ($LockCrash) { &RequestLock() or die( "Could not get editing lock" ); }
< 	else {
< 		if ( !&RequestLock() ) { &ForceReleaseLock('main'); }
< 
< 		# Clear all other locks.
< 		&ForceReleaseLock('cache');
< 		&ForceReleaseLock('diff');
< 		&ForceReleaseLock('index');
< 	}
< 	
< 	&OpenPage($id);
< 	&OpenDefaultText();
< 	$old     = $Text{'text'};
< 	$oldrev  = $Section{'revision'};
< 	$pgtime  = $Section{'ts'};
< 	$preview = 0;
< 	$preview = 1 if ( &GetParam( "Preview", "" ) ne "" );
< 	
< 	if ( !$preview && ( $old eq $string ) ) {    # No changes (ok for preview)
< 		&ReleaseLock();
< 		&ReBrowsePage( $id, "", 1 );
< 		return;
< 	}
< 	
< 	if ( ( $UserID > 399 ) || ( $Section{'id'} > 399 ) ) {
< 		$newAuthor = ( $UserID ne $Section{'id'} );    # known user(s)
< 	}
< 	else {
< 		$newAuthor = ( $Section{'ip'} ne $authorAddr );    # hostname fallback
< 	}
< 	$newAuthor = 1 if ( $oldrev == 0 );    # New page
< 	$newAuthor = 0 if ( !$newAuthor );     # Standard flag form, not empty
< 	                                       # Detect editing conflicts and resubmit edit
< 	                                       
< 	if ( ( $oldrev > 0 ) && ( $newAuthor && ( $oldtime != $pgtime ) ) ) {
< 		&ReleaseLock();
< 		if ( $oldconflict > 0 ) {    # Conflict again...
< 			&DoEdit( $id, 2, $pgtime, $string, $preview );
< 		}
< 		else {
< 			&DoEdit( $id, 1, $pgtime, $string, $preview );
< 		}
< 		return;
< 	}
< 	
< 	if ($preview) {
< 		&ReleaseLock();
< 		&DoEdit( $id, 0, $pgtime, $string, 1 );
< 		return;
< 	}
< 	
< 	$user = &GetParam( "username", "" );
< 
< 	# If the person doing editing chooses, send out email notification
< 	if ($EmailNotify) {
< 		&EmailNotify( $id, $user )
< 		  if &GetParam( "do_email_notify", "" ) eq 'on';
< 	}
< 	
< 	if ( &GetParam( "recent_edit", "" ) eq 'on' ) {
< 		$isEdit = 1;
< 	}
< 	
< 	if ( !$isEdit ) {
< 		&SetPageCache( 'oldmajor', $Section{'revision'} );
< 	}
< 	
< 	if ($newAuthor) {
< 		&SetPageCache( 'oldauthor', $Section{'revision'} );
< 	}
< 	
< 	&SaveKeepSection();
< 	&ExpireKeepFile();
< 	
< 	if ($UseDiff) {
< 		&UpdateDiffs( $id, $editTime, $old, $string, $isEdit, $newAuthor );
< 	}
< 	
< 	$Text{'text'}      = $string;
< 	$Text{'minor'}     = $isEdit;
< 	$Text{'newauthor'} = $newAuthor;
< 	$Text{'summary'}   = $summary;
< 	$Section{'host'}   = &GetRemoteHost(1);
< 	
< 	&SaveDefaultText();
< 	&SavePage();
< 	&WriteRcLog( $id, $summary, $isEdit, $editTime, $Section{'revision'}, $user,
< 		$Section{'host'} );
< 
< 	if ($UseCache) {
< 		&UnlinkHtmlCache($id);    # Old cached copy is invalid
< 		if ( $Page{'revision'} < 2 ) {    # If this is a new page...
< 			&NewPageCacheClear($id);      # ...uncache pages linked to this one.
< 		}
< 	}
< 	
< 	if ( $UseIndex && ( $Page{'revision'} == 1 ) ) {
< 		unlink($IndexFile);               # Regenerate index on next request
< 	}
< 	&ReleaseLock();
< 	&ReBrowsePage( $id, "", 1 );
< }
< 
< sub UpdateDiffs {
< 	my ( $id, $editTime, $old, $new, $isEdit, $newAuthor ) = @_;
< 	my ( $editDiff, $oldMajor, $oldAuthor );
< 	
< 	$editDiff  = &GetDiff( $old, $new, 0 );    # 0 = already in lock
< 	$oldMajor  = &GetPageCache('oldmajor');
< 	$oldAuthor = &GetPageCache('oldauthor');
< 	
< 	if ($UseDiffLog) {
<   		my $editDiff = Diff::diffClassic($old, $new);  # add this line
<   		&WriteDiff($id, $editTime, $editDiff);
< 	}
< 	
< 	&SetPageCache( 'diff_default_minor', $editDiff );
< 	if ( $isEdit || !$newAuthor ) {
< 		&OpenKeptRevisions('text_default');
< 	}
< 	
< 	if ( !$isEdit ) {
< 		&SetPageCache( 'diff_default_major', "1" );
< 	}	
< 	else {
< 		&SetPageCache( 'diff_default_major',
< 			&GetKeptDiff( $new, $oldMajor, 0 ) );
< 	}
< 	
< 	if ($newAuthor) {
< 		&SetPageCache( 'diff_default_author', "1" );
< 	}	
< 	elsif ( $oldMajor == $oldAuthor ) {
< 		&SetPageCache( 'diff_default_author', "2" );
< 	}
< 	else {
< 		&SetPageCache( 'diff_default_author',
< 			&GetKeptDiff( $new, $oldAuthor, 0 ) );
< 	}
< }
< 
< # Translation note: the email messages are still sent in English
< # Send an email message.
< sub SendEmail {
<   my ($to, $from, $reply, $subject, $message) = @_;
< 
<   # sendmail options:
<   #    -odq : send mail to queue (i.e. later when convenient)
<   #    -oi  : do not wait for "." line to exit
<   #    -t   : headers determine recipient.
<   open (SENDMAIL, "| $SendMail -oi -t ") or die "Can't send email: $!\n";
<   print SENDMAIL <<"EOF";
< From: $from
< To: $to
< Reply-to: $reply
< Subject: $subject\n
< $message
< EOF
<   close(SENDMAIL) or warn "sendmail didn't close nicely";
< }
< 
< ## Email folks who want to know a note that a page has been modified. - JimM.
< sub EmailNotify {
<   local $/ = "\n";   # don't slurp whole files in this sub.
< 
<   if ($EmailNotify) {
<     my ($id, $user) = @_;
<     if ($user) {
<       $user = " by $user";
<     }
<     my $address;
<     return  if (!-f $EmailFile);  # No notifications yet
<     open(EMAIL, $EmailFile)
<       or die "Can't open $EmailFile: $!\n";
<     $address = join ",", <EMAIL>;
<     $address =~ s/\n//g;
<     close(EMAIL);
<     my $home_url = $q->url();
<     my $page_url = $home_url . &ScriptLinkChar() . &UriEscape($id);
<     my $editors_summary = $q->param("summary");
<     if (($editors_summary eq "*") or ($editors_summary eq "")){
<       $editors_summary = "";
<     }
<     else {
<       $editors_summary = "\n Summary: $editors_summary";
<     }
<     my $content = <<"END_MAIL_CONTENT";
< 
<  The $SiteName page $id at
<    $page_url
<  has been changed$user to revision $Page{revision}. $editors_summary
< 
<  (Replying to this notification will
<   send email to the entire mailing list,
<   so only do that if you mean to.
< 
<   To remove yourself from this list, visit
<   ${home_url}?action=editprefs .)
< END_MAIL_CONTENT
<     my $subject = "The $id page at $SiteName has been changed.";
<     # I'm setting the "reply-to" field to be the same as the "to:" field
<     # which seems appropriate for a mailing list, especially since the
<     # $EmailFrom string needn't be a real email address.
<     &SendEmail($address, $EmailFrom, $address, $subject, $content);
<   }
< }
< 
< sub SearchTitleAndBody {
< 	my ($term, $filter) = @_;
< 	my ( $name, $freeName, @found, $excludeTerm, $excludeFilter );
< 	
< 	#If the search term has a !preceding it, strip it and set the exclusion flag
< 	if ($term =~ m/^\!/){ 
< 		$excludeTerm = 1;
< 		$term = substr($term, 1);	
< 	}
< 	#If the filter string has a !preceding it, strip it and set the exclusion flag	
< 	if ($filter =~ m/^\!/){ 
< 		$excludeFilter = 1;
< 		$filter = substr($filter, 1);	
< 	}
< 
< 	foreach $name ( &AllPagesList() ) {
< 		if ($excludeFilter){
< 			if ($filter) { next if ($name =~ m/$filter/); }
< 		}
< 		else {
< 			if ($filter) { next unless ($name =~ m/$filter/); }
< 		}
< 		
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if (!$excludeTerm){  
< 			if ( ( $Text{'text'} =~ /$term/ig ) || ( $name =~ /$term/i ) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( $freeName =~ /$term/i ) {
< 					push( @found, $name );
< 				}
< 			}
< 		}
< 		else { 
< 			if ( ! (( $Text{'text'} =~ /$term/i ) || ( $name =~ /$term/i )) ) {
< 				push( @found, $name );
< 			}
< 			elsif ( $FreeLinks && ( $name =~ m/_/ ) ) {
< 				$freeName = $name;
< 				$freeName =~ s/_/ /g;
< 				
< 				if ( ! ($freeName =~ /$term/i) ) {
< 					push( @found, $name );
< 				}
< 			}			
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub SearchBody {
< 	my ($string) = @_;
< 	my ( $name, @found );
< 	
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		if ( $Text{'text'} =~ /$string/i ) {
< 			push( @found, $name );
< 		}
< 	}
< 	
< 	return @found;
< }
< 
< sub UnlinkHtmlCache {
< 	my ($id) = @_;
< 	my $idFile;
< 	
< 	$idFile = &GetHtmlCacheFile($id);
< 	
< 	if ( -f $idFile ) {
< 		unlink($idFile);
< 	}
< }
< 
< sub NewPageCacheClear {
< 	my ($id) = @_;
< 	my $name;
< 	
< 	return if ( !$UseCache );
< 	
< 	$id =~ s|.+/|/|;    # If subpage, search for just the subpage
< 	                    # The following code used to search the body for the $id
< 	foreach $name ( &AllPagesList() ) {    # Remove all to be safe
< 		&UnlinkHtmlCache($name);
< 	}
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub DoUnlock {
< 	my $LockMessage = "Normal Unlock.";
< 	
< 	print &GetHeader( "", "Removing edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>This operation may take several seconds...</h2>\n";
< 	
< 	if ( &ForceReleaseLock('main') ) {
< 		$LockMessage = "Forced Unlock.";
< 	}
< 	
< 	&ForceReleaseLock('cache');
< 	&ForceReleaseLock('diff');
< 	&ForceReleaseLock('index');
< 	
< 	print "\n<br><h2>$LockMessage</h2>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub WriteRcLog {
< 	my ( $id, $summary, $isEdit, $editTime, $revision, $name, $rhost ) = @_;
< 	my ( $extraTemp, %extra );
< 	
< 	%extra = ();
< 	$extra{'id'}       = $UserID   if ( $UserID > 0 );
< 	$extra{'name'}     = $name     if ( $name ne "" );
< 	$extra{'revision'} = $revision if ( $revision ne "" );
< 	$extraTemp = join( $FS2, %extra );
< 
< 	# The two fields at the end of a line are kind and extension-hash
< 	my $rc_line = join( $FS3, $editTime, $id, $summary, $isEdit, $rhost, "0", $extraTemp );
< 	
< 	if ( !open( OUT, ">>$RcFile" ) ) {
< 		die( Ts( '%s log error:', $RCName ) . " $!" );
< 	}
< 	
< 	print OUT $rc_line . "\n";
< 	close(OUT);
< }
< 
< sub WriteDiff {
< 	my ( $id, $editTime, $diffString ) = @_;
< 	
< 	open( OUT, ">>$DataDir/diff_log" ) or die( "can not write diff_log" );
< 	print OUT "------\n" . $id . "|" . $editTime . "\n";
< 	print OUT $diffString;
< 	close(OUT);
< }
< 
< # Actions are vetoable if someone edits the page before
< # the keep expiry time. For example, page deletion. If
< # no one edits the page by the time the keep expiry time
< # elapses, then no one has vetoed the last action, and the
< # action is accepted.
< # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
< sub ProcessVetos {
< 	my ($expirets);
< 	
< 	$expirets = $Now - ( $KeepDays * 24 * 60 * 60 );
< 	
< 	return ( 0, "(done)" ) unless $Page{'ts'} < $expirets;
< 	
< 	if ( $DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o ) {
< 		&DeletePage( $OpenPageName, 1, 1 );
< 		return ( 1, "(deleted)" );
< 	}
< 	
< 	if ( $ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o ) {
< 		my $fname = $1;
< 
< 		# Only replace an allowed, existing file.
< 		if ( ( grep { $_ eq $fname } @ReplaceableFiles ) && -e $fname ) {
< 			if ( $Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims ) {
< 				my $string = $1;
< 				
< 				$string =~ s/\r\n/\n/gms;
< 				open( OUT, ">$fname" ) or return 0;
< 				print OUT $string;
< 				close OUT;
< 				
< 				return ( 0, "(replaced)" );
< 			}
< 		}
< 	}
< 	return ( 0, "(done)" );
< }
< 
< sub DoMaintain {
< 	my ( $name, $fname, $data, $message, $status );
< 	
< 	print &GetHeader( "", "Maintenance on all pages", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	$fname = "$DataDir/maintain";
< 	
< 	if ( !&UserIsAdmin() ) {
< 		if ( ( -f $fname ) && ( ( -M $fname ) < 0.5 ) ) {
< 			print "\nMaintenance not done. ";
< 			print "\n(Maintenance can only be done once every 12 hours.)";
< 			print "\nRemove the 'maintain' file or wait.";
< 			print "\n</div>";
< 			print &GetCommonFooter();
< 			print "\n</div></div></div></div></body></html>";
< 			
< 			return;
< 		}
< 	}
< 	
< 	&RequestLock() or die( "Could not get maintain-lock" );
< 
< 	foreach $name ( &AllPagesList() ) {
< 		&OpenPage($name);
< 		&OpenDefaultText();
< 		
< 		( $status, $message ) = &ProcessVetos();
< 		&ExpireKeepFile() unless $status;
< 		
< 		print "\n.... " if ( $name =~ m|/| );
< 		print &GetPageLink($name);
< 		print "\n $message<br>";
< 	}
< 
< 	&WriteStringToFile( $fname, Ts( 'Maintenance done at %s', &TimeToText($Now) ) );
< 	&ReleaseLock();
< 
< 	# Do any rename/deletion commands
< 	# (Must be outside lock because it will grab its own lock)
< 	$fname = "$DataDir/editlinks";
< 	
< 	if ( -f $fname ) {
< 		$data = &ReadFileOrDie($fname);
< 		print "\n<hr>Processing rename/delete commands:<br>";
< 		&UpdateLinksList( $data, 1, 1 );    # Always update RC and links
< 		unlink("$fname.old");
< 		rename( $fname, "$fname.old" );
< 	}
< 	
< 	if ($MaintTrimRc) {
< 		&RequestLock() or die( "Could not get lock for RC maintenance" );
< 		$status = &TrimRc();                # Consider error messages?
< 		&ReleaseLock();
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # Must be called within a lock.
< # Thanks to Alex Schroeder for original code
< sub TrimRc {
< 	my ( @rc, @temp, $starttime, $days, $status, $data, $i, $ts );
< 
< 	# Determine the number of days to go back
< 	$days = 0;
< 	
< 	foreach (@RcDays) {
< 		$days = $_ if $_ > $days;
< 	}
< 	$starttime = $Now - $days * 24 * 60 * 60;
< 	return 1 if ( !-f $RcFile );    # No work if no file exists
< 	( $status, $data ) = &ReadFile($RcFile);
< 	
< 	if ( !$status ) {
< 		print "\n<p><strong>Could not open $RCName log file</strong> $RcFile<p>Error was:<pre>$!</pre></p></p>";
< 		
< 		return 0;
< 	}
< 
< 	# Move the old stuff from rc to temp
< 	@rc = split( /\n/, $data );
< 	
< 	for ( $i = 0 ; $i < @rc ; $i++ ) {
< 		($ts) = split( /$FS3/, $rc[$i] );
< 		last if ( $ts >= $starttime );
< 	}
< 	
< 	return 1 if ( $i < 1 );    # No lines to move from new to old
< 	
< 	@temp = splice( @rc, 0, $i );
< 
< 	# Write new files and backups
< 	if ( !open( OUT, ">>$RcOldFile" ) ) {
< 		print "\n<p><strong>Could not open $RCName log file:</strong> $RcOldFile<p>Error was:<pre>$!</pre></p></p>";
< 		return 0;
< 	}
< 	print OUT join( "\n", @temp ) . "\n";
< 	close(OUT);
< 	
< 	&WriteStringToFile( $RcFile . '.old', $data );
< 	$data = join( "\n", @rc );
< 	$data .= "\n" if ( $data ne "" );    # If no entries, don't add blank line
< 	&WriteStringToFile( $RcFile, $data );
< 	
< 	return 1;
< }
< 
< sub DoMaintainRc {
< 	print &GetHeader( "", "Maintaining RC log", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	return if ( !&UserIsAdminOrError() );
< 	&RequestLock() or die( "Could not get lock for RC maintenance" );
< 	
< 	if ( &TrimRc() ) {
< 		print "\n<br>RC maintenance done.<br>";
< 	}
< 	else {
< 		print "\n<br>RC maintenance not done.<br>";
< 	}
< 	&ReleaseLock();
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub UserIsEditorOrError {
< 	if ( !&UserIsEditor() ) {
< 		print "\n<h2>This operation is restricted to site editors only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></body></html>";
< 			
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub UserIsAdminOrError {
< 	if ( !&UserIsAdmin() ) {
< 		print "\n<h2>This operation is restricted to administrators only...</h2>";
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></body></html>";	
< 		return 0;
< 	}
< 	
< 	return 1;
< }
< 
< sub CheckIsAuthUser {
< 	my ($id) = @_;
< 	my $auth = ""; 
< 	my $found = 0;
< 	my $authtype;
< 	my $authname; 
< 	my $aname;
< 	my $afname;
< 	my $linecount = 0;
< 
< 	if (!(&UserIsAdmin())) {
< 		$aname = $id;
< 		$aname =~ s/(^[^\/]+)\/*[^\/]*$/$1/;
< 		$afname = $PageDir . "/" . &GetPageDirectory($aname) . "/" . $aname . "/" . "AuthUsers.db";
< 		
< 		if (-r $afname) {			
< 			if ($id =~ /^(.*)\/.*/) { $aname = $1; }
< 			
< 			open (AFN,"<$afname");
< 			while (<AFN>) {
< 				if (/$FS1/) { next; }       	# skip header and footer
< 				if (/^>\s[^\w]/) { next; }  	# skip comments	
< 				if (/diff-/){ next; }		
< 				if (/>{([\w]+):([\w]+)}</) {    # pattern is {e:UserName} allow read and edit, or {r:UserName} for allow read
< 					$authtype = $1;
< 					$authname = $2; 
< 					
< 					if ($authtype eq "e"){ $authtype = "2"; $linecount++; }
< 					elsif ($authtype eq "r"){ $authtype = "1"; }
< 					else { $authtype = "1"; }
< 					
< 					if ($UserData{'username'} eq $authname) { $found = 1; $auth = $authtype; }
< 				}
< 			}
< 			close AFN;
< 			if ($linecount == 0){ $auth = "3"; }
< 			elsif ($found == 0) { $auth = ""; }
< 		}
< 		else {
< 			$auth = "3";
< 		}
< 	}
< 	else {
< 		$auth = "3";
< 	}
< 	return $auth;
< }
< 
< sub DoEditLock {
< 	my ($fname);
< 	
< 	print &GetHeader( "", "Set or Remove global edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	return if ( !&UserIsAdminOrError() );
< 	$fname = "$DataDir/noedit";
< 
< 	if ( &GetParam( "set", 1 ) ) {
< 		&WriteStringToFile( $fname, "editing locked." );
< 	}
< 	else {
< 		unlink($fname);
< 	}
< 	
< 	if ( -f $fname ) {
< 		print "\n<h2>Edit lock created.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Edit lock removed.</h2>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub DoPageLock {
< 	my ( $fname, $id );
< 	
< 	print &GetHeader( "", "Set or Remove page edit lock", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	# Consider allowing page lock/unlock at editor level?
< 	return if ( !&UserIsAdminOrError() );
< 		
< 	$id = &GetParam( "id", "" );
< 	if ( $id eq "" ) {
< 		print "\n<p>Missing page id to lock/unlock...</p>";
< 		
< 		return;
< 	}
< 	
< 	return if ( !&ValidIdOrDie($id) );    # Consider nicer error?
< 	$fname = &GetLockedPageFile($id);
< 	
< 	if ( &GetParam( "set", 1 ) ) {
< 		&WriteStringToFile( $fname, "editing locked." );
< 	}
< 	else {
< 		unlink($fname);
< 	}
< 
< 	if ( -f $fname ) {
< 		print "\n<h2>Lock for '$id' created.</h2>";
< 	}
< 	else {
< 		print "\n<h2>Lock for '$id' removed.</h2>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub DoEditBanned {
< 	my ( $banList, $status );
< 	
< 	print &GetHeader( "", "Editing Banned list", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	return if ( !&UserIsAdminOrError() );
< 	( $status, $banList ) = &ReadFile("$DataDir/banlist");
< 	$banList = "" if ( !$status );
< 	
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print GetHiddenValue( "edit_ban", 1 );
< 	print "\n<h2> Banned IP/network/host list:</h2>";
< 	print "\nEach entry is either a commented line (starting with #), ";
< 	print "\nor a Perl regular expression (matching either an IP address or ";
< 	print "\na hostname).  <br><br><b>Note:</b> To test the ban on yourself, you must ";
< 	print "\ngive up your admin access (remove password in Preferences).";
< 	print "\n<p><br><b>Example:</b><br><br>";
< 	print "\n# blocks hosts ending with .foocorp.com<br>";
< 	print "\n<tt> \\.foocorp\\.com\$</tt><br><br>";
< 	print "\n# blocks exact IP address<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.9\$</tt><br><br>";
< 	print "\n# blocks whole 123.21.3.* IP network<br>";
< 	print "\n<tt> ^123\\.21\\.3\\.\\d+\$</tt><br><br></p>";
< 	print &GetTextArea( 'banlist', $banList, 12, 50 );
< 	print "\n<br><br>";
< 	print $q->submit( -name => 'Save' );
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	;
< }
< 
< sub DoUpdateBanned {
< 	my ( $newList, $fname );
< 	
< 	print &GetHeader( "", "Updating Banned list", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	$fname = "$DataDir/banlist";
< 	$newList = &GetParam( "banlist", "#Empty file" );
< 	
< 	if ( $newList eq "" ) {
< 		print "\n<p>Empty banned list or error.</p>";
< 		print "\n<p>Resubmit with at least one space character to remove.</p>";
< 	}
< 	elsif ( $newList =~ /^\s*$/s ) {
< 		unlink($fname);
< 		print "\n<p>Removed banned list</p>";
< 	}
< 	else {
< 		&WriteStringToFile( $fname, $newList );
< 		print "\n<p>Updated banned list</p>";
< 	}
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # ==== Editing/Deleting pages and links ====
< sub DoEditLinks {
< 	print &GetHeader( "", "Editing Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
< 	}
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	print "\n<form id='wikiform' action='$ScriptName' enctype='application/x-www-form-urlencoded' method='POST'>";
< 	print GetHiddenValue( "edit_links", 1 );
< 	print "\n<h2>Editing/Deleting page titles:</h2>";
< 	print "\nEnter one command on each line.  Page names are case-sensitive!<br><br><b>Commands are:</b><br>";
< 	print "\n<tt>?PageName</tt> -- lists all sub-pages of PageName<br>";
< 	print "\n<tt>!PageName</tt> -- deletes the page called PageName<br>";
< 	print "\n<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>=OldPageName/*=NewPageName</tt> -- Renames OldPageName, its sub-pages, to NewPageName and updates links to OldPageName.<br>";
< 	print "\n<tt>|OldPageName|NewPageName</tt> -- Changes links from OldPageName to NewPageName. (Used to rename links to non-existing pages.)<br><br>";
< 	print &GetTextArea( 'commandlist', "", 12, 50 );
< 	print "\n<br><br>";
< 	print $q->checkbox(
< 		-name     => "p_changerc",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Edit $RCName"
< 	);
< 	print "\n<br>";
< 	print $q->checkbox(
< 		-name     => "p_changetext",
< 		-override => 1,
< 		-checked  => 1,
< 		-label    => "Substitute text for rename"
< 	);
< 	print "\n<br><br>";
< 	print $q->submit( -name => 'Process Command' );
< 	print "\n</form>";
< 	print "\n</div>";
< 	
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub UpdateLinksList {
< 	my ( $commandList, $doRC, $doText ) = @_;
< 	
< 	if ($doText) {
< 		&BuildLinkIndex();
< 	}
< 	&RequestLock() or die "UpdateLinksList could not get main lock";
< 	unlink($IndexFile) if ($UseIndex);
< 	
< 	foreach ( split( /\n/, $commandList ) ) {
< 		s/\s+$//g;
< 		
< 		next if ( !(/^[=!|?]/) );    # Only valid commands.
< 		print "\nProcessing $_<br>\n";
< 		
< 		if (/^\!(.+)/) {
< 			&DeletePage( $1, $doRC, $doText );
< 		}
< 		elsif (/^\?(.+)/){
< 			print "\n<b>Sub-pages of " . &GetPageLink($1) . "\n<br><b>";
< 			print join ("\n<br>", map { &GetPageLink($_) }&AllSubPagesList($1));
< 			print "\n<br><br>";
< 		}
< 		elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
<       		my $GivenPage = $1;
<       		my $GivenNewName = $2;
<       
<       		if ($GivenPage =~ s[\/\*][]) {
<        			print "\nRenaming subpages of $GivenPage too...<br>";
<         
<         		foreach (&AllSubPagesList($GivenPage)) {
< 					my $NewSubName = $_;
< 					
< 					$NewSubName =~ s[$GivenPage][$GivenNewName]i;
< 					print "\nrenaming $_ to $NewSubName<br>";
< 					&RenamePage($_, $NewSubName, $doRC, $doText);
< 		        }
<       		}
< 		      # rename the page itself
< 		      print "\nrenaming $GivenPage to $GivenNewName<br>";
< 		      &RenamePage($GivenPage, $GivenNewName, $doRC, $doText);
< 		}
< 		elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
< 			&RenameTextLinks( $1, $2 );
< 		}
< 	}
< 	
< 	&NewPageCacheClear(".");        # Clear cache (needs testing?)
< 	unlink($IndexFile) if ($UseIndex);
< 	&ReleaseLock();
< }
< 
< sub BuildLinkIndex {
< 	my ( @pglist, $page, @links, $link, %seen );
< 	
< 	@pglist    = &AllPagesList();
< 	%LinkIndex = ();
< 	
< 	foreach $page (@pglist) {
< 		&BuildLinkIndexPage($page);
< 	}
< }
< 
< sub BuildLinkIndexPage {
< 	my ($page) = @_;
< 	my ( @links, $link, %seen );
< 	
< 	@links = &GetPageLinks( $page, 1, 0, 0 );
< 	%seen = ();
< 	
< 	foreach $link (@links) {
< 		if ( defined( $LinkIndex{$link} ) ) {
< 			if ( !$seen{$link} ) {
< 				$LinkIndex{$link} .= " " . $page;
< 			}
< 		}
< 		else {
< 			$LinkIndex{$link} .= " " . $page;
< 		}
< 		$seen{$link} = 1;
< 	}
< }
< 
< sub DoUpdateLinks {
< 	my ( $commandList, $doRC, $doText );
< 	
< 	print &GetHeader( "", "Updating Links", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ($AdminDelete) {
< 		return if ( !&UserIsAdminOrError() );
< 	}
< 	else {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	$commandList = &GetParam( "commandlist", "" );
< 	$doRC        = &GetParam( "p_changerc",  "0" );
< 	$doRC = 1 if ( $doRC eq "on" );
< 	$doText = &GetParam( "p_changetext", "0" );
< 	$doText = 1 if ( $doText eq "on" );
< 	
< 	if ( $commandList eq "" ) {
< 		print "\n<p>Empty command list or error.</p>";
< 	}
< 	else {
< 		&UpdateLinksList( $commandList, $doRC, $doText );
< 		print "\n<p>Finished command list.</p>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub EditRecentChanges {
< 	my ( $action, $old, $new ) = @_;
< 	
< 	&EditRecentChangesFile( $RcFile,    $action, $old, $new, 1 );
< 	&EditRecentChangesFile( $RcOldFile, $action, $old, $new, 0 );
< }
< 
< sub EditRecentChangesFile {
< 	my ( $fname, $action, $old, $new, $printError ) = @_;
< 	my ( $status, $fileData, $errorText, $rcline, @rclist );
< 	my ( $outrc, $ts, $page, $junk );
< 	
< 	( $status, $fileData ) = &ReadFile($fname);
< 	
< 	if ( !$status ) {
< 
< 		# Save error text if needed.
< 		$errorText = "\n<p><strong>Could not open $RCName log file:</strong> $fname<p>Error was:<pre>$!</pre></p></p>";
< 		print $errorText if ($printError);
< 		
< 		return;
< 	}
< 	
< 	$outrc = "";
< 	@rclist = split( /\n/, $fileData );
< 	
< 	foreach $rcline (@rclist) {
< 		( $ts, $page, $junk ) = split( /$FS3/, $rcline );
< 		if ( $page eq $old ) {
< 			if ( $action == 1 ) {    # Delete
< 				;                    # Do nothing (don't add line to new RC)
< 			}
< 			elsif ( $action == 2 ) {
< 				$junk = $rcline;
< 				$junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
< 				$outrc .= $junk . "\n";
< 			}
< 		}
< 		else {
< 			$outrc .= $rcline . "\n";
< 		}
< 	}
< 	
< 	&WriteStringToFile( $fname . ".old", $fileData );    # Backup copy
< 	&WriteStringToFile( $fname, $outrc );
< }
< 
< # Delete and rename must be done inside locks.
< sub DeletePage {
< 	my ( $page, $doRC, $doText ) = @_;
< 	my ( $fname, $status );
< 	
< 	$page =~ s/ /_/g;
< 	$page =~ s/\[+//;
< 	$page =~ s/\]+//;
< 	$status = &ValidId($page);
< 	
< 	if ( $status ne "" ) {
< 		print "\nDelete-Page: page $page is invalid, error is: $status<br>";
< 		return;
< 	}
< 	
< 	$fname = &GetPageFile($page);
< 	unlink($fname) if ( -f $fname );
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	unlink($fname)     if ( -f $fname );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 1, $page, "" ) if ($doRC);    # Delete page
< 	       # Currently don't do anything with page text
< }
< 
< # Given text, returns substituted text
< sub SubstituteTextLinks {
< 	my ( $old, $new, $text ) = @_;
< 
< 	# Much of this is taken from the common markup
< 	%SaveUrl      = ();
< 	$SaveUrlIndex = 0;
< 	$text =~ s/$FS(\d)/$1/g;    # Remove separators (paranoia)
< 	
< 	if ($RawHtml) {
< 		$text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
< 	}
< 	
< 	$text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<tt>((.|\n)*?)<\/tt>)/&StoreRaw($1)/ige;
< 	$text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
< 	
< 	if ($FreeLinks) {
< 		$text =~ s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
< 		$text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
< 	}
< 	
< 	if ($BracketText) {         # Links like [URL text of link]
< 		$text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
< 		$text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
< 	}
< 	
< 	$text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
< 	$text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
< 	
< 	if ($WikiLinks) {
< 		$text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
< 	}
< 
< 	# Thanks to David Claughton for the following fix
< 	1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;    # Restore saved text
< 	
< 	return $text;
< }
< 
< sub SubFreeLink {
< 	my ( $link, $name, $old, $new ) = @_;
< 	my ($oldlink);
< 	
< 	$oldlink = $link;
< 	$link =~ s/^\s+//;
< 	$link =~ s/\s+$//;
< 	
< 	if ( ( $link eq $old ) || ( &FreeToNormal($old) eq &FreeToNormal($link) ) )
< 	{
< 		$link = $new;
< 	}
< 	
< 	else {
< 		$link = $oldlink;    # Preserve spaces if no match
< 	}
< 	
< 	$link = "[[$link";
< 	
< 	if ( $name ne "" ) {
< 		$link .= "|$name";
< 	}
< 	
< 	$link .= "]]";
< 	
< 	return &StoreRaw($link);
< }
< 
< sub SubWikiLink {
< 	my ( $link, $old, $new ) = @_;
< 	my ($newBracket);
< 	
< 	$newBracket = 0;
< 	
< 	if ( $link eq $old ) {
< 		$link = $new;
< 		if ( !( $new =~ /^$LinkPattern$/ ) ) {
< 			$link = "[[$link]]";
< 		}
< 	}
< 	
< 	return &StoreRaw($link);
< }
< 
< # Rename is mostly copied from expire
< sub RenameKeepText {
< 	my ( $page, $old, $new ) = @_;
< 	my ( $fname, $status, $data, @kplist, %tempSection, $changed );
< 	my ( $sectName, $newText );
< 	
< 	$fname = $KeepDir . "/" . &GetPageDirectory($page) . "/$page.kp";
< 	return if ( !( -f $fname ) );
< 	( $status, $data ) = &ReadFile($fname);
< 	return if ( !$status );
< 	@kplist = split( /$FS1/, $data, -1 );    # -1 keeps trailing null fields
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	shift(@kplist) if ( $kplist[0] eq "" );  # First can be empty
< 	return if ( length(@kplist) < 1 );       # Also empty
< 	%tempSection = split( /$FS2/, $kplist[0], -1 );
< 
< 	if ( !defined( $tempSection{'keepts'} ) ) {
< 		return;
< 	}
< 
< 	# First pass: optimize for nothing changed
< 	$changed = 0;
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$changed = 1 if ( $Text{'text'} ne $newText );
< 		}
< 	}
< 	
< 	return if ( !$changed );    # No sections changed
< 	open( OUT, ">$fname" ) or return;
< 	
< 	foreach (@kplist) {
< 		%tempSection = split( /$FS2/, $_, -1 );
< 		$sectName = $tempSection{'name'};
< 		if ( $sectName =~ /^(text_)/ ) {
< 			%Text = split( /$FS3/, $tempSection{'data'}, -1 );
< 			$newText = &SubstituteTextLinks( $old, $new, $Text{'text'} );
< 			$Text{'text'} = $newText;
< 			$tempSection{'data'} = join( $FS3, %Text );
< 			print OUT $FS1, join( $FS2, %tempSection );
< 		}
< 		else {
< 			print OUT $FS1, $_;
< 		}
< 	}
< 	close(OUT);
< }
< 
< sub RenameTextLinks {
< 	my ( $old, $new ) = @_;
< 	my ( $changed, $file, $page, $section, $oldText, $newText, $status );
< 	my ( $oldCanonical, @pageList );
< 	$old =~ s/ /_/g;
< 	$oldCanonical = &FreeToNormal($old);
< 	$new =~ s/ /_/g;
< 	$status = &ValidId($old);
< 	
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
< 	
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename-Text: new page $new is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$old =~ s/_/ /g;
< 	$new =~ s/_/ /g;
< 
< 	# Note: the LinkIndex must be built prior to this routine
< 	return if ( !defined( $LinkIndex{$oldCanonical} ) );
< 	@pageList = split( ' ', $LinkIndex{$oldCanonical} );
< 	foreach $page (@pageList) {
< 		$changed = 0;
< 		&OpenPage($page);
< 		foreach $section ( keys %Page ) {
< 			if ( $section =~ /^text_/ ) {
< 				&OpenSection($section);
< 				%Text    = split( /$FS3/, $Section{'data'}, -1 );
< 				$oldText = $Text{'text'};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Text{'text'} = $newText;
< 					$Section{'data'} = join( $FS3, %Text );
< 					$Page{$section} = join( $FS2, %Section );
< 					$changed = 1;
< 				}
< 			}
< 			elsif ( $section =~ /^cache_diff/ ) {
< 				$oldText = $Page{$section};
< 				$newText = &SubstituteTextLinks( $old, $new, $oldText );
< 				if ( $oldText ne $newText ) {
< 					$Page{$section} = $newText;
< 					$changed = 1;
< 				}
< 			}
< 
< 			# Add other text-sections (categories) here
< 		}
< 		if ($changed) {
< 			$file = &GetPageFile($page);
< 			&WriteStringToFile( $file, join( $FS1, %Page ) );
< 		}
< 		&RenameKeepText( $page, $old, $new );
< 	}
< }
< 
< sub RenamePage {
< 	my ( $old, $new, $doRC, $doText ) = @_;
< 	my ( $oldfname, $newfname, $oldkeep, $newkeep, $status );
< 	
< 	$old =~ s/ /_/g;
< 	$new    = &FreeToNormal($new);
< 	$status = &ValidId($old);
< 	
< 	if ( $status ne "" ) {
< 		print "\nRename: old page $old is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$status = &ValidId($new);
< 	if ( $status ne "" ) {
< 		print "\nRename: new page $new is invalid, error is: $status<br>";
< 		return;
< 	}
< 	$newfname = &GetPageFile($new);
< 	if ( -f $newfname ) {
< 		print "\nRename: new page $new already exists--not renamed.<br>";
< 		return;
< 	}
< 	$oldfname = &GetPageFile($old);
< 	if ( !( -f $oldfname ) ) {
< 		print "\nRename: old page $old does not exist--nothing done.<br>";
< 		return;
< 	}
< 	
< 	&CreatePageDir( $PageDir, $new );    # It might not exist yet
< 	rename( $oldfname, $newfname );
< 	&CreatePageDir( $KeepDir, $new );
< 	$oldkeep = $KeepDir . "/" . &GetPageDirectory($old) . "/$old.kp";
< 	$newkeep = $KeepDir . "/" . &GetPageDirectory($new) . "/$new.kp";
< 	unlink($newkeep) if ( -f $newkeep );    # Clean up if needed.
< 	rename( $oldkeep, $newkeep );
< 	unlink($IndexFile) if ($UseIndex);
< 	&EditRecentChanges( 2, $old, $new ) if ($doRC);
< 
< 	if ($doText) {
< 		&BuildLinkIndexPage($new);          # Keep index up-to-date
< 		&RenameTextLinks( $old, $new );
< 	}
< }
< 
< sub DoShowVersion {
< 	print &GetHeader( "", "Displaying Wiki Version", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	print "\n<h2>NobleWiki</h2>";
< 	print "\n<p>derived from UseModWiki version 1.0</p>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub GetCssChoices {
< 	my $choices = "";
< 	my $result = "";
< 	my $current = &GetParam('stylesheet', "");
< 	my $selected = "";
< 	
< 	opendir( TEMP, $CssDir );
< 	my @files = readdir(TEMP);
< 	closedir(TEMP);		
< 
< 	foreach my $file(@files){
< 		next unless ($file =~ /^wiki.*?\.css$/);    # allow wiki.something.css and wiki.css
< 		
< 		if ($current eq "/css/$file"){ $choices .= "\n<option value='/css/$file' selected='selected'>$file</option>"; }
< 		else { 	$choices .= "\n<option value='/css/$file'>$file</option>"; }
< 	}
< 	
< 	$result .= "\n<select id='stylesheet' class='wikiselectbox' name='p_stylesheet'>";
< 	$result .= $choices;
< 	$result .= "\n</select>";
< 	
< 	return $result;
< }
< 
< # Admin bar contributed by ElMoro (with some changes)
< sub GetPageLockLink {
< 	my ( $id, $status, $name ) = @_;
< 	
< 	if ($FreeLinks) {
< 		$id = &FreeToNormal($id);
< 	}
< 	return &ScriptLink( "action=pagelock&set=$status&id=$id", $name );
< }
< sub GetGallery {
< 	my ($params) = @_;
< 	my @lines = split(/\r?\n/, $params);
< 	my $lineNum = 0;
< 	my $imageNum = 0;
< 	my %options;
< 	my $images = "";
< 	my $text = "";
< 	
< 	my $defaultImage = "image1.jpg";
< 	my $defaultThumb = "thumb_image1.jpg";
< 	my $image;
< 	my $thumb;
< 	my $title;
< 	my $header;
< 	my $caption;
< 	my $description;
< 	my $thumbWidth = 100;
< 	
< 	$GLOBAL_galleryCount++;
< 		
< 	foreach my $line (@lines){
< 		%options = &GetOptions($line);
< 		
< 		if ($lineNum == 0){
< 			$lineNum++;
< 			
< 			if ($options{'thumbWidth'}){ $thumbWidth = $options{'thumbWidth'}; } else { $thumbWidth = 100; }
< 			if ($options{'description'}){ $description = $options{'description'}; }
< 			if ($options{'header'}){ $header = $options{'header'}; }
< 			if ($options{'caption'}){ $caption = $options{'caption'}; }		
< 			
< 			next;	
< 		}
< 		else {		
< 			if ($options{'image'}){ $image = $options{'image'}; }
< 			if ($options{'thumb'}){ $thumb = $options{'thumb'}; }
< 			if ($options{'title'}){ $title = $options{'title'}; } else { $title = "IMAGE: $GLOBAL_galleryCount:$imageNum"; $imageNum++; }
< 			
< 			unless (-e "$UploadDir/$image"){ $image = $defaultImage; }
< 			unless (-e "$UploadDir/$thumb"){ $thumb = $defaultThumb; }
< 			
< 			my ($imageWidth, $imageHeight) = &ComputeImageRatio($thumb, $thumbWidth, "", 1);
< 				
< 			$images .= "\n			<li><a href='$UploadUrl/$image' title='$title'><img width='$imageWidth' height='$imageHeight' src='$UploadUrl/$thumb'/></a></li>";
< 		}
< 	}
< 	
< 	$text .= "\n<div id='gallery-$GLOBAL_galleryCount' class='gallery'>";
< 	$text .= "\n	    <script type='text/javascript'>\$(function() { \$('#gallery-$GLOBAL_galleryCount a').lightBox(); });</script>";
< 	
< 	if ($header){ $text .= "\n	    <div class='gallery header'>$header</div>"; }
< 	
< 	$text .= "\n	    <ul>";	
< 	$text .= $images;
< 	$text .= "\n	    </ul>";
< 	
< 	if ($caption){ $text .= "\n	    <div class='gallery caption'>$caption</div>"; }
< 	if ($description){ $text .= "\n	    <div class='gallery description'>$description</div>"; }
< 	
< 	$text .= "\n	</div>";		
< 	
< 	return $text;
< }
< 
< sub GetFlash {
< 	my ($options) = @_;
< 	my %options = &GetOptions($options);	
< 	my $fpath = "$UploadUrl/";
< 	my $defaultSWF = 'ufo.swf';
< 	my $maxWidth = 400;
< 	my $maxHeight = 300;
< 	my $ratio = 1;
< 	
< 	my $text = "";
< 	
< 	my $fname;
< 	my $fwidth;
< 	my $fheight;
< 	my $idDiv = "ufoDiv$GLOBAL_flashCount";
< 	my $idFO = "FO_$GLOBAL_flashCount";
< 
< 	if ($options{'name'}){ $fname = $options{'name'}; } else { $fname = $defaultSWF; }
< 	if ($options{'width'}){ $fwidth = $options{'width'}; } else { $fwidth = $maxWidth; }
< 	if ($options{'height'}){ $fheight = $options{'height'}; } else { $fheight = $maxHeight; }
< 	
< 	if ($fwidth > $maxWidth){
< 		$ratio = $maxWidth / $fwidth;
< 		$fwidth = $maxWidth;
< 		$fheight = int ($ratio * $fheight);
< 	}
< 	elsif ($fheight > $maxHeight){
< 		$ratio = $maxHeight / $fheight;
< 		$fheight = $maxHeight;
< 		$fwidth = int ($ratio * $fwidth);
< 	}
< 			
< 	unless (-e "$UploadDir/$fname"){ $fname = $defaultSWF; }
< 	
< 	$text .= "\n<div id='$idDiv' class='ufoFlash'>";
< 	$text .= "\n<script type='text/javascript'>";
< 	$text .= "\n			var fpath = '$fpath';";
< 	$text .= "\n			var fname = '$fname';";
< 	$text .= "\n			var fwidth = $fwidth;";
< 	$text .= "\n			var fheight = $fheight;";
< 	$text .= "\n			var $idFO = { 'movie': fpath + fname, 'width':fwidth, 'height':fheight, 'majorversion':'8', 'build':'0', 'xi':'true' };";
< 	$text .= "\n			\$(window).load(function () {";
< 	$text .= "\n				UFO.create($idFO, '$idDiv');";					
< 	$text .= "\n				document.getElementById('$idDiv').style.width = fwidth;";
< 	$text .= "\n				document.getElementById('$idDiv').style.height= fheight;";
< 	$text .= "\n		    });";
< 	$text .= "\n		</script>";		
< 	$text .= "\n		<p style='margin-top: 0px;'>[ <i><b>$fname</b></i> ]<br> is unavailable for viewing.	Please enable JavaScript and/or download the latest <a href='http://www.macromedia.com/go/getflashplayer'>Flash Player</a>.</p>";
< 	$text .= "\n		<p><a href='http://www.macromedia.com/go/getflashplayer'><img src='http://wiki.kurcina.org/img/ufo/get_flash_player.gif' alt='Get macromedia Flash Player' style='border: none; float: right; margin-right:10px;' /></a></p>";
< 	$text .= "\n		<p style='clear: both;'></p>";
< 	$text .= "\n	</div>";
< 
< 	$GLOBAL_flashCount++;
< 	
< 	return $text;		
< }
< sub GetAdminBar {
< 	my ($id, $cssClass) = @_;
< 	my ($result);
< 
< 	$result .= "\n<div $cssClass>";
< 	$result .= "Administration: ";
< 	
< 	my ($notValid) = $id =~ /^\d*$/;
< 	
< 	if ($id eq "" || $notValid){ $result .= "<span class='disabled'>Lock Page</span>"; }
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) { $result .= &GetPageLockLink( $id, 0, "Unlock Page" ); }
< 		else { $result .= &GetPageLockLink( $id, 1, "Lock Page" ); }
< 	} 
< 		
< 	if ($id eq "" || $notValid){ $result .= " | " . "<span class='disabled'>Delete Page</span>"; }
< 	else { $result .= " | " . &GetDeleteLink( $id, "Delete Page", 0 ); }
< 	
< 	$result .= " | " . &ScriptLink( "action=editbanned", "Banned List" );
< 	$result .= " | " . &ScriptLink( "action=maintain", "Maintenance" );
< 	$result .= " | " . &ScriptLink( "action=editlinks", "Manage pages" );
< 	$result .= " | " . &ScriptLink( "action=orphans", "List Orphans" );
< 	$result .= " | " . &ScriptLink( "action=listfiles&filter=sample", "Manage Assets" );
< 			
< 	if ( -f "$DataDir/noedit" ) {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=0", "Unlock site" );
< 	}
< 	else {
< 		$result .= " | " . &ScriptLink( "action=editlock&set=1", "Lock site" );
< 	}
< 	
< 	$result .= "</div>";
< 	
< 	return $result;
< }
< 
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
< 	my ($id) = @_;
< 	
< 	return if ( !&ValidIdOrDie($id) );
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	if ( $ConfirmDel && !&GetParam( 'confirm', 0 )) {
< 		print &GetHeader( "", Ts( 'Confirm Delete %s', $id ), "" );
< 		print &GetLeftNav("");
< 		print "\n<div class='wikiadmin'>";
< 		print "\n<h2>Delete Page?</h2>";
< 		print "\nConfirm deletion of '<b>$id</b>' by following this link: ";
< 		print &GetDeleteLink( $id, "Confirm Delete", 1 );
< 		print "\n</div>";
< 		print &GetCommonFooter();
< 		print "\n</div></div></div></div></body></html>";	
< 		
< 		return;
< 	}
< 	
< 	print &GetHeader( "", Ts( 'Delete %s', $id ), "" );
< 	print &GetLeftNav("");	
< 	print "\n<div class='wikiadmin'>";
< 	
< 	if ( $id eq $HomePage ) {
< 		print Ts( '%s can not be deleted.', $HomePage );
< 	}
< 	else {
< 		if ( -f &GetLockedPageFile($id) ) {
< 			print Ts( '%s can not be deleted because it is locked.', $id );
< 		}
< 		else {
< 
< 			# Must lock because of RC-editing
< 			&RequestLock() or die( "Could not get editing lock" );
< 			DeletePage( $id, 1, 1 );
< 			&ReleaseLock();
< 			print Ts( '%s has been deleted.', $id );
< 		}
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
< 	print &GetHeader( "", "File Upload Page", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	print "\n<h2>Select File</h2>";
< 	print "\nThe current upload size limit is $MaxPost.<br>";
< 	print "\nChange the <tt>\$MaxPost</tt> variable to increase this limit.<br><br>";
< 	print "\n<form id='wikiform' method='post' action='$ScriptName' enctype='multipart/form-data'>";
< 	print "\n<input type='hidden' name='upload' value='1' />";
< 	print "\nFile to Upload: ";
< 	print "\n<input class='wikibutton' id='wikifile' type='file' name='file'>";
< 	print "\n<input class='wikibutton' id='wikisubmit' type='submit' name='Submit' value='Upload'>";
< 	print "\n</form>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub SaveUpload {
< 	my ( $filename, $printFilename, $uploadFilehandle, $fileUrl );
< 	print &GetHeader( "", "Upload Finished", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 		
< 	if ( !$AllUpload ) {
< 		return if ( !&UserIsEditorOrError() );
< 	}
< 	
< 	$UploadDir .= "/" if ( substr( $UploadDir, -1, 1 ) ne "/" );    # End with /
< 	$UploadUrl .= "/" if ( substr( $UploadUrl, -1, 1 ) ne "/" );    # End with /
< 	$filename = $q->param('file');
< 	$filename =~ s/.*[\/\\](.*)/$1/;    # Only name after last \ or /
< 	
< 	$uploadFilehandle = $filename;
< 	open UPLOADFILE, ">$UploadDir$filename";
< 	binmode(UPLOADFILE);	
< 	while (<$uploadFilehandle>) { print UPLOADFILE; }
< 	close UPLOADFILE;
< 	
< 
< 	print "\n<h2>Upload Completed</h2>";
< 	print "\nThe wiki link to your file is:<br><br>";
< 	
< 	$printFilename = $filename;
< 	$printFilename =~ s/ /\%20/g;       # Replace spaces with escaped spaces
< 	$fileUrl = $UploadUrl . $printFilename;
< 	print "\n<tt>upload:$printFilename</tt><br>[ <a href='$fileUrl' target='_blank'>$fileUrl</a> ]<br><br>";
< 
< 	if ( $filename =~ /${ImageExtensions}$/ ) {
< 		print "\n<hr class='wikiuploadbar'><img class='wikiuploadbar' src='$UploadUrl$filename' title='$fileUrl'>";
< 	}
< 	
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub ConvertFsFile {
< 	my ( $oldFS, $newFS, $fname ) = @_;
< 	my ( $oldData, $newData, $status );
< 	
< 	return if ( !-f $fname );           # Convert only existing regular files
< 	( $status, $oldData ) = &ReadFile($fname);
< 	
< 	if ( !$status ) {
< 		print "\n<br><strong>Could not open file $fname:</strong>Error was:<pre>$!</pre><br>";
< 		
< 		return;
< 	}
< 	
< 	$newData = $oldData;
< 	$newData =~ s/$oldFS(\d)/$newFS . $1/ge;
< 	
< 	return if ( $oldData eq $newData );    # Do not write if the same
< 	&WriteStringToFile( $fname, $newData );
< 
< 	# print $fname . '<br>';    # progress report
< }
< 
< # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
< # Note that top level directory (page/keep/user) contains only dirs
< sub ConvertFsDir {
< 	my ( $oldFS, $newFS, $topDir ) = @_;
< 	my ( @dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname );
< 	
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	@dirs = sort(@dirs);
< 	
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$topDir/$dir" );             # Top level directories only
< 		next if ( -f "$topDir/$dir.cvt" );          # Skip if already converted
< 		
< 		opendir( DIRLIST, "$topDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
< 		
< 		foreach $file (@files) {
< 			next if ( ( $file eq '.' ) || ( $file eq '..' ) );
< 			$fname = "$topDir/$dir/$file";
< 			if ( -f $fname ) {
< 				# print $fname . '<br>';   # progress
< 				&ConvertFsFile( $oldFS, $newFS, $fname );
< 			}
< 			elsif ( -d $fname ) {
< 				opendir( DIRLIST, $fname );
< 				@subFiles = readdir(DIRLIST);
< 				closedir(DIRLIST);
< 				
< 				foreach $subFile (@subFiles) {
< 					next if ( ( $subFile eq '.' ) || ( $subFile eq '..' ) );
< 					$subFname = "$fname/$subFile";
< 					if ( -f $subFname ) {
< 						# print $subFname . '<br>';   # progress
< 						&ConvertFsFile( $oldFS, $newFS, $subFname );
< 					}
< 				}
< 			}
< 		}
< 		&WriteStringToFile( "$topDir/$dir.cvt", 'converted' );
< 	}
< }
< 
< sub ConvertFsCleanup {
< 	my ($topDir) = @_;
< 	my ( @dirs, $dir );
< 	
< 	opendir( DIRLIST, $topDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-f "$topDir/$dir" );             # Remove only files...
< 		next unless ( $dir =~ m/\.cvt$/ );          # ...that end with .cvt
< 		unlink "$topDir/$dir";
< 	}
< }
< 
< sub DoConvert {
< 	my $oldFS = "\xb3";
< 	my $newFS = "\x1e\xff\xfe\x1e";
< 	
< 	print &GetHeader( "", "Convert wiki DB", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";	
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	if ( $FS ne $newFS ) {
< 		print "\nYou must change the $NewFS option before converting the wiki DB.<br>";
< 		return;
< 	}
< 	
< 	&WriteStringToFile( "$DataDir/noedit", 'editing locked.' );
< 	print "\nWiki DB locked for conversion.<br>";
< 	print "\nConverting Wiki DB...<br>";
< 	
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/rclog.old" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog" );
< 	&ConvertFsFile( $oldFS, $newFS, "$DataDir/oldrclog.old" );
< 	&ConvertFsDir( $oldFS, $newFS, $PageDir );
< 	&ConvertFsDir( $oldFS, $newFS, $KeepDir );
< 	&ConvertFsDir( $oldFS, $newFS, $UserDir );
< 	&ConvertFsCleanup($PageDir);
< 	&ConvertFsCleanup($KeepDir);
< 	&ConvertFsCleanup($UserDir);
< 	
< 	print "\nFinished converting wiki DB.<br>";
< 	print "\nRemove file $DataDir/noedit to unlock wiki for editing.<br>";
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< # Remove user-id files if no useful preferences set
< sub DoTrimUsers {
< 	my ( %Data, $status, $data, $maxID, $id, $removed, $keep );
< 	my ( @dirs, @files, $dir, $file, $item );
< 	
< 	print &GetHeader( "", "Trim wiki users", "" );
< 	print &GetLeftNav("");
< 	print "\n<div class='wikiadmin'>";
< 	return if ( !&UserIsAdminOrError() );
< 	
< 	$removed = 0;
< 	$maxID   = 1001;
< 	opendir( DIRLIST, $UserDir );
< 	@dirs = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 
< 	foreach $dir (@dirs) {
< 		next if ( substr( $dir, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next if ( !-d "$UserDir/$dir" );            # Top level directories only
< 		
< 		opendir( DIRLIST, "$UserDir/$dir" );
< 		@files = readdir(DIRLIST);
< 		closedir(DIRLIST);
< 		
< 		foreach $file (@files) {
< 			if ( $file =~ m/(\d+).db/ ) {           # Only numeric ID files
< 				$id    = $1;
< 				$maxID = $id if ( $id > $maxID );
< 				%Data  = ();
< 				( $status, $data ) = &ReadFile("$UserDir/$dir/$file");
< 				
< 				if ($status) {
< 					%Data =
< 					  split( /$FS1/, $data, -1 )
< 					  ;    # -1 keeps trailing null fields
< 					$keep = 0;
< 					
< 					foreach $item (qw(username password adminpw stylesheet)) {
< 						$keep = 1
< 						  if ( defined( $Data{$item} )
< 							&& ( $Data{$item} ne "" ) );
< 					}
< 					
< 					if ( !$keep ) {
< 						unlink "$UserDir/$dir/$file";
< 				   		# print "\n$UserDir/$dir/$file" . '<br>';  # progress
< 						$removed += 1;
< 					}
< 				}
< 			}
< 		}
< 	}
< 	print Ts( 'Removed %s files.', $removed ) . '<br>';
< 	print Ts( 'Recommended $StartUID setting is %s.', $maxID + 100 ) . '<br>';
< 	print "\n</div>";
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";	
< }
< 
< sub DoAssetsToc {
< 	## Check $DataDir and see if assets-toc exists
< 	## -- if not, then build TOC
< 	## -- if does, but is older than 1 minute, rebuild TOC
< 	## Return TOC	
< }
< sub DoFilterToc {
< 	## Given @filters, pageIndex, pageSize
< 	## Get TOC from DoAssetsTOC
< 	## Apply @filters; sort, apply pageIndex * pageSize as offset
< 	## Return FilteredTOC	
< }
< sub DoListFiles {
< 	my ( @list, $file, $size, @links, $numlinks, $linkname, $title, $action );
< 	my ( @files, @includes, @filters, $item, $include, $qualifies, $filecount, $keeppath, $uploadpath, $term, $excludeFilter, $targetDir );
< 	my ( $id, $filter, $managedisabled ) = @_;
< 
< 	if ($managedisabled){ 
< 		$targetDir = "$DisabledDir";
< 	}
< 	else {
< 		$targetDir = "$UploadDir";
< 	}
< 
< 	# CREATE array of filters
< 	$filter = lc($filter);
< 	$filter =~ s/\s//go;
< 	if ($filter ne ""){ 
< 		if ($filter =~ m/,/){
< 			@filters = split(',', $filter);
< 			
< 		}
< 		else {
< 			push (@filters, $filter);
< 		}
< 		$term = "using '<em>$filter</em>'";
< 	}
< 		
< 	# READ DIRECTORY	
< 	opendir( DIRLIST, $targetDir );
< 	@list = readdir(DIRLIST);
< 	closedir(DIRLIST);
< 	
< 	# RUN INCLUSIVE FILTERS
< 	foreach $file (@list){		
< 		next if ( substr( $file, 0, 1 ) eq '.' );    # No ., .., or .dirs
< 		next unless &ExtensionAllowed($file);        # Only files with valid extensions may be shown
< 		
< 		if ($filter eq ""){  push @includes, $file; next; }
< 		
< 		$qualifies = 0;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;
< 			$include = $item;
< 					
< 			if ($item =~ m/^\!/){ next; }
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 1; }}		
< 		}
< 		
< 		if ($qualifies){ push @includes, $file; }
< 	}
< 
< 	# RUN EXCLUSIVE FILTERS
< 
< 	foreach $file (@includes){
< 		if ($filter eq ""){  push @files, $file; next; }
< 				
< 		$qualifies = 1;						
< 		foreach $item (@filters){
< 			$item =~ s/\s//go;					
< 			unless ($item =~ m/^\!/){ next; }
< 			$include = substr($item, 1);
< 
< 			if ($include) { if (lc($file) =~ m/$include/){ $qualifies = 0; }}		
< 		}
< 		
< 		if ($qualifies){ push @files, $file; }
< 	}
< 	
< 	print &GetHeader( "", "Manage Assets", "" );
< 	print &GetLeftNav($id);
< 	print "\n<div class='wikidiff'>";
< 	
< 	#return if ( !&UserIsEditorOrError() );
< 		
< 	if ($managedisabled){
< 		print "\n<h2>", scalar(@files), " disabled assets found: $term</h2>";
< 		
< 		# MOVE file to disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $keeppath){
< 				if (-w $UploadDir){
< 					if (rename($keeppath, $uploadpath)){
< 						print "\nSuccessfuly re-enabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to re-enable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 	else {
< 		print "\n<h2>", scalar(@files), " assets found: $term</h2>";
< 		
< 		# MOVE file from disabled directory
< 		if ($id ne ""){
< 			$uploadpath = "$UploadDir/$id";
< 			$keeppath = "$DisabledDir/$id";
< 			
< 			if (-e $uploadpath){
< 				if (-w $DisabledDir){
< 					if (rename($uploadpath, $keeppath)){
< 						print "\nSuccessfuly disabled <tt>$id</tt><br><br>";	
< 					}
< 					else {
< 						print "\nEncountered error when attempting to disable <tt>$id</tt><br><br>";
< 					}
< 				}
< 			}
< 		}
< 	}
< 
< 	print "\n<table class='wikilargelist'>";
< 	print "\n<tr><th>WikiLink</th><th>URI</th><th>Size</th><th>Linked Pages</th></tr>";
< 	
< 	foreach $file (@files) {
< 		$filecount++;
< 		$linkname = "upload:$file";
< 		
< 		@links = SearchTitleAndBody($file, "", "");
< 		$numlinks = scalar(@links);
< 
< 		$title = "";
< 		$action = "";
< 			
< 		if ($managedisabled){			
< 			$size = sprintf("%.3f KB", (-s "$DisabledDir/$file")/1000);
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td>$file</td>";
< 			print "\n<td>$size</td>";			
< 			
< 			if ( &UserIsEditorOrAdmin() ){
< 				$title = "Click to re-enable file.";
< 				$action = "href='$ScriptName?action=listdisabled&id=$file'";
< 			}
< 		}
< 		else {		
< 			$uploadpath = "$UploadUrl/$file";
< 			$size = sprintf("%.3f KB", (-s "$UploadDir/$file")/1000);	
< 			
< 			print "\n<tr>";
< 			print "\n<td><tt>$linkname</tt></td>";
< 			print "\n<td><a href='$uploadpath' target='_blank' title='Click to view in a new window'>$file</a></td>";
< 			print "\n<td>$size</td>";
< 			
< 			if ($numlinks > 0){
< 				$title = "Click to see what pages link to this file.";
< 				$action = "href='$ScriptName?back=$file'";
< 			}
< 			elsif ( &UserIsEditorOrAdmin() ){
< 				$numlinks = "0";
< 				$title = "Click to disable file.";
< 				$action = "href='$ScriptName?action=listfiles&id=$file'";
< 			}		
< 		}
< 
< 		print "\n<td><a class='wikilink' title='$title' $action>$numlinks</a></td>";
< 		print "\n</tr>";
< 	}
< 	
< 	if (scalar(@files) == 0){
< 		print "\n<td colspan='4'>No files available</td></tr>";
< 	}
< 	print "\n</table>";
< 	print "\n<form id='wikiform' action='$ScriptName' method='POST'>";
< 	print "\n<br>Naming filter:<br><input type='text' name='filter' value='$filter'>&nbsp;";
< 	print "\n<input type='submit' value='Apply Filter'>";
< 	
< 	
< 	if ($managedisabled){
< 		print "\n<input type='hidden' name='action' value='listdisabled'>";		
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listfiles;\"'><input type='button' value='View Active Files'/></a><br>";
< 	}
< 	else {
< 		print "\n<input type='hidden' name='action' value='listfiles'>";
< 		print "<a onclick='window.location.href=\"$ScriptName?action=listdisabled;\"'><input type='button' value='View Disabled Files'/></a><br>";
< 	}
< 	print "\nUse ! to exclude a term, separate terms with a comma";
< 	print "\n</form>";
< 	print "\n</div>";
< 
< 	print &GetCommonFooter();
< 	print "\n</div></div></div></div></body></html>";				
< }
< 
< 
< #END_OF_OTHER_CODE
< &DoWikiRequest() if ( $RunCGI && ( $_ ne 'nocgi' ) );    # Do everything.
< 1;    # In case we are loaded from elsewhere
< 
< # == End of UseModWiki script. ===========================================
< 
< 
< </nowiki></pre>
---
> = TESTING =
> 
> [LocalWiki:HomePage upload:SAMPLE.churcill.jpg]
------
GRoWWII|1196392538
4c4
< [LocalWiki:upload:nations.at.war.jpg upload:GRoWWII/nations.at.war.jpg|width=400|boxwidth=410|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
---
> [LocalWiki:upload:GRoWWII/nations.at.war.jpg upload:GRoWWII/nations.at.war.jpg|width=400|boxwidth=410|boxfloat=right|description=Nations At War|caption=There are six major nations at war; three for the Allies of Freedom and three for the Axis of Power.  The Allies are led by the United States of America ' USA ', peered with Russia ' USSR ' and the United Kingdom Empire ' UK '.  On the opposing side are Germany, Japan, and Italy.]
------
WikiMinimums|1196394839
19a20,21
> **WikiContacts
> **WikiHelp
------
NobleWiki|1196415750
36a36,37
> ||Print Link List||Updated this presentation to have a table.  Any non-existent pages identified will show with the 'Create this entry' icon.||
> 
------
WikiBugs|1196416215
9c9
< ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||Appears to be that bracket images within table cells fail to resolve.  See any of the home page images||OPEN||
---
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||Appears to be that bracket images within table cells fail to resolve.  See any of the home page images||FIXED-2007.11.27||
------
WikiBugs|1196416229
3c3
< !!Date Discovered!!Contributor!!Description!!Status!!
---
> !!Date!!Contributor!!Description!!Status!!
------
WikiTemplates|1196487828
67a69
>  #SUBPAGES
------
NobleWiki|1196499560
26a26,27
> ||File Icon Boxes||If an asset link has a non-bitmap image extension a box with an icon for that file type is presented.||
> 
------
WikiMinimums|1196504247
40a41,58
> ***icons/
> ****icons/icons.ai.100px.jpg
> ****icons/icons.fh.100px.jpg
> ****icons/icons.fla.100px.jpg
> ****icons/icons.psd.100px.jpg
> ****icons/icons.pdf.100px.jpg
> ****icons/icons.swf.100px.jpg
> ****icons/icons.ppt.100px.jpg
> ****icons/icons.xls.100px.jpg
> ****icons/icons.doc.100px.jpg
> ****icons/icons.txt.100px.jpg
> ****icons/icons.as.100px.jpg
> ****icons/icons.css.100px.jpg
> ****icons/icons.js.100px.jpg
> ****icons/icons.xml.100px.jpg
> ****icons/icons.UNKNOWN.100px.jpg
> 
> 
------
FlashSWF/ExampleDiceland|1196552443
5c5
< This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the [http://www.boardgamegeek.com/game/2937 DiceLand] available at [http://www.kidultgame.com/en/homepage.htm?http://www.kidultgame.com/en/diceland/diceland.htm Kidult]
---
> This is an example of a MagicFlash.  This SWF is a work-in-progress implementation of the [http://www.boardgamegeek.com/game/2937 Diceland] available at [http://www.kidultgame.com/en/homepage.htm?http://www.kidultgame.com/en/diceland/diceland.htm Kidult]
------
WikiBugs|1196552706
12a13
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Seems that the back-links or <tt><nowiki>GetFullLinkList</nowiki></tt> subroutines ignore spaces, periods, and capitilization when performing a search.||OPEN||
------
WikiBugs|1196566983
13c13
< ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Seems that the back-links or <tt><nowiki>GetFullLinkList</nowiki></tt> subroutines ignore spaces, periods, and capitilization when performing a search.||OPEN||
---
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Seems that the back-links or <tt><nowiki>GetFullLinkList</nowiki></tt> subroutines ignore spaces, periods, and capitilization when performing a search.||FIXED-2007.12.01||
------
NobleWiki|1196567794
38a38,41
> ||Disabled regex Search||A checkbox near the search form when marked will disable the default search mechanism that allows search terms to be interpreted as regex values.||
> ||Disable regex back-links||The <tt><nowiki>DoBackLinks</nowiki></tt> subroutine no longer uses search terms as regular expressions.||
> 
> 
------
NobleWiki|1196567859
30c30
< ||IE6 textarea||Added <tt><div style='width:100%;'>...</div></tt> around the textarea in <tt><nowiki>sub GetTextArea {}</nowiki></tt> to enable 100% width in IE6||
---
> ||IE6 textarea||Added <tt><nowiki><div style='width:100%;'>...</div></nowiki></tt> around the textarea in <tt><nowiki>sub GetTextArea {}</nowiki></tt> to enable 100% width in IE6||
------
NobleWiki|1196638791
10c10
< !!!!Difference Things!!
---
> !!Difference Things!!Description||
28c28
< !!!!Minor Things!!
---
> !!Minor Things!!Description||
44c44
< !!!!Patches Applied!!
---
> !!Patches Applied!!Description||
65c65
< !!!!Patches Under Consideration!!
---
> !!Patches Under Consideration!!Description||
73c73
< !!!!Broken Things!!
---
> !!Broken Things!!Description||
82c82
< !!!!Features Planned for future versions of <nowiki>NobleWiki</nowiki>!!
---
> !!Features Planned!!Description||
------
NobleWiki|1196638823
10c10
< !!Difference Things!!Description||
---
> !!Difference Things!!Description!!
28c28
< !!Minor Things!!Description||
---
> !!Minor Things!!Description!!
44c44
< !!Patches Applied!!Description||
---
> !!Patches Applied!!Description!!
65c65
< !!Patches Under Consideration!!Description||
---
> !!Patches Under Consideration!!Description!!
73c73
< !!Broken Things!!Description||
---
> !!Broken Things!!Description!!
82c82
< !!Features Planned!!Description||
---
> !!Features Planned!!Description!!
------
GRoWWII/TOandE|1196638973
89,93c89,93
< || ||Armor||10th Armored Corps||
< || ||Engineers||33rd Engineers Corps||
< || ||Infantry||II Infantry Corps||
< || ||Naval Operations||4th Naval Operations Corps||
< || ||Strategic Air||First Strategic Air Corps||
---
> ||Combat||Armor||10th Armored Corps||
> ||Combat||Engineers||33rd Engineers Corps||
> ||Combat||Infantry||II Infantry Corps||
> ||Combat||Naval Operations||4th Naval Operations Corps||
> ||Combat||Strategic Air||First Strategic Air Corps||
95,99c95,99
< || ||Ordnance||22nd Ordnance Corps||
< || ||Repair||9th Repair Corps||
< || ||Robotics||XIV Robotics Corps||
< || ||Signals||Third Signals Corps||
< || ||Technology||1st Technology Corps||
---
> ||Service||Ordnance||22nd Ordnance Corps||
> ||Service||Repair||9th Repair Corps||
> ||Service||Robotics||XIV Robotics Corps||
> ||Service||Signals||Third Signals Corps||
> ||Service||Technology||1st Technology Corps||
101,105c101,105
< || ||Chaplain||3rd Chaplain Corps||
< || ||Command||Alpha-2 Command Corps||
< || ||Electronics||23rd Electronics Corps||
< || ||Intelligence||7th Intelligence Coprs||
< || ||Medical||5th Medical Corps||
---
> ||Support||Chaplain||3rd Chaplain Corps||
> ||Support||Command||Alpha-2 Command Corps||
> ||Support||Electronics||23rd Electronics Corps||
> ||Support||Intelligence||7th Intelligence Coprs||
> ||Support||Medical||5th Medical Corps||
107,114c107,114
< || ||Finance||Third Finance Corps||
< || ||Legal||Primary Legal Corps||
< || ||Peace||Pacific Peace Corps||
< || ||Police||Group 3 Police Corps||
< || ||Public Affairs||Western Public Affairs Corps||
< || ||Research||Boston Research Corps||
< || ||Training||Biluxi Training Corps||
< || ||Transportation||East Transportation Corps|| 
---
> ||Base||Finance||Third Finance Corps||
> ||Base||Legal||Primary Legal Corps||
> ||Base||Peace||Pacific Peace Corps||
> ||Base||Police||Group 3 Police Corps||
> ||Base||Public Affairs||Western Public Affairs Corps||
> ||Base||Research||Boston Research Corps||
> ||Base||Training||Biluxi Training Corps||
> ||Base||Transportation||East Transportation Corps|| 
------
GRoWWII/TOandE|1196639271
154c154
< !!!!Light Infantry Regiment|width=250!!23 OP!!
---
> !!Class!!Light Infantry Regiment|width=250!!23 OP!!
159c159
< !!!!Heavy Infantry Regiment!! 27 OP !!
---
> !!Class!!Heavy Infantry Regiment!! 27 OP !!
164c164
< !!!!Advanced Infantry Regiment!! 40 OP!!
---
> !!Class!!Advanced Infantry Regiment!! 40 OP!!
169c169
< !!!!Robotic Assault Regiment!! 82 OP!!
---
> !!Class!!Robotic Assault Regiment!! 82 OP!!
174c174
< !!!!Vanguard Infantry Regiment!! 46 OP!!
---
> !!Class!!Vanguard Infantry Regiment!! 46 OP!!
179c179
< !!!!Artillery Support Regiment!! 37 OP!!
---
> !!Class!!Artillery Support Regiment!! 37 OP!!
184c184
< !!!!Field Infantry Regiment!! 27 OP!!
---
> !!Class!!Field Infantry Regiment!! 27 OP!!
189c189
< !!!!Division Support Regiment!! 33 OP!!
---
> !!Class!!Division Support Regiment!! 33 OP!!
194c194
< !!!!Armored Assault Regiment!! 78 OP!!
---
> !!Class!!Armored Assault Regiment!! 78 OP!!
199c199
< !!!!Heavy Armored Assault Regiment!! 104 OP!!
---
> !!Class!!Heavy Armored Assault Regiment!! 104 OP!!
------
NobleWiki|1196641220
23a24
> ||Table Sorting||Added jQuery Tablesorter 2.0 to engage any table created properly.  See WikiTables for more information.||
------
WikiTables|1196641503
25a26,28
> === Table Sorting ===
> A client-side implementation of table sorting via the use of the jQuery extension "Tablesorter 2.0" is automatically engaged for any table created properly.  The sample tables above are properly created; they start with the <tt><nowiki>!!</nowiki></tt> in the first row, and are followed entirely by <tt><nowiki>||</nowiki></tt> in all remaining rows. Click in the header of a column to reverse the sort order.  Hold the <tt>SHIFT</tt> key to select multiple columns.
> 
------
HomePage|1196646801
8c8
< ||NobleMission|style=background-color:#f5f5f5;||What to see and expect from this wiki, and how to contribute||
---
> ||NobleMission|class=first||What to see and expect from this wiki, and how to contribute||
------
NobleWiki|1196647112
11c11
< ||Negation Search|style=background-color:#f5f5f5;||Precede the search term with '!' exclamation point and the search API will find every <em>but</em> that term.||
---
> ||Negation Search|class=first||Precede the search term with '!' exclamation point and the search API will find every <em>but</em> that term.||
30c30
< ||Cancel button|style=background-color:#f5f5f5;||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
---
> ||Cancel button|class=first||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
46c46
< ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix|style=background-color:#f5f5f5;|width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
---
> ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix|class=first|width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
67c67
< ||UseMod:WikiPatches/EmbeddedBacklinks|style=background-color:#f5f5f5;|width=300||want||
---
> ||UseMod:WikiPatches/EmbeddedBacklinks|class=first|width=300||want||
75c75
< ||<tt>T(<string>)</tt>|style=background-color:#f5f5f5;||These are removed for now to declutter the perl code.  Will return as a set of configuration files - one per language.||
---
> ||<tt>T(<string>)</tt>|class=first||These are removed for now to declutter the perl code.  Will return as a set of configuration files - one per language.||
84c84
< ||<tt><nowiki>{{history|events}}</nowiki></tt>|style=background-color:#f5f5f5;||Create a timeline using the Timeline javascript widget||
---
> ||<tt><nowiki>{{history|events}}</nowiki></tt>|class=first||Create a timeline using the Timeline javascript widget||
------
ExampleTemplate|1196647181
4c4
< ||Image|width=100|style=background-color:#eeeeee;||$VARIABLE1$|align=left ||
---
> ||Image|width=100|class=first||$VARIABLE1$|align=left ||
------
WikiTemplates/HomePage|1196647212
4c4
< ||<b>Image</b>|width=100|style=background-color:#eeeeee;||$UPLOADIMAGE$||
---
> ||<b>Image</b>|width=100|class=first||$UPLOADIMAGE$||
------
GRoWWII/TOandE|1196647243
88c88
< ||Combat||Amphibious||V Amphibious Corps||
---
> ||Combat|class=first||Amphibious||V Amphibious Corps||
------
GRoWWII/TOandE|1196647942
154c154
< !!Class!!Light Infantry Regiment|width=250!!23 OP!!
---
> !!Class|tablesort=none!!Light Infantry Regiment|width=250!!23 OP!!
------
WikiTables|1196648015
53a53,55
> ||<tt><nowiki>|tablesort=none</nowiki></tt>||When provided in the first row of a table, will prevent the Tablesorter script to elect the table for javascript sortable table interactivity.||
> 
> 
------
SandBox|1196651971
3a5,14
> upload:fred.js
> 
> upload:SAMPLE.churcill.jpg
> 
> http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg
> http://wiki.kurcina.org/attachments/SAMPLE.churcill.pdf
> 
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.pdf
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.ai
> [LocalWiki:SAMPLE.churcill.pdf click]
------
WikiImages|1196657325
8,28c8,28
< These are the basic ones, used for general viewing:
< ||.jpg || JPEG, Joint Photographer's Expert Group format.||
< ||.bmp || Microsoft Bitmap format.||
< ||.gif || <nowiki>CompuServe</nowiki> Graphic Image Format.||
< 
< These are used during the development cycle. 
< ||.psd || Adobe Photoshop.  These would generally be template files for creating new images.||
< ||.ai  || Adobe Illustrator. ||
< ||.doc || Microsoft Word document.||
< ||.txt || Text files.||
< 
< These are often either the final product or used as reference material.
< ||.xls || Microsoft Excel spreadsheet.||
< ||.ppt || Microsoft Powerpoint.||
< ||.pdf || Adobe Acrobat.  This should be the preferred format for sharing all assets not meant for Web-only viewing.||
< 
< These are specific to Web development.
< ||.js  || Javascript file.||
< ||.css || Cascading Stylesheet file.||
< 
< === Remote File Linking ===
---
> !!Extension|class=first|width=200!!These are the basic ones, used for general viewing!!
> ||.jpg||JPEG, Joint Photographer's Expert Group format.||
> ||.bmp||Microsoft Bitmap format.||
> ||.gif||<nowiki>CompuServe</nowiki> Graphic Image Format.||
> 
> !!Extension|class=first|width=200!!TThese are used during the development cycle.!!
> ||.psd||Adobe Photoshop.  These would generally be template files for creating new images.||
> ||.ai||Adobe Illustrator.||
> ||.doc||Microsoft Word document.||
> ||.txt||Text files.||
> 
> !!Extension|class=first|width=200!!TThese are often either the final product or used as reference material.!!
> ||.xls|class=first|| Microsoft Excel spreadsheet.||
> ||.ppt| Microsoft Powerpoint.||
> ||.pdf|| Adobe Acrobat.  This should be the preferred format for sharing all assets not meant for Web-only viewing.||
> 
> !!Extension|class=first|width=200!!These are specific to Web development.!!
> ||.js||Javascript file.||
> ||.css||Cascading Stylesheet file.||
> 
> === Direct File Linking ===
43,48c43,45
<  <b>For example: </b> <tt><nowiki>[http://blogs.kurcina.org/cgi-bin/index.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]</nowiki></tt>
<  [http://blogs.kurcina.org/cgi-bin/blosxom.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]
<  <b>And also: </b> <tt><nowiki>[http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]</nowiki></tt>
<  [http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]
<  <b>As well as: </b> <tt><nowiki>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]</nowiki></tt>
<  [LocalWiki:HomePage upload:SAMPLE.churcill.jpg]
---
>  <b>For example: </b> <tt><nowiki>[http://blogs.kurcina.org/cgi-bin/index.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]</nowiki></tt>[http://blogs.kurcina.org/cgi-bin/blosxom.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]
>  <b>And also: </b> <tt><nowiki>[http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]</nowiki></tt>[http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]
>  <b>As well as: </b> <tt><nowiki>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]</nowiki></tt>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]
53c50
< !!Option width=100!!Description!!
---
> !!Option|width=100|class=first!!Description!!
------
WikiImages|1196657491
38c39
<  upload:SAMPLE.churcill.jpg
---
> upload:SAMPLE.churcill.jpg
43,45c44,46
<  <b>For example: </b> <tt><nowiki>[http://blogs.kurcina.org/cgi-bin/index.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]</nowiki></tt>[http://blogs.kurcina.org/cgi-bin/blosxom.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]
<  <b>And also: </b> <tt><nowiki>[http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]</nowiki></tt>[http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]
<  <b>As well as: </b> <tt><nowiki>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]</nowiki></tt>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]
---
> <b>For example: </b> <tt><nowiki>[http://blogs.kurcina.org/cgi-bin/index.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]</nowiki></tt>[http://blogs.kurcina.org/cgi-bin/blosxom.cgi http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg]
> <b>And also: </b> <tt><nowiki>[http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]</nowiki></tt>[http://forums.kurcina.org/cgi-bin/groww2/index.cgi upload:SAMPLE.churcill.jpg]
> <b>As well as: </b> <tt><nowiki>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]</nowiki></tt>[LocalWiki:HomePage upload:SAMPLE.churcill.jpg]
------
WikiImages|1196657871
88a88,104
> === Icon Boxes ===
> All text or binary files that aren't images referenced using the <tt><nowiki>upload:filename.ext</nowiki></tt> syntax will automatically create an icon and caption box. The icon presented will depend upon the extension of the file linked.  Here are examples of links to each of the files supported:
> 
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.ai
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.pdf
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.fh
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.fla
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.swf
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.psd
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.xml
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.css
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.js
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.txt
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.doc
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.ppt
> upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.xls
> 
------
WikiImages|1196660318
13c13
< !!Extension|class=first|width=200!!TThese are used during the development cycle.!!
---
> !!Extension|class=first|width=200!!These are used during the development cycle.!!
20,22c20,22
< ||.xls|class=first|| Microsoft Excel spreadsheet.||
< ||.ppt| Microsoft Powerpoint.||
< ||.pdf|| Adobe Acrobat.  This should be the preferred format for sharing all assets not meant for Web-only viewing.||
---
> ||.xls|class=first||Microsoft Excel spreadsheet.||
> ||.ppt||Microsoft Powerpoint.||
> ||.pdf||Adobe Acrobat.  This should be the preferred format for sharing all assets not meant for Web-only viewing.||
89,103c89,97
< All text or binary files that aren't images referenced using the <tt><nowiki>upload:filename.ext</nowiki></tt> syntax will automatically create an icon and caption box. The icon presented will depend upon the extension of the file linked.  Here are examples of links to each of the files supported:
< 
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.ai
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.pdf
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.fh
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.fla
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.swf
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.psd
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.xml
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.css
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.js
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.txt
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.doc
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.ppt
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.xls
---
> All files that aren't images referenced using the <tt><nowiki>upload:filename.ext</nowiki></tt> syntax will automatically create an icon and caption box. The icon presented will depend upon the extension of the file linked.  Here are examples of links to each of the files supported:
> 
> ||upload:SAMPLE.ai|tableclass=none||upload:SAMPLE.pdf||
> ||upload:SAMPLE.fh||upload:SAMPLE.fla||
> ||upload:SAMPLE.swf||upload:SAMPLE.psd||
> ||upload:SAMPLE.xml||upload:SAMPLE.css||
> ||upload:SAMPLE.js||upload:SAMPLE.txt||
> ||upload:SAMPLE.doc||upload:SAMPLE.ppt||
> ||upload:SAMPLE.xls||||
------
WikiImages|1196660359
97c97
< ||upload:SAMPLE.xls||||
---
> ||||upload:SAMPLE.xls||
------
WikiBugs|1196661211
13a14
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output||OPEN||
------
GameConventions|1196667631
2a3,9
> <pre>
>  DundraCon
>  KublaCon
>  Origins
>  GenCon
>  Essen
> </pre>
------
GameConventions|1196667658
1c1
< ====== Describe the new page here. =
---
> == A List of Gaming Conventions =
------
CategoryGames|1196667710
7a7
> ||GamePeriodicals||List of magazines geared towards boardgame enthusiasts||
------
WikiBugs|1196670178
10c10
< ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans list legitimate sub pages||OPEN||
---
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans incorrectly lists legitimate sub pages||OPEN||
14c14
< ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output||OPEN||
---
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output||FIXED-2007.12.03||
------
NobleWiki|1196718447
86c86
< ||<tt><nowiki>{{comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab.||
---
> ||<tt><nowiki>{{comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab and input would be GUI-based instead of using the Edit-box. Uses sub-pages named as /CommentsPage or /CommentsPageSubpage.||
92a91,94
> ||<tt><nowiki>{{data|id}}</nowiki></tt>||Added dataset storage in two phases.  Phase I is JSON creation for reference by SWFs, and JavaScript libraries.  Phase II is a read/write API possibly via XmlHttpSocket for AJAX or SWF.||
> 
> 
> 
------
NobleWiki|1196718629
91c91,92
< ||<tt><nowiki>{{data|id}}</nowiki></tt>||Added dataset storage in two phases.  Phase I is JSON creation for reference by SWFs, and JavaScript libraries.  Phase II is a read/write API possibly via XmlHttpSocket for AJAX or SWF.||
---
> ||<tt><nowiki>{{data|id}}</nowiki></tt>||Add dataset storage in two phases.  Phase I is JSON creation for reference by SWFs, and JavaScript libraries.  Phase II is a read/write API possibly via XmlHttpSocket for AJAX or SWF.||
> ||<tt><nowiki>{{code|syntax}}</nowiki></tt>||Add syntax highlighting for common language files like perl, actionscript, javascript, css, xml, and html. The output will be contained within <tt><nowiki><code class='syntax'></code></nowiki></tt> blocks and dynamically higlighted using javascript.||
------
NobleWiki|1196718858
95a93,95
> ||<tt><nowiki>{{blog|entryid}}</nowiki></tt>||This would be a new GUI that writes to a dataset page under PageId/Blogentryid and support RSS 1.0.  Features are editing, archive, publishing, and a WYSIWYG.||
> 
> 
------
NobleWiki|1196719015
95a94,96
> ||<tt><nowiki>{{form|formid}}</nowiki></tt>||Create a simple configuration-driven form generator that would write to a dataset page.  Simple form templates should be made available such as voting + graph-view, feedback/mailer, calculation, and dataset data-entry + graph-view.||
> 
> 
------
WikiUploads|1196751235
1c1,20
< ====== Describe the new page here. =
---
> = Asset Uploads =
> 
> <wikitoc 250>
> 
> == Uploading Files =
> 
> == List Assets =
> 
> === Table Sorting =
> 
> === Search Filters =
> 
> == Priviledge Mode =
> 
> === Managed Active Assets =
> 
> === Managed Disabled Assets =
> 
> == Related Entries =
> {{template:RelatedEntries/WikiEditing}}
------
WikiUploads|1196751244
3c3
< <wikitoc 250>
---
> <toc 250>
------
WikiTemplates/TemplateExample|1196751322
3,8c3,8
< !!!! EXAMPLE Sub-page Template !!
< || Image|| $VARIABLE1$ ||
< || link|| $VARIABLE2$ ||
< || my sub-page|| $VARIABLE3$ ||
< || your sub-page ||$VARIABLE4$ ||
< || bracketed url ||$VARIABLE5$ ||
---
> !!!!EXAMPLE Sub-page Template!!
> ||Image||$VARIABLE1$||
> ||link||$VARIABLE2$||
> ||my sub-page||$VARIABLE3$||
> ||your sub-page ||$VARIABLE4$ ||
> ||bracketed url ||$VARIABLE5$}||
------
RelatedEntries/WikiEditing|1196751383
13a13
> WikiUploads
------
RelatedEntries/WikiEditing|1196751520
0a1,2
> 
> 
------
NobleWiki|1196899274
86c86
< ||<tt><nowiki>{{comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab and input would be GUI-based instead of using the Edit-box. Uses sub-pages named as /CommentsPage or /CommentsPageSubpage.||
---
> ||<tt><nowiki>{{comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab and input would be GUI-based instead of using the Edit-box. Uses sub-pages named as <tt><nowiki>/CommentsPage</nowiki></tt> or <tt><nowiki>/CommentsSubPage</nowiki></tt>.||
91c91
< ||<tt><nowiki>{{data|id}}</nowiki></tt>||Add dataset storage in two phases.  Phase I is JSON creation for reference by SWFs, and JavaScript libraries.  Phase II is a read/write API possibly via XmlHttpSocket for AJAX or SWF.||
---
> ||<tt><nowiki>{{data|id}}</nowiki></tt>||Add dataset storage in two phases.  Phase I is JSON creation for reference by SWFs, and <tt><nowiki>JavaScript</nowiki></tt> libraries.  Phase II is a read/write API possibly via <tt><nowiki>XmlHttpSocket</nowiki></tt> for AJAX or SWF.||
93c93
< ||<tt><nowiki>{{blog|entryid}}</nowiki></tt>||This would be a new GUI that writes to a dataset page under PageId/Blogentryid and support RSS 1.0.  Features are editing, archive, publishing, and a WYSIWYG.||
---
> ||<tt><nowiki>{{blog|entryid}}</nowiki></tt>||This would be a new GUI that writes to a dataset page under <tt><nowiki>PageId/Blogentryid</nowiki></tt> and support RSS 1.0.  Features are editing, archive, publishing, and a WYSIWYG.||
97,98d95
< Additionally, I've been reading about what appears to be a major fork of <nowiki>UseMod</nowiki> created by [UseMod:AlexSchroeder Alex Schroeder] named [UseMod:OddMuse OddMuse] that I want to investigate.  The interesting thing is how that wiki's modules are set up.
< 
------
WikiUploads|1196901436
2a2,10
> This wiki engine provides a simple interface for uploading assets, listing them for use, and moving them around.  The sorts of assets allowed for upload are restricted by the wiki variables <tt><nowiki>$DownloadExtensions</nowiki></tt> and <tt><nowiki>$ImageExtensions</nowiki></tt>.  By default, the types of assets allowed will be limited by their file extension:	
> 
> <pre>
>  $ImageExtensions = gif|jpg|png|bmp|jpeg|ico|tiff
>  $DownloadExtensions = pdf|psd|ai|xls|xml|ppt|js|css|doc|txt|swf|fla|fh9|fh11
> </pre>
> 
> As can be seen, the list is definitive and covers most of the benign file types useful for developers, artists, and the general wiki user.
> 
6a14,15
> Click on the [LocalWiki:action=upload Upload] link at the top or bottom "Goto" bar.  In the two-column GUI, the left-navigation will also have the upload link.  The page will refresh an display a simple form.  Click the "Browse..." button to select a file from the file system, and then optionally provide a destination folder.  The destination folder can be something that currently exists as shown in the drop-list, or can be a new folder.  Click the upload button to complete the process.  The response screen will then display the image or link to the image.  Additionally, the response screen will display the <tt><nowiki>upload:XXXX</nowiki></tt> syntax that can be used to make reference to the file from any wiki page.  See WikiImages for more about that.
> 
------
WikiImages|1196902630
97c97
< ||||upload:SAMPLE.xls||
---
> ||upload:SAMPLE.xls||upload:SAMPLE.zip||
------
WikiHelp|1196903636
5,7c5,6
<  CategoryCategory
<  AdminFeatures
<  WikiEditing
---
> {{template:RelatedEntries/WikiEditing}}
> 
------
WikiUploads|1196915235
11c11
< <toc 250>
---
> <toc>
14c14
< Click on the [LocalWiki:action=upload Upload] link at the top or bottom "Goto" bar.  In the two-column GUI, the left-navigation will also have the upload link.  The page will refresh an display a simple form.  Click the "Browse..." button to select a file from the file system, and then optionally provide a destination folder.  The destination folder can be something that currently exists as shown in the drop-list, or can be a new folder.  Click the upload button to complete the process.  The response screen will then display the image or link to the image.  Additionally, the response screen will display the <tt><nowiki>upload:XXXX</nowiki></tt> syntax that can be used to make reference to the file from any wiki page.  See WikiImages for more about that.
---
> Click on the [LocalWiki:action=upload Upload] link at the top or bottom "Goto" bar.  In the two-column GUI, the left-navigation will also have the upload link.  The page will refresh an display a simple form.  Click the "Browse..." button to select a file from the file system, and then optionally provide a destination folder.  The destination folder can be something that currently exists as shown in the drop-list, or can be a new folder.  Click the upload button to complete the process.  The response screen will then display the image or link to the image.  Additionally, the response screen will display the <tt><nowiki>upload:filename.tla</nowiki></tt> syntax that can be used to make reference to the file from any wiki page.  See WikiImages for more about that.
17a17,18
> This basic view is available to all wiki users.  It's a page that displays the available active assets such as bitmaps, text, or source files as a list within a table.  The view also provides a way to preview the asset and shows a string that can be used within any WikiPage in order to present the asset.  All assets may appear in either the MAIN folder or in a sub-folder like <tt>/FlashSWF</tt> or <tt>/Examples</tt>
> 
19a20,21
> The asset list is in a table format and shows the folder, file type, as asset size in kilo-bytes.  As a properly formed WikiTable, the list allows on or more columns to be sorted.  Clicking a column header will switch between ascending and descending order.  Shift-click multiple columns to sort by that many.
> 
22c23,32
< == Priviledge Mode =
---
> The default sort filter is <tt>!/</tt> which basically is the same as indicating the <tt>MAIN</tt> folder.  Removing the default sort will show all assets in all folders.  The filter can be any keywords or fragments; the engine will then display just those assets with values.  To exclude a keyword or fragment precede it with an exclamation point.
> 
> For example:
>  !/         Displays anything without a slash '/'; essentially the same as 'MAIN'
>  jpg        Displays all jpg files
>  jpg, swf   Displays all jpg and swf files.
>  !jpg, !swf Displays all files except those that are swf or jpg.
> 
> == Priviledged Mode =
> Editors and Administrators that access the asset view are in 'priviledged mode' and will be given a some powerful interface features.  This is signified by replacing the name of view from 'List Assets' to 'Manage Assets'. 
25a35,39
> The default view will show an expanded table with a column for the number of back-links and a checkbox column for selecting one or more files to move.  The back-links indicate how many pages make reference to the particular asset.  Assets with zero links are those eligible to be moved.  To move an asset, mark its checkbox and near the bottom of the table pick a new folder to create an move the assets into or select one of the existing folders from the drop-list.
> 
> ==== Disabling Assets =
> One of the drop-list options is to select 'DISABLED'; any assets moved here will be made unavailable to be linked and will qualify for deletion by an Administrator.  Any files moved into the DISABLED directory will be placed into a similarly named sub-folder if they aren't in the MAIN folder.
> 
27a41,48
> Clicking on the 'View Disabled Assets' button will switch the view to the DISABLED directory.  This directory can't be accessed via the browser; any assets here are can't be previewed.  Any search filter in placed when the button is clicked will continue in the next view.
> 
> ==== Deleting Assets =
> The 'Managed Disabled Assets' view has a slightly modified drop-list.  The option for 'ACTIVE' will re-enable the assets.  The option for 'DELETE' will move the asset into a protected directory on the server.  Once the asset is moved into the DELETED directory it can't be recovered via the wiki but can be accessed by the server administrator or wiki owner to either permanently delete or to move back into the other directories.
> 
> === File Clobbering =
> Any assets that are moved will clobber - erase, and over-write - any existing assets in the destination if their filenames are the same.  This can be a quick way to 
> 
------
WikiMinimums|1196915546
20d19
< **WikiContacts
21a21,34
> **WikiContacts
> **WikiStyleGuide
> **WikiHeadings
> **WikiGallery
> **WikiFlash
> **WikiTOCs
> **WikiURLs
> **WikiImages
> **WikiTables
> **WikiLists
> **WikiMarkup
> **WikiTemplates
> **WikiUploads
> 
------
SandBox|1197119371
3,14c3,5
< [LocalWiki:HomePage upload:SAMPLE.churcill.jpg]
< 
< upload:fred.js
< 
< upload:SAMPLE.churcill.jpg
< 
< http://wiki.kurcina.org/attachments/SAMPLE.churcill.jpg
< http://wiki.kurcina.org/attachments/SAMPLE.churcill.pdf
< 
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.pdf
< upload:http://wiki.kurcina.org/attachments/SAMPLE.churcill.ai
< [LocalWiki:SAMPLE.churcill.pdf click]
---
> {{code|height=100
> print 'HELLO WORLD';
> }}
------
WikiCodeBox|1197121517
1,2c1,80
< ====== Describe the new page here. =
< 
---
> = <nowiki>CodePress</nowiki> Code Boxes =
> NobleWiki employs the <nowiki>CodePress</nowiki> "[http://codepress.org Real Time Syntax Highlighting Editor written in JavaScript]" written by [mailto:fermads@gmail.com Fernando M.A.d.S.].  With the use of these 'code boxes', script and programming language code may be displayed in a nicely formatted manner for citation within pages dedicated to software development.
> <toc>
> == Invocation ==
> The basic code box invocation is as follows:
> <pre>
> {{code:LANGUAGE|option=value1|option=value2
> lines of code
> lines of code
> }}
> </pre>
> 
> !!Element!!Description!!
> ||<tt>:LANGUAGE</tt>||Specify the language parameter for the syntax-highlighting  If the wrong parameter is specified or if none is given, no highlighting will occur.||
> ||<tt>option=value</tt>||Specify option switches delimited by the '|' character.||
> ||<tt>lines of code</tt>||Have all of the code to be highlighted on their own lines; do not fold them into the same lines as the starting or ending pairs of braces.||
> 
> == Supported Syntaxes =
> Here are the supported languages that can be syntax-highlighted by the <nowiki>CodePress</nowiki> engine:
> !!Language!!parameter!!Description!!
> ||ASP||<tt>:asp</tt>||Microsoft Active Server Pages||
> ||C#||<tt>:csharp</tt>||Microsoft C#||
> ||Auto IT||<tt>:autoit</tt>||??||
> ||CSS||<tt>:css</tt>||Cascading Style Sheet||
> ||Generic||<tt>:generic</tt>||Specify this to highlight any syntax||
> ||HTML||<tt>:html</tt>||Hypertext Markup Language||
> ||Java||<tt>:java</tt>||Sun Java||
> ||<nowiki>JavaScript</nowiki>||<tt>:javascript</tt>||Sun <nowiki>JavaScript</nowiki>||
> ||perl||<tt>:perl</tt>||Practical Extraction and Reporting Language||
> ||PHP||<tt>:php</tt>||PHP||
> ||Ruby||<tt>:ruby</tt>||The Ruby Language||
> ||SQL||<tt>:sql</tt>||Standard Query Language||
> ||TXT||<tt>:text</tt>||Plain text.  This is the default; no syntax-highlighting occurs.||
> ||<nowiki>VBScript</nowiki>||<tt>:vbscript</tt>||Microsoft <nowiki>VBScript</nowiki>||
> ||XSL||<tt>:xsl</tt>||<nowiki>XML Style Sheets</nowiki>||
> 
> == Common Switches =
> Here are the option switches currently available:
> !!Switch!!Description!!
> ||<tt>height=NNN</tt>||Sets the height in pixels of the textarea displayed for the highlighted code.  The minimum height of 100 pixels tall is the default if this switch is not specified.||
> 
> == Simple Example =
> {{code
> print 'HELLO WORLD';
> }}
> 
> The above was created using this syntax:
> <pre>
> {{code
> print 'HELLO WORLD';
> }}
> </pre>
> 
> == Detailed Example =
> {{code:javascript|height=150
> self.toggleAutoComplete = function() {
> 	self.editor.autocomplete = (self.editor.autocomplete) ? false : true;
> }
> 
> self.toggleReadOnly = function() {
> 	self.textarea.readOnly = (self.textarea.readOnly) ? false : true;
> 	if(self.style.display != 'none') // prevent exception on FF + iframe with display:none
> 		self.editor.readOnly(self.textarea.readOnly ? true : false);
> }
> }}
> 
> The above was created using:
> <pre>
> {{code:javascript|height=150
> self.toggleAutoComplete = function() {
> 	self.editor.autocomplete = (self.editor.autocomplete) ? false : true;
> }
> 
> self.toggleReadOnly = function() {
> 	self.textarea.readOnly = (self.textarea.readOnly) ? false : true;
> 	if(self.style.display != 'none') // prevent exception on FF + iframe with display:none
> 		self.editor.readOnly(self.textarea.readOnly ? true : false);
> }
> }}
> </pre>
------
RelatedEntries/WikiEditing|1197121536
15a15
> WikiCodeBox
------
NobleWiki|1197187137
2c2
< <toc 170>
---
> <toc>
7c7
< === Features =
---
> == Features =
10c10
< !!Difference Things!!Description!!
---
> !!Difference&nbsp;Things!!Description!!
29c28,30
< !!Minor Things!!Description!!
---
> ||JSON Blocks|Very useful for providing data to various applets like the open-source Flash charting tool.||
> ||Code Boxes||If code needs to be shown - be it perl, <nowiki>JavaScript</nowiki>, CSS, or even HTML; use [WikiCodeBox Code Boxes].   These will show line-numbering and have syntax-highlighting.||
> ||index.cgi||The wiki.pl script has been renamed.||
42a43
> == Patches Applied =
65a66
> == Possible Patches =
95a96,97
> ||<tt><nowiki>{{whiteboard|shared}}</nowiki></tt>||Create sketches using Flash, and store the output as a bitmap on the server, and the curves as JSON elements.||
> 
------
SandBox|1197268927
1,5c1
< = TESTING =
< 
< {{code|height=100
< print 'HELLO WORLD';
< }}
---
> #MAGIC Discuss
------
SandBox|1197273329
0a1,2
> A lot of things go here.
> 
------
SandBox|1197273342
------
SandBox|1197273353
1,4d0
< A lot of things go here.
< 
< 
< 
5a4
> A lot of things go here.
------
SandBox|1197273412
4c4,23
< A lot of things go here.
---
> = Welcome =
> <blockquote>The goal of this Noble Pursuit Games wiki is to provide a common repository and access point for all structured datum gathered either from the forums, the blog, or elsewhere.  <cite>-- [LocalWiki:HomePage/RobertKurcina Robert Kurcina]</cite></blockquote>
> 
> == Topics ==
> These are the principal starting points of NobleWiki and the concept of the NoblePursuit.
> 
> !!Item!!Description!!
> ||NobleMission|class=first||What to see and expect from this wiki, and how to contribute||
> ||CategoryCategory||List the principal categories of entries that this wiki plans to support.||
> ||WikiHelp||Help on how to create new pages for this wiki||
> ||SandBox||A playground for messing with the wiki entries for n00bs||
> ||ListOfWantedPages||These are stubbed pages yet to be created||
> 
> == Related Entries =
>  GRoWWII
>  [http://blogs.kurcina.org/cgi-bin/blosxom.cgi Noble Pursuit Games Blog]
>  [http://forums.kurcina.org/cgi-bin/groww2/index.cgi Giant Robots of World War II Forums]
> 
>  #SUBPAGES
> 
------
SandBox|1197273454
7,23d7
< == Topics ==
< These are the principal starting points of NobleWiki and the concept of the NoblePursuit.
< 
< !!Item!!Description!!
< ||NobleMission|class=first||What to see and expect from this wiki, and how to contribute||
< ||CategoryCategory||List the principal categories of entries that this wiki plans to support.||
< ||WikiHelp||Help on how to create new pages for this wiki||
< ||SandBox||A playground for messing with the wiki entries for n00bs||
< ||ListOfWantedPages||These are stubbed pages yet to be created||
< 
< == Related Entries =
<  GRoWWII
<  [http://blogs.kurcina.org/cgi-bin/blosxom.cgi Noble Pursuit Games Blog]
<  [http://forums.kurcina.org/cgi-bin/groww2/index.cgi Giant Robots of World War II Forums]
< 
<  #SUBPAGES
< 
------
SandBox|1197274085
3a2,3
> #MAGIC Flash name=FlashSWF/diceland.swf height=300 width=200
> 
------
SandBox|1197274095
------
SandBox|1197274105
3,4d2
< #MAGIC Flash name=FlashSWF/diceland.swf height=300 width=200
< 
------
SandBox|1197274142
3,6d1
< = Welcome =
< <blockquote>The goal of this Noble Pursuit Games wiki is to provide a common repository and access point for all structured datum gathered either from the forums, the blog, or elsewhere.  <cite>-- [LocalWiki:HomePage/RobertKurcina Robert Kurcina]</cite></blockquote>
< 
< 
------
HomePage/RobertKurcina|1197304612
0a1,3
> #MAGIC Discuss
> 
> 
------
HomePage/RobertKurcina|1197304628
1,3d0
< #MAGIC Discuss
< 
< 
------
HomePage/RobertKurcina|1197304707
0a1,3
> #MAGIC Discuss
> 
> 
------
RelatedEntries/WikiEditing|1197335864
------
SandBox|1197358188
------
SandBox|1197363264
1c1
< #MAGIC Discuss
---
> #MAGIC Discuss locked=true
------
SandBox|1197363522
1a3
> ~~~~~
------
SandBox|1197363534
3c3
< ~~~~~
---
> ~~~~
------
SandBox|1197363549
3c3,5
< ~~~~
---
> == True =
> 
> 
------
SandBox|1197363559
5a5,7
> ~~~~~
> 
> 
------
SandBox|1197363567
5c5
< ~~~~~
---
> ~~~~
------
SandBox|1197363578
3,7d1
< == True =
< 
< ~~~~
< 
< 
------
NobleWiki|1197363740
42a42,43
> ||Discuss Page||This is a work-in-progress.  Essentially add <tt><nowiki>#MAGIC Discuss</nowiki></tt> in order to activate discussion form and feedback set for a page.  Deactivate form but leave feedback in place by adding parameter locked=true.||
> 
------
SandBox|1197363792
1c1
< #MAGIC Discuss locked=true
---
> #MAGIC Discuss
------
HomePage|1197478143
0a1,2
> #MAGIC Discuss
> 
------
HomePage|1197478189
1,2d0
< #MAGIC Discuss
< 
------
SandBox|1197610185
1c1
< #MAGIC Discuss
---
> #MAGIC:solo Discuss
------
SandBox|1197610198
1c1
< #MAGIC:solo Discuss
---
> #MAGIC Discuss solo
------
SandBox|1197610212
1a3
> News news news
------
SandBox|1197610218
3d1
< News news news
------
WikiMinimums|1197612126
11c11
< **[MagicContent MagicContent.pm]
---
> **MagicContent
41a42
> **MagicContent
------
WikiMinimums|1197612163
11d10
< **MagicContent
------
MagicContent|1197612231
1c1,9
< ====== Describe the new page here. =
---
> = Magic Content Pages = 
> These type of pages have a special directive added to it that will be processed by the wiki engine to create unique content derived from one or more external modules.  For example, the ListOfWantedPages is essentially a blank page except for a single magic content directive.
> <toc>
> == Syntax =
> The way to invoke a magic content command is to specify somewhere in the page the following pattern:
> 
> <pre>
> #MAGIC command @position
> </pre>
------
MagicContent|1197612247
8c8
< #MAGIC command @position
---
> #MAGIC discuss
------
SandBox|1197612317
1a2
> #MAGIC Discuss solo
------
SandBox|1197612350
2c2
< #MAGIC Discuss solo
---
> #MAGIC WantedPages threshold=0
------
SandBox|1197612361
1d0
< #MAGIC Discuss solo
2a2
> #MAGIC Discuss solo
------
SandBox|1197612376
1,2c1,2
< #MAGIC WantedPages threshold=0
< #MAGIC Discuss solo
---
> #MAGIC Discuss @top
> asdf asdfa asdf
------
SandBox|1197612385
1c1
< #MAGIC Discuss @top
---
> #MAGIC @top Discuss
------
SandBox|1197612404
1,2c1,5
< #MAGIC @top Discuss
< asdf asdfa asdf
---
> #MAGIC @solo Discuss
> asdf
> asdf
> asdf
> asdf
------
SandBox|1197612417
2,5d1
< asdf
< asdf
< asdf
< asdf
------
SandBox|1197613356
1c1,5
< #MAGIC @solo Discuss
---
> aasdf asdf 
> 
> #MAGIC @insert Discuss
> 
> 1234 12341 234 
------
SandBox|1197613363
3c3
< #MAGIC @insert Discuss
---
>  #MAGIC @insert Discuss
------
SandBox|1197613370
1c1
< aasdf asdf 
---
> 
------
SandBox|1197613375
0a1,3
> #MAGIC @insert Discuss
> 
> 1234 12341 234 
3,6d4
<  #MAGIC @insert Discuss
< 
< 1234 12341 234 
< 
------
SandBox|1197613427
1,3c1
< #MAGIC @insert Discuss
< 
< 1234 12341 234 
---
> #MAGIC @check Discuss
------
MagicCommands|1197613561
1c1
< ====== Describe the new page here. =
---
> #MAGIC @solo ListCommands
------
WikiMinimums|1197613625
17a18,20
> **MagicContent
> **MagicCommands
> **MagicFlash
41d43
< **MagicContent
------
MagicAll|1197614607
1c1
< ====== Describe the new page here. =
---
> #MAGIC AllPages
------
MagicAll|1197614626
1c1
< #MAGIC AllPages
---
> #MAGIC AllPages list=ol
------
HomePage|1197614883
0a1
> #MAGIC Category
------
HomePage|1197614931
1c1
< #MAGIC Category
---
> #MAGIC Category thispage=Home
------
HomePage|1197614979
1c1
< #MAGIC Category thispage=Home
---
> #MAGIC Category thispage=Wiki
------
HomePage|1197614989
1c1
< #MAGIC Category thispage=Wiki
---
> #MAGIC Category thispage=WikiFlash
------
HomePage|1197614998
1d0
< #MAGIC Category thispage=WikiFlash
------
MagicContent|1197615296
4c4
< == Syntax =
---
> == Syntax and Invocation =
8c8
< #MAGIC discuss
---
> #MAGIC [@position] command [key=value key=value ...]
10a11,42
> An example specification that will invoke the <tt><nowiki>AllPages</nowiki></tt> command and place a list of pages above the wiki page's content.  The key/value pair <tt>list=ol</tt> informs the command to show the list as a numbered ordered list.
> 
> <pre>
> #MAGIC @top AllPages list=ol
> </pre>
> 
> The wiki engine will not display the magic content during a preview request while editing a page.  Magic content will display only after a page has been saved.
> 
> == Single Process Request =
> The <tt>#MAGIC</tt> directive may appear only once and as the first line of a wiki page. Only the first directive is processed; all of the others are ignored.  
> 
> == Position Attribute =
> The @position attribute is optional and by default is interpreted to be <tt>'bottom'</tt>.
> 
> !!Position!!Effect!!
> ||bottom||This is the default.  The magic content created will appear <i>after</i> any wiki content in the page.||
> ||top||This will position the magic content <i>before</i> any wiki content in the page.||
> ||solo||Any wiki content in the page will become suppressed; it will not display. ||
> ||check||The wiki engine will look for a querystring parameter <tt>'magic'</tt> and use that value for the value of the position attribute's value.||
> 
> == Command Attribute =
> This must be specified, and it must be one of the values as shown in the MagicCommands page.
> 
> !!Command!!Parameters!!Content Generated!!
> ||<tt><nowiki>Foobar</nowiki></tt>||none||Does nothing.  This is a place-holder to assist wiki developers to create their own commands.  Such development is done at the wiki engine level using perl.||
> ||<tt><nowiki>Discuss</nowiki></tt>||threaded=Y, numbered=Y, thumbs=Y, locked=Y||Inserts a feedback/comments interface.  Assigning a value to any of the parameters, as in <tt>threaded=Y</tt> will activate that option.  See MagicDiscussion for more information.||
> ||<tt><nowiki>Flash</nowiki></tt>||name=XXXX, height=NNN, width=NNN||Will create MagicFlash content by pulling an asset from the [WikiUploads uploads] directory.||
> ||<tt><nowiki>Params</nowiki></tt>||key=value||This is a simple command that merely echoes the key=value pairs that are entered.  Useful for development.||
> ||<tt><nowiki>ListCommands</nowiki></tt>||none||As can be seen at MagicCommands, this command lists all available magic content commands by name.||
> ||<tt><nowiki>AllPages</nowiki></tt>||none||This is a cleaner version of the index search, and of the [LocalWiki:action=links All Links] request.  See MagicAll for an ordered-list implementation of this command.||
> ||<tt><nowiki>Category</nowiki></tt>||thispage=XXX||Not sure.  The original developer [UseMod::tarquin tarquin] writes <tt>...returns the search results for the browsed page title.</tt>.||
> ||<tt><nowiki>WantedPages</nowiki></tt>||none||The ListOfWantedPages demonstrates this command.  It is a list of all pages that have been created as links but do not yet have wiki pages.||
------
MagicWanted|1197615377
1c1
< ====== Describe the new page here. =
---
> #REDIRECT ListOfWantedPages
------
WikiMinimums|1197615443
18c18,19
< **MagicContent
---
> **ListOfWantedPages
> **MagicAll
20c21,22
< **MagicFlash
---
> **MagicContent
> **MagicFlash 
------
MagicContent|1197615527
42c42
< ||<tt><nowiki>WantedPages</nowiki></tt>||none||The ListOfWantedPages demonstrates this command.  It is a list of all pages that have been created as links but do not yet have wiki pages.||
---
> ||<tt><nowiki>WantedPages</nowiki></tt>||none||The ListOfWantedPages, which is a redirect from MagicWanted, demonstrates this command.  It is a list of all pages that have been created as links but do not yet have wiki pages.||
------
MagicContent|1197615593
41c41
< ||<tt><nowiki>Category</nowiki></tt>||thispage=XXX||Not sure.  The original developer [UseMod::tarquin tarquin] writes <tt>...returns the search results for the browsed page title.</tt>.||
---
> ||<tt><nowiki>Category</nowiki></tt>||thispage=XXX||Not sure.  The original developer [UseMod:tarquin tarquin] writes <tt>...returns the search results for the browsed page title.</tt>.||
------
SandBox|1197615665
1a2,12
> asdf
> asd
> asd
> fasd
> fasd
> fasd
> fasdf
> asdf
> asdf
> asdf
> asdf
------
HomePage|1197615820
19a20
> [[Category:Nova]]
------
WikiUploads|1197615831
51a52
> [[Category:Nova]]
------
SandBox|1197615866
1,12c1
< #MAGIC @check Discuss
< asdf
< asd
< asd
< fasd
< fasd
< fasd
< fasdf
< asdf
< asdf
< asdf
< asdf
---
> #MAGIC Category thispage=Category:Nova
------
SandBox|1197615983
1c1
< #MAGIC Category thispage=Category:Nova
---
> #MAGIC Category
------
SandBox|1197616072
1c1,2
< #MAGIC Category
---
> #MAGIC @check Discuss
> 
------
WikiFlash|1197616786
7c7
< {{flash:name=FlashSWF/diceland.swf|width=400|height=300}}
---
> {{flash:name=diceland.swf|width=400|height=300}}
12c12
< {{flash:name=FlashSWF/diceland.swf|width=400|height=300}}
---
> {{flash:name=diceland.swf|width=400|height=300}}
27c27
<   #MAGIC Flash name=FlashSWF/diceland.swf height=300 width=200
---
>   #MAGIC Flash name=diceland.swf height=300 width=200
------
WikiFlash|1197616919
7c7
< {{flash:name=diceland.swf|width=400|height=300}}
---
> {{flash:name=FlashSWF/diceland.swf|width=400|height=300}}
12c12
< {{flash:name=diceland.swf|width=400|height=300}}
---
> {{flash:name=FlashSWF/diceland.swf|width=400|height=300}}
27c27
<   #MAGIC Flash name=diceland.swf height=300 width=200
---
>   #MAGIC Flash name=FlashSWF/diceland.swf height=300 width=200
------
SandBox|1197617607
1c1
< #MAGIC @check Discuss
---
> #MAGIC @check Discuss locked=y
------
SandBox|1197617883
1c1
< #MAGIC @check Discuss locked=y
---
> #MAGIC @check Discuss locked=y numbered=y
------
SandBox|1197617902
1c1
< #MAGIC @check Discuss locked=y numbered=y
---
> #MAGIC @check Discuss numbered=y
------
SandBox|1197617927
1,2c1
< #MAGIC @check Discuss numbered=y
< 
---
> #MAGIC @check Discuss
------
SandBox|1197617943
1c1
< #MAGIC @check Discuss
---
> #MAGIC @check Discuss thumbs=Y|numbered=Y
------
SandBox|1197618029
1c1
< #MAGIC @check Discuss thumbs=Y|numbered=Y
---
> #MAGIC @check Discuss numbered=Y
------
BulletinBoardCode|1197620068
1,2c1,43
< ====== Describe the new page here. =
< 
---
> = Bulletin Board Code =
> This is a microformat for quick creation of text using simplified markup syntax.  BBCode is named as such because it is a feature for Bulletin Board applications like phpBB and eBlah.  Within the NobleWiki wiki engine, BBCode is available via the MagicBlog directive, the MagicDiscussion directive, and via the <tt><nowiki>{{bbcode:}}</nowiki></tt> command.  The BBCode features in NobleWiki is lazily implemented; for example the <tt>[list][/list]</tt> command allows nesting a mere three-layers deep.
> 
> <toc>
> 
> == Syntax for Safe Parsing =
> The goal of BBCode is to present a relatively easy way of marking up user input that is also easy to parse.  Here's an example of how BBCode is used, via the <tt><nowiki>{{bbcode::}}</nowiki></tt> command:
> 
> Type this:
> <pre>
> {{bbcode:
> [list]
> [*] [email=x@x.com]item 1 is an e-mail link[/email]
> [*] [u]item 2 is underlined[/u]
> [*] [i]item 3 is italicized[/i]
> [*] [b]item 4 is bold[/b]
> [*] [url=www.yahoo.com]item 5 links to www.yahoo.com[/url]
> [/list]
> }}
> </pre>
> 
> To get this:
> {{bbcode:
> [list]
> [*] [email=x@x.com]item 1 is an e-mail link[/email]
> [*] [u]item 2 is underlined[/u]
> [*] [i]item 3 is italicized[/i]
> [*] [b]item 4 is bold[/b]
> [*] [url=www.yahoo.com]item 5 links to www.yahoo.com[/url]
> [/list]
> }}
> == BBCode Tags =
>   The list of tags available are as follows:
> 
> !!Tag!!Effect Generated!!
> ||<tt>[code]text[/code]</tt>||Creates a padded code-block for presenting monospaced text.  Excellent for showing programming language syntax.||
> ||<tt>[b]text[/b]</tt>||The wrapped text will become bold.||
> ||<tt>[i]text[/i]</tt>||The wrapped text will become italicized.||
> ||<tt>[u]text[/u]</tt>||The wrapped text will become underlined.||
> ||<tt>[email]text[/email]</tt>||The wrapped text becomes an email hyperlink with a URL being that of the wrapped text.||
> ||<tt>[email=uri]text[/email]</tt>||The wrapped text becomes an email hyperlink with a URL of the uri provided.||
> ||<tt>[url]text[/url]]</tt>||The wrapped text becomes a hyperlink with a URL being that of the wrapped text.||
> ||<tt>[url=uri]text[/url]</tt>||The wrapped text becomes a hyperlink with a URL of the uri provided.||
------
WikiMinimums|1197620152
9a10
> **BulletinBoardCode
19a21,22
> **MagicBlog
> **MagicDiscussion
------
WikiMinimums|1197620217
54a55
> ***img/screenshots/*
------
MagicContent|1197652518
2c2
< These type of pages have a special directive added to it that will be processed by the wiki engine to create unique content derived from one or more external modules.  For example, the ListOfWantedPages is essentially a blank page except for a single magic content directive.
---
> These type of pages have a special directive added to it that will be processed by the wiki engine to create unique content derived from one or more external modules.  For example, the ListOfWantedPages is essentially a blank page except for a single magic content directive.  Magic content can of also share a page with normal wiki content, as can be seen in the MagicDiscussion and MagicCalendar commands.
5c5
< The way to invoke a magic content command is to specify somewhere in the page the following pattern:
---
> The way to invoke a magic content command is to specify at the very top of the page the following pattern:
------
MagicContent|1197652570
41d40
< ||<tt><nowiki>Category</nowiki></tt>||thispage=XXX||Not sure.  The original developer [UseMod:tarquin tarquin] writes <tt>...returns the search results for the browsed page title.</tt>.||
------
BulletinBoardCode|1197687280
36a37,38
> ||<tt>text</tt>||The text entered will be shown with all extra white-space like line-spaces removed.||
> ||<tt>[br]text</tt>||Adds a line break before the text entered.||
39a42,45
> ||<tt>[img]text[/img]</tt>||The wrapped text will become replaced by the image it points to.||
> ||<tt>[img=url]text[/img]</tt>||The wrapped text will become replaced by the image it points to.  The text itself becomes the tooltip.||
> ||<tt>[upload]text[/upload]</tt>||The wrapped text will become replaced by the asset it points to. See WikiUploads for a list of available assets.||
> ||<tt>[upload=url]text[/upload]</tt>||The wrapped text will become replaced by the asset it points to.  The text itself becomes the tooltip.  See WikiUploads for a list of available assets.||
43a50,56
> ||<tt>[list]text[*]item[/list]</tt>||Creates a bulleted list with each list item on a separate line.||
> ||<tt>[list=1]text[*]item[/list]</tt>||Creates an ordered list using numbers with each list item on a separate line.||
> ||<tt>[list=a]text[*]item[/list]</tt>||Creates an ordered list using lower-case letters with each list item on a separate line.||
> ||<tt>[list=A]text[*]item[/list]</tt>||Creates an ordered list using upper-case letters with each list item on a separate line.||
> ||<tt>[quote]text[/quote]</tt>||The wrapped text is set within a padded and bordered box with a slight offset.  The title of the box will show the word <tt>quote:</tt>||
> ||<tt>[quote=author]text[/quote]</tt>||The wrapped text is set within a padded and bordered box with a slight offset.  The title of the box will show <tt>author said:</tt>||
> ||<tt>[code]text[/code]</tt>||The wrapped text becomes monospaced and will be set within a padded and bordered box with a slight offset.  Any BBCode wrapped by these tags will not be processed through the parser and instead remain as code.</tt>||
------
BulletinBoardCode|1197688900
36d35
< ||<tt>[code]text[/code]</tt>||Creates a padded code-block for presenting monospaced text.  Excellent for showing programming language syntax.||
38c37
< ||<tt>[br]text</tt>||Adds a line break before the text entered.||
---
> ||<tt>[br]</tt>||Adds a line break||
------
MagicDiscussion|1197689485
1c1,2
< ====== Describe the new page here. =
---
> = Magic Feedback =
> By adding <tt>#MAGIC</tt> Discuss to a wiki page, it will add a feedback form that can be filled out by any user that has logged in with a userID.
------
MagicDiscussion|1197689506
2c2
< By adding <tt>#MAGIC</tt> Discuss to a wiki page, it will add a feedback form that can be filled out by any user that has logged in with a userID.
---
> By adding the MagicCommand <tt>#MAGIC Discuss</tt> to a wiki page, it will add a feedback form that can be filled out by any user that has logged in with a userID.
------
MagicDiscussion|1197689545
2c2
< By adding the MagicCommand <tt>#MAGIC Discuss</tt> to a wiki page, it will add a feedback form that can be filled out by any user that has logged in with a userID.
---
> By adding the MagicContent command <tt>#MAGIC Discuss</tt> to a wiki page, it will add a feedback form that can be filled out by any user that has logged in with a userID.
------
SandBox|1197692033
1c1
< #MAGIC @check Discuss numbered=Y
---
> #MAGIC @check Fred numbered=Y
------
SandBox|1197692041
1c1
< #MAGIC @check Fred numbered=Y
---
> #MAGIC Fred numbered=Y
------
SandBox|1197692062
1c1
< #MAGIC Fred numbered=Y
---
> #MAGIC @check Discuss numbered=Y
------
SandBox|1197692782
1a3,8
> sadf
> asdf
> asdf
> asdf
> asdf
> asdf
------
SandBox|1197702899
1,8c1
< #MAGIC @check Discuss numbered=Y
< 
< sadf
< asdf
< asdf
< asdf
< asdf
< asdf
---
> == Add your content here =
------
SandBox|1197702912
------
HomePage|1197702941
0a1
> #MAGIC @check Discuss numbered=Y
20d20
< [[Category:Nova]]
------
Category_Tone|1197706156
2a3
> Done.
------
NobleWiki|1197706525
43a43,44
> ||Expanded <tt><nowiki>$SimpleLinks</nowiki></tt>||Links like <tt><nowiki>Setup_Box</nowiki></tt> and <tt><nowiki>SetUp_box</nowiki></tt> are allowed.  Both will create bracketed links but not show the underscore character.||
> 
------
InterMap|1197707754
3a4
> !!Prefix!!Base URI!!Description!!
------
MagicDiscussion|1197781695
1,3c1,2
< = Magic Feedback =
< By adding the MagicContent command <tt>#MAGIC Discuss</tt> to a wiki page, it will add a feedback form that can be filled out by any user that has logged in with a userID.
< 
---
> = Magic Discussions =
> By adding the MagicContent command <tt>#MAGIC Discuss</tt> to a wiki page, a feedback form will appear that can be filled out by any user that has logged in with a userID.  Any feedback that has been received will be written into the filesystem under <tt><nowiki>$DiscussDir</nowiki></tt>.  The feedback form can be locked by either setting the <tt>locked=Y</tt> option for the command.
------
MagicDiscussion|1197781705
------
GRoWWII|1197782038
35,37c35
< == Related =
<  /WorldHistory
<  /RulesFAQ
---
> == Related Entries =
39,40d36
<  /Mutators
<  /TOandE
42a40
>  #SUBPAGES
------
PrivateUserGroups|1197782475
3c3
< Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like {e:UserName} or {r:UserName} to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an Authorization Error page [ AuthError ]
---
> Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName}</tt></nowiki> or <tt><nowiki>{r:UserName}</tt></nowiki> to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an Authorization Error page [ AuthError ]
------
PrivateUserGroups|1197782502
3c3
< Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName}</tt></nowiki> or <tt><nowiki>{r:UserName}</tt></nowiki> to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an Authorization Error page [ AuthError ]
---
> Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName}</nowiki></tt> or <tt><nowiki>{r:UserName}</nowiki></tt> to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an Authorization Error page [ AuthError ]
------
PrivateUserGroups|1197782556
3c3
< Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName}</nowiki></tt> or <tt><nowiki>{r:UserName}</nowiki></tt> to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an Authorization Error page [ AuthError ]
---
> Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName}</nowiki></tt> or <tt><nowiki>{r:UserName}</nowiki></tt> to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an [AuthError Authorization Error] page 
------
NobleWiki|1197783382
28c28
< ||JSON Blocks|Very useful for providing data to various applets like the open-source Flash charting tool.||
---
> ||JSON Blocks||Very useful for providing data to various applets like the open-source Flash charting tool.||
------
GameDesignsInProgress|1215667569
30a31
>  Swashbuckling
------
GameDesignsInProgress|1215667616
31c31
<  Swashbuckling
---
>  [[Swashbuckling]]
------
WikiDiscuss|1215704874
1c1,10
< ====== Describe the new page here. =
---
> == Wiki Features Suggestions =
> 
> Add the features to be discussed here.  Do not add a [[MagicContent | Discuss Page ]] element to this page.
> 
> === Discuss Page =
> * Provide a mechanism to group discussions into a forums-like list.
> * Provide a mechanism to group discussions by author
> * Have discussions be tracked by [[RecentChanges]]
> 
> 
------
GameDesignsInProgress|1215750308
31c31
<  [[Swashbuckling]]
---
>  SwashBuckling
------
SwashBuckling|1215750837
1,2c1,10
< ====== Describe the new page here. =
< 
---
> = Swashbuckling =
> Swashbuckling is a battle between two or more cavalier medieval weapon masters of extra-ordinary ability, dueling out to the death upon terrifying precipices or at the edges of a ruined fortress' battlements. Or not; the fighters are after-all refined in the courtesy and mannerisms as well, and so perhaps the duels might end with just a slight cut and a nod.
> 
> The introductory game provides the core rules of play and can be resolved in 15-30 minutes.  The intermediate game introduces to the players the use of characters as well as the use of the ace cards.  The standard game provides for more options in play to prepare the gamers for the advanced game.  It is with this final section of rules the game introduces character customization, battlefield customization, and mission-oriented adventures.
> 
> == Theme and Setting =
> The core game mechanic is card-driven combat using 2D maps to track unit position.  The play of the game is through the conventions of a stylized poker game using decorative cards and poker chips.  The setting will initially be 16th Century Medieval Europe, but in planning is the introduction of other cultures.  Each game set should represent a pair of opposing crews of fighters; each able to hold ground against any other duelist.  
> 
> == Para-time Universe =
> The game will expand to use the Morfiuthelas and other conventions found in the Role-playing game setting of Mai Appollonia Yo!  Specifically there will be introduction of magic, anachronistic devices, and doppelgangers.
------
HomePage/RobertKurcina|1218003117
1,3d0
< #MAGIC Discuss
< 
< 
------
NobleWiki|1218035818
5c5
< This wiki for Noble Pursuit Games is derived from the freely available [Wiki:UseModWIki UseMod 1.03] wiki engine available as the Wiki:UseModWiki site.
---
> This wiki for Noble Pursuit Games is derived from the freely available [Wiki:UseModWIki UseMod 1.03] wiki engine available as the Wiki:UseModWiki site.  The base install of the NobleWiki engine includes everything listed within the [WikiMinimums StarterPages].
102a103
>  WikiMinimums
------
MagicContent|1218036078
2c2
< These type of pages have a special directive added to it that will be processed by the wiki engine to create unique content derived from one or more external modules.  For example, the ListOfWantedPages is essentially a blank page except for a single magic content directive.  Magic content can of also share a page with normal wiki content, as can be seen in the MagicDiscussion and MagicCalendar commands.
---
> These type of pages have a special directive added to it that will be processed by the wiki engine to create unique content derived from one or more external modules.  For example, the ListOfWantedPages is essentially a blank page except for a single magic content directive.  Magic content can of also be placed within normal wiki content, as can be seen in the MagicDiscussion and MagicCalendar commands.
------
MagicContent|1218036112
2c2
< These type of pages have a special directive added to it that will be processed by the wiki engine to create unique content derived from one or more external modules.  For example, the ListOfWantedPages is essentially a blank page except for a single magic content directive.  Magic content can of also be placed within normal wiki content, as can be seen in the MagicDiscussion and MagicCalendar commands.
---
> These type of pages have a special directive added to it that will be processed by the wiki engine to create unique content derived from one or more external modules.  For example, the ListOfWantedPages is essentially a blank page except for a single magic content directive.  Magic content can also be placed within normal wiki content, as can be seen in the MagicDiscussion and MagicCalendar commands.
------
WikiMinimums|1218094007
79c79
< ***css/jquery.lightbox-0.4.css
---
> ***css/jquery.lightbox.css
86,87c86,87
< ***js/jquery-1.2.1.js
< ***js/jquery.lightbox-0.4.js
---
> ***js/jquery.js
> ***js/jquery.lightbox.js
------
SandBox|1218122222
1,2c1,5174
< == Add your content here =
< 
---
> #!perl
> # UseModWiki version 1.0.4 (December 1, 2007)
> # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
> # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
> # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
> #    <marcus@ira.uka.de>
> # ...which was based on
> #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
> #    and The Original WikiWikiWeb  (C) Ward Cunningham
> #        <ward@c2.com> (code reused with permission)
> # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
> #
> # This program is free software; you can redistribute it and/or modify
> # it under the terms of the GNU General Public License as published by
> # the Free Software Foundation; either version 2 of the License, or
> # (at your option) any later version.
> #
> # This program is distributed in the hope that it will be useful,
> # but WITHOUT ANY WARRANTY; without even the implied warranty of
> # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> # GNU General Public License for more details.
> #
> # You should have received a copy of the GNU General Public License
> # along with this program; if not, write to the
> #    Free Software Foundation, Inc.
> #    59 Temple Place, Suite 330
> #    Boston, MA 02111-1307 USA
> 
> package UseModWiki;
> use strict;
> local $| = 1;  # Do not buffer output (localized for mod_perl)
> 
> # Configuration/constant variables:
> use vars qw(@RcDays @HtmlPairs @HtmlSingle
>   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
>   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
>   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
>   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
>   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
>   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
>   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
>   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
>   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
>   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
>   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
>   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
>   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
>   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
>   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
>   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
>   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
>   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine 
>   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
>   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
>   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton 
>   $EditNameLink $UseMetaWiki @ImageSites $BracketImg );
> # Note: $NotifyDefault is kept because it was a config variable in 0.90
> # Other global variables:
> use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
>   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
>   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
>   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
>   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
>   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
>   $ConfigError $UploadPattern );
> 
> # == Configuration =====================================================
> $DataDir     = "C:/wikidb"; # Main wiki directory
> $UseConfig   = 1;       # 1 = use config file,    0 = do not look for config
> $ConfigFile  = "$DataDir/config";   # Configuration file
> 
> # Default configuration (used if UseConfig is 0)
> $CookieName  = "Wiki";          # Name for this wiki (for multi-wiki sites)
> $SiteName    = "Wiki";          # Name of site (used for titles)
> $HomePage    = "HomePage";      # Home page (change space to _)
> $RCName      = "RecentChanges"; # Name of changes page (change space to _)
> $LogoUrl     = "/wiki.gif";     # URL for site logo ("" for no logo)
> $ENV{PATH}   = "/usr/bin/";     # Path used to find "diff"
> $ScriptTZ    = "";              # Local time zone ("" means do not print)
> $RcDefault   = 30;              # Default number of RecentChanges days
> @RcDays      = qw(1 3 7 30 90); # Days for links on RecentChanges
> $KeepDays    = 14;              # Days to keep old revisions
> $SiteBase    = "";              # Full URL for <BASE> header
> $FullUrl     = "";              # Set if the auto-detected URL is wrong
> $RedirType   = 1;               # 1 = CGI.pm, 2 = script, 3 = no redirect
> $AdminPass   = "";              # Set to non-blank to enable password(s)
> $EditPass    = "";              # Like AdminPass, but for editing only
> $StyleSheet  = "";              # URL for CSS stylesheet (like "/wiki.css")
> $NotFoundPg  = "";              # Page for not-found links ("" for blank pg)
> $EmailFrom   = "Wiki";          # Text for "From: " field of email notes.
> $SendMail    = "/usr/sbin/sendmail";  # Full path to sendmail executable
> $FooterNote  = "";              # HTML for bottom of every page
> $EditNote    = "";              # HTML notice above buttons on edit page
> $MaxPost     = 1024 * 210;      # Maximum 210K posts (about 200K for pages)
> $NewText     = "";              # New page text ("" for default message)
> $HttpCharset = "";              # Charset for pages, like "iso-8859-2"
> $UserGotoBar = "";              # HTML added to end of goto bar
> $InterWikiMoniker = '';         # InterWiki moniker for this wiki. (for RSS)
> $SiteDescription  = $SiteName;  # Description of this wiki. (for RSS)
> $RssLogoUrl  = '';              # Optional image for RSS feed
> $EarlyRules  = '';              # Local syntax rules for wiki->html (evaled)
> $LateRules   = '';              # Local syntax rules for wiki->html (evaled)
> $KeepSize    = 0;               # If non-zero, maximum size of keep file
> $BGColor     = 'white';         # Background color ('' to disable)
> $DiffColor1  = '#ffffaf';       # Background color of old/deleted text
> $DiffColor2  = '#cfffcf';       # Background color of new/added text
> $FavIcon     = '';              # URL of bookmark/favorites icon, or ''
> $RssDays     = 7;               # Default number of days in RSS feed
> $UserHeader  = '';              # Optional HTML header additional content
> $UserBody    = '';              # Optional <BODY> tag additional content
> $StartUID    = 1001;            # Starting number for user IDs
> $UploadDir   = '';              # Full path (like /foo/www/uploads) for files
> $UploadUrl   = '';              # Full URL (like http://foo.com/uploads)
> @ImageSites  = qw();            # Url prefixes of good image sites: ()=all
> 
> # Major options:
> $UseSubpage  = 1;           # 1 = use subpages,       0 = do not use subpages
> $UseCache    = 0;           # 1 = cache HTML pages,   0 = generate every page
> $EditAllowed = 1;           # 1 = editing allowed,    0 = read-only
> $RawHtml     = 0;           # 1 = allow <HTML> tag,   0 = no raw HTML in pages
> $HtmlTags    = 0;           # 1 = "unsafe" HTML tags, 0 = only minimal tags
> $UseDiff     = 0;           # 1 = use diff features,  0 = do not use diff
> $FreeLinks   = 1;           # 1 = use [[word]] links, 0 = LinkPattern only
> $WikiLinks   = 1;           # 1 = use LinkPattern,    0 = use [[word]] only
> $AdminDelete = 1;           # 1 = Admin only deletes, 0 = Editor can delete
> $RunCGI      = 1;           # 1 = Run script as CGI,  0 = Load but do not run
> $EmailNotify = 0;           # 1 = use email notices,  0 = no email on changes
> $EmbedWiki   = 0;           # 1 = no headers/footers, 0 = normal wiki pages
> $DeletedPage = 'DeletedPage';   # 0 = disable, 'PageName' = tag to delete page
> $ReplaceFile = 'ReplaceFile';   # 0 = disable, 'PageName' = indicator tag
> @ReplaceableFiles = ();     # List of allowed server files to replace
> $TableSyntax = 1;           # 1 = wiki syntax tables, 0 = no table syntax
> $NewFS       = 0;           # 1 = new multibyte $FS,  0 = old $FS
> $UseUpload   = 0;           # 1 = allow uploads,      0 = no uploads
> 
> # Minor options:
> $LogoLeft     = 0;      # 1 = logo on left,       0 = logo on right
> $RecentTop    = 1;      # 1 = recent on top,      0 = recent on bottom
> $UseDiffLog   = 1;      # 1 = save diffs to log,  0 = do not save diffs
> $KeepMajor    = 1;      # 1 = keep major rev,     0 = expire all revisions
> $KeepAuthor   = 1;      # 1 = keep author rev,    0 = expire all revisions
> $ShowEdits    = 0;      # 1 = show minor edits,   0 = hide edits by default
> $HtmlLinks    = 0;      # 1 = allow A HREF links, 0 = no raw HTML links
> $SimpleLinks  = 0;      # 1 = only letters,       0 = allow _ and numbers
> $NonEnglish   = 0;      # 1 = extra link chars,   0 = only A-Za-z chars
> $ThinLine     = 0;      # 1 = fancy <hr> tags,    0 = classic wiki <hr>
> $BracketText  = 1;      # 1 = allow [URL text],   0 = no link descriptions
> $UseAmPm      = 1;      # 1 = use am/pm in times, 0 = use 24-hour times
> $UseIndex     = 0;      # 1 = use index file,     0 = slow/reliable method
> $UseHeadings  = 1;      # 1 = allow = h1 text =,  0 = no header formatting
> $NetworkFile  = 1;      # 1 = allow remote file:, 0 = no file:// links
> $BracketWiki  = 0;      # 1 = [WikiLnk txt] link, 0 = no local descriptions
> $UseLookup    = 1;      # 1 = lookup host names,  0 = skip lookup (IP only)
> $FreeUpper    = 1;      # 1 = force upper case,   0 = do not force case
> $FastGlob     = 1;      # 1 = new faster code,    0 = old compatible code
> $MetaKeywords = 1;      # 1 = Google-friendly,    0 = search-engine averse
> $NamedAnchors = 1;      # 0 = no anchors, 1 = enable anchors,
>                         # 2 = enable but suppress display
> $SlashLinks   = 0;      # 1 = use script/action links, 0 = script?action
> $UpperFirst   = 1;      # 1 = free links start uppercase, 0 = no ucfirst
> $AdminBar     = 1;      # 1 = admins see admin links, 0 = no admin bar
> $RepInterMap  = 0;      # 1 = intermap is replacable, 0 = not replacable
> $ConfirmDel   = 1;      # 1 = delete link confirm page, 0 = immediate delete
> $MaskHosts    = 0;      # 1 = mask hosts/IPs,      0 = no masking
> $LockCrash    = 0;      # 1 = crash if lock stuck, 0 = auto clear locks
> $HistoryEdit  = 0;      # 1 = edit links on history page, 0 = no edit links
> $OldThinLine  = 0;      # 1 = old ==== thick line, 0 = ------ for thick line
> $NumberDates  = 0;      # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
> $ParseParas   = 0;      # 1 = new paragraph markup, 0 = old markup
> $AuthorFooter = 1;      # 1 = show last author in footer, 0 = do not show
> $AllUpload    = 0;      # 1 = anyone can upload,   0 = only editor/admins
> $LimitFileUrl = 1;      # 1 = limited use of file: URLs, 0 = no limits
> $MaintTrimRc  = 0;      # 1 = maintain action trims RC, 0 = only maintainrc
> $SearchButton = 0;      # 1 = search button on page, 0 = old behavior
> $EditNameLink = 0;      # 1 = edit links use name (CSS), 0 = '?' links
> $UseMetaWiki  = 0;      # 1 = add MetaWiki search links, 0 = no MW links
> $BracketImg   = 1;      # 1 = [url url.gif] becomes image link, 0 = no img
> 
> # Names of sites.  (The first entry is used for the number link.)
> @IsbnNames = ('bn.com', 'amazon.com', 'search');
> # Full URL of each site before the ISBN
> @IsbnPre = ('http://search.barnesandnoble.com/booksearch/isbninquiry.asp?isbn=',
>             'http://www.amazon.com/exec/obidos/ISBN=',
>             'http://www.pricescan.com/books/BookDetail.asp?isbn=');
> # Rest of URL of each site after the ISBN (usually '')
> @IsbnPost = ('', '', '');
> 
> # HTML tag lists, enabled if $HtmlTags is set.
> # Scripting is currently possible with these tags,
> # so they are *not* particularly "safe".
> # Tags that must be in <tag> ... </tag> pairs:
> @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
>   em s strike strong tt var div center blockquote ol ul dl table caption);
> # Single tags (that do not require a closing /tag)
> @HtmlSingle = qw(br p hr li dt dd tr td th);
> @HtmlPairs = (@HtmlPairs, @HtmlSingle);  # All singles can also be pairs
> 
> # == You should not have to change anything below this line. =============
> $IndentLimit = 20;                  # Maximum depth of nested lists
> $PageDir     = "$DataDir/page";     # Stores page data
> $HtmlDir     = "$DataDir/html";     # Stores HTML versions
> $UserDir     = "$DataDir/user";     # Stores user data
> $KeepDir     = "$DataDir/keep";     # Stores kept (old) page data
> $TempDir     = "$DataDir/temp";     # Temporary files and locks
> $LockDir     = "$TempDir/lock";     # DB is locked if this exists
> $InterFile   = "$DataDir/intermap"; # Interwiki site->url map
> $RcFile      = "$DataDir/rclog";    # New RecentChanges logfile
> $RcOldFile   = "$DataDir/oldrclog"; # Old RecentChanges logfile
> $IndexFile   = "$DataDir/pageidx";  # List of all pages
> $EmailFile   = "$DataDir/emails";   # Email notification lists
> 
> if ($RepInterMap) {
>   push @ReplaceableFiles, $InterFile;
> }
> 
> # The "main" program, called at the end of this script file.
> sub DoWikiRequest {
>   if ($UseConfig && (-f $ConfigFile)) {
>     $ConfigError = '';
>     if (!do $ConfigFile) {   # Some error occurred
>       $ConfigError = $@;
>       if ($ConfigError eq '') {
>         # Unfortunately, if the last expr returns 0, one will get a false
>         # error above.  To remain compatible with existing installs the
>         # wiki must not report an error unless there is error text in $@.
>         # (Errors in "use strict" may not have error text.)
>         # Uncomment the line below if you want to catch use strict errors.
> #       $ConfigError = T('Unknown Error (no error text)');
>       }
>     }
>   }
>   &InitLinkPatterns();
>   if (!&DoCacheBrowse()) {
>     eval $BrowseCode;
>     &InitRequest() or return;
>     if (!&DoBrowseRequest()) {
>       eval $OtherCode;
>       &DoOtherRequest();
>     }
>   }
> }
> 
> # == Common and cache-browsing code ====================================
> sub InitLinkPatterns {
>   my ($UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim);
> 
>   # Field separators are used in the URL-style patterns below.
>   if ($NewFS) {
>     $FS  = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
>   } else {
>     $FS  = "\xb3";    # The FS character is a superscript "3"
>   }
>   $FS1 = $FS . "1";   # The FS values are used to separate fields
>   $FS2 = $FS . "2";   # in stored hashtables and other data structures.
>   $FS3 = $FS . "3";   # The FS character is not allowed in user data.
>   $UpperLetter = "[A-Z";
>   $LowerLetter = "[a-z";
>   $AnyLetter   = "[A-Za-z";
>   if ($NonEnglish) {
>     $UpperLetter .= "\xc0-\xde";
>     $LowerLetter .= "\xdf-\xff";
>     if ($NewFS) {
>       $AnyLetter   .= "\x80-\xff";
>     } else {
>       $AnyLetter   .= "\xc0-\xff";
>     }
>   }
>   if (!$SimpleLinks) {
>     $AnyLetter .= "_0-9";
>   }
>   $UpperLetter .= "]"; $LowerLetter .= "]"; $AnyLetter .= "]";
>   # Main link pattern: lowercase between uppercase, then anything
>   $LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter
>          . $AnyLetter . "*";
>   # Optional subpage link pattern: uppercase, lowercase, then anything
>   $LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
>   if ($UseSubpage) {
>     # Loose pattern: If subpage is used, subpage may be simple name
>     $LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
>     # Strict pattern: both sides must be the main LinkPattern
>     # $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
>   } else {
>     $LinkPattern = "($LpA)";
>   }
>   $QDelim = '(?:"")?';     # Optional quote delimiter (not in output)
>   $AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
>   $LinkPattern .= $QDelim;
>   # Inter-site convention: sites must start with uppercase letter
>   # (Uppercase letter avoids confusion with URLs)
>   $InterSitePattern = $UpperLetter . $AnyLetter . "+";
>   $InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
>   if ($FreeLinks) {
>     # Note: the - character must be first in $AnyLetter definition
>     if ($NonEnglish) {
>       if ($NewFS) {
>         $AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
>       } else {
>         $AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
>       }
>     } else {
>       $AnyLetter = "[-,.()' _0-9A-Za-z]";
>     }
>   }
>   $FreeLinkPattern = "($AnyLetter+)";
>   if ($UseSubpage) {
>     $FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+)";
>   }
>   $FreeLinkPattern .= $QDelim;
>   # Url-style links are delimited by one of:
>   #   1.  Whitespace                           (kept in output)
>   #   2.  Left or right angle-bracket (< or >) (kept in output)
>   #   3.  Right square-bracket (])             (kept in output)
>   #   4.  A single double-quote (")            (kept in output)
>   #   5.  A $FS (field separator) character    (kept in output)
>   #   6.  A double double-quote ("")           (removed from output)
>   $UrlProtocols = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|"
>                   . "prospero|telnet|gopher";
>   $UrlProtocols .= '|file'  if ($NetworkFile || !$LimitFileUrl);
>   $UrlPattern = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
>   $ImageExtensions = "(gif|jpg|png|bmp|jpeg|ico|tiff?)";
>   $RFCPattern = "RFC\\s?(\\d+)";
>   $ISBNPattern = "ISBN:?([0-9- xX]{10,})";
>   $UploadPattern = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
> }
> 
> # Simple HTML cache
> sub DoCacheBrowse {
>   my ($query, $idFile, $text);
> 
>   return 0  if (!$UseCache);
>   $query = $ENV{'QUERY_STRING'};
>   if (($query eq "") && ($ENV{'REQUEST_METHOD'} eq "GET")) {
>     $query = $HomePage;  # Allow caching of home page.
>   }
>   if (!($query =~ /^$LinkPattern$/)) {
>     if (!($FreeLinks && ($query =~ /^$FreeLinkPattern$/))) {
>       return 0;  # Only use cache for simple links
>     }
>   }
>   $idFile = &GetHtmlCacheFile($query);
>   if (-f $idFile) {
>     local $/ = undef;   # Read complete files
>     open(INFILE, "<$idFile") or return 0;
>     $text = <INFILE>;
>     close INFILE;
>     print $text;
>     return 1;
>   }
>   return 0;
> }
> 
> sub GetHtmlCacheFile {
>   my ($id) = @_;
> 
>   return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
> }
> 
> sub GetPageDirectory {
>   my ($id) = @_;
> 
>   if ($id =~ /^([a-zA-Z])/) {
>     return uc($1);
>   }
>   return "other";
> }
> 
> sub T {
>   my ($text) = @_;
> 
>   if (defined($Translate{$text}) && ($Translate{$text} ne ''))  {
>     return $Translate{$text};
>   }
>   return $text;
> }
> 
> sub Ts {
>   my ($text, $string, $noquote) = @_;
> 
>   $string = &QuoteHtml($string) unless $noquote;
>   $text = T($text);
>   $text =~ s/\%s/$string/;
>   return $text;
> }
> 
> sub Tss {
>   my $text = $_[0];
>   my @args = @_;
> 
>   @args = map {
>     $_ = &QuoteHtml($_);
>   } @args;
>   $text = T($text);
>   $text =~ s/\%([1-9])/$args[$1]/ge;
>   return $text;
> }
> 
> sub QuoteHtml {
>   my ($html) = @_;
> 
>   $html =~ s/&/&amp;/g;
>   $html =~ s/</&lt;/g;
>   $html =~ s/>/&gt;/g;
>   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
>   return $html;
> }
> 
> # == Normal page-browsing and RecentChanges code =======================
> $BrowseCode = ""; # Comment next line to always compile (slower)
> #$BrowseCode = <<'#END_OF_BROWSE_CODE';
> use CGI;
> use CGI::Carp qw(fatalsToBrowser);
> 
> sub InitRequest {
>   my @ScriptPath = split('/', "$ENV{SCRIPT_NAME}");
> 
>   $CGI::POST_MAX = $MaxPost;
>   if ($UseUpload) {
>     $CGI::DISABLE_UPLOADS = 0;  # allow uploads
>   } else {
>     $CGI::DISABLE_UPLOADS = 1;  # no uploads
>   }
>   $q = new CGI;
>   # Fix some issues with editing UTF8 pages (if charset specified)
>   if ($HttpCharset ne '') {
>     $q->charset($HttpCharset);
>   }
>   $Now = time;                     # Reset in case script is persistent
>   $ScriptName = pop(@ScriptPath);  # Name used in links
>   $IndexInit = 0;                  # Must be reset for each request
>   $InterSiteInit = 0;
>   %InterSite = ();
>   $MainPage = ".";       # For subpages only, the name of the top-level page
>   $OpenPageName = "";    # Currently open page
>   &CreateDir($DataDir);  # Create directory if it doesn't exist
>   if (!-d $DataDir) {
>     &ReportError(Ts('Could not create %s', $DataDir) . ": $!");
>     return 0;
>   }
>   &InitCookie();         # Reads in user data
>   return 1;
> }
> 
> sub InitCookie {
>   %SetCookie = ();
>   $TimeZoneOffset = 0;
>   undef $q->{'.cookies'};  # Clear cache if it exists (for SpeedyCGI)
>   %UserData = ();          # Fix for persistent environments.
>   %UserCookie = $q->cookie($CookieName);
>   $UserID = $UserCookie{'id'};
>   $UserID =~ s/\D//g;  # Numeric only
>   if ($UserID < 200) {
>     $UserID = 111;
>   } else {
>     &LoadUserData($UserID);
>   }
>   if ($UserID > 199) {
>     if (($UserData{'id'}       != $UserCookie{'id'})      ||
>         ($UserData{'randkey'}  != $UserCookie{'randkey'})) {
>       $UserID = 113;
>       %UserData = ();   # Invalid.  Consider warning message.
>     }
>   }
>   if ($UserData{'tzoffset'} != 0) {
>     $TimeZoneOffset = $UserData{'tzoffset'} * (60 * 60);
>   }
> }
> 
> sub DoBrowseRequest {
>   my ($id, $action, $text);
> 
>   if (!$q->param) {             # No parameter
>     &BrowsePage($HomePage);
>     return 1;
>   }
>   $id = &GetParam('keywords', '');
>   if ($id) {                    # Just script?PageName
>     if ($FreeLinks && (!-f &GetPageFile($id))) {
>       $id = &FreeToNormal($id);
>     }
>     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
>       $id = $NotFoundPg;
>     }
>     &BrowsePage($id)  if &ValidIdOrDie($id);
>     return 1;
>   }
>   $action = lc(&GetParam('action', ''));
>   $id = &GetParam('id', '');
>   if ($action eq 'browse') {
>     if ($FreeLinks && (!-f &GetPageFile($id))) {
>       $id = &FreeToNormal($id);
>     }
>     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
>       $id = $NotFoundPg;
>     }
>     &BrowsePage($id)  if &ValidIdOrDie($id);
>     return 1;
>   } elsif ($action eq 'rc') {
>     &BrowsePage($RCName);
>     return 1;
>   } elsif ($action eq 'random') {
>     &DoRandom();
>     return 1;
>   } elsif ($action eq 'history') {
>     &DoHistory($id)   if &ValidIdOrDie($id);
>     return 1;
>   }
>   return 0;  # Request not handled
> }
> 
> sub BrowsePage {
>   my ($id) = @_;
>   my ($fullHtml, $oldId, $allDiff, $showDiff, $openKept);
>   my ($revision, $goodRevision, $diffRevision, $newText);
> 
>   &OpenPage($id);
>   &OpenDefaultText();
>   $openKept = 0;
>   $revision = &GetParam('revision', '');
>   $revision =~ s/\D//g;           # Remove non-numeric chars
>   $goodRevision = $revision;      # Non-blank only if exists
>   if ($revision ne '') {
>     &OpenKeptRevisions('text_default');
>     $openKept = 1;
>     if (!defined($KeptRevisions{$revision})) {
>       $goodRevision = '';
>     } else {
>       &OpenKeptRevision($revision);
>     }
>   }
>   # Raw mode: just untranslated wiki text
>   if (&GetParam('raw', 0)) {
>      print &GetHttpHeader('text/plain');
>      print $Text{'text'};
>      return;
>   }
>   $newText = $Text{'text'};     # For differences
>   # Handle a single-level redirect
>   $oldId = &GetParam('oldid', '');
>   if (($oldId eq '') && (substr($Text{'text'}, 0, 10) eq '#REDIRECT ')) {
>     $oldId = $id;
>     if (($FreeLinks) && ($Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/)) {
>       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/);
>       $id = &FreeToNormal($id);
>     } else {
>       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+(\S+)/);
>     }
>     if (&ValidId($id) eq '') {
>       # Consider revision in rebrowse?
>       &ReBrowsePage($id, $oldId, 0);
>       return;
>     } else {  # Not a valid target, so continue as normal page
>       $id = $oldId;
>       $oldId = '';
>     }
>   }
>   $MainPage = $id;
>   $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
>   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId, 1);
>   if ($revision ne '') {
>     if (($revision eq $Page{'revision'}) || ($goodRevision ne '')) {
>       $fullHtml .= '<b>' . Ts('Showing revision %s', $revision) . "</b><br>";
>     } else {
>       $fullHtml .= '<b>' . Ts('Revision %s not available', $revision)
>                    . ' (' . T('showing current revision instead')
>                    . ')</b><br>';
>     }
>   }
>   $allDiff  = &GetParam('alldiff', 0);
>   if ($allDiff != 0) {
>     $allDiff = &GetParam('defaultdiff', 1);
>   }
>   if ((($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName))
>       && &GetParam('norcdiff', 1)) {
>     $allDiff = 0;  # Only show if specifically requested
>   }
>   $showDiff = &GetParam('diff', $allDiff);
>   if ($UseDiff && $showDiff) {
>     $diffRevision = $goodRevision;
>     $diffRevision = &GetParam('diffrevision', $diffRevision);
>     # Eventually try to avoid the following keep-loading if possible?
>     &OpenKeptRevisions('text_default')  if (!$openKept);
>     $fullHtml .= &GetDiffHTML($showDiff, $id, $diffRevision,
>                               $revision, $newText);
>     $fullHtml .= "<hr class=wikilinediff>\n";
>   }
>   $fullHtml .= '<div class=wikitext>';
>   $fullHtml .= &WikiToHTML($Text{'text'});
>   $fullHtml .= '</div>';
>   if (($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName)) {
>     print $fullHtml;
>     print "<hr class=wikilinerc>\n";
>     print '<div class=wikirc>';
>     &DoRc(1);
>     print '</div>';
>     print &GetFooterText($id, $goodRevision);
>     return;
>   }
>   $fullHtml .= &GetFooterText($id, $goodRevision);
>   print $fullHtml;
>   return  if ($showDiff || ($revision ne ''));  # Don't cache special version
>   &UpdateHtmlCache($id, $fullHtml)  if ($UseCache && ($oldId eq ''));
> }
> 
> sub ReBrowsePage {
>   my ($id, $oldId, $isEdit) = @_;
> 
>   if ($oldId ne "") {   # Target of #REDIRECT (loop breaking)
>     print &GetRedirectPage("action=browse&id=$id&oldid=$oldId",
>                            $id, $isEdit);
>   } else {
>     print &GetRedirectPage($id, $id, $isEdit);
>   }
> }
> 
> sub DoRc {
>   my ($rcType) = @_;   # 0 = RSS, 1 = HTML
>   my ($fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly);
>   my (@fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML);
>   my $starttime = 0;
>   my $showbar = 0;
> 
>   if (0 == $rcType) {
>     $showHTML = 0;
>   } else {
>     $showHTML = 1;
>   }
>   if (&GetParam("from", 0)) {
>     $starttime = &GetParam("from", 0);
>     if ($showHTML) {
>       print "<h2>" . Ts('Updates since %s', &TimeToText($starttime))
>             . "</h2>\n";
>     }
>   } else {
>     $daysago = &GetParam("days", 0);
>     $daysago = &GetParam("rcdays", 0)  if ($daysago == 0);
>     if ($daysago) {
>       $starttime = $Now - ((24*60*60)*$daysago);
>       if ($showHTML) {
>         print "<h2>" . Ts('Updates in the last %s day'
>                           . (($daysago != 1)?"s":""), $daysago) . "</h2>\n";
>       }
>       # Note: must have two translations (for "day" and "days")
>       # Following comment line is for translation helper script
>       # Ts('Updates in the last %s days', '');
>     }
>   }
>   if ($starttime == 0) {
>     if (0 == $rcType) {
>       $starttime = $Now - ((24*60*60)*$RssDays);
>     } else {
>       $starttime = $Now - ((24*60*60)*$RcDefault);
>     }
>     if ($showHTML) {
>       print "<h2>" . Ts('Updates in the last %s day'
>                         . (($RcDefault != 1)?"s":""), $RcDefault) . "</h2>\n";
>     }
>     # Translation of above line is identical to previous version
>   }
>   # Read rclog data (and oldrclog data if needed)
>   ($status, $fileData) = &ReadFile($RcFile);
>   $errorText = "";
>   if (!$status) {
>     # Save error text if needed.
>     $errorText = '<p><strong>' . Ts('Could not open %s log file', $RCName)
>                  . ":</strong> $RcFile<p>"
>                  . T('Error was') . ":\n<pre>$!</pre>\n" . '<p>'
>     . T('Note: This error is normal if no changes have been made.') . "\n";
>   }
>   @fullrc = split(/\n/, $fileData);
>   $firstTs = 0;
>   if (@fullrc > 0) {  # Only false if no lines in file
>     ($firstTs) = split(/$FS3/, $fullrc[0]);
>   }
>   if (($firstTs == 0) || ($starttime <= $firstTs)) {
>     ($status, $oldFileData) = &ReadFile($RcOldFile);
>     if ($status) {
>       @fullrc = split(/\n/, $oldFileData . $fileData);
>     } else {
>       if ($errorText ne "") {  # could not open either rclog file
>         print $errorText;
>         print "<p><strong>"
>               . Ts('Could not open old %s log file', $RCName)
>               . ":</strong> $RcOldFile<p>"
>               . T('Error was') . ":\n<pre>$!</pre>\n";
>         return;
>       }
>     }
>   }
>   $lastTs = 0;
>   if (@fullrc > 0) {  # Only false if no lines in file
>     ($lastTs) = split(/$FS3/, $fullrc[$#fullrc]);
>   }
>   $lastTs++  if (($Now - $lastTs) > 5);  # Skip last unless very recent
> 
>   $idOnly = &GetParam("rcidonly", "");
>   if ($idOnly && $showHTML) {
>     print '<b>(' . Ts('for %s only', &ScriptLink($idOnly, &QuoteHtml($idOnly)), 1)
>           . ')</b><br>';
>   }
>   if ($showHTML) {
>     foreach $i (@RcDays) {
>       print " | "  if $showbar;
>       $showbar = 1;
>       print &ScriptLink("action=rc&days=$i",
>                         Ts('%s day' . (($i != 1)?'s':''), $i));
>         # Note: must have two translations (for "day" and "days")
>         # Following comment line is for translation helper script
>         # Ts('%s days', '');
>     }
>     print "<br>" . &ScriptLink("action=rc&from=$lastTs",
>                                T('List new changes starting from'));
>     print " " . &TimeToText($lastTs) . "<br>\n";
>   }
>   $i = 0;
>   while ($i < @fullrc) {  # Optimization: skip old entries quickly
>     ($ts) = split(/$FS3/, $fullrc[$i]);
>     if ($ts >= $starttime) {
>       $i -= 1000  if ($i > 0);
>       last;
>     }
>     $i += 1000;
>   }
>   $i -= 1000  if (($i > 0) && ($i >= @fullrc));
>   for (; $i < @fullrc ; $i++) {
>     ($ts) = split(/$FS3/, $fullrc[$i]);
>     last if ($ts >= $starttime);
>   }
>   if ($i == @fullrc && $showHTML) {
>     print '<br><strong>' . Ts('No updates since %s',
>                               &TimeToText($starttime)) . "</strong><br>\n";
>   } else {
>     splice(@fullrc, 0, $i);  # Remove items before index $i
>     # Consider an end-time limit (items older than X)
>     if (0 == $rcType) {
>       print &GetRcRss(@fullrc);
>     } else {
>       print &GetRcHtml(@fullrc);
>     }
>   }
>   if ($showHTML) {
>     print '<p>' . Ts('Page generated %s', &TimeToText($Now)), "<br>\n";
>   }
> }
> 
> sub GetRc {
>   my $rcType = shift;
>   my @outrc = @_;
>   my ($rcline, $date, $newtop, $author, $inlist, $result);
>   my ($showedit, $link, $all, $idOnly, $headItem, $item);
>   my ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp);
>   my ($rcchangehist, $tEdit, $tChanges, $tDiff);
>   my ($headList, $pagePrefix, $historyPrefix, $diffPrefix);
>   my %extra = ();
>   my %changetime = ();
>   my %pagecount = ();
> 
>   # Slice minor edits
>   $showedit = &GetParam("rcshowedit", $ShowEdits);
>   $showedit = &GetParam("showedit", $showedit);
>   if ($showedit != 1) {
>     my @temprc = ();
>     foreach $rcline (@outrc) {
>       ($ts, $pagename, $summary, $isEdit, $host) = split(/$FS3/, $rcline);
>       if ($showedit == 0) {  # 0 = No edits
>         push(@temprc, $rcline)  if (!$isEdit);
>       } else {               # 2 = Only edits
>         push(@temprc, $rcline)  if ($isEdit);
>       }
>     }
>     @outrc = @temprc;
>   }
>   # Optimize param fetches out of main loop
>   $rcchangehist = &GetParam("rcchangehist", 1);
>   # Optimize translations out of main loop
>   $tEdit    = T('(edit)');
>   $tDiff    = T('(diff)');
>   $tChanges = T('changes');
>   $pagePrefix = $QuotedFullUrl . &ScriptLinkChar();
>   $diffPrefix = $pagePrefix . &QuoteHtml("action=browse&diff=4&id=");
>   $historyPrefix = $pagePrefix . &QuoteHtml("action=history&id=");
>   foreach $rcline (@outrc) {
>     ($ts, $pagename) = split(/$FS3/, $rcline);
>     $pagecount{$pagename}++;
>     $changetime{$pagename} = $ts;
>   }
>   $date = "";
>   $all = &GetParam("rcall", 0);
>   $all = &GetParam("all", $all);
>   $newtop = &GetParam("rcnewtop", $RecentTop);
>   $newtop = &GetParam("newtop", $newtop);
>   $idOnly = &GetParam("rcidonly", "");
>   $inlist = 0;
>   $headList = '';
>   $result = '';
>   @outrc = reverse @outrc if ($newtop);
>   foreach $rcline (@outrc) {
>     ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp)
>       = split(/$FS3/, $rcline);
>     next  if ((!$all) && ($ts < $changetime{$pagename}));
>     next  if (($idOnly ne "") && ($idOnly ne $pagename));
>     %extra = split(/$FS2/, $extraTemp, -1);
>     if ($date ne &CalcDay($ts)) {
>       $date = &CalcDay($ts);
>       if (1 == $rcType) {  # HTML
>         # add date, properly closing lists first
>         if ($inlist) {
>           $result .= "</UL>\n";
>           $inlist = 0;
>         }
>         $result .= "<p><strong>" . $date . "</strong></p>\n";
>         if (!$inlist) {
>           $result .= "<UL>\n";
>           $inlist = 1;
>         }
>       }
>     }
>     if (0 == $rcType) {  # RSS
>       ($headItem, $item) = &GetRssRcLine($pagename, $ts, $host,
>                               $extra{'name'}, $extra{'id'}, $summary, $isEdit,
>                               $pagecount{$pagename}, $extra{'revision'},
>                               $diffPrefix, $historyPrefix, $pagePrefix);
>       $headList .= $headItem;
>       $result   .= $item;
>     } else {  # HTML
>       $result .= &GetHtmlRcLine($pagename, $ts, $host, $extra{'name'},
>                          $extra{'id'}, $summary, $isEdit,
>                          $pagecount{$pagename}, $extra{'revision'},
>                          $tEdit, $tDiff, $tChanges, $all, $rcchangehist);
>     }
>   }
>   if (1 == $rcType) {
>     $result .= "</UL>\n"  if ($inlist);  # Close final tag
>   }
>   return ($headList, $result);  # Just ignore headList for HTML
> }
> 
> sub GetRcHtml {
>   my ($html, $extra);
> 
>   ($extra, $html) = &GetRc(1, @_);
>   return $html;
> }
> 
> sub GetHtmlRcLine {
>   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
>       $isEdit, $pagecount, $revision, $tEdit, $tDiff, $tChanges, $all,
>       $rcchangehist) = @_;
>   my ($author, $sum, $edit, $count, $link, $html);
> 
>   $html = '';
>   $host = &QuoteHtml($host);
>   if (defined($userName) && defined($userID)) {
>     $author = &GetAuthorLink($host, $userName, $userID);
>   } else {
>     $author = &GetAuthorLink($host, "", 0);
>   }
>   $sum = "";
>   if (($summary ne "") && ($summary ne "*")) {
>     $summary = &QuoteHtml($summary);
>     $sum = "<strong>[$summary]</strong> ";
>   }
>   $edit = "";
>   $edit = "<em>$tEdit</em> "  if ($isEdit);
>   $count = "";
>   if ((!$all) && ($pagecount > 1)) {
>     $count = "($pagecount ";
>     if ($rcchangehist) {
>       $count .= &GetHistoryLink($pagename, $tChanges);
>     } else {
>       $count .= $tChanges;
>     }
>     $count .= ") ";
>   }
>   $link = "";
>   if ($UseDiff && &GetParam("diffrclink", 1)) {
>     $link .= &ScriptLinkDiff(4, $pagename, $tDiff, "") . "  ";
>   }
>   $link .= &GetPageLink($pagename);
>   $html .= "<li>$link ";
>   $html .=  &CalcTime($timestamp) . " $count$edit" . " $sum";
>   $html .= ". . . . . $author\n";
>   return $html;
> }
> 
> sub GetRcRss {
>   my ($rssHeader, $headList, $items);
> 
>   # Normally get URL from script, but allow override
>   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
>   $QuotedFullUrl = &QuoteHtml($FullUrl);
>   $SiteDescription = &QuoteHtml($SiteDescription);
> 
>   my $ChannelAbout = &QuoteHtml($FullUrl . &ScriptLinkChar()
>                                 . $ENV{QUERY_STRING});
>   $rssHeader = <<RSS ;
> <?xml version="1.0" encoding="ISO-8859-1"?>
> <rdf:RDF
>     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
>     xmlns="http://purl.org/rss/1.0/"
>     xmlns:dc="http://purl.org/dc/elements/1.1/"
>     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
> >
>     <channel rdf:about="$ChannelAbout">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <link>${\($QuotedFullUrl . &ScriptLinkChar() . &QuoteHtml("$RCName"))}</link>
>         <description>${\(&QuoteHtml($SiteDescription))}</description>
>         <wiki:interwiki>
>             <rdf:Description link="$QuotedFullUrl">
>                 <rdf:value>$InterWikiMoniker</rdf:value>
>             </rdf:Description>
>         </wiki:interwiki>
>         <items>
>             <rdf:Seq>
> RSS
>   ($headList, $items) = &GetRc(0, @_);
>   $rssHeader .= $headList;
>   return <<RSS ;
> $rssHeader
>             </rdf:Seq>
>         </items>
>     </channel>
>     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
>         <title>${\(&QuoteHtml($SiteName))}</title>
>         <url>$RssLogoUrl</url>
>         <link>$QuotedFullUrl</link>
>     </image>
> $items
> </rdf:RDF>
> RSS
> }
> 
> sub GetRssRcLine{
>   my ($pagename, $timestamp, $host, $userName, $userID, $summary, $isEdit,
>       $pagecount, $revision, $diffPrefix, $historyPrefix, $pagePrefix) = @_;
>   my ($pagenameEsc, $itemID, $description, $authorLink, $author, $status,
>       $importance, $date, $item, $headItem);
> 
>   $pagenameEsc = CGI::escape($pagename);
>   # Add to list of items in the <channel/>
>   $itemID = $FullUrl . &ScriptLinkChar()
>             . &GetOldPageParameters('browse', $pagenameEsc, $revision);
>   $itemID = &QuoteHtml($itemID);
>   $headItem = "                <rdf:li rdf:resource=\"$itemID\"/>\n";
>   # Add to list of items proper.
>   if (($summary ne "") && ($summary ne "*")) {
>     $description = &QuoteHtml($summary);
>   }
>   $host = &QuoteHtml($host);
>   if ($userName) {
>     $author = &QuoteHtml($userName);
>     $authorLink = 'link="' . $QuotedFullUrl . &ScriptLinkChar() . $author . '"';
>   } else {
>     $author = $host;
>   }
>   $status = (1 == $revision) ? 'new' : 'updated';
>   $importance = $isEdit ? 'minor' : 'major';
>   $timestamp += $TimeZoneOffset;
>   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($timestamp);
>   $year += 1900;
>   $date = sprintf("%4d-%02d-%02dT%02d:%02d:%02d+%02d:00",
>     $year, $mon+1, $mday, $hour, $min, $sec, $TimeZoneOffset/(60*60));
>   $pagename = &QuoteHtml($pagename);
>   # Write it out longhand
>   $item = <<RSS ;
>     <item rdf:about="$itemID">
>         <title>$pagename</title>
>         <link>$pagePrefix$pagenameEsc</link>
>         <description>$description</description>
>         <dc:date>$date</dc:date>
>         <dc:contributor>
>             <rdf:Description wiki:host="$host" $authorLink>
>                 <rdf:value>$author</rdf:value>
>             </rdf:Description>
>         </dc:contributor>
>         <wiki:status>$status</wiki:status>
>         <wiki:importance>$importance</wiki:importance>
>         <wiki:diff>$diffPrefix$pagenameEsc</wiki:diff>
>         <wiki:version>$revision</wiki:version>
>         <wiki:history>$historyPrefix$pagenameEsc</wiki:history>
>     </item>
> RSS
>   return ($headItem, $item);
> }
> 
> sub DoRss {
>   print "Content-type: text/xml\n\n";
>   &DoRc(0);
> }
> 
> sub DoRandom {
>   my ($id, @pageList);
> 
>   @pageList = &AllPagesList();  # Optimize?
>   $id = $pageList[int(rand($#pageList + 1))];
>   &ReBrowsePage($id, "", 0);
> }
> 
> sub DoHistory {
>   my ($id) = @_;
>   my ($html, $canEdit, $row, $newText);
> 
>   print &GetHeader('', Ts('History of %s', $id), '') . '<br>';
>   &OpenPage($id);
>   &OpenDefaultText();
>   $newText = $Text{'text'};
>   $canEdit = 0;
>   $canEdit = &UserCanEdit($id)  if ($HistoryEdit);
>   if ($UseDiff) {
>     print <<EOF ;
>       <form action="$ScriptName" METHOD="GET">
>           <input type="hidden" name="action" value="browse"/>
>           <input type="hidden" name="diff" value="1"/>
>           <input type="hidden" name="id" value="$id"/>
>       <table border="0" width="100%"><tr>
> EOF
>   }
>   $html = &GetHistoryLine($id, $Page{'text_default'}, $canEdit, $row++);
>   &OpenKeptRevisions('text_default');
>   foreach (reverse sort {$a <=> $b} keys %KeptRevisions) {
>     next  if ($_ eq "");  # (needed?)
>     $html .= &GetHistoryLine($id, $KeptRevisions{$_}, $canEdit, $row++);
>   }
>   print $html;
>   if ($UseDiff) {
>     my $label = T('Compare');
>     print "<tr><td align='center'><input type='submit' "
>           . "value='$label'/>&nbsp;&nbsp;</td></table></form>\n";
>     print "<hr class=wikilinediff>\n";
>     print &GetDiffHTML(&GetParam('defaultdiff', 1), $id, '', '', $newText);
>   }
>   print &GetCommonFooter();
> }
> 
> sub GetMaskedHost {
>   my ($text) = @_;
>   my ($logText);
> 
>   if (!$MaskHosts) {
>     return $text;
>   }
>   $logText = T('(logged)');
>   if (!($text =~ s/\d+$/$logText/)) { # IP address (ending numbers masked)
>     $text =~ s/^[^\.\(]+/$logText/;   # Host name: mask until first .
>   }
>   return $text;
> }
> 
> sub GetHistoryLine {
>   my ($id, $section, $canEdit, $row) = @_;
>   my ($html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor);
>   my (%sect, %revtext);
> 
>   %sect = split(/$FS2/, $section, -1);
>   %revtext = split(/$FS3/, $sect{'data'});
>   $rev = $sect{'revision'};
>   $summary = $revtext{'summary'};
>   if ((defined($sect{'host'})) && ($sect{'host'} ne '')) {
>     $host = $sect{'host'};
>   } else {
>     $host = $sect{'ip'};
>   }
>   $host = &GetMaskedHost($host);
>   $user = $sect{'username'};
>   $uid = $sect{'id'};
>   $ts = $sect{'ts'};
>   $minor = '';
>   $minor = '<i>' . T('(edit)') . '</i> '  if ($revtext{'minor'});
>   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
>   if ($UseDiff) {
>     my ($c1, $c2);
>     $c1 = 'checked="checked"' if 1 == $row;
>     $c2 = 'checked="checked"' if 0 == $row;
>     $html .= "<tr><td align='center'><input type='radio' "
>              . "name='diffrevision' value='$rev' $c1/> ";
>     $html .= "<input type='radio' name='revision' value='$rev' $c2/></td><td>";
>   }
>   if (0 == $row) { # current revision
>     $html .= &GetPageLinkText($id, Ts('Revision %s', $rev)) . ' ';
>     if ($canEdit) {
>       $html .= &GetEditLink($id, T('Edit')) . ' ';
>     }
>   } else {
>     $html .= &GetOldPageLink('browse', $id, $rev,
>                              Ts('Revision %s', $rev)) . ' ';
>     if ($canEdit) {
>       $html .= &GetOldPageLink('edit',   $id, $rev, T('Edit')) . ' ';
>     }
>   }
>   $html .= ". . " . $minor . &TimeToText($ts) . " ";
>   $html .= T('by') . ' ' . &GetAuthorLink($host, $user, $uid) . " ";
>   if (defined($summary) && ($summary ne "") && ($summary ne "*")) {
>     $summary = &QuoteHtml($summary);   # Thanks Sunir! :-)
>     $html .= "<b>[$summary]</b> ";
>   }
>   $html .= $UseDiff ? "</tr>\n" : "<br>\n";
>   return $html;
> }
> 
> # ==== HTML and page-oriented functions ====
> sub ScriptLinkChar {
>   if ($SlashLinks) {
>     return '/';
>   }
>   return '?';
> }
> 
> sub ScriptLink {
>   my ($action, $text) = @_;
> 
>   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
>          . "\">$text</a>";
> }
> 
> sub ScriptLinkClass {
>   my ($action, $text, $class) = @_;
> 
>   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
>          . '" class="' . $class . "\">$text</a>";
> }
> 
> sub GetPageLinkText {
>   my ($id, $name) = @_;
> 
>   $id =~ s|^/|$MainPage/|;
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>     $name =~ s/_/ /g;
>   }
>   return &ScriptLinkClass($id, $name, 'wikipagelink');
> }
> 
> sub GetPageLink {
>   my ($id) = @_;
> 
>   return &GetPageLinkText($id, $id);
> }
> 
> sub GetEditLink {
>   my ($id, $name) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>     $name =~ s/_/ /g;
>   }
>   return &ScriptLinkClass("action=edit&id=$id", $name, 'wikipageedit');
> }
> 
> sub GetDeleteLink {
>   my ($id, $name, $confirm) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>     $name =~ s/_/ /g;
>   }
>   return &ScriptLink("action=delete&id=$id&confirm=$confirm", $name);
> }
> 
> sub GetOldPageParameters {
>   my ($kind, $id, $revision) = @_;
> 
>   $id = &FreeToNormal($id) if $FreeLinks;
>   return "action=$kind&id=$id&revision=$revision";
> }
> 
> sub GetOldPageLink {
>   my ($kind, $id, $revision, $name) = @_;
> 
>   $name =~ s/_/ /g if $FreeLinks;
>   return &ScriptLink(&GetOldPageParameters($kind, $id, $revision), $name);
> }
> 
> sub GetPageOrEditAnchoredLink {
>   my ($id, $anchor, $name) = @_;
>   my (@temp, $exists);
> 
>   if ($name eq "") {
>     $name = $id;
>     if ($FreeLinks) {
>       $name =~ s/_/ /g;
>     }
>   }
>   $id =~ s|^/|$MainPage/|;
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   $exists = 0;
>   if ($UseIndex) {
>     if (!$IndexInit) {
>       @temp = &AllPagesList();          # Also initializes hash
>     }
>     $exists = 1  if ($IndexHash{$id});
>   } elsif (-f &GetPageFile($id)) {      # Page file exists
>     $exists = 1;
>   }
>   if ($exists) {
>     $id = "$id#$anchor"  if $anchor;
>     $name = "$name#$anchor"  if $anchor && $NamedAnchors != 2;
>     return &GetPageLinkText($id, $name);
>   }
>   if ($FreeLinks && !$EditNameLink) {
>     if ($name =~ m| |) {  # Not a single word
>       $name = "[$name]";  # Add brackets so boundaries are obvious
>     }
>   }
>   if ($EditNameLink) {
>     return &GetEditLink($id, $name);
>   } else {
>     return $name . &GetEditLink($id, '?');
>   }
> }
> 
> sub GetPageOrEditLink {
>     my ($id, $name) = @_;
>     return &GetPageOrEditAnchoredLink($id, "", $name);
> }
> 
> sub GetBackLinksSearchLink {
>   my ($id) = @_;
>   my $name = $id;
> 
>   $id =~ s|.+/|/|;   # Subpage match: search for just /SubName
>   if ($FreeLinks) {
>     $name =~ s/_/ /g;  # Display with spaces
>     $id =~ s/_/+/g;    # Search for url-escaped spaces
>   }
>   return &ScriptLink("back=$id", $name);
> }
> 
> sub GetPrefsLink {
>   return &ScriptLink("action=editprefs", T('Preferences'));
> }
> 
> sub GetRandomLink {
>   return &ScriptLink("action=random", T('Random Page'));
> }
> 
> sub ScriptLinkDiff {
>   my ($diff, $id, $text, $rev) = @_;
> 
>   $rev = "&revision=$rev"  if ($rev ne "");
>   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
>   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
> }
> 
> sub ScriptLinkDiffRevision {
>   my ($diff, $id, $rev, $text) = @_;
> 
>   $rev = "&diffrevision=$rev"  if ($rev ne "");
>   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
>   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
> }
> 
> sub GetUploadLink {
>   return &ScriptLink('action=upload', T('Upload'));
> }
> 
> sub ScriptLinkTitle {
>   my ($action, $text, $title) = @_;
> 
>   if ($FreeLinks) {
>     $action =~ s/ /_/g;
>   }
>   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
>          . "\" title=\"$title\">$text</a>";
> }
> 
> sub GetAuthorLink {
>   my ($host, $userName, $uid) = @_;
>   my ($html, $title, $userNameShow);
> 
>   $userNameShow = $userName;
>   if ($FreeLinks) {
>     $userName     =~ s/ /_/g;
>     $userNameShow =~ s/_/ /g;
>   }
>   if (&ValidId($userName) ne "") {  # Invalid under current rules
>     $userName = "";  # Just pretend it isn't there.
>   }
>   if (($uid > 0) && ($userName ne "")) {
>     $html = &ScriptLinkTitle($userName, $userNameShow,
>             Ts('ID %s', $uid) . ' ' . Ts('from %s', $host));
>   } else {
>     $html = $host;
>   }
>   return $html;
> }
> 
> sub GetHistoryLink {
>   my ($id, $text) = @_;
> 
>   if ($FreeLinks) {
>     $id =~ s/ /_/g;
>   }
>   return &ScriptLink("action=history&id=$id", $text);
> }
> 
> sub GetHeader {
>   my ($id, $title, $oldId, $backlinks) = @_;
>   my $header = "";
>   my $logoImage = "";
>   my $result = "";
>   my $embed = &GetParam('embed', $EmbedWiki);
>   my $altText = T('[Home]');
> 
>   $result = &GetHttpHeader('');
>   if ($FreeLinks) {
>     $title =~ s/_/ /g;   # Display as spaces
>   }
>   $result .= &GetHtmlHeader("$SiteName: $title");
>   return $result  if ($embed);
> 
>   $result .= '<div class=wikiheader>';
>   if ($oldId ne '') {
>     $result .= $q->h3('(' . Ts('redirected from %s', 
>                                &GetEditLink($oldId, &QuoteHtml($oldId)), 1) . ')');
>   }
>   if ((!$embed) && ($LogoUrl ne "")) {
>     $logoImage = "img src=\"$LogoUrl\" alt=\"$altText\" border=0";
>     if (!$LogoLeft) {
>       $logoImage .= " align=\"right\"";
>     }
>     $header = &ScriptLink($HomePage, "<$logoImage>");
>   }
>   if ($id and $backlinks) {
>     $result .= $q->h1($header . &GetBackLinksSearchLink($id));
>   } else {
>     $result .= $q->h1($header . $title);
>   }
>   if (&GetParam("toplinkbar", 1)) {
>     $result .= &GetGotoBar($id) . "<hr class=wikilineheader>";
>   }
>   $result .= '</div>';
>   return $result;
> }
> 
> sub GetHttpHeader {
>   my ($type) = @_;
>   my $cookie;
> 
>   $type = 'text/html'  if ($type eq '');
>   if (defined($SetCookie{'id'})) {
>     $cookie = "$CookieName="
>             . "rev&" . $SetCookie{'rev'}
>             . "&id&" . $SetCookie{'id'}
>             . "&randkey&" . $SetCookie{'randkey'};
>     $cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
>     if ($HttpCharset ne '') {
>       return $q->header(-cookie=>$cookie,
>                         -type=>"$type; charset=$HttpCharset");
>     }
>     return $q->header(-cookie=>$cookie);
>   }
>   if ($HttpCharset ne '') {
>     return $q->header(-type=>"$type; charset=$HttpCharset");
>   }
>   return $q->header(-type=>$type);
> }
> 
> sub GetHtmlHeader {
>   my ($title) = @_;
>   my ($dtd, $html, $bodyExtra, $stylesheet);
> 
>   $html = '';
>   $dtd = '-//IETF//DTD HTML//EN';
>   $html = qq(<!DOCTYPE HTML PUBLIC "$dtd">\n);
>   $title = $q->escapeHTML($title);
>   $html .= "<HTML><HEAD><TITLE>$title</TITLE>\n";
>   if ($FavIcon ne '') {
>     $html .= '<LINK REL="SHORTCUT ICON" HREF="' . $FavIcon . '">' 
>   }
>   if ($MetaKeywords) {
>       my $keywords = $OpenPageName;
>       $keywords =~ s/([a-z])([A-Z])/$1, $2/g;
>       $html .= "<META NAME='KEYWORDS' CONTENT='$keywords'/>\n" if $keywords;
>   }
>   # we don't want robots indexing our history or other admin pages
>   my $action = lc(&GetParam('action', ''));
>   unless (!$action or $action eq "rc" or $action eq "index") {
>     $html .= "<META NAME='robots' CONTENT='noindex,nofollow'>\n";
>   }
>   if ($SiteBase ne "") {
>     $html .= qq(<BASE HREF="$SiteBase">\n);
>   }
>   $stylesheet = &GetParam('stylesheet', $StyleSheet);
>   $stylesheet = $StyleSheet  if ($stylesheet eq '');
>   $stylesheet = ''  if ($stylesheet eq '*');  # Allow removing override
>   if ($stylesheet ne '') {
>     $html .= qq(<LINK REL="stylesheet" HREF="$stylesheet">\n);
>   }
>   $html .= $UserHeader;
>   $bodyExtra = '';
>   if ($UserBody ne '') {
>     $bodyExtra = ' ' . $UserBody;
>   }
>   if ($BGColor ne '') {
>     $bodyExtra .= qq( BGCOLOR="$BGColor");
>   }
>   $html .= "</HEAD><BODY$bodyExtra>\n";
>   return $html;
> }
> 
> sub GetFooterText {
>   my ($id, $rev) = @_;
>   my $result;
> 
>   if (&GetParam('embed', $EmbedWiki)) {
>     return $q->end_html;
>   }
>   $result = '<div class=wikifooter>';
>   $result .= "<hr class=wikilinefooter>\n";
>   $result .= &GetFormStart();
>   $result .= &GetGotoBar($id);
>   if (&UserCanEdit($id, 0)) {
>     if ($rev ne '') {
>       $result .= &GetOldPageLink('edit',   $id, $rev,
>                                  Ts('Edit revision %s of this page', $rev));
>     } else {
>       $result .= &GetEditLink($id, T('Edit text of this page'));
>     }
>   } else {
>     $result .= T('This page is read-only');
>   }
>   $result .= ' | ';
>   $result .= &GetHistoryLink($id, T('View other revisions'));
>   if ($rev ne '') {
>     $result .= ' | ';
>     $result .= &GetPageLinkText($id, T('View current revision'));
>   }
>   if ($UseMetaWiki) {
>     $result .= ' | <a href="http://sunir.org/apps/meta.pl?' . &UriEscape($id) . '">'
>                . T('Search MetaWiki') . '</a>';
>   }
>   if ($Section{'revision'} > 0) {
>     $result .= '<br>';
>     if ($rev eq '') {  # Only for most current rev
>       $result .= T('Last edited');
>     } else {
>       $result .= T('Edited');
>     }
>     $result .= ' ' . &TimeToText($Section{ts});
>     if ($AuthorFooter) {
>       $result .= ' ' . Ts('by %s', &GetAuthorLink($Section{'host'},
>                                      $Section{'username'}, $Section{'id'}), 1);
>     }
>   }
>   if ($UseDiff) {
>     $result .= ' ' . &ScriptLinkDiff(4, $id, T('(diff)'), $rev);
>   }
>   $result .= '<br>' . &GetSearchForm();
>   if ($AdminBar && &UserIsAdmin()) {
>     $result .= '<br>' . &GetAdminBar($id);
>   }
>   if ($DataDir =~ m|/tmp/|) {
>     $result .= '<br><b>' . T('Warning') . ':</b> '
>                . Ts('Database is stored in temporary directory %s',
>                     $DataDir) . '<br>';
>   }
>   if ($ConfigError ne '') {
>     $result .= '<br><b>' . T('Config file error:') . '</b> '
>                . $ConfigError . '<br>';
>   }
>   $result .= $q->endform;
>   if ($FooterNote ne '') {
>     $result .= T($FooterNote);
>   }
>   $result .= '</div>';
>   $result .= &GetMinimumFooter();
>   return $result;
> }
> 
> sub GetCommonFooter {
>   my ($html);
> 
>   $html = '<div class=wikifooter>' . '<hr class=wikilinefooter>'
>           . &GetFormStart() . &GetGotoBar('')
>           . &GetSearchForm() . $q->endform;
>   if ($FooterNote ne '') {
>     $html .= T($FooterNote);
>   }
>   $html .= '</div>' . $q->end_html;
>   return $html;
> }
> 
> sub GetMinimumFooter {
>   return $q->end_html;
> }
> 
> sub GetFormStart {
>   return $q->startform("POST", "$ScriptName",
>                        "application/x-www-form-urlencoded");
> }
> 
> sub GetGotoBar {
>   my ($id) = @_;
>   my ($main, $bartext);
> 
>   $bartext  = &GetPageLink($HomePage);
>   if ($id =~ m|/|) {
>     $main = $id;
>     $main =~ s|/.*||;  # Only the main page name (remove subpage)
>     $bartext .= " | " . &GetPageLink($main);
>   }
>   $bartext .= " | " . &GetPageLink($RCName);
>   $bartext .= " | " . &GetPrefsLink();
>   if ($UseUpload && &UserCanUpload()) {
>     $bartext .= " | " . &GetUploadLink();
>   }
>   if (&GetParam("linkrandom", 0)) {
>     $bartext .= " | " . &GetRandomLink();
>   }
>   if ($UserGotoBar ne '') {
>     $bartext .= " | " . $UserGotoBar;
>   }
>   $bartext .= "<br>\n";
>   return $bartext;
> }
> 
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
>   my ($id, $status, $name) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
> }
> 
> sub GetAdminBar {
>   my ($id) = @_;
>   my ($result);
> 
>   $result = T('Administration') . ': ';
>   if (-f &GetLockedPageFile($id))   { 
>     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
>   }
>   else  {
>     $result .= &GetPageLockLink($id, 1, T('Lock page'));
>   }
>   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
>   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
>   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
>   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
>   if (-f "$DataDir/noedit") {
>     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
>   } else {
>     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
>   }
>   return $result;
> }
> 
> sub GetSearchForm {
>   my ($result);
> 
>   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
>   if ($SearchButton) {
>     $result .= $q->submit('dosearch', T('Go!'));
>   } else {  
>     $result .= &GetHiddenValue("dosearch", 1);
>   }
>   return $result;
> }
> 
> sub GetRedirectPage {
>   my ($newid, $name, $isEdit) = @_;
>   my ($url, $html);
>   my ($nameLink);
> 
>   # Normally get URL from script, but allow override.
>   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
>   $url = $FullUrl . &ScriptLinkChar() . &UriEscape($newid);
>   $nameLink = "<a href=\"$url\">$name</a>";
>   if ($RedirType < 3) {
>     if ($RedirType == 1) {             # Use CGI.pm
>       # NOTE: do NOT use -method (does not work with old CGI.pm versions)
>       # Thanks to Daniel Neri for fixing this problem.
>       $html = $q->redirect(-uri=>$url);
>     } else {                           # Minimal header
>       $html  = "Status: 302 Moved\n";
>       $html .= "Location: $url\n";
>       $html .= "Content-Type: text/html\n";  # Needed for browser failure
>       $html .= "\n";
>     }
>     $html .= "\n" . Ts('Your browser should go to the %s page.', $newid);
>     $html .= ' ' . Ts('If it does not, click %s to continue.', $nameLink);
>   } else {
>     if ($isEdit) {
>       $html  = &GetHeader('', T('Thanks for editing...'), '');
>       $html .= Ts('Thank you for editing %s.', $nameLink);
>     } else {
>       $html  = &GetHeader('', T('Link to another page...'), '');
>     }
>     $html .= "\n<p>";
>     $html .= Ts('Follow the %s link to continue.', $nameLink);
>     $html .= &GetMinimumFooter();
>   }
>   return $html;
> }
> 
> # ==== Common wiki markup ====
> sub RestoreSavedText {
>   my ($text) = @_;
> 
>   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
>   return $text;
> }
> 
> sub RemoveFS {
>   my ($text) = @_;
> 
>   # Note: must remove all $FS, and $FS may be multi-byte/char separator
>   $text =~ s/($FS)+(\d)/$2/g;
>   return $text;
> }
> 
> sub WikiToHTML {
>   my ($pageText) = @_;
>   $TableMode = 0;
> 
>   %SaveUrl = ();
>   %SaveNumUrl = ();
>   $SaveUrlIndex = 0;
>   $SaveNumUrlIndex = 0;
>   $pageText = &RemoveFS($pageText);
>   if ($RawHtml) {
>     $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
>   }
>   $pageText = &QuoteHtml($pageText);
>   $pageText =~ s/\\ *\r?\n/ /g;          # Join lines with backslash at end
>   if ($ParseParas) {
>     # Note: The following 3 rules may span paragraphs, so they are
>     #       copied from CommonMarkup
>     $pageText =~
>         s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
>     $pageText =~
>         s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
>     $pageText =~
>         s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
>     $pageText =~ s/((.|\n)+?\n)\s*(\n|$)/&ParseParagraph($1)/geo;
>     $pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
>   } else {
>     $pageText = &CommonMarkup($pageText, 1, 0);   # Multi-line markup
>     $pageText = &WikiLinesToHtml($pageText);      # Line-oriented markup
>   }
>   while (@HeadingNumbers) {
>     pop @HeadingNumbers;
>     $TableOfContents .= "</dd></dl>\n\n";
>   }
>   $pageText =~ s/&lt;toc&gt;/$TableOfContents/gi;
>   if ($LateRules ne '') {
>     $pageText = &EvalLocalRules($LateRules, $pageText, 0);
>   }
>   return &RestoreSavedText($pageText);
> }
> 
> sub CommonMarkup {
>   my ($text, $useImage, $doLines) = @_;
>   local $_ = $text;
> 
>   if ($doLines < 2) { # 2 = do line-oriented only
>     # The <nowiki> tag stores text with no markup (except quoting HTML)
>     s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
>     # The <pre> tag wraps the stored text with the HTML <pre> tag
>     s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
>     s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
>     if ($EarlyRules ne '') {
>       $_ = &EvalLocalRules($EarlyRules, $_, !$useImage);
>     }
>     s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
>     if ($HtmlTags) {
>       my ($t);
>       foreach $t (@HtmlPairs) {
>         s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
>       }
>       foreach $t (@HtmlSingle) {
>         s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
>       }
>     } else {
>       # Note that these tags are restricted to a single line
>       s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
>       s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
>       s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
>       s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
>     }
>     s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;  # <tt> (MeatBall)
>     s/\&lt;br\&gt;/<br>/gi;  # Allow simple line break anywhere
>     if ($HtmlLinks) {
>       s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
>     }
>     if ($FreeLinks) {
>       # Consider: should local free-link descriptions be conditional?
>       # Also, consider that one could write [[Bad Page|Good Page]]?
>       s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
>       s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
>     }
>     if ($BracketText) {  # Links like [URL text of link]
>       s/\[$UrlPattern\s+([^\]]+?)\]/&StoreBracketUrl($1, $2, $useImage)/geos;
>       s/\[$InterLinkPattern\s+([^\]]+?)\]/&StoreBracketInterPage($1, $2,
>                                                              $useImage)/geos;
>       if ($WikiLinks && $BracketWiki) {  # Local bracket-links
>         s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
>         s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1,
>                                                $2, $3)/geos if $NamedAnchors;
>       }
>     }
>     s/\[$UrlPattern\]/&StoreBracketUrl($1, "", 0)/geo;
>     s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0)/geo;
>     s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
>     s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
>     if ($UseUpload) {
>       s/$UploadPattern/&StoreUpload($1)/geo;
>     }
>     if ($WikiLinks) {
>       s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1,
>                              $2, ""))/geo if $NamedAnchors;
>       # CAA: Putting \b in front of $LinkPattern breaks /SubPage links
>       #      (subpage links without the main page)
>       s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
>     }
>     s/\b$RFCPattern/&StoreRFC($1)/geo;
>     s/\b$ISBNPattern/&StoreISBN($1)/geo;
>     if ($ThinLine) {
>       if ($OldThinLine) {  # Backwards compatible, conflicts with headers
>         s/====+/<hr noshade class=wikiline size=2>/g;
>       } else {             # New behavior--no conflict
>         s/------+/<hr noshade class=wikiline size=2>/g;
>       }
>       s/----+/<hr noshade class=wikiline size=1>/g;
>     } else {
>       s/----+/<hr class=wikiline>/g;
>     }
>   }
>   if ($doLines) { # 0 = no line-oriented, 1 or 2 = do line-oriented
>     # The quote markup patterns avoid overlapping tags (with 5 quotes)
>     # by matching the inner quotes for the strong pattern.
>     s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g;
>     s/''(.*?)''/<em>$1<\/em>/g;
>     if ($UseHeadings) {
>       s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
>     }
>     if ($TableMode) {
>       s/((\|\|)+)/"<\/TD><TD COLSPAN=\"" . (length($1)\/2) . "\">"/ge;
>     }
>   }
>   return $_;
> }
> 
> sub EmptyCellsToNbsp {
>   my ($row) = @_;
> 
>   $row =~ s/(?<=\|\|)\s+(?=\|\|)/&nbsp;/g;
>   $row =~ s/^\s+(?=\|\|)/&nbsp;/;
>   $row =~ s/(?<=\|\|)\s+$/&nbsp;/;
>   return $row;
> }
> 
> sub WikiLinesToHtml {
>   my ($pageText) = @_;
>   my ($pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode);
> 
>   @htmlStack = ();
>   $depth = 0;
>   $pageHtml = "";
>   foreach (split(/\n/, $pageText)) {  # Process lines one-at-a-time
>     $code = '';
>     $codeAttributes = '';
>     $TableMode = 0;
>     $_ .= "\n";
>     if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
>       $code = "DL";
>       $depth = length $1;
>     } elsif (s/^(\:+)/<dt><dd>/) {
>       $code = "DL";
>       $depth = length $1;
>     } elsif (s/^(\*+)/<li>/) {
>       $code = "UL";
>       $depth = length $1;
>     } elsif (s/^(\#+)/<li>/) {
>       $code = "OL";
>       $depth = length $1;
>     } elsif ($TableSyntax &&
>              s/^((\|\|)+)(.*)\|\|\s*$/"<TR VALIGN='CENTER' "
>                                       . "ALIGN='CENTER'><TD colspan='"
>                                . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/TD><\/TR>\n"/e) {
>       $code = 'TABLE';
>       $codeAttributes = "BORDER='1'";
>       $TableMode = 1;
>       $depth = 1;
>     } elsif (/^[ \t].*\S/) {
>       $code = "PRE";
>       $depth = 1;
>     } else {
>       $depth = 0;
>     }
>     while (@htmlStack > $depth) {   # Close tags as needed
>       $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
>     }
>     if ($depth > 0) {
>       $depth = $IndentLimit  if ($depth > $IndentLimit);
>       if (@htmlStack) {  # Non-empty stack
>         $oldCode = pop(@htmlStack);
>         if ($oldCode ne $code) {
>           $pageHtml .= "</$oldCode><$code>\n";
>         }
>         push(@htmlStack, $code);
>       }
>       while (@htmlStack < $depth) {
>         push(@htmlStack, $code);
>         $pageHtml .= "<$code $codeAttributes>\n";
>       }
>     }
>     if (!$ParseParas) {
>       s/^\s*$/<p>\n/;                      # Blank lines become <p> tags
>     }
>     $pageHtml .= &CommonMarkup($_, 1, 2);  # Line-oriented common markup
>   }
>   while (@htmlStack > 0) {       # Clear stack
>     $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
>   }
>   return $pageHtml;
> }
> 
> sub EvalLocalRules {
>   my ($rules, $origText, $isDiff) = @_;
>   my ($text, $reportError, $errorText);
> 
>   $text = $origText;
>   $reportError = 1;
>   # Basic idea: the $rules should change $text, possibly with different
>   # behavior if $isDiff is true (no images or color changes?)
>   # Note: for fun, the $rules could also change $reportError and $origText
>   if (!eval $rules) {
>     $errorText = $@;
>     if ($errorText eq '') {
>       # Search for "Unknown Error" for the reason the next line is commented
> #     $errorText = T('Unknown Error (no error text)');
>     }
>     if ($errorText ne '') {
>       $text = $origText;    # Consider: should partial results be kept?
>       if ($reportError) {
>         $text .= '<hr><b>' . T('Local rule error:') . '</b><br>'
>                  . &QuoteHtml($errorText);
>       }
>     }
>   }
>   return $text;
> }
>  
> sub UriEscape {
>   my ($uri) = @_;
>   $uri =~ s/([\x00-\x1f\x7f-\xff])/sprintf("%%%02X", ord($1))/ge;
>   $uri =~ s/\&/\&amp;/g;
>   return $uri;
> }
> 
> sub ParseParagraph {
>   my ($text) = @_;
> 
>   $text = &CommonMarkup($text, 1, 0);   # Multi-line markup
>   $text = &WikiLinesToHtml($text);      # Line-oriented markup
>   return "<p>$text</p>\n";
> }
> 
> sub StoreInterPage {
>   my ($id, $useImage) = @_;
>   my ($link, $extra);
> 
>   ($link, $extra) = &InterPageLink($id, $useImage);
>   # Next line ensures no empty links are stored
>   $link = &StoreRaw($link)  if ($link ne "");
>   return $link . $extra;
> }
> 
> sub InterPageLink {
>   my ($id, $useImage) = @_;
>   my ($name, $site, $remotePage, $url, $punct);
> 
>   ($id, $punct) = &SplitUrlPunct($id);
>   $name = $id;
>   ($site, $remotePage) = split(/:/, $id, 2);
>   $url = &GetSiteUrl($site);
>   return ("", $id . $punct)  if ($url eq "");
>   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
>   $url .= $remotePage;
>   return (&UrlLinkOrImage($url, $name, $useImage), $punct);
> }
> 
> sub StoreBracketInterPage {
>   my ($id, $text, $useImage) = @_;
>   my ($site, $remotePage, $url, $index);
> 
>   ($site, $remotePage) = split(/:/, $id, 2);
>   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
>   $url = &GetSiteUrl($site);
>   if ($text ne "") {
>     return "[$id $text]"  if ($url eq "");
>   } else {
>     return "[$id]"  if ($url eq "");
>     $text = &GetBracketUrlIndex($id);
>   }
>   $url .= $remotePage;
>   if ($BracketImg && $useImage && &ImageAllowed($text)) {
>     $text = "<img src=\"$text\">";
>   } else {
>     $text = "[$text]";
>   }
>   return &StoreRaw("<a href=\"$url\">$text</a>");
> }
> 
> sub GetBracketUrlIndex {
>   my ($id) = @_;
>   my ($index, $key);
> 
>   # Consider plain array?
>   if ($SaveNumUrl{$id} > 0) {
>     return $SaveNumUrl{$id};
>   }
>   $SaveNumUrlIndex++;  # Start with 1
>   $SaveNumUrl{$id} = $SaveNumUrlIndex;
>   return $SaveNumUrlIndex;
> }
> 
> sub GetSiteUrl {
>   my ($site) = @_;
>   my ($data, $status);
> 
>   if (!$InterSiteInit) {
>     ($status, $data) = &ReadFile($InterFile);
>     if ($status) {
>       %InterSite = split(/\s+/, $data);  # Consider defensive code
>     }
>     # Check for definitions to allow file to override automatic settings
>     if (!defined($InterSite{'LocalWiki'})) {
>       $InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
>     }
>     if (!defined($InterSite{'Local'})) {
>       $InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
>     }
>     $InterSiteInit = 1;  # Init only once per request
>   }
>   return $InterSite{$site}  if (defined($InterSite{$site}));
>   return '';
> }
> 
> sub StoreRaw {
>   my ($html) = @_;
> 
>   $SaveUrl{$SaveUrlIndex} = $html;
>   return $FS . $SaveUrlIndex++ . $FS;
> }
> 
> sub StorePre {
>   my ($html, $tag) = @_;
> 
>   return &StoreRaw("<$tag>" . $html . "</$tag>");
> }
> 
> sub StoreHref {
>   my ($anchor, $text) = @_;
> 
>   return "<a" . &StoreRaw($anchor) . ">$text</a>";
> }
> 
> sub StoreUrl {
>   my ($name, $useImage) = @_;
>   my ($link, $extra);
> 
>   ($link, $extra) = &UrlLink($name, $useImage);
>   # Next line ensures no empty links are stored
>   $link = &StoreRaw($link)  if ($link ne "");
>   return $link . $extra;
> }
> 
> sub UrlLink {
>   my ($rawname, $useImage) = @_;
>   my ($name, $punct);
> 
>   ($name, $punct) = &SplitUrlPunct($rawname);
>   if ($LimitFileUrl && ($NetworkFile && $name =~ m|^file:|)) {
>     # Only do remote file:// links. No file:///c|/windows.
>     if ($name =~ m|^file://[^/]|) {
>       return ("<a href=\"$name\">$name</a>", $punct);
>     }
>     return ($rawname, '');
>   }
>   return (&UrlLinkOrImage($name, $name, $useImage), $punct);
> }
> 
> sub UrlLinkOrImage {
>   my ($url, $name, $useImage) = @_;
> 
>   # Restricted image URLs so that mailto:foo@bar.gif is not an image
>   if ($useImage && &ImageAllowed($url)) {
>     return "<img src=\"$url\">";
>   }
>   return "<a href=\"$url\">$name</a>";
> }
> 
> sub ImageAllowed {
>   my ($url) = @_;
>   my ($site, $imagePrefixes);
> 
>   $imagePrefixes = 'http:|https:|ftp:';
>   $imagePrefixes .= '|file:'  if (!$LimitFileUrl);
>   return 0  unless ($url =~ /^($imagePrefixes).+\.$ImageExtensions$/i);
>   return 0  if ($url =~ /"/);      # No HTML-breaking quotes allowed
>   return 1  if (@ImageSites < 1);  # Most common case: () means all allowed
>   return 0  if ($ImageSites[0] eq 'none');  # Special case: none allowed
>   foreach $site (@ImageSites) {
>     return 1  if ($site eq substr($url, 0, length($site)));  # Match prefix
>   }
>   return 0;
> }
> 
> sub StoreBracketUrl {
>   my ($url, $text, $useImage) = @_;
> 
>   if ($text eq "") {
>     $text = &GetBracketUrlIndex($url);
>   } elsif ($text =~ /^$InterLinkPattern$/) {
>     my @interlink = split(/:/, $text, 2);
>     $text = &GetSiteUrl($interlink[0]) . $interlink[1];
>   }
>   if ($BracketImg && $useImage && &ImageAllowed($text)) {
>     $text = "<img src=\"$text\">";
>   } else {
>     $text = "[$text]";
>   }
>   return &StoreRaw("<a href=\"$url\">$text</a>");
> }
> 
> sub StoreBracketLink {
>   my ($name, $text) = @_;
> 
>   return &StoreRaw(&GetPageLinkText($name, "[$text]"));
> }
> 
> sub StoreBracketAnchoredLink {
>   my ($name, $anchor, $text) = @_;
> 
>   return &StoreRaw(&GetPageLinkText("$name#$anchor", "[$text]"));
> }
> 
> sub StorePageOrEditLink {
>   my ($page, $name) = @_;
> 
>   if ($FreeLinks) {
>     $page =~ s/^\s+//;      # Trim extra spaces
>     $page =~ s/\s+$//;
>     $page =~ s|\s*/\s*|/|;  # ...also before/after subpages
>   }
>   $name =~ s/^\s+//;
>   $name =~ s/\s+$//;
>   return &StoreRaw(&GetPageOrEditLink($page, $name));
> }
> 
> sub StoreRFC {
>   my ($num) = @_;
> 
>   return &StoreRaw(&RFCLink($num));
> }
> 
> sub RFCLink {
>   my ($num) = @_;
> 
>   return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\">RFC $num</a>";
> }
> 
> sub StoreUpload {
>   my ($url) = @_;
> 
>   return &StoreRaw(&UploadLink($url));
> }
> 
> sub UploadLink {
>   my ($filename) = @_;
>   my ($html, $url);
>  
>   return $filename  if ($UploadUrl eq '');  # No bad links if misconfigured
>   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
>   $url = $UploadUrl . $filename;
>   $html = '<a href="' . $url . '">';
>   if (&ImageAllowed($url)) {
>     $html .= '<img src="' . $url . '" alt="upload:' . $filename . '">';
>   } else {
>     $html .= 'upload:' . $filename;
>   }
>   $html .= '</a>';
>   return $html;
> }
> 
> sub StoreISBN {
>   my ($num) = @_;
> 
>   return &StoreRaw(&ISBNLink($num));
> }
> 
> sub ISBNALink {
>   my ($num, $pre, $post, $text) = @_;
> 
>   return '<a href="' . $pre . $num . $post . '">' . $text . '</a>';
> }
> 
> sub ISBNLink {
>   my ($rawnum) = @_;
>   my ($rawprint, $html, $num, $numSites, $i);
> 
>   $num = $rawnum;
>   $rawprint = $rawnum;
>   $rawprint =~ s/ +$//;
>   $num =~ s/[- ]//g;
>   $numSites = scalar @IsbnNames;  # Number of entries
>   if ((length($num) != 10) || ($numSites < 1)) {
>     return "ISBN $rawnum";
>   }
>   $html = &ISBNALink($num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint);
>   if ($numSites > 1) {
>     $html .= ' (';
>     $i = 1;
>     while ($i < $numSites) {
>       $html .= &ISBNALink($num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i]);
>       if ($i < ($numSites - 1)) {  # Not the last site
>         $html .= ', ';
>       }
>       $i++;
>     }
>     $html .= ')';
>   }
>   $html .= " "  if ($rawnum =~ / $/);  # Add space if old ISBN had space.
>   return $html;
> }
> 
> sub SplitUrlPunct {
>   my ($url) = @_;
>   my ($punct);
> 
>   if ($url =~ s/\"\"$//) {
>     return ($url, "");   # Delete double-quote delimiters here
>   }
>   $punct = "";
>   if ($NewFS) {
>     ($punct) = ($url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/);
>     $url =~ s/([^a-zA-Z0-9\/\x80-\xff]+)$//;
>   } else {
>     ($punct) = ($url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/);
>     $url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
>   }
>   return ($url, $punct);
> }
> 
> sub StripUrlPunct {
>   my ($url) = @_;
>   my ($junk);
> 
>   ($url, $junk) = &SplitUrlPunct($url);
>   return $url;
> }
> 
> sub WikiHeadingNumber {
>     my ($depth, $text) = @_;
>     my ($anchor, $number);
> 
>     return '' unless --$depth > 0;  # Don't number H1s because it looks stupid
>     while (scalar @HeadingNumbers < ($depth-1)) {
>         push @HeadingNumbers, 1;
>         $TableOfContents .= '<dl><dt> </dt><dd>';
>     }
>     if (scalar @HeadingNumbers < $depth) {
>         push @HeadingNumbers, 0;
>         $TableOfContents .= '<dl><dt> </dt><dd>';
>     }
>     while (scalar @HeadingNumbers > $depth) {
>         pop @HeadingNumbers;
>         $TableOfContents .= "</dd></dl>\n\n";
>     }
>     $HeadingNumbers[$#HeadingNumbers]++;
>     $number = (join '.', @HeadingNumbers) . '. ';
>     # Remove embedded links. THIS IS FRAGILE!
>     $text = &RestoreSavedText($text);
>     $text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si; # No such page syntax
>     $text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
>     # Cook anchor by canonicalizing $text.
>     $anchor = $text;
>     $anchor =~ s/\<.*?\>//g; 
>     $anchor =~ s/\W/_/g;   
>     $anchor =~ s/__+/_/g;
>     $anchor =~ s/^_//;
>     $anchor =~ s/_$//;
>     # Last ditch effort
>     $anchor = '_' . (join '_', @HeadingNumbers) unless $anchor;
>     $TableOfContents .= $number . &ScriptLink("$OpenPageName#$anchor",$text)
>                         . "</dd>\n<dt> </dt><dd>";
>     return &StoreHref(" name=\"$anchor\"") . $number;
> }
> 
> sub WikiHeading {
>   my ($pre, $depth, $text) = @_;
> 
>   $depth = length($depth);
>   $depth = 6  if ($depth > 6);
>   $text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e; # $' == $POSTMATCH
>   return $pre . "<H$depth>$text</H$depth>\n";
> }
> 
> # ==== Difference markup and HTML ====
> sub GetDiffHTML {
>   my ($diffType, $id, $revOld, $revNew, $newText) = @_;
>   my ($html, $diffText, $diffTextTwo, $priorName, $links, $usecomma);
>   my ($major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName);
> 
>   $links = "(";
>   $usecomma = 0;
>   $major  = &ScriptLinkDiff(1, $id, T('major diff'), "");
>   $minor  = &ScriptLinkDiff(2, $id, T('minor diff'), "");
>   $author = &ScriptLinkDiff(3, $id, T('author diff'), "");
>   $useMajor  = 1;
>   $useMinor  = 1;
>   $useAuthor = 1;
>   $diffType = &GetParam("defaultdiff", 1)  if ($diffType == 4);
>   if ($diffType == 1) {
>     $priorName = T('major');
>     $cacheName = 'major';
>     $useMajor  = 0;
>   } elsif ($diffType == 2) {
>     $priorName = T('minor');
>     $cacheName = 'minor';
>     $useMinor  = 0;
>   } elsif ($diffType == 3) {
>     $priorName = T('author');
>     $cacheName = 'author';
>     $useAuthor = 0;
>   }
>   if ($revOld ne "") {
>     # Note: OpenKeptRevisions must have been done by caller.
>     # Eventually optimize if same as cached revision
>     $diffText = &GetKeptDiff($newText, $revOld, 1);  # 1 = get lock
>     if ($diffText eq "") {
>       $diffText = T('(The revisions are identical or unavailable.)');
>     }
>   } else {
>     $diffText  = &GetCacheDiff($cacheName);
>   }
>   $useMajor  = 0  if ($useMajor  && ($diffText eq &GetCacheDiff("major")));
>   $useMinor  = 0  if ($useMinor  && ($diffText eq &GetCacheDiff("minor")));
>   $useAuthor = 0  if ($useAuthor && ($diffText eq &GetCacheDiff("author")));
>   $useMajor  = 0  if ((!defined(&GetPageCache('oldmajor'))) ||
>                       (&GetPageCache("oldmajor") < 1));
>   $useAuthor = 0  if ((!defined(&GetPageCache('oldauthor'))) ||
>                       (&GetPageCache("oldauthor") < 1));
>   if ($useMajor) {
>     $links .= $major;
>     $usecomma = 1;
>   }
>   if ($useMinor) {
>     $links .= ", "  if ($usecomma);
>     $links .= $minor;
>     $usecomma = 1;
>   }
>   if ($useAuthor) {
>     $links .= ", "  if ($usecomma);
>     $links .= $author;
>   }
>   if (!($useMajor || $useMinor || $useAuthor)) {
>     $links .= T('no other diffs');
>   }
>   $links .= ")";
>   if ((!defined($diffText)) || ($diffText eq "")) {
>     $diffText = T('No diff available.');
>   }
>   if ($revOld ne "") {
>     my $currentRevision = T('current revision');
>     $currentRevision = Ts('revision %s', $revNew) if $revNew;
>     $html = '<b>'
>       . Tss("Difference (from revision %1 to %2)", $revOld, $currentRevision)
>       . "</b>\n" . "$links<br>" . &DiffToHTML($diffText);
>   } else {
>     if (($diffType != 2) &&
>         ((!defined(&GetPageCache("old$cacheName"))) ||
>          (&GetPageCache("old$cacheName") < 1))) {
>       $html = '<b>'
>               . Ts('No diff available--this is the first %s revision.',
>                    $priorName) . "</b>\n$links";
>     } else {
>       $html = '<b>'
>               . Ts('Difference (from prior %s revision)', $priorName)
>               . "</b>\n$links<br>" . &DiffToHTML($diffText);
>     }
>   }
>   @HeadingNumbers = ();
>   $TableOfContents = '';
>   return $html;
> }
> 
> sub GetCacheDiff {
>   my ($type) = @_;
>   my ($diffText);
> 
>   $diffText = &GetPageCache("diff_default_$type");
>   $diffText = &GetCacheDiff('minor')  if ($diffText eq "1");
>   $diffText = &GetCacheDiff('major')  if ($diffText eq "2");
>   return $diffText;
> }
> 
> # Must be done after minor diff is set and OpenKeptRevisions called
> sub GetKeptDiff {
>   my ($newText, $oldRevision, $lock) = @_;
>   my (%sect, %data, $oldText);
> 
>   $oldText = "";
>   if (defined($KeptRevisions{$oldRevision})) {
>     %sect = split(/$FS2/, $KeptRevisions{$oldRevision}, -1);
>     %data = split(/$FS3/, $sect{'data'}, -1);
>     $oldText = $data{'text'};
>   }
>   return ""  if ($oldText eq "");  # Old revision not found
>   return &GetDiff($oldText, $newText, $lock);
> }
> 
> sub GetDiff {
>   my ($old, $new, $lock) = @_;
>   my ($diff_out, $oldName, $newName);
> 
>   &CreateDir($TempDir);
>   $oldName = "$TempDir/old_diff";
>   $newName = "$TempDir/new_diff";
>   if ($lock) {
>     &RequestDiffLock() or return "";
>     $oldName .= "_locked";
>     $newName .= "_locked";
>   }
>   &WriteStringToFile($oldName, $old);
>   &WriteStringToFile($newName, $new);
>   $diff_out = `diff $oldName $newName`;
>   &ReleaseDiffLock()  if ($lock);
>   $diff_out =~ s/\\ No newline.*\n//g;   # Get rid of common complaint.
>   # No need to unlink temp files--next diff will just overwrite.
>   return $diff_out;
> }
> 
> sub DiffToHTML {
>   my ($html) = @_;
>   my ($tChanged, $tRemoved, $tAdded);
> 
>   $tChanged = T('Changed:');
>   $tRemoved = T('Removed:');
>   $tAdded   = T('Added:');
>   $html =~ s/\n--+//g;
>   # Note: Need spaces before <br> to be different from diff section.
>   $html =~ s/(^|\n)(\d+.*c.*)/$1 <br><strong>$tChanged $2<\/strong><br>/g;
>   $html =~ s/(^|\n)(\d+.*d.*)/$1 <br><strong>$tRemoved $2<\/strong><br>/g;
>   $html =~ s/(^|\n)(\d+.*a.*)/$1 <br><strong>$tAdded $2<\/strong><br>/g;
>   $html =~ s/\n((<.*\n)+)/&ColorDiff($1, $DiffColor1, 0)/ge;
>   $html =~ s/\n((>.*\n)+)/&ColorDiff($1, $DiffColor2, 1)/ge;
>   return $html;
> }
> 
> sub ColorDiff {
>   my ($diff, $color, $type) = @_;
>   my ($colorHtml, $classHtml);
> 
>   $diff =~ s/(^|\n)[<>]/$1/g;
>   $diff = &QuoteHtml($diff);
>   # Do some of the Wiki markup rules:
>   %SaveUrl = ();
>   %SaveNumUrl = ();
>   $SaveUrlIndex = 0;
>   $SaveNumUrlIndex = 0;
>   $diff = &RemoveFS($diff);
>   $diff = &CommonMarkup($diff, 0, 1);      # No images, all patterns
>   if ($LateRules ne '') {
>     $diff = &EvalLocalRules($LateRules, $diff, 1);
>   }
>   1 while $diff =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
>   $diff =~ s/\r?\n/<br>/g;
>   $colorHtml = '';
>   if ($color ne '') {
>     $colorHtml = " bgcolor=$color";
>   }
>   if ($type) {
>     $classHtml = ' class=wikidiffnew';
>   } else {
>     $classHtml = ' class=wikidiffold';
>   }
>   return "<table width=\"95\%\"$colorHtml$classHtml><tr><td>\n" . $diff
>          . "</td></tr></table>\n";
> }
> 
> # ==== Database (Page, Section, Text, Kept, User) functions ====
> sub OpenNewPage {
>   my ($id) = @_;
> 
>   %Page = ();
>   $Page{'version'} = 3;      # Data format version
>   $Page{'revision'} = 0;     # Number of edited times
>   $Page{'tscreate'} = $Now;  # Set once at creation
>   $Page{'ts'} = $Now;        # Updated every edit
> }
> 
> sub OpenNewSection {
>   my ($name, $data) = @_;
> 
>   %Section = ();
>   $Section{'name'} = $name;
>   $Section{'version'} = 1;      # Data format version
>   $Section{'revision'} = 0;     # Number of edited times
>   $Section{'tscreate'} = $Now;  # Set once at creation
>   $Section{'ts'} = $Now;        # Updated every edit
>   $Section{'ip'} = $ENV{REMOTE_ADDR};
>   $Section{'host'} = '';        # Updated only for real edits (can be slow)
>   $Section{'id'} = $UserID;
>   $Section{'username'} = &GetParam("username", "");
>   $Section{'data'} = $data;
>   $Page{$name} = join($FS2, %Section);  # Replace with save?
> }
> 
> sub OpenNewText {
>   my ($name) = @_;  # Name of text (usually "default")
>   %Text = ();
>   if ($NewText ne '') {
>     $Text{'text'} = T($NewText);
>   } else {
>     $Text{'text'} = T('Describe the new page here.') . "\n";
>   }
>   $Text{'text'} .= "\n"  if (substr($Text{'text'}, -1, 1) ne "\n");
>   $Text{'minor'} = 0;      # Default as major edit
>   $Text{'newauthor'} = 1;  # Default as new author
>   $Text{'summary'} = '';
>   &OpenNewSection("text_$name", join($FS3, %Text));
> }
> 
> sub GetPageFile {
>   my ($id) = @_;
> 
>   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
> }
> 
> sub OpenPage {
>   my ($id) = @_;
>   my ($fname, $data);
> 
>   if ($OpenPageName eq $id) {
>     return;
>   }
>   %Section = ();
>   %Text = ();
>   $fname = &GetPageFile($id);
>   if (-f $fname) {
>     $data = &ReadFileOrDie($fname);
>     %Page = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>   } else {
>     &OpenNewPage($id);
>   }
>   if ($Page{'version'} != 3) {
>     &UpdatePageVersion();
>   }
>   $OpenPageName = $id;
> }
> 
> sub OpenSection {
>   my ($name) = @_;
> 
>   if (!defined($Page{$name})) {
>     &OpenNewSection($name, "");
>   } else {
>     %Section = split(/$FS2/, $Page{$name}, -1);
>   }
> }
> 
> sub OpenText {
>   my ($name) = @_;
> 
>   if (!defined($Page{"text_$name"})) {
>     &OpenNewText($name);
>   } else {
>     &OpenSection("text_$name");
>     %Text = split(/$FS3/, $Section{'data'}, -1);
>   }
> }
> 
> sub OpenDefaultText {
>   &OpenText('default');
> }
> 
> # Called after OpenKeptRevisions
> sub OpenKeptRevision {
>   my ($revision) = @_;
> 
>   %Section = split(/$FS2/, $KeptRevisions{$revision}, -1);
>   %Text = split(/$FS3/, $Section{'data'}, -1);
> }
> 
> sub GetPageCache {
>   my ($name) = @_;
> 
>   return $Page{"cache_$name"};
> }
> 
> # Always call SavePage within a lock.
> sub SavePage {
>   my $file = &GetPageFile($OpenPageName);
> 
>   $Page{'revision'} += 1;    # Number of edited times
>   $Page{'ts'} = $Now;        # Updated every edit
>   &CreatePageDir($PageDir, $OpenPageName);
>   &WriteStringToFile($file, join($FS1, %Page));
> }
> 
> sub SaveSection {
>   my ($name, $data) = @_;
> 
>   $Section{'revision'} += 1;   # Number of edited times
>   $Section{'ts'} = $Now;       # Updated every edit
>   $Section{'ip'} = $ENV{REMOTE_ADDR};
>   $Section{'id'} = $UserID;
>   $Section{'username'} = &GetParam("username", "");
>   $Section{'data'} = $data;
>   $Page{$name} = join($FS2, %Section);
> }
> 
> sub SaveText {
>   my ($name) = @_;
> 
>   &SaveSection("text_$name", join($FS3, %Text));
> }
> 
> sub SaveDefaultText {
>   &SaveText('default');
> }
> 
> sub SetPageCache {
>   my ($name, $data) = @_;
> 
>   $Page{"cache_$name"} = $data;
> }
> 
> sub UpdatePageVersion {
>   &ReportError(T('Bad page version (or corrupt page).'));
> }
> 
> sub KeepFileName {
>   return $KeepDir . "/" . &GetPageDirectory($OpenPageName)
>          . "/$OpenPageName.kp";
> }
> 
> sub SaveKeepSection {
>   my $file = &KeepFileName();
>   my $data;
> 
>   return  if ($Section{'revision'} < 1);  # Don't keep "empty" revision
>   $Section{'keepts'} = $Now;
>   $data = $FS1 . join($FS2, %Section);
>   &CreatePageDir($KeepDir, $OpenPageName);
>   &AppendStringToFileLimited($file, $data, $KeepSize);
> }
> 
> sub ExpireKeepFile {
>   my ($fname, $data, @kplist, %tempSection, $expirets);
>   my ($anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev);
>   my ($oldMajor, $oldAuthor);
> 
>   $fname = &KeepFileName();
>   return  if (!(-f $fname));
>   $data = &ReadFileOrDie($fname);
>   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>   return  if (length(@kplist) < 1);  # Also empty
>   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
>   return  if (length(@kplist) < 1);  # Also empty
>   %tempSection = split(/$FS2/, $kplist[0], -1);
>   if (!defined($tempSection{'keepts'})) {
>     return;  # Bad keep file
>   }
>   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
>   return  if ($tempSection{'keepts'} >= $expirets);  # Nothing old enough
>   $anyExpire = 0;
>   $anyKeep   = 0;
>   %keepFlag  = ();
>   $oldMajor  = &GetPageCache('oldmajor');
>   $oldAuthor = &GetPageCache('oldauthor');
>   foreach (reverse @kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     $sectRev = $tempSection{'revision'};
>     $expire = 0;
>     if ($sectName eq "text_default") {
>       if (($KeepMajor  && ($sectRev == $oldMajor)) ||
>           ($KeepAuthor && ($sectRev == $oldAuthor))) {
>         $expire = 0;
>       } elsif ($tempSection{'keepts'} < $expirets) {
>         $expire = 1;
>       }
>     } else {
>       if ($tempSection{'keepts'} < $expirets) {
>         $expire = 1;
>       }
>     }
>     if (!$expire) {
>       $keepFlag{$sectRev . "," . $sectName} = 1;
>       $anyKeep = 1;
>     } else {
>       $anyExpire = 1;
>     }
>   }
>   if (!$anyKeep) {  # Empty, so remove file
>     unlink($fname);
>     return;
>   }
>   return  if (!$anyExpire);  # No sections expired
>   open (OUT, ">$fname") or die (Ts('cant write %s', $fname) . ": $!");
>   foreach (@kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     $sectRev = $tempSection{'revision'};
>     if ($keepFlag{$sectRev . "," . $sectName}) {
>       print OUT $FS1, $_;
>     }
>   }
>   close(OUT);
> }
> 
> sub OpenKeptList {
>   my ($fname, $data);
> 
>   @KeptList = ();
>   $fname = &KeepFileName();
>   return  if (!(-f $fname));
>   $data = &ReadFileOrDie($fname);
>   @KeptList = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
> }
> 
> sub OpenKeptRevisions {
>   my ($name) = @_;  # Name of section
>   my ($fname, $data, %tempSection);
> 
>   %KeptRevisions = ();
>   &OpenKeptList();
>   foreach (@KeptList) {
>     %tempSection = split(/$FS2/, $_, -1);
>     next  if ($tempSection{'name'} ne $name);
>     $KeptRevisions{$tempSection{'revision'}} = $_;
>   }
> }
> 
> sub LoadUserData {
>   my ($data, $status);
> 
>   %UserData = ();
>   ($status, $data) = &ReadFile(&UserDataFilename($UserID));
>   if (!$status) {
>     $UserID = 112;  # Could not open file.  Consider warning message?
>     return;
>   }
>   %UserData = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
> }
> 
> sub UserDataFilename {
>   my ($id) = @_;
> 
>   return ""  if ($id < 1);
>   return $UserDir . "/" . ($id % 10) . "/$id.db";
> }
> 
> # ==== Misc. functions ====
> sub ReportError {
>   my ($errmsg) = @_;
> 
>   print $q->header, $q->start_html, "<H2>", &QuoteHtml($errmsg), "</H2>", $q->end_html;
> }
> 
> sub ValidId {
>   my ($id) = @_;
> 
>   if (length($id) > 120) {
>     return Ts('Page name is too long: %s', $id);
>   }
>   if ($id =~ m| |) {
>     return Ts('Page name may not contain space characters: %s', $id);
>   }
>   if ($UseSubpage) {
>     if ($id =~ m|.*/.*/|) {
>       return Ts('Too many / characters in page %s', $id);
>     }
>     if ($id =~ /^\//) {
>       return Ts('Invalid Page %s (subpage without main page)', $id);
>     }
>     if ($id =~ /\/$/) {
>       return Ts('Invalid Page %s (missing subpage name)', $id);
>     }
>   }
>   if ($FreeLinks) {
>     $id =~ s/ /_/g;
>     if (!$UseSubpage) {
>       if ($id =~ /\//) {
>         return Ts('Invalid Page %s (/ not allowed)', $id);
>       }
>     }
>     if (!($id =~ m|^$FreeLinkPattern$|)) {
>       return Ts('Invalid Page %s', $id);
>     }
>     if ($id =~ m|\.db$|) {
>       return Ts('Invalid Page %s (must not end with .db)', $id);
>     }
>     if ($id =~ m|\.lck$|) {
>       return Ts('Invalid Page %s (must not end with .lck)', $id);
>     }
>     return "";
>   } else {
>     if (!($id =~ /^$LinkPattern$/)) {
>       return Ts('Invalid Page %s', $id);
>     }
>   }
>   return "";
> }
> 
> sub ValidIdOrDie {
>   my ($id) = @_;
>   my $error;
> 
>   $error = &ValidId($id);
>   if ($error ne "") {
>     &ReportError($error);
>     return 0;
>   }
>   return 1;
> }
> 
> sub UserCanEdit {
>   my ($id, $deepCheck) = @_;
> 
>   # Optimized for the "everyone can edit" case (don't check passwords)
>   if (($id ne "") && (-f &GetLockedPageFile($id))) {
>     return 1  if (&UserIsAdmin());  # Requires more privledges
>     # Consider option for editor-level to edit these pages?
>     return 0;
>   }
>   if (!$EditAllowed) {
>     return 1  if (&UserIsEditor());
>     return 0;
>   }
>   if (-f "$DataDir/noedit") {
>     return 1  if (&UserIsEditor());
>     return 0;
>   }
>   if ($deepCheck) {   # Deeper but slower checks (not every page)
>     return 1  if (&UserIsEditor());
>     return 0  if (&UserIsBanned());
>   }
>   return 1;
> }
> 
> sub UserIsBanned {
>   my ($host, $ip, $data, $status);
> 
>   ($status, $data) = &ReadFile("$DataDir/banlist");
>   return 0  if (!$status);  # No file exists, so no ban
>   $data =~ s/\r//g;
>   $ip = $ENV{'REMOTE_ADDR'};
>   $host = &GetRemoteHost(0);
>   foreach (split(/\n/, $data)) {
>     next  if ((/^\s*$/) || (/^#/));  # Skip empty, spaces, or comments
>     return 1  if ($ip   =~ /$_/i);
>     return 1  if ($host =~ /$_/i);
>   }
>   return 0;
> }
> 
> sub UserIsAdmin {
>   my (@pwlist, $userPassword);
> 
>   return 0  if ($AdminPass eq "");
>   $userPassword = &GetParam("adminpw", "");
>   return 0  if ($userPassword eq "");
>   foreach (split(/\s+/, $AdminPass)) {
>     next  if ($_ eq "");
>     return 1  if ($userPassword eq $_);
>   }
>   return 0;
> }
> 
> sub UserIsEditor {
>   my (@pwlist, $userPassword);
> 
>   return 1  if (&UserIsAdmin());             # Admin includes editor
>   return 0  if ($EditPass eq "");
>   $userPassword = &GetParam("adminpw", "");  # Used for both
>   return 0  if ($userPassword eq "");
>   foreach (split(/\s+/, $EditPass)) {
>     next  if ($_ eq "");
>     return 1  if ($userPassword eq $_);
>   }
>   return 0;
> }
> 
> sub UserCanUpload {
>   return 1  if (&UserIsEditor());
>   return $AllUpload;
> }
> 
> sub GetLockedPageFile {
>   my ($id) = @_;
> 
>   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
> }
> 
> sub RequestLockDir {
>   my ($name, $tries, $wait, $errorDie) = @_;
>   my ($lockName, $n);
> 
>   &CreateDir($TempDir);
>   $lockName = $LockDir . $name;
>   $n = 0;
>   while (mkdir($lockName, 0555) == 0) {
>     if ($! != 17) {
>       die(Ts('can not make %s', $LockDir) . ": $!\n")  if $errorDie;
>       return 0;
>     }
>     return 0  if ($n++ >= $tries); 
>     sleep($wait);
>   }
>   return 1;
> }
> 
> sub ReleaseLockDir {
>   my ($name) = @_;
> 
>   rmdir($LockDir . $name);
> }
> 
> sub RequestLock {
>   # 10 tries, 3 second wait, possibly die on error
>   return &RequestLockDir("main", 10, 3, $LockCrash);
> }
> 
> sub ReleaseLock {
>   &ReleaseLockDir('main');
> }
> 
> sub ForceReleaseLock {
>   my ($name) = @_;
>   my $forced;
> 
>   # First try to obtain lock (in case of normal edit lock)
>   # 5 tries, 3 second wait, do not die on error
>   $forced = !&RequestLockDir($name, 5, 3, 0);
>   &ReleaseLockDir($name);  # Release the lock, even if we didn't get it.
>   return $forced;
> }
> 
> sub RequestCacheLock {
>   # 4 tries, 2 second wait, do not die on error
>   return &RequestLockDir('cache', 4, 2, 0);
> }
> 
> sub ReleaseCacheLock {
>   &ReleaseLockDir('cache');
> }
> 
> sub RequestDiffLock {
>   # 4 tries, 2 second wait, do not die on error
>   return &RequestLockDir('diff', 4, 2, 0);
> }
> 
> sub ReleaseDiffLock {
>   &ReleaseLockDir('diff');
> }
> 
> # Index lock is not very important--just return error if not available
> sub RequestIndexLock {
>   # 1 try, 2 second wait, do not die on error
>   return &RequestLockDir('index', 1, 2, 0);
> }
> 
> sub ReleaseIndexLock {
>   &ReleaseLockDir('index');
> }
> 
> sub ReadFile {
>   my ($fileName) = @_;
>   my ($data);
>   local $/ = undef;   # Read complete files
> 
>   if (open(IN, "<$fileName")) {
>     $data=<IN>;
>     close IN;
>     return (1, $data);
>   }
>   return (0, "");
> }
> 
> sub ReadFileOrDie {
>   my ($fileName) = @_;
>   my ($status, $data);
> 
>   ($status, $data) = &ReadFile($fileName);
>   if (!$status) {
>     die(Ts('Can not open %s', $fileName) . ": $!");
>   }
>   return $data;
> }
> 
> sub WriteStringToFile {
>   my ($file, $string) = @_;
> 
>   open (OUT, ">$file") or die(Ts('cant write %s', $file) . ": $!");
>   print OUT  $string;
>   close(OUT);
> }
> 
> sub AppendStringToFile {
>   my ($file, $string) = @_;
> 
>   open (OUT, ">>$file") or die(Ts('cant write %s', $file) . ": $!");
>   print OUT  $string;
>   close(OUT);
> }
> 
> sub AppendStringToFileLimited {
>   my ($file, $string, $limit) = @_;
> 
>   if (($limit < 1) || (((-s $file) + length($string)) <= $limit)) {
>     &AppendStringToFile($file, $string);
>   }
> }
> 
> sub CreateDir {
>   my ($newdir) = @_;
> 
>   mkdir($newdir, 0775)  if (!(-d $newdir));
> }
> 
> sub CreatePageDir {
>   my ($dir, $id) = @_;
>   my $subdir;
> 
>   &CreateDir($dir);  # Make sure main page exists
>   $subdir = $dir . "/" . &GetPageDirectory($id);
>   &CreateDir($subdir);
>   if ($id =~ m|([^/]+)/|) {
>     $subdir = $subdir . "/" . $1;
>     &CreateDir($subdir);
>   }
> }
> 
> sub UpdateHtmlCache {
>   my ($id, $html) = @_;
>   my $idFile;
> 
>   $idFile = &GetHtmlCacheFile($id);
>   &CreatePageDir($HtmlDir, $id);
>   if (&RequestCacheLock()) {
>     &WriteStringToFile($idFile, $html);
>     &ReleaseCacheLock();
>   }
> }
> 
> sub GenerateAllPagesList {
>   my (@pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId);
> 
>   @pages = ();
>   if ($FastGlob) {
>     # The following was inspired by the FastGlob code by Marc W. Mengel.
>     # Thanks to Bob Showalter for pointing out the improvement.
>     opendir(PAGELIST, $PageDir);
>     @dirs = readdir(PAGELIST);
>     closedir(PAGELIST);
>     @dirs = sort(@dirs);
>     foreach $dir (@dirs) {
>       next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs or files
>       opendir(PAGELIST, "$PageDir/$dir");
>       @pageFiles = readdir(PAGELIST);
>       closedir(PAGELIST);
>       foreach $id (@pageFiles) {
>         next  if (($id eq '.') || ($id eq '..'));
>         if (substr($id, -3) eq '.db') {
>           push(@pages, substr($id, 0, -3));
>         } elsif (substr($id, -4) ne '.lck') {
>           opendir(PAGELIST, "$PageDir/$dir/$id");
>           @subpageFiles = readdir(PAGELIST);
>           closedir(PAGELIST);
>           foreach $subId (@subpageFiles) {
>             if (substr($subId, -3) eq '.db') {
>               push(@pages, "$id/" . substr($subId, 0, -3));
>             }
>           }
>         }
>       }
>     }
>   } else {
>     # Old slow/compatible method.
>     @dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
>     foreach $dir (@dirs) {
>       if (-e "$PageDir/$dir") {  # Thanks to Tim Holt
>         while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
>           s|^$PageDir/||;
>           m|^[^/]+/(\S*).db|;
>           $id = $1;
>           push(@pages, $id);
>         }
>       }
>     }
>   }
>   return sort(@pages);
> }
> 
> sub AllPagesList {
>   my ($rawIndex, $refresh, $status);
> 
>   if (!$UseIndex) {
>     return &GenerateAllPagesList();
>   }
>   $refresh = &GetParam("refresh", 0);
>   if ($IndexInit && !$refresh) {
>     # Note for mod_perl: $IndexInit is reset for each query
>     # Eventually consider some timestamp-solution to keep cache?
>     return @IndexList;
>   }
>   if ((!$refresh) && (-f $IndexFile)) {
>     ($status, $rawIndex) = &ReadFile($IndexFile);
>     if ($status) {
>       %IndexHash = split(/\s+/, $rawIndex);
>       @IndexList = sort(keys %IndexHash);
>       $IndexInit = 1;
>       return @IndexList;
>     }
>     # If open fails just refresh the index
>   }
>   @IndexList = ();
>   %IndexHash = ();
>   @IndexList = &GenerateAllPagesList();
>   foreach (@IndexList) {
>     $IndexHash{$_} = 1;
>   }
>   $IndexInit = 1;  # Initialized for this run of the script
>   # Try to write out the list for future runs
>   &RequestIndexLock() or return @IndexList;
>   &WriteStringToFile($IndexFile, join(" ", %IndexHash));
>   &ReleaseIndexLock();
>   return @IndexList;
> }
> 
> sub CalcDay {
>   my ($ts) = @_;
> 
>   $ts += $TimeZoneOffset;
>   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
>   if ($NumberDates) {
>     return ($year + 1900) . '-' . ($mon+1) . '-' . $mday;
>   }
>   return ("January", "February", "March", "April", "May", "June",
>           "July", "August", "September", "October", "November",
>           "December")[$mon]. " " . $mday . ", " . ($year+1900);
> }
> 
> sub CalcTime {
>   my ($ts) = @_;
>   my ($ampm, $mytz);
> 
>   $ts += $TimeZoneOffset;
>   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
>   $mytz = "";
>   if (($TimeZoneOffset == 0) && ($ScriptTZ ne "")) {
>     $mytz = " " . $ScriptTZ;
>   }
>   $ampm = "";
>   if ($UseAmPm) {
>     $ampm = " am";
>     if ($hour > 11) {
>       $ampm = " pm";
>       $hour = $hour - 12;
>     }
>     $hour = 12   if ($hour == 0);
>   }
>   $min = "0" . $min   if ($min<10);
>   return $hour . ":" . $min . $ampm . $mytz;
> }
> 
> sub TimeToText {
>   my ($t) = @_;
> 
>   return &CalcDay($t) . " " . &CalcTime($t);
> }
> 
> sub GetParam {
>   my ($name, $default) = @_;
>   my $result;
> 
>   $result = $q->param($name);
>   if (!defined($result)) {
>     if (defined($UserData{$name})) {
>       $result = $UserData{$name};
>     } else {
>       $result = $default;
>     }
>   }
>   return $result;
> }
> 
> sub GetHiddenValue {
>   my ($name, $value) = @_;
> 
>   $q->param($name, $value);
>   return $q->hidden($name);
> }
> 
> sub GetRemoteHost {
>   my ($doMask) = @_;
>   my ($rhost, $iaddr);
> 
>   $rhost = $ENV{REMOTE_HOST};
>   if ($UseLookup && ($rhost eq "")) {
>     # Catch errors (including bad input) without aborting the script
>     eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
>          . '$rhost = gethostbyaddr($iaddr, AF_INET)';
>   }
>   if ($rhost eq "") {
>     $rhost = $ENV{REMOTE_ADDR};
>   }
>   $rhost = &GetMaskedHost($rhost)  if ($doMask);
>   return $rhost;
> }
> 
> sub FreeToNormal {
>   my ($id) = @_;
> 
>   $id =~ s/ /_/g;
>   $id = ucfirst($id)  if ($UpperFirst || $FreeUpper);
>   if (index($id, '_') > -1) {  # Quick check for any space/underscores
>     $id =~ s/__+/_/g;
>     $id =~ s/^_//;
>     $id =~ s/_$//;
>     if ($UseSubpage) {
>       $id =~ s|_/|/|g;
>       $id =~ s|/_|/|g;
>     }
>   }
>   if ($FreeUpper) {
>     # Note that letters after ' are *not* capitalized
>     if ($id =~ m|[-_.,\(\)/][a-z]|) {    # Quick check for non-canonical case
>       $id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
>     }
>   }
>   return $id;
> }
> #END_OF_BROWSE_CODE
> 
> # == Page-editing and other special-action code ========================
> $OtherCode = ""; # Comment next line to always compile (slower)
> #$OtherCode = <<'#END_OF_OTHER_CODE';
> 
> sub DoOtherRequest {
>   my ($id, $action, $text, $search);
> 
>   $action = &GetParam("action", "");
>   $id = &GetParam("id", "");
>   if ($action ne "") {
>     $action = lc($action);
>     if      ($action eq "edit") {
>       &DoEdit($id, 0, 0, "", 0)  if &ValidIdOrDie($id);
>     } elsif ($action eq "unlock") {
>       &DoUnlock();
>     } elsif ($action eq "index") {
>       &DoIndex();
>     } elsif ($action eq "links") {
>       &DoLinks();
>     } elsif ($action eq "maintain") {
>       &DoMaintain();
>     } elsif ($action eq "pagelock") {
>       &DoPageLock();
>     } elsif ($action eq "editlock") {
>       &DoEditLock();
>     } elsif ($action eq "editprefs") {
>       &DoEditPrefs();
>     } elsif ($action eq "editbanned") {
>       &DoEditBanned();
>     } elsif ($action eq "editlinks") {
>       &DoEditLinks();
>     } elsif ($action eq "login") {
>       &DoEnterLogin();
>     } elsif ($action eq "newlogin") {
>       $UserID = 0;
>       &DoEditPrefs();  # Also creates new ID
>     } elsif ($action eq "version") {
>       &DoShowVersion();
>     } elsif ($action eq "rss") {
>       &DoRss();
>     } elsif ($action eq "delete") {
>       &DoDeletePage($id);
>     } elsif ($UseUpload && ($action eq "upload")) {
>       &DoUpload();
>     } elsif ($action eq "maintainrc") {
>       &DoMaintainRc();
>     } elsif ($action eq "convert") {
>       &DoConvert();
>     } elsif ($action eq "trimusers") {
>       &DoTrimUsers();
>     } else {
>       &ReportError(Ts('Invalid action parameter %s', $action));
>     }
>     return;
>   }
>   if (&GetParam("edit_prefs", 0)) {
>     &DoUpdatePrefs();
>     return;
>   }
>   if (&GetParam("edit_ban", 0)) {
>     &DoUpdateBanned();
>     return;
>   }
>   if (&GetParam("enter_login", 0)) {
>     &DoLogin();
>     return;
>   }
>   if (&GetParam("edit_links", 0)) {
>     &DoUpdateLinks();
>     return;
>   }
>   if ($UseUpload && (&GetParam("upload", 0))) {
>     &SaveUpload();
>     return;
>   }
>   $search = &GetParam("search", "");
>   if (($search ne "") || (&GetParam("dosearch", "") ne "")) {
>     &DoSearch($search);
>     return;
>   } else {
>     $search = &GetParam("back","");
>     if ($search ne "") {
>       &DoBackLinks($search);
>       return;
>     }
>   }
>   # Handle posted pages
>   if (&GetParam("oldtime", "") ne "") {
>     $id = &GetParam("title", "");
>     &DoPost()  if &ValidIdOrDie($id);
>     return;
>   }
>   &ReportError(T('Invalid URL.'));
> }
> 
> sub DoEdit {
>   my ($id, $isConflict, $oldTime, $newText, $preview) = @_;
>   my ($header, $editRows, $editCols, $userName, $revision, $oldText);
>   my ($summary, $isEdit, $pageTime);
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);  # Take care of users like Markus Lude :-)
>   }
>   if (!&UserCanEdit($id, 1)) {
>     print &GetHeader('', T('Editing Denied'), '');
>     if (&UserIsBanned()) {
>       print T('Editing not allowed: user, ip, or network is blocked.');
>       print "<p>";
>       print T('Contact the wiki administrator for more information.');
>     } else {
>       print Ts('Editing not allowed: %s is read-only.', $SiteName);
>     }
>     print &GetCommonFooter();
>     return;
>   }
>   # Consider sending a new user-ID cookie if user does not have one
>   &OpenPage($id);
>   &OpenDefaultText();
>   $pageTime = $Section{'ts'};
>   $header = Ts('Editing %s', $id);
>   # Old revision handling
>   $revision = &GetParam('revision', '');
>   $revision =~ s/\D//g;  # Remove non-numeric chars
>   if ($revision ne '') {
>     &OpenKeptRevisions('text_default');
>     if (!defined($KeptRevisions{$revision})) {
>       $revision = '';
>       # Consider better solution like error message?
>     } else {
>       &OpenKeptRevision($revision);
>       $header = Ts('Editing revision %s of ', $revision ) . $id;
>     }
>   }
>   $oldText = $Text{'text'};
>   if ($preview && !$isConflict) {
>     $oldText = $newText;
>   }
>   $editRows = &GetParam("editrows", 20);
>   $editCols = &GetParam("editcols", 65);
>   print &GetHeader($id, &QuoteHtml($header), '');
>   if ($revision ne '') {
>     print "\n<b>"
>           . Ts('Editing old revision %s.', $revision) . "  "
>     . T('Saving this page will replace the latest revision with this text.')
>           . '</b><br>'
>   }
>   if ($isConflict) {
>     $editRows -= 10  if ($editRows > 19);
>     print "\n<H1>" . T('Edit Conflict!') . "</H1>\n";
>     if ($isConflict>1) {
>       # The main purpose of a new warning is to display more text
>       # and move the save button down from its old location.
>       print "\n<H2>" . T('(This is a new conflict)') . "</H2>\n";
>     }
>     print "<p><strong>",
>           T('Someone saved this page after you started editing.'), " ",
>           T('The top textbox contains the saved text.'), " ",
>           T('Only the text in the top textbox will be saved.'),
>           "</strong><br>\n",
>           T('Scroll down to see your edited text.'), "<br>\n";
>     print T('Last save time:'), ' ', &TimeToText($oldTime),
>           " (", T('Current time is:'), ' ', &TimeToText($Now), ")<br>\n";
>   }
>   print &GetFormStart();
>   print &GetHiddenValue("title", $id), "\n",
>         &GetHiddenValue("oldtime", $pageTime), "\n",
>         &GetHiddenValue("oldconflict", $isConflict), "\n";
>   if ($revision ne "") {
>     print &GetHiddenValue("revision", $revision), "\n";
>   }
>   print &GetTextArea('text', $oldText, $editRows, $editCols);
>   $summary = &GetParam("summary", "*");
>   print "<p>", T('Summary:'),
>         $q->textfield(-name=>'summary',
>                       -default=>$summary, -override=>1,
>                       -size=>60, -maxlength=>200);
>   if (&GetParam("recent_edit") eq "on") {
>     print "<br>", $q->checkbox(-name=>'recent_edit', -checked=>1,
>                                -label=>T('This change is a minor edit.'));
>   } else {
>     print "<br>", $q->checkbox(-name=>'recent_edit',
>                                -label=>T('This change is a minor edit.'));
>   }
>   if ($EmailNotify) {
>     print "&nbsp;&nbsp;&nbsp;" .
>            $q->checkbox(-name=> 'do_email_notify',
>       -label=>Ts('Send email notification that %s has been changed.', $id));
>   }
>   print "<br>";
>   if ($EditNote ne '') {
>     print T($EditNote) . '<br>';  # Allow translation
>   }
>   print $q->submit(-name=>'Save', -value=>T('Save')), "\n";
>   $userName = &GetParam("username", "");
>   if ($userName ne "") {
>     print ' (', T('Your user name is'), ' ',
>           &GetPageLink($userName) . ') ';
>   } else {
>     print ' (', Ts('Visit %s to set your user name.', &GetPrefsLink(), 1), ') ';
>   }
>   print $q->submit(-name=>'Preview', -value=>T('Preview')), "\n";
>   if ($isConflict) {
>     print "\n<br><hr><p><strong>", T('This is the text you submitted:'),
>           "</strong><p>",
>           &GetTextArea('newtext', $newText, $editRows, $editCols),
>           "<p>\n";
>   }
>   if ($preview) {
>     print '<div class=wikipreview>';
>     print "<hr class=wikilinepreview>\n";
>     print "<h2>", T('Preview:'), "</h2>\n";
>     if ($isConflict) {
>       print "<b>",
>             T('NOTE: This preview shows the revision of the other author.'),
>             "</b><hr>\n";
>     }
>     $MainPage = $id;
>     $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
>     print &WikiToHTML($oldText) . "<hr class=wikilinepreview>\n";
>     print "<h2>", T('Preview only, not yet saved'), "</h2>\n";
>     print '</div>';
>   }
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetHistoryLink($id, T('View other revisions')) . "<br>\n";
>     print &GetGotoBar($id);
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub GetTextArea {
>   my ($name, $text, $rows, $cols) = @_;
> 
>   if (&GetParam("editwide", 1)) {
>     return $q->textarea(-name=>$name, -default=>$text,
>                         -rows=>$rows, -columns=>$cols, -override=>1,
>                         -style=>'width:100%', -wrap=>'virtual');
>   }
>   return $q->textarea(-name=>$name, -default=>$text,
>                       -rows=>$rows, -columns=>$cols, -override=>1,
>                       -wrap=>'virtual');
> }
> 
> sub DoEditPrefs {
>   my ($check, $recentName, %labels);
> 
>   $recentName = $RCName;
>   $recentName =~ s/_/ /g;
>   &DoNewLogin()  if ($UserID < 400);
>   print &GetHeader('', T('Editing Preferences'), '');
>   print '<div class=wikipref>';
>   print &GetFormStart();
>   print GetHiddenValue("edit_prefs", 1), "\n";
>   print '<b>' . T('User Information:') . "</b>\n";
>   print '<br>' . Ts('Your User ID number: %s', $UserID) . "\n";
>   print '<br>' . T('UserName:') . ' ', &GetFormText('username', "", 20, 50);
>   print ' ' . T('(blank to remove, or valid page name)');
>   print '<br>' . T('Set Password:') . ' ',
>         $q->password_field(-name=>'p_password', -value=>'*', 
>                            -size=>15, -maxlength=>50),
>         ' ', T('(blank to remove password)'), '<br>(',
>         T('Passwords allow sharing preferences between multiple systems.'),
>         ' ', T('Passwords are completely optional.'), ')';
>   if (($AdminPass ne '') || ($EditPass ne '')) {
>     print '<br>', T('Administrator Password:'), ' ',
>           $q->password_field(-name=>'p_adminpw', -value=>'*', 
>                              -size=>15, -maxlength=>50),
>           ' ', T('(blank to remove password)'), '<br>',
>           T('(Administrator passwords are used for special maintenance.)');
>   }
>   if ($EmailNotify) {
>     print "<br>";
>     print &GetFormCheck('notify', 1,
>           T('Include this address in the site email list.')), ' ',
>           T('(Uncheck the box to remove the address.)');
>     print '<br>', T('Email Address:'), ' ',
>           &GetFormText('email', "", 30, 60);
>   }
>   print "<hr class=wikilinepref><b>$recentName:</b>\n";
>   print '<br>', T('Default days to display:'), ' ',
>         &GetFormText('rcdays', $RcDefault, 4, 9);
>   print "<br>", &GetFormCheck('rcnewtop', $RecentTop,
>                               T('Most recent changes on top'));
>   print "<br>", &GetFormCheck('rcall', 0,
>                               T('Show all changes (not just most recent)'));
>   %labels = (0=>T('Hide minor edits'), 1=>T('Show minor edits'),
>              2=>T('Show only minor edits'));
>   print '<br>', T('Minor edit display:'), ' ';
>   print $q->popup_menu(-name=>'p_rcshowedit',
>                        -values=>[0,1,2], -labels=>\%labels,
>                        -default=>&GetParam("rcshowedit", $ShowEdits));
>   print "<br>", &GetFormCheck('rcchangehist', 1,
>                               T('Use "changes" as link to history'));
>   if ($UseDiff) {
>     print '<hr class=wikilinepref><b>', T('Differences:'), "</b>\n";
>     print "<br>", &GetFormCheck('diffrclink', 1,
>                                 Ts('Show (diff) links on %s', $recentName));
>     print "<br>", &GetFormCheck('alldiff', 0,
>                                 T('Show differences on all pages'));
>     print "  (",  &GetFormCheck('norcdiff', 1,
>                                 Ts('No differences on %s', $recentName)), ")";
>     %labels = (1=>T('Major'), 2=>T('Minor'), 3=>T('Author'));
>     print '<br>', T('Default difference type:'), ' ';
>     print $q->popup_menu(-name=>'p_defaultdiff',
>                          -values=>[1,2,3], -labels=>\%labels,
>                          -default=>&GetParam("defaultdiff", 1));
>   }
>   print '<hr class=wikilinepref><b>', T('Misc:'), "</b>\n";
>   # Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
>   print '<br>', T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset);
>   print '<br>', T('Time Zone offset (hours):'), ' ',
>         &GetFormText('tzoffset', 0, 4, 9);
>   print '<br>', &GetFormCheck('editwide', 1,
>                               T('Use 100% wide edit area (if supported)'));
>   print '<br>',
>         T('Edit area rows:'), ' ', &GetFormText('editrows', 20, 4, 4),
>         ' ', T('columns:'),   ' ', &GetFormText('editcols', 65, 4, 4);
> 
>   print '<br>', &GetFormCheck('toplinkbar', 1,
>                               T('Show link bar on top'));
>   print '<br>', &GetFormCheck('linkrandom', 0,
>                               T('Add "Random Page" link to link bar'));
>   print '<br>' . T('StyleSheet URL:') . ' ',
>         &GetFormText('stylesheet', "", 30, 150);
>   print '<br>', $q->submit(-name=>'Save', -value=>T('Save')), "\n";
>   print $q->endform;
>   print '</div>';
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub GetFormText {
>   my ($name, $default, $size, $max) = @_;
>   my $text = &GetParam($name, $default);
> 
>   return $q->textfield(-name=>"p_$name", -default=>$text,
>                        -override=>1, -size=>$size, -maxlength=>$max);
> }
> 
> sub GetFormCheck {
>   my ($name, $default, $label) = @_;
>   my $checked = (&GetParam($name, $default) > 0);
> 
>   return $q->checkbox(-name=>"p_$name", -override=>1, -checked=>$checked,
>                       -label=>$label);
> }
> 
> sub DoUpdatePrefs {
>   my ($username, $password, $stylesheet);
> 
>   # All link bar settings should be updated before printing the header
>   &UpdatePrefCheckbox("toplinkbar");
>   &UpdatePrefCheckbox("linkrandom");
>   print &GetHeader('', T('Saving Preferences'), '');
>   print '<br>';
>   if ($UserID < 1001) {
>     print '<b>',
>           Ts('Invalid UserID %s, preferences not saved.', $UserID), '</b>';
>     if ($UserID == 111) {
>       print '<br>',
>             T('(Preferences require cookies, but no cookie was sent.)');
>     }
>     print &GetCommonFooter();
>     return;
>   }
>   $username = &GetParam("p_username",  "");
>   if ($FreeLinks) {
>     $username =~ s/^\[\[(.+)\]\]/$1/;  # Remove [[ and ]] if added
>     $username =  &FreeToNormal($username);
>     $username =~ s/_/ /g;
>   }
>   if ($username eq "") {
>     print T('UserName removed.'), '<br>';
>     undef $UserData{'username'};
>   } elsif ((!$FreeLinks) && (!($username =~ /^$LinkPattern$/))) {
>     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
>   } elsif ($FreeLinks && (!($username =~ /^$FreeLinkPattern$/))) {
>     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
>   } elsif (length($username) > 50) {  # Too long
>     print T('UserName must be 50 characters or less. (not saved)'), "<br>\n";
>   } else {
>     print Ts('UserName %s saved.', $username), '<br>';
>     $UserData{'username'} = $username;
>   }
>   $password = &GetParam("p_password",  "");
>   if ($password eq "") {
>     print T('Password removed.'), '<br>';
>     undef $UserData{'password'};
>   } elsif ($password ne "*") {
>     print T('Password changed.'), '<br>';
>     $UserData{'password'} = $password;
>   }
>   if (($AdminPass ne "") || ($EditPass ne "")) {
>     $password = &GetParam("p_adminpw",  "");
>     if ($password eq "") {
>       print T('Administrator password removed.'), '<br>';
>       undef $UserData{'adminpw'};
>     } elsif ($password ne "*") {
>       print T('Administrator password changed.'), '<br>';
>       $UserData{'adminpw'} = $password;
>       if (&UserIsAdmin()) {
>         print T('User has administrative abilities.'), '<br>';
>       } elsif (&UserIsEditor()) {
>         print T('User has editor abilities.'), '<br>';
>       } else {
>         print T('User does not have administrative abilities.'), ' ',
>               T('(Password does not match administrative password(s).)'),
>               '<br>';
>       }
>     }
>   }
>   if ($EmailNotify) {
>     &UpdatePrefCheckbox("notify");
>     &UpdateEmailList();
>   }
>   &UpdatePrefNumber("rcdays", 0, 0, 999999);
>   &UpdatePrefCheckbox("rcnewtop");
>   &UpdatePrefCheckbox("rcall");
>   &UpdatePrefCheckbox("rcchangehist");
>   &UpdatePrefCheckbox("editwide");
>   if ($UseDiff) {
>     &UpdatePrefCheckbox("norcdiff");
>     &UpdatePrefCheckbox("diffrclink");
>     &UpdatePrefCheckbox("alldiff");
>     &UpdatePrefNumber("defaultdiff", 1, 1, 3);
>   }
>   &UpdatePrefNumber("rcshowedit", 1, 0, 2);
>   &UpdatePrefNumber("tzoffset", 0, -999, 999);
>   &UpdatePrefNumber("editrows", 1, 1, 999);
>   &UpdatePrefNumber("editcols", 1, 1, 999);
>   print T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset), '<br>';
>   $TimeZoneOffset = &GetParam("tzoffset", 0) * (60 * 60);
>   print T('Local time:'), ' ', &TimeToText($Now), '<br>';
>   $stylesheet = &GetParam('p_stylesheet', '');
>   if ($stylesheet eq '') {
>     if (&GetParam('stylesheet', '') ne '') {
>       print T('StyleSheet URL removed.'), '<br>';
>     }
>     undef $UserData{'stylesheet'};
>   } else {
>     $stylesheet =~ s/[">]//g;  # Remove characters that would cause problems
>     $UserData{'stylesheet'} = $stylesheet;
>     print T('StyleSheet setting saved.'), '<br>';
>   }
>   &SaveUserData();
>   print '<b>', T('Preferences saved.'), '</b>';
>   print &GetCommonFooter();
> }
> 
> # add or remove email address from preferences to $EmailFile
> sub UpdateEmailList {
>   my (@old_emails);
> 
>   local $/ = "\n";  # don't slurp whole files in this sub.
>   if (my $new_email = $UserData{'email'} = &GetParam("p_email", "")) {
>     my $notify = $UserData{'notify'};
>     if (-f $EmailFile) {
>       open(NOTIFY, $EmailFile)
>         or die(Ts('Could not read from %s:', $EmailFile) . " $!\n");
>       @old_emails = <NOTIFY>;
>       close(NOTIFY);
>     } else {
>       @old_emails = ();
>     }
>     my $already_in_list = grep /$new_email/, @old_emails;
>     if ($notify and (not $already_in_list)) {
>       &RequestLock() or die(T('Could not get mail lock'));
>       if (!open(NOTIFY, ">>$EmailFile")) {
>         &ReleaseLock();  # Don't leave hangling locks
>         die(Ts('Could not append to %s:', $EmailFile) . " $!\n");
>       }
>       print NOTIFY $new_email, "\n";
>       close(NOTIFY);
>       &ReleaseLock();
>     }
>     elsif ((not $notify) and $already_in_list) {
>       &RequestLock() or die(T('Could not get mail lock'));
>       if (!open(NOTIFY, ">$EmailFile")) {
>         &ReleaseLock();
>         die(Ts('Could not overwrite %s:', "$EmailFile") . " $!\n");
>       }
>       foreach (@old_emails) {
>         print NOTIFY "$_" unless /$new_email/;
>       }
>       close(NOTIFY);
>       &ReleaseLock();
>     }
>   }
> }
> 
> sub UpdatePrefCheckbox {
>   my ($param) = @_;
>   my $temp = &GetParam("p_$param", "*");
> 
>   $UserData{$param} = 1  if ($temp eq "on");
>   $UserData{$param} = 0  if ($temp eq "*");
>   # It is possible to skip updating by using another value, like "2"
> }
> 
> sub UpdatePrefNumber {
>   my ($param, $integer, $min, $max) = @_;
>   my $temp = &GetParam("p_$param", "*");
> 
>   return  if ($temp eq "*");
>   $temp =~ s/[^-\d\.]//g;
>   $temp =~ s/\..*//  if ($integer);
>   return  if ($temp eq "");
>   return  if (($temp < $min) || ($temp > $max));
>   $UserData{$param} = $temp;
> }
> 
> sub DoIndex {
>   print &GetHeader('', T('Index of all pages'), '');
>   print '<br>';
>   &PrintPageList(&AllPagesList());
>   print &GetCommonFooter();
> }
> 
> # Create a new user file/cookie pair
> sub DoNewLogin {
>   # Consider warning if cookie already exists
>   # (maybe use "replace=1" parameter)
>   &CreateUserDir();
>   $SetCookie{'id'} = &GetNewUserId();
>   $SetCookie{'randkey'} = int(rand(1000000000));
>   $SetCookie{'rev'} = 1;
>   %UserCookie = %SetCookie;
>   $UserID = $SetCookie{'id'};
>   # The cookie will be transmitted in the next header
>   %UserData = %UserCookie;
>   $UserData{'createtime'} = $Now;
>   $UserData{'createip'} = $ENV{REMOTE_ADDR};
>   &SaveUserData();
> }
> 
> sub DoEnterLogin {
>   print &GetHeader('', T('Login'), "");
>   print &GetFormStart();
>   print &GetHiddenValue('enter_login', 1), "\n";
>   print '<br>', T('User ID number:'), ' ',
>         $q->textfield(-name=>'p_userid', -value=>'',
>                       -size=>15, -maxlength=>50);
>   print '<br>', T('Password:'), ' ',
>         $q->password_field(-name=>'p_password', -value=>'', 
>                            -size=>15, -maxlength=>50);
>   print '<br>', $q->submit(-name=>'Login', -value=>T('Login')), "\n";
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub DoLogin {
>   my ($uid, $password, $success);
> 
>   $success = 0;
>   $uid = &GetParam("p_userid", "");
>   $uid =~ s/\D//g;
>   $password = &GetParam("p_password",  "");
>   if (($uid > 199) && ($password ne "") && ($password ne "*")) {
>     $UserID = $uid;
>     &LoadUserData();
>     if ($UserID > 199) {
>       if (defined($UserData{'password'}) &&
>           ($UserData{'password'} eq $password)) {
>         $SetCookie{'id'} = $uid;
>         $SetCookie{'randkey'} = $UserData{'randkey'};
>         $SetCookie{'rev'} = 1;
>         $success = 1;
>       }
>     }
>   }
>   print &GetHeader('', T('Login Results'), '');
>   if ($success) {
>     print Ts('Login for user ID %s complete.', $uid);
>   } else {
>     print Ts('Login for user ID %s failed.', $uid);
>   }
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub GetNewUserId {
>   my ($id);
> 
>   $id = $StartUID;
>   while (-f &UserDataFilename($id+1000)) {
>     $id += 1000;
>   }
>   while (-f &UserDataFilename($id+100)) {
>     $id += 100;
>   }
>   while (-f &UserDataFilename($id+10)) {
>     $id += 10;
>   }
>   &RequestLock() or die(T('Could not get user-ID lock'));
>   while (-f &UserDataFilename($id)) {
>     $id++;
>   }
>   &WriteStringToFile(&UserDataFilename($id), "lock");  # reserve the ID
>   &ReleaseLock();
>   return $id;
> }
> 
> # Consider user-level lock?
> sub SaveUserData {
>   my ($userFile, $data);
> 
>   &CreateUserDir();
>   $userFile = &UserDataFilename($UserID);
>   $data = join($FS1, %UserData);
>   &WriteStringToFile($userFile, $data);
> }
> 
> sub CreateUserDir {
>   my ($n, $subdir);
> 
>   if (!(-d "$UserDir/0")) {
>     &CreateDir($UserDir);
> 
>     foreach $n (0..9) {
>       $subdir = "$UserDir/$n";
>       &CreateDir($subdir);
>     }
>   }
> }
> 
> sub DoSearch {
>   my ($string) = @_;
> 
>   if ($string eq '') {
>     &DoIndex();
>     return;
>   }
>   print &GetHeader('', &QuoteHtml(Ts('Search for: %s', $string)), '');
>   print '<br>';
>   &PrintPageList(&SearchTitleAndBody($string));
>   print &GetCommonFooter();
> }
> 
> sub DoBackLinks {
>   my ($string) = @_;
> 
>   print &GetHeader('', &QuoteHtml(Ts('Backlinks for: %s', $string)), '');
>   print '<br>';
>   # At this time the backlinks are mostly a renamed search.
>   # An initial attempt to match links only failed on subpages and free links.
>   # Escape some possibly problematic characters:
>   $string =~ s/([-'().,])/\\$1/g; 
>   &PrintPageList(&SearchTitleAndBody($string));
>   print &GetCommonFooter();
> }
> 
> sub PrintPageList {
>   my $pagename;
> 
>   print "<h2>", Ts('%s pages found:', ($#_ + 1)), "</h2>\n";
>   foreach $pagename (@_) {
>     print ".... "  if ($pagename =~ m|/|);
>     print &GetPageLink($pagename), "<br>\n";
>   }
> }
> 
> sub DoLinks {
>   print &GetHeader('', &QuoteHtml(T('Full Link List')), '');
>   print "<hr><pre>\n\n\n\n\n";  # Extra lines to get below the logo
>   &PrintLinkList(&GetFullLinkList());
>   print "</pre>\n";
>   print &GetCommonFooter();
> }
> 
> sub PrintLinkList {
>   my ($pagelines, $page, $names, $editlink);
>   my ($link, $extra, @links, %pgExists);
> 
>   %pgExists = ();
>   foreach $page (&AllPagesList()) {
>     $pgExists{$page} = 1;
>   }
>   $names = &GetParam("names", 1);
>   $editlink = &GetParam("editlink", 0);
>   foreach $pagelines (@_) {
>     @links = ();
>     foreach $page (split(' ', $pagelines)) {
>       if ($page =~ /\:/) {  # URL or InterWiki form
>         if ($page =~ /$UrlPattern/) {
>           ($link, $extra) = &UrlLink($page, 0);  # No images
>         } else {
>           ($link, $extra) = &InterPageLink($page, 0);  # No images
>         }
>       } else {
>         if ($pgExists{$page}) {
>           $link = &GetPageLink($page);
>         } else {
>           $link = $page;
>           if ($editlink) {
>             $link .= &GetEditLink($page, "?");
>           }
>         }
>       }
>       push(@links, $link);
>     }
>     if (!$names) {
>       shift(@links);
>     }
>     print join(' ', @links), "\n";
>   }
> }
> 
> sub GetFullLinkList {
>   my ($name, $unique, $sort, $exists, $empty, $link, $search);
>   my ($pagelink, $interlink, $urllink);
>   my (@found, @links, @newlinks, @pglist, %pgExists, %seen, $main);
> 
>   $unique = &GetParam("unique", 1);
>   $sort = &GetParam("sort", 1);
>   $pagelink = &GetParam("page", 1);
>   $interlink = &GetParam("inter", 0);
>   $urllink = &GetParam("url", 0);
>   $exists = &GetParam("exists", 2);
>   $empty = &GetParam("empty", 0);
>   $search = &GetParam("search", "");
>   if (($interlink == 2) || ($urllink == 2)) {
>     $pagelink = 0;
>   }
>   %pgExists = ();
>   @pglist = &AllPagesList();
>   foreach $name (@pglist) {
>     $pgExists{$name} = 1;
>   }
>   %seen = ();
>   foreach $name (@pglist) {
>     @newlinks = ();
>     if ($unique != 2) {
>       %seen = ();
>     }
>     @links = &GetPageLinks($name, $pagelink, $interlink, $urllink);
>     if ($UseSubpage) {
>       $main = $name;
>       $main =~ s/\/.*//;
>     }
>     foreach $link (@links) {
>       if ($UseSubpage && ($link =~ /^\//)) {
>         $link = $main . $link;
>       }
>       $seen{$link}++;
>       if (($unique > 0) && ($seen{$link} != 1)) {
>         next;
>       }
>       if (($exists == 0) && ($pgExists{$link} == 1)) {
>         next;
>       }
>       if (($exists == 1) && ($pgExists{$link} != 1)) {
>         next;
>       }
>       if (($search ne "") && !($link =~ /$search/)) {
>         next;
>       }
>       push(@newlinks, $link);
>     }
>     @links = @newlinks;
>     if ($sort) {
>       @links = sort(@links);
>     }
>     unshift (@links, $name);
>     if ($empty || ($#links > 0)) {  # If only one item, list is empty.
>       push(@found, join(' ', @links));
>     }
>   }
>   return @found;
> }
> 
> sub GetPageLinks {
>   my ($name, $pagelink, $interlink, $urllink) = @_;
>   my ($text, @links);
> 
>   @links = ();
>   &OpenPage($name);
>   &OpenDefaultText();
>   $text = $Text{'text'};
>   $text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
>   $text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
>   $text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
>   $text =~ s/<code>(.|\n)*?\<\/code>/ /ig;
>   if ($interlink) {
>     $text =~ s/''+/ /g;  # Quotes can adjacent to inter-site links
>     $text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
>   } else {
>     $text =~ s/$InterLinkPattern/ /g;
>   }
>   if ($urllink) {
>     $text =~ s/''+/ /g;  # Quotes can adjacent to URLs
>     $text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
>   } else {
>     $text =~ s/$UrlPattern/ /g;
>   }
>   if ($pagelink) {
>     if ($FreeLinks) {
>       my $fl = $FreeLinkPattern;
>       $text =~ s/\[\[$fl\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
>       $text =~ s/\[\[$fl\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
>     }
>     if ($WikiLinks) {
>       $text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
>     }
>   }
>   return @links;
> }
> 
> sub DoPost {
>   my ($editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user);
>   my $string = &GetParam("text", undef);
>   my $id = &GetParam("title", "");
>   my $summary = &GetParam("summary", "");
>   my $oldtime = &GetParam("oldtime", "");
>   my $oldconflict = &GetParam("oldconflict", "");
>   my $isEdit = 0;
>   my $editTime = $Now;
>   my $authorAddr = $ENV{REMOTE_ADDR};
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   if (!&UserCanEdit($id, 1)) {
>     # This is an internal interface--we don't need to explain
>     &ReportError(Ts('Editing not allowed for %s.', $id));
>     return;
>   }
>   if (($id eq   'SampleUndefinedPage')    ||
>       ($id eq T('SampleUndefinedPage'))   ||
>       ($id eq   'Sample_Undefined_Page')  ||
>       ($id eq T('Sample_Undefined_Page'))) {
>     &ReportError(Ts('%s cannot be defined.', $id));
>     return;
>   }
>   $string  = &RemoveFS($string);
>   $summary = &RemoveFS($summary);
>   $summary =~ s/[\r\n]//g;
>   if (length($summary) > 300) {  # Too long (longer than form allows)
>     $summary = substr($summary, 0, 300);
>   }
>   # Add a newline to the end of the string (if it doesn't have one)
>   $string .= "\n"  if (!($string =~ /\n$/));
>   # Lock before getting old page to prevent races
>   # Consider extracting lock section into sub, and eval-wrap it?
>   # (A few called routines can die, leaving locks.)
>   if ($LockCrash) {
>     &RequestLock() or die(T('Could not get editing lock'));
>   } else {
>     if (!&RequestLock()) {
>       &ForceReleaseLock('main');
>     }
>     # Clear all other locks.
>     &ForceReleaseLock('cache');
>     &ForceReleaseLock('diff');
>     &ForceReleaseLock('index');
>   }
>   &OpenPage($id);
>   &OpenDefaultText();
>   $old = $Text{'text'};
>   $oldrev = $Section{'revision'};
>   $pgtime = $Section{'ts'};
>   $preview = 0;
>   $preview = 1  if (&GetParam("Preview", "") ne "");
>   if (!$preview && ($old eq $string)) {  # No changes (ok for preview)
>     &ReleaseLock();
>     &ReBrowsePage($id, "", 1);
>     return;
>   }
>   if (($UserID > 399) || ($Section{'id'} > 399))  {
>     $newAuthor = ($UserID ne $Section{'id'});       # known user(s)
>   } else {
>     $newAuthor = ($Section{'ip'} ne $authorAddr);  # hostname fallback
>   }
>   $newAuthor = 1  if ($oldrev == 0);  # New page
>   $newAuthor = 0  if (!$newAuthor);   # Standard flag form, not empty
>   # Detect editing conflicts and resubmit edit
>   if (($oldrev > 0) && ($newAuthor && ($oldtime != $pgtime))) {
>     &ReleaseLock();
>     if ($oldconflict > 0) {  # Conflict again...
>       &DoEdit($id, 2, $pgtime, $string, $preview);
>     } else {
>       &DoEdit($id, 1, $pgtime, $string, $preview);
>     }
>     return;
>   }
>   if ($preview) {
>     &ReleaseLock();
>     &DoEdit($id, 0, $pgtime, $string, 1);
>     return;
>   }
>   $user = &GetParam("username", "");
>   # If the person doing editing chooses, send out email notification
>   if ($EmailNotify) {
>     &EmailNotify($id, $user) if &GetParam("do_email_notify", "") eq 'on';
>   }
>   if (&GetParam("recent_edit", "") eq 'on') {
>     $isEdit = 1;
>   }
>   if (!$isEdit) {
>     &SetPageCache('oldmajor', $Section{'revision'});
>   }
>   if ($newAuthor) {
>     &SetPageCache('oldauthor', $Section{'revision'});
>   }
>   &SaveKeepSection();
>   &ExpireKeepFile();
>   if ($UseDiff) {
>     &UpdateDiffs($id, $editTime, $old, $string, $isEdit, $newAuthor);
>   }
>   $Text{'text'} = $string;
>   $Text{'minor'} = $isEdit;
>   $Text{'newauthor'} = $newAuthor;
>   $Text{'summary'} = $summary;
>   $Section{'host'} = &GetRemoteHost(1);
>   &SaveDefaultText(); 
>   &SavePage();
>   &WriteRcLog($id, $summary, $isEdit, $editTime, $Section{'revision'},
>               $user, $Section{'host'});
>   if ($UseCache) {
>     &UnlinkHtmlCache($id);         # Old cached copy is invalid
>     if ($Page{'revision'} < 2) {   # If this is a new page...
>       &NewPageCacheClear($id);     # ...uncache pages linked to this one.
>     }
>   }
>   if ($UseIndex && ($Page{'revision'} == 1)) {
>     unlink($IndexFile);  # Regenerate index on next request
>   }
>   &ReleaseLock();
>   &ReBrowsePage($id, "", 1);
> }
> 
> sub UpdateDiffs {
>   my ($id, $editTime, $old, $new, $isEdit, $newAuthor) = @_;
>   my ($editDiff, $oldMajor, $oldAuthor);
> 
>   $editDiff  = &GetDiff($old, $new, 0);     # 0 = already in lock
>   $oldMajor  = &GetPageCache('oldmajor');
>   $oldAuthor = &GetPageCache('oldauthor');
>   if ($UseDiffLog) {
>     &WriteDiff($id, $editTime, $editDiff);
>   }
>   &SetPageCache('diff_default_minor', $editDiff);
>   if ($isEdit || !$newAuthor) {
>     &OpenKeptRevisions('text_default');
>   }
>   if (!$isEdit) {
>     &SetPageCache('diff_default_major', "1");
>   } else {
>     &SetPageCache('diff_default_major', &GetKeptDiff($new, $oldMajor, 0));
>   }
>   if ($newAuthor) {
>     &SetPageCache('diff_default_author', "1");
>   } elsif ($oldMajor == $oldAuthor) {
>     &SetPageCache('diff_default_author', "2");
>   } else {
>     &SetPageCache('diff_default_author', &GetKeptDiff($new, $oldAuthor, 0));
>   }
> }
> 
> # Translation note: the email messages are still sent in English
> # Send an email message.
> sub SendEmail {
>   my ($to, $from, $reply, $subject, $message) = @_;
> 
>   # sendmail options:
>   #    -odq : send mail to queue (i.e. later when convenient)
>   #    -oi  : do not wait for "." line to exit
>   #    -t   : headers determine recipient.
>   open (SENDMAIL, "| $SendMail -oi -t ") or die "Can't send email: $!\n";
>   print SENDMAIL <<"EOF";
> From: $from
> To: $to
> Reply-to: $reply
> Subject: $subject\n
> $message
> EOF
>   close(SENDMAIL) or warn "sendmail didn't close nicely";
> }
> 
> ## Email folks who want to know a note that a page has been modified. - JimM.
> sub EmailNotify {
>   local $/ = "\n";   # don't slurp whole files in this sub.
> 
>   if ($EmailNotify) {
>     my ($id, $user) = @_;
>     if ($user) {
>       $user = " by $user";
>     }
>     my $address;
>     return  if (!-f $EmailFile);  # No notifications yet
>     open(EMAIL, $EmailFile)
>       or die "Can't open $EmailFile: $!\n";
>     $address = join ",", <EMAIL>;
>     $address =~ s/\n//g;
>     close(EMAIL);
>     my $home_url = $q->url();
>     my $page_url = $home_url . &ScriptLinkChar() . &UriEscape($id);
>     my $pref_url = $home_url . &ScriptLinkChar() . "action=editprefs";
>     my $editors_summary = $q->param("summary");
>     if (($editors_summary eq "*") or ($editors_summary eq "")){
>       $editors_summary = "";
>     }
>     else {
>       $editors_summary = "\n Summary: $editors_summary";
>     }
>     my $content = <<"END_MAIL_CONTENT";
> 
>  The $SiteName page $id at
>    $page_url
>  has been changed$user to revision $Page{revision}. $editors_summary
> 
>  (Replying to this notification will
>   send email to the entire mailing list,
>   so only do that if you mean to.
> 
>   To remove yourself from this list, visit
>   $pref_url .)
> END_MAIL_CONTENT
>     my $subject = "The $id page at $SiteName has been changed.";
>     # I'm setting the "reply-to" field to be the same as the "to:" field
>     # which seems appropriate for a mailing list, especially since the
>     # $EmailFrom string needn't be a real email address.
>     &SendEmail($address, $EmailFrom, $address, $subject, $content);
>   }
> }
> 
> sub SearchTitleAndBody {
>   my ($string) = @_;
>   my ($name, $freeName, @found);
> 
>   foreach $name (&AllPagesList()) {
>     &OpenPage($name);
>     &OpenDefaultText();
>     if (($Text{'text'} =~ /$string/i) || ($name =~ /$string/i)) {
>       push(@found, $name);
>     } elsif ($FreeLinks) {
>       if ($name =~ m/_/) {
>         $freeName = $name;
>         $freeName =~ s/_/ /g;
>         if ($freeName =~ /$string/i) {
>           push(@found, $name);
>         }
>       } elsif ($string =~ m/ /) {
>         $freeName = $string;
>         $freeName =~ s/ /_/g;
>         if ($Text{'text'} =~ /$freeName/i) {
>           push(@found, $name);
>         }
>       }
>     }
>   }
>   return @found;
> }
> 
> sub SearchBody {
>   my ($string) = @_;
>   my ($name, @found);
> 
>   foreach $name (&AllPagesList()) {
>     &OpenPage($name);
>     &OpenDefaultText();
>     if ($Text{'text'} =~ /$string/i){
>       push(@found, $name);
>     }
>   }
>   return @found;
> }
> 
> sub UnlinkHtmlCache {
>   my ($id) = @_;
>   my $idFile;
> 
>   $idFile = &GetHtmlCacheFile($id);
>   if (-f $idFile) {
>     unlink($idFile);
>   }
> }
> 
> sub NewPageCacheClear {
>   my ($id) = @_;
>   my $name;
> 
>   return if (!$UseCache);
>   $id =~ s|.+/|/|;  # If subpage, search for just the subpage
>   # The following code used to search the body for the $id
>   foreach $name (&AllPagesList()) {  # Remove all to be safe
>     &UnlinkHtmlCache($name);
>   }
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub DoUnlock {
>   my $LockMessage = T('Normal Unlock.');
> 
>   print &GetHeader('', T('Removing edit lock'), '');
>   print '<p>', T('This operation may take several seconds...'), "\n";
>   if (&ForceReleaseLock('main')) {
>     $LockMessage = T('Forced Unlock.');
>   }
>   &ForceReleaseLock('cache');
>   &ForceReleaseLock('diff');
>   &ForceReleaseLock('index');
>   print "<br><h2>$LockMessage</h2>";
>   print &GetCommonFooter();
> }
> 
> # Note: all diff and recent-list operations should be done within locks.
> sub WriteRcLog {
>   my ($id, $summary, $isEdit, $editTime, $revision, $name, $rhost) = @_;
>   my ($extraTemp, %extra);
> 
>   %extra = ();
>   $extra{'id'} = $UserID          if ($UserID > 0);
>   $extra{'name'} = $name          if ($name ne "");
>   $extra{'revision'} = $revision  if ($revision ne "");
>   $extraTemp = join($FS2, %extra);
>   # The two fields at the end of a line are kind and extension-hash
>   my $rc_line = join($FS3, $editTime, $id, $summary,
>                      $isEdit, $rhost, "0", $extraTemp);
>   if (!open(OUT, ">>$RcFile")) {
>     die(Ts('%s log error:', $RCName) . " $!");
>   }
>   print OUT  $rc_line . "\n";
>   close(OUT);
> }
> 
> sub WriteDiff {
>   my ($id, $editTime, $diffString) = @_;
> 
>   open (OUT, ">>$DataDir/diff_log") or die(T('can not write diff_log'));
>   print OUT  "------\n" . $id . "|" . $editTime . "\n";
>   print OUT  $diffString;
>   close(OUT);
> }
> 
> # Actions are vetoable if someone edits the page before
> # the keep expiry time. For example, page deletion. If
> # no one edits the page by the time the keep expiry time
> # elapses, then no one has vetoed the last action, and the
> # action is accepted.
> # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
> sub ProcessVetos {
>   my ($expirets);
> 
>   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
>   return (0, T('(done)'))  unless $Page{'ts'} < $expirets;
>   if ($DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o) {
>     &DeletePage($OpenPageName, 1, 1);
>     return (1, T('(deleted)'));
>   }
>   if ($ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o) {
>     my $fname = $1;
>     # Only replace an allowed, existing file.
>     if ((grep {$_ eq $fname} @ReplaceableFiles) && -e $fname) {
>        if ($Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims)
>        {
>          my $string = $1;
>          $string =~ s/\r\n/\n/gms;
>          open (OUT, ">$fname") or return 0;
>          print OUT $string;
>          close OUT;
>          return (0, T('(replaced)'));
>       }
>     }
>   }
>   return (0, T('(done)'));
> }
> 
> sub DoMaintain {
>   my ($name, $fname, $data, $message, $status);
>   print &GetHeader('', T('Maintenance on all pages'), '');
>   print "<br>";
>   $fname = "$DataDir/maintain";
>   if (!&UserIsAdmin()) {
>     if ((-f $fname) && ((-M $fname) < 0.5)) {
>       print T('Maintenance not done.'), ' ';
>       print T('(Maintenance can only be done once every 12 hours.)');
>       print ' ', T('Remove the "maintain" file or wait.');
>       print &GetCommonFooter();
>       return;
>     }
>   }
>   &RequestLock() or die(T('Could not get maintain-lock'));
>   foreach $name (&AllPagesList()) {
>     &OpenPage($name);
>     &OpenDefaultText();
>     ($status, $message) = &ProcessVetos();
>     &ExpireKeepFile() unless $status;
>     print ".... "  if ($name =~ m|/|);
>     print &GetPageLink($name);
>     print " $message<br>\n";
>   }
>   &WriteStringToFile($fname, Ts('Maintenance done at %s', &TimeToText($Now)));
>   &ReleaseLock();
>   # Do any rename/deletion commands
>   # (Must be outside lock because it will grab its own lock)
>   $fname = "$DataDir/editlinks";
>   if (-f $fname) {
>     $data = &ReadFileOrDie($fname);
>     print '<hr>', T('Processing rename/delete commands:'), "<br>\n";
>     &UpdateLinksList($data, 1, 1);  # Always update RC and links
>     unlink("$fname.old");
>     rename($fname, "$fname.old");
>   }
>   if ($MaintTrimRc) {
>     &RequestLock() or die(T('Could not get lock for RC maintenance'));
>     $status = &TrimRc();  # Consider error messages?
>     &ReleaseLock();
>   }
>   print &GetCommonFooter();
> }
> 
> # Must be called within a lock.
> # Thanks to Alex Schroeder for original code
> sub TrimRc {
>   my (@rc, @temp, $starttime, $days, $status, $data, $i, $ts);
> 
>   # Determine the number of days to go back
>   $days = 0;
>   foreach (@RcDays) {
>     $days = $_  if $_ > $days;
>   }
>   $starttime = $Now - $days * 24 * 60 * 60;
>   return 1  if (!-f $RcFile);  # No work if no file exists
>   ($status, $data) = &ReadFile($RcFile);
>   if (!$status) {
>     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
>           . ":</strong> $RcFile<p>"
>           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
>     return 0;
>   }
>   # Move the old stuff from rc to temp
>   @rc = split(/\n/, $data);
>   for ($i = 0; $i < @rc; $i++) {
>     ($ts) = split(/$FS3/, $rc[$i]);
>     last  if ($ts >= $starttime);
>   }
>   return 1  if ($i < 1);  # No lines to move from new to old
>   @temp = splice(@rc, 0, $i);
>   # Write new files and backups
>   if (!open(OUT, ">>$RcOldFile")) {
>     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
>           . ":</strong> $RcOldFile<p>"
>           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
>     return 0;
>   }
>   print OUT  join("\n", @temp) . "\n";
>   close(OUT);
>   &WriteStringToFile($RcFile . '.old', $data);
>   $data = join("\n", @rc);
>   $data .= "\n"  if ($data ne '');  # If no entries, don't add blank line
>   &WriteStringToFile($RcFile, $data);
>   return 1;
> }
> 
> sub DoMaintainRc {
>   print &GetHeader('', T('Maintaining RC log'), '');
>   return  if (!&UserIsAdminOrError());
>   &RequestLock() or die(T('Could not get lock for RC maintenance'));
>   if (&TrimRc()) {
>     print '<br>' . T('RC maintenance done.') . '<br>';
>   } else {
>     print '<br>' . T('RC maintenance not done.') . '<br>';
>   }
>   &ReleaseLock();
>   print &GetCommonFooter();
> }
> 
> sub UserIsEditorOrError {
>   if (!&UserIsEditor()) {
>     print '<p>', T('This operation is restricted to site editors only...');
>     print &GetCommonFooter();
>     return 0;
>   }
>   return 1;
> }
> 
> sub UserIsAdminOrError {
>   if (!&UserIsAdmin()) {
>     print '<p>', T('This operation is restricted to administrators only...');
>     print &GetCommonFooter();
>     return 0;
>   }
>   return 1;
> }
> 
> sub DoEditLock {
>   my ($fname);
> 
>   print &GetHeader('', T('Set or Remove global edit lock'), '');
>   return  if (!&UserIsAdminOrError());
>   $fname = "$DataDir/noedit";
>   if (&GetParam("set", 1)) {
>     &WriteStringToFile($fname, "editing locked.");
>   } else {
>     unlink($fname);
>   }
>   if (-f $fname) {
>     print '<p>', T('Edit lock created.'), '<br>';
>   } else {
>     print '<p>', T('Edit lock removed.'), '<br>';
>   }
>   print &GetCommonFooter();
> }
> 
> sub DoPageLock {
>   my ($fname, $id);
> 
>   print &GetHeader('', T('Set or Remove page edit lock'), '');
>   # Consider allowing page lock/unlock at editor level?
>   return  if (!&UserIsAdminOrError());
>   $id = &GetParam("id", "");
>   if ($id eq "") {
>     print '<p>', T('Missing page id to lock/unlock...');
>     return;
>   }
>   return  if (!&ValidIdOrDie($id));       # Consider nicer error?
>   $fname = &GetLockedPageFile($id);
>   if (&GetParam("set", 1)) {
>     &WriteStringToFile($fname, "editing locked.");
>   } else {
>     unlink($fname);
>   }
>   if (-f $fname) {
>     print '<p>', Ts('Lock for %s created.', $id), '<br>';
>   } else {
>     print '<p>', Ts('Lock for %s removed.', $id), '<br>';
>   }
>   print &GetCommonFooter();
> }
> 
> sub DoEditBanned {
>   my ($banList, $status);
> 
>   print &GetHeader('', T('Editing Banned list'), '');
>   return  if (!&UserIsAdminOrError());
>   ($status, $banList) = &ReadFile("$DataDir/banlist");
>   $banList = ""  if (!$status);
>   print &GetFormStart();
>   print GetHiddenValue("edit_ban", 1), "\n";
>   print "<b>Banned IP/network/host list:</b><br>\n";
>   print "<p>Each entry is either a commented line (starting with #), ",
>         "or a Perl regular expression (matching either an IP address or ",
>         "a hostname).  <b>Note:</b> To test the ban on yourself, you must ",
>         "give up your admin access (remove password in Preferences).";
>   print "<p>Example:<br>",
>         "# blocks hosts ending with .foocorp.com<br>",
>         "\\.foocorp\\.com\$<br>",
>         "# blocks exact IP address<br>",
>         "^123\\.21\\.3\\.9\$<br>",
>         "# blocks whole 123.21.3.* IP network<br>",
>         "^123\\.21\\.3\\.\\d+\$<p>";
>   print &GetTextArea('banlist', $banList, 12, 50);
>   print "<br>", $q->submit(-name=>'Save'), "\n";
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub DoUpdateBanned {
>   my ($newList, $fname);
> 
>   print &GetHeader('', T('Updating Banned list'), '');
>   return  if (!&UserIsAdminOrError());
>   $fname = "$DataDir/banlist";
>   $newList = &GetParam("banlist", "#Empty file");
>   if ($newList eq "") {
>     print "<p>", T('Empty banned list or error.');
>     print "<p>", T('Resubmit with at least one space character to remove.');
>   } elsif ($newList =~ /^\s*$/s) {
>     unlink($fname);
>     print "<p>", T('Removed banned list');
>   } else {
>     &WriteStringToFile($fname, $newList);
>     print "<p>", T('Updated banned list');
>   }
>   print &GetCommonFooter();
> }
> 
> # ==== Editing/Deleting pages and links ====
> sub DoEditLinks {
>   print &GetHeader('', T('Editing Links'), '');
>   if ($AdminDelete) {
>     return  if (!&UserIsAdminOrError());
>   } else {
>     return  if (!&UserIsEditorOrError());
>   }
>   print &GetFormStart();
>   print GetHiddenValue("edit_links", 1), "\n";
>   print "<b>Editing/Deleting page titles:</b><br>\n";
>   print "<p>Enter one command on each line.  Commands are:<br>",
>         "<tt>!PageName</tt> -- deletes the page called PageName<br>\n",
>         "<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName ",
>         "to NewPageName and updates links to OldPageName.<br>\n",
>         "<tt>|OldPageName|NewPageName</tt> -- Changes links to OldPageName ",
>         "to NewPageName.",
>         " (Used to rename links to non-existing pages.)<br>\n",
>         "<b>Note: page names are case-sensitive!</b>\n";
>   print &GetTextArea('commandlist', "", 12, 50);
>   print $q->checkbox(-name=>"p_changerc", -override=>1, -checked=>1,
>                       -label=>"Edit $RCName");
>   print "<br>\n";
>   print $q->checkbox(-name=>"p_changetext", -override=>1, -checked=>1,
>                       -label=>"Substitute text for rename");
>   print "<br>", $q->submit(-name=>'Edit'), "\n";
>   print $q->endform;
>   if (!&GetParam('embed', $EmbedWiki)) {
>     print '<div class=wikifooter>';
>     print "<hr class=wikilinefooter>\n";
>     print &GetGotoBar('');
>     print '</div>';
>   }
>   print &GetMinimumFooter();
> }
> 
> sub UpdateLinksList {
>   my ($commandList, $doRC, $doText) = @_;
> 
>   if ($doText) {
>     &BuildLinkIndex();
>   }
>   &RequestLock() or die T('UpdateLinksList could not get main lock');
>   unlink($IndexFile)  if ($UseIndex);
>   foreach (split(/\n/, $commandList)) {
>     s/\s+$//g;
>     next  if (!(/^[=!|]/));  # Only valid commands.
>     print "Processing $_<br>\n";
>     if (/^\!(.+)/) {
>       &DeletePage($1, $doRC, $doText);
>     } elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
>       &RenamePage($1, $2, $doRC, $doText);
>     } elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
>       &RenameTextLinks($1, $2);
>     }
>   }
>   &NewPageCacheClear(".");  # Clear cache (needs testing?)
>   unlink($IndexFile)  if ($UseIndex);
>   &ReleaseLock();
> }
> 
> sub BuildLinkIndex {
>   my (@pglist, $page, @links, $link, %seen);
> 
>   @pglist = &AllPagesList();
>   %LinkIndex = ();
>   foreach $page (@pglist) {
>     &BuildLinkIndexPage($page);
>   }
> }
> 
> sub BuildLinkIndexPage {
>   my ($page) = @_;
>   my (@links, $link, %seen);
> 
>   @links = &GetPageLinks($page, 1, 0, 0);
>   %seen = ();
>   foreach $link (@links) {
>     if (defined($LinkIndex{$link})) {
>       if (!$seen{$link}) {
>         $LinkIndex{$link} .= " " . $page;
>       }
>     } else {
>       $LinkIndex{$link} .= " " . $page;
>     }
>     $seen{$link} = 1;
>   }
> }
> 
> sub DoUpdateLinks {
>   my ($commandList, $doRC, $doText);
> 
>   print &GetHeader('', T('Updating Links'), '');
>   if ($AdminDelete) {
>     return  if (!&UserIsAdminOrError());
>   } else {
>     return  if (!&UserIsEditorOrError());
>   }
>   $commandList = &GetParam("commandlist", "");
>   $doRC   = &GetParam("p_changerc", "0");
>   $doRC   = 1  if ($doRC eq "on");
>   $doText = &GetParam("p_changetext", "0");
>   $doText = 1  if ($doText eq "on");
>   if ($commandList eq "") {
>     print "<p>", T('Empty command list or error.');
>   } else {
>     &UpdateLinksList($commandList, $doRC, $doText);
>     print "<p>", T('Finished command list.');
>   }
>   print &GetCommonFooter();
> }
> 
> sub EditRecentChanges {
>   my ($action, $old, $new) = @_;
> 
>   &EditRecentChangesFile($RcFile,    $action, $old, $new, 1);
>   &EditRecentChangesFile($RcOldFile, $action, $old, $new, 0);
> }
> 
> sub EditRecentChangesFile {
>   my ($fname, $action, $old, $new, $printError) = @_;
>   my ($status, $fileData, $errorText, $rcline, @rclist);
>   my ($outrc, $ts, $page, $junk);
> 
>   ($status, $fileData) = &ReadFile($fname);
>   if (!$status) {
>     # Save error text if needed.
>     $errorText = "<p><strong>"
>                  . Ts('Could not open %s log file:', $RCName)
>                  . "</strong> $fname"
>                  . "<p>" . T('Error was:') . "\n<pre>$!</pre>\n";
>     print $errorText  if ($printError);
>     return;
>   }
>   $outrc = "";
>   @rclist = split(/\n/, $fileData);
>   foreach $rcline (@rclist) {
>     ($ts, $page, $junk) = split(/$FS3/, $rcline);
>     if ($page eq $old) {
>       if ($action == 1) {  # Delete
>         ; # Do nothing (don't add line to new RC)
>       } elsif ($action == 2) {
>         $junk = $rcline;
>         $junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
>         $outrc .= $junk . "\n";
>       }
>     } else {
>       $outrc .= $rcline . "\n";
>     }
>   }
>   &WriteStringToFile($fname . ".old", $fileData);  # Backup copy
>   &WriteStringToFile($fname, $outrc);
> }
> 
> # Delete and rename must be done inside locks.
> sub DeletePage {
>   my ($page, $doRC, $doText) = @_;
>   my ($fname, $status);
> 
>   $page =~ s/ /_/g;
>   $page =~ s/\[+//;
>   $page =~ s/\]+//;
>   $status = &ValidId($page);
>   if ($status ne "") {
>     print Tss('Delete-Page: page %1 is invalid, error is: %2', $page, $status)
>           . "<br>\n";
>     return;
>   }
>   $fname = &GetPageFile($page);
>   unlink($fname)  if (-f $fname);
>   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
>   unlink($fname)  if (-f $fname);
>   unlink($IndexFile)  if ($UseIndex);
>   &EditRecentChanges(1, $page, "")  if ($doRC);  # Delete page
>   # Currently don't do anything with page text
> }
> 
> # Given text, returns substituted text
> sub SubstituteTextLinks {
>   my ($old, $new, $text) = @_;
> 
>   # Much of this is taken from the common markup
>   %SaveUrl = ();
>   $SaveUrlIndex = 0;
>   $text =~ s/$FS(\d)/$1/g;              # Remove separators (paranoia)
>   if ($RawHtml) {
>     $text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
>   }
>   $text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
>   $text =~ s/(<code>((.|\n)*?)<\/code>)/&StoreRaw($1)/ige;
>   $text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
>   if ($FreeLinks) {
>     $text =~
>      s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
>     $text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
>   }
>   if ($BracketText) {  # Links like [URL text of link]
>     $text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
>     $text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
>   }
>   $text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
>   $text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
>   if ($WikiLinks) {
>     $text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
>   }
>   # Thanks to David Claughton for the following fix
>   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
>   return $text;
> }
> 
> sub SubFreeLink {
>   my ($link, $name, $old, $new) = @_;
>   my ($oldlink);
> 
>   $oldlink = $link;
>   $link =~ s/^\s+//;
>   $link =~ s/\s+$//;
>   if (($link eq $old) || (&FreeToNormal($old) eq &FreeToNormal($link))) {
>     $link = $new;
>   } else {
>     $link = $oldlink;  # Preserve spaces if no match
>   }
>   $link = "[[$link";
>   if ($name ne "") {
>     $link .= "|$name";
>   }
>   $link .= "]]";
>   return &StoreRaw($link);
> }
> 
> sub SubWikiLink {
>   my ($link, $old, $new) = @_;
>   my ($newBracket);
> 
>   $newBracket = 0;
>   if ($link eq $old) {
>     $link = $new;
>     if (!($new =~ /^$LinkPattern$/)) {
>       $link = "[[$link]]";
>     }
>   }
>   return &StoreRaw($link);
> }
> 
> # Rename is mostly copied from expire
> sub RenameKeepText {
>   my ($page, $old, $new) = @_;
>   my ($fname, $status, $data, @kplist, %tempSection, $changed);
>   my ($sectName, $newText);
> 
>   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
>   return  if (!(-f $fname));
>   ($status, $data) = &ReadFile($fname);
>   return  if (!$status);
>   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>   return  if (length(@kplist) < 1);  # Also empty
>   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
>   return  if (length(@kplist) < 1);  # Also empty
>   %tempSection = split(/$FS2/, $kplist[0], -1);
>   if (!defined($tempSection{'keepts'})) {
>     return;
>   }
>   # First pass: optimize for nothing changed
>   $changed = 0;
>   foreach (@kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     if ($sectName =~ /^(text_)/) {
>       %Text = split(/$FS3/, $tempSection{'data'}, -1);
>       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
>       $changed = 1  if ($Text{'text'} ne $newText);
>     }
>   }
>   return  if (!$changed);  # No sections changed
>   open (OUT, ">$fname") or return;
>   foreach (@kplist) {
>     %tempSection = split(/$FS2/, $_, -1);
>     $sectName = $tempSection{'name'};
>     if ($sectName =~ /^(text_)/) {
>       %Text = split(/$FS3/, $tempSection{'data'}, -1);
>       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
>       $Text{'text'} = $newText;
>       $tempSection{'data'} = join($FS3, %Text);
>       print OUT $FS1, join($FS2, %tempSection);
>     } else {
>       print OUT $FS1, $_;
>     }
>   }
>   close(OUT);
> }
> 
> sub RenameTextLinks {
>   my ($old, $new) = @_;
>   my ($changed, $file, $page, $section, $oldText, $newText, $status);
>   my ($oldCanonical, @pageList);
> 
>   $old =~ s/ /_/g;
>   $oldCanonical = &FreeToNormal($old);
>   $new =~ s/ /_/g;
>   $status = &ValidId($old);
>   if ($status ne "") {
>     print Tss('Rename-Text: old page %1 is invalid, error is: %2', $old, $status)
>           . "<br>\n";
>     return;
>   }
>   $status = &ValidId($new);
>   if ($status ne "") {
>     print Tss('Rename-Text: new page %1 is invalid, error is: %2', $new, $status)
>           . "<br>\n";
>     return;
>   }
>   $old =~ s/_/ /g;
>   $new =~ s/_/ /g;
>   # Note: the LinkIndex must be built prior to this routine
>   return  if (!defined($LinkIndex{$oldCanonical}));
>   @pageList = split(' ', $LinkIndex{$oldCanonical});
>   foreach $page (@pageList) {
>     $changed = 0;
>     &OpenPage($page);
>     foreach $section (keys %Page) {
>       if ($section =~ /^text_/) {
>         &OpenSection($section);
>         %Text = split(/$FS3/, $Section{'data'}, -1);
>         $oldText = $Text{'text'};
>         $newText = &SubstituteTextLinks($old, $new, $oldText);
>         if ($oldText ne $newText) {
>           $Text{'text'} = $newText;
>           $Section{'data'} = join($FS3, %Text);
>           $Page{$section} = join($FS2, %Section);
>           $changed = 1;
>         }
>       } elsif ($section =~ /^cache_diff/) {
>         $oldText = $Page{$section};
>         $newText = &SubstituteTextLinks($old, $new, $oldText);
>         if ($oldText ne $newText) {
>           $Page{$section} = $newText;
>           $changed = 1;
>         }
>       }
>       # Add other text-sections (categories) here
>     }
>     if ($changed) {
>       $file = &GetPageFile($page);
>       &WriteStringToFile($file, join($FS1, %Page));
>     }
>     &RenameKeepText($page, $old, $new);
>   }
> }
> 
> sub RenamePage {
>   my ($old, $new, $doRC, $doText) = @_;
>   my ($oldfname, $newfname, $oldkeep, $newkeep, $status);
> 
>   $old =~ s/ /_/g;
>   $new = &FreeToNormal($new);
>   $status = &ValidId($old);
>   if ($status ne "") {
>     print Tss('Rename: old page %1 is invalid, error is: %2', $old, $status)
>           . "<br>\n";
>     return;
>   }
>   $status = &ValidId($new);
>   if ($status ne "") {
>     print Tss('Rename: new page %1 is invalid, error is: %2', $new, $status)
>           . "<br>\n";
>     return;
>   }
>   $newfname = &GetPageFile($new);
>   if (-f $newfname) {
>     print Ts('Rename: new page %s already exists--not renamed.', $new)
>           . "<br>\n";
>     return;
>   }
>   $oldfname = &GetPageFile($old);
>   if (!(-f $oldfname)) {
>     print Ts('Rename: old page %s does not exist--nothing done.', $old)
>           . "<br>\n";
>     return;
>   }
>   &CreatePageDir($PageDir, $new);  # It might not exist yet
>   rename($oldfname, $newfname);
>   &CreatePageDir($KeepDir, $new);
>   $oldkeep = $KeepDir . "/" . &GetPageDirectory($old) .  "/$old.kp";
>   $newkeep = $KeepDir . "/" . &GetPageDirectory($new) .  "/$new.kp";
>   unlink($newkeep)  if (-f $newkeep);  # Clean up if needed.
>   rename($oldkeep,  $newkeep);
>   unlink($IndexFile)  if ($UseIndex);
>   &EditRecentChanges(2, $old, $new)  if ($doRC);
>   if ($doText) {
>     &BuildLinkIndexPage($new);  # Keep index up-to-date
>     &RenameTextLinks($old, $new);
>   }
> }
> 
> sub DoShowVersion {
>   print &GetHeader('', T('Displaying Wiki Version'), '');
>   print "<p>UseModWiki version 1.0.4</p>\n";
>   print &GetCommonFooter();
> }
> 
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
>   my ($id) = @_;
> 
>   return  if (!&ValidIdOrDie($id));
>   print &GetHeader('', Ts('Delete %s', $id), '');
>   return  if (!&UserIsAdminOrError());
>   if ($ConfirmDel && !&GetParam('confirm', 0)) {
>     print '<p>';
>     print Ts('Confirm deletion of %s by following this link:', $id);
>     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
>     print '</p>';
>     print &GetCommonFooter();
>     return;
>   }
>   print '<p>';
>   if ($id eq $HomePage)  {
>     print Ts('%s can not be deleted.', $HomePage);
>   } else {
>     if (-f &GetLockedPageFile($id))   {
>       print Ts('%s can not be deleted because it is locked.', $id);
>     } else {
>       # Must lock because of RC-editing
>       &RequestLock() or die(T('Could not get editing lock'));
>       DeletePage($id, 1, 1);
>       &ReleaseLock();
>       print Ts('%s has been deleted.', $id);
>     }
>   }
>   print '</p>';
>   print &GetCommonFooter();
> }
> 
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
>   print &GetHeader('', T('File Upload Page'), '');
>   if (!$AllUpload) {
>     return if (!&UserIsEditorOrError());
>   }
>   print '<p>' . Ts('The current upload size limit is %s.', $MaxPost) . ' '
>         . Ts('Change the %s variable to increase this limit.', '$MaxPost');
>   print '</p><br>';
>   print '<FORM METHOD="post" ACTION="' . $ScriptName
>         . '" ENCTYPE="multipart/form-data">';
>   print '<input type="hidden" name="upload" value="1" />';
>   print T('File to Upload:'), ' <INPUT TYPE="file" NAME="file"><br><BR>';
>   print '<INPUT TYPE="submit" NAME="Submit" VALUE="', T('Upload'), '">';
>   print '</FORM>';
>   print &GetCommonFooter(); 
> }
> 
> sub SaveUpload {
>   my ($filename, $printFilename, $uploadFilehandle);
>  
>   print &GetHeader('', T('Upload Finished'), '');
>   if (!$AllUpload) {
>     return  if (!&UserIsEditorOrError());
>   }
>   $UploadDir .= '/'  if (substr($UploadDir, -1, 1) ne '/');  # End with /
>   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
>   $filename = $q->param('file');
>   $filename =~ s/.*[\/\\](.*)/$1/;  # Only name after last \ or /
>   $uploadFilehandle = $q->upload('file');
>   open UPLOADFILE, ">$UploadDir$filename";
>   binmode UPLOADFILE;
>   while (<$uploadFilehandle>) { print UPLOADFILE; }
>   close UPLOADFILE;
>   print T('The wiki link to your file is:') . "\n<br><BR>";
>   $printFilename = $filename;
>   $printFilename =~ s/ /\%20/g;  # Replace spaces with escaped spaces
>   print "upload:" . $printFilename . "<BR><BR>\n";
>   if ($filename =~ /$ImageExtensions$/i) {
>     print '<HR><img src="' . $UploadUrl . $filename . '">' . "\n";
>   }
>   print &GetCommonFooter();
> }
> 
> sub ConvertFsFile {
>   my ($oldFS, $newFS, $fname) = @_;
>   my ($oldData, $newData, $status);
> 
>   return  if (!-f $fname);  # Convert only existing regular files
>   ($status, $oldData) = &ReadFile($fname);
>   if (!$status) {
>     print '<br><strong>' . Ts('Could not open file %s', $fname)
>           . ':</strong>' . T('Error was') . ":\n<pre>$!</pre>\n" . '<br>';
>     return;
>   }
>   $newData = $oldData;
>   $newData =~ s/$oldFS(\d)/$newFS . $1/ge;
>   return  if ($oldData eq $newData);  # Do not write if the same
>   &WriteStringToFile($fname, $newData);
> # print $fname . '<br>';    # progress report
> }
> 
> # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
> # Note that top level directory (page/keep/user) contains only dirs
> sub ConvertFsDir {
>   my ($oldFS, $newFS, $topDir) = @_;
>   my (@dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname);
> 
>   opendir(DIRLIST, $topDir);
>   @dirs = readdir(DIRLIST);
>   closedir(DIRLIST);
>   @dirs = sort(@dirs);
>   foreach $dir (@dirs) {
>     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
>     next  if (!-d "$topDir/$dir");          # Top level directories only
>     next  if (-f "$topDir/$dir.cvt");       # Skip if already converted
>     opendir(DIRLIST, "$topDir/$dir");
>     @files = readdir(DIRLIST);
>     closedir(DIRLIST);
>     foreach $file (@files) {
>       next  if (($file eq '.') || ($file eq '..'));
>       $fname = "$topDir/$dir/$file";
>       if (-f $fname) {
> #       print $fname . '<br>';   # progress
>         &ConvertFsFile($oldFS, $newFS, $fname);
>       } elsif (-d $fname) {
>         opendir(DIRLIST, $fname);
>         @subFiles = readdir(DIRLIST);
>         closedir(DIRLIST);
>         foreach $subFile (@subFiles) {
>           next  if (($subFile eq '.') || ($subFile eq '..'));
>           $subFname = "$fname/$subFile";
>           if (-f $subFname) {
> #           print $subFname . '<br>';   # progress
>             &ConvertFsFile($oldFS, $newFS, $subFname);
>           }
>         }
>       }
>     }
>   &WriteStringToFile("$topDir/$dir.cvt", 'converted');
>   }
> }
> 
> sub ConvertFsCleanup {
>   my ($topDir) = @_;
>   my (@dirs, $dir);
> 
>   opendir(DIRLIST, $topDir);
>   @dirs = readdir(DIRLIST);
>   closedir(DIRLIST);
>   foreach $dir (@dirs) {
>     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
>     next  if (!-f "$topDir/$dir");          # Remove only files...
>     next  unless ($dir =~ m/\.cvt$/);       # ...that end with .cvt
>     unlink "$topDir/$dir";
>   }
> }
> 
> sub DoConvert {
>   my $oldFS = "\xb3";
>   my $newFS = "\x1e\xff\xfe\x1e";
> 
>   print &GetHeader('', T('Convert wiki DB'), '');
>   return if (!&UserIsAdminOrError());
>   if ($FS ne $newFS) {
>     print Ts('You must change the %s option before converting the wiki DB.',
>              '$NewFS') . '<br>';
>     return;
>   }
>   &WriteStringToFile("$DataDir/noedit", 'editing locked.');
>   print T('Wiki DB locked for conversion.') . '<br>';
>   print T('Converting Wiki DB...') . '<br>';
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog");
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog.old");
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog");
>   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog.old");
>   &ConvertFsDir($oldFS, $newFS, $PageDir);
>   &ConvertFsDir($oldFS, $newFS, $KeepDir);
>   &ConvertFsDir($oldFS, $newFS, $UserDir);
>   &ConvertFsCleanup($PageDir);
>   &ConvertFsCleanup($KeepDir);
>   &ConvertFsCleanup($UserDir);
>   print T('Finished converting wiki DB.') . '<br>';
>   print Ts('Remove file %s to unlock wiki for editing.', "$DataDir/noedit")
>         . '<br>';
>   print &GetCommonFooter();
> }
> 
> # Remove user-id files if no useful preferences set
> sub DoTrimUsers {
>   my (%Data, $status, $data, $maxID, $id, $removed, $keep);
>   my (@dirs, @files, $dir, $file, $item);
> 
>   print &GetHeader('', T('Trim wiki users'), '');
>   return if (!&UserIsAdminOrError());
>   $removed = 0;
>   $maxID = 1001;
>   opendir(DIRLIST, $UserDir);
>   @dirs = readdir(DIRLIST);
>   closedir(DIRLIST);
>   foreach $dir (@dirs) {
>     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
>     next  if (!-d "$UserDir/$dir");         # Top level directories only
>     opendir(DIRLIST, "$UserDir/$dir");
>     @files = readdir(DIRLIST);
>     closedir(DIRLIST);
>     foreach $file (@files) {
>       if ($file =~ m/(\d+).db/) {  # Only numeric ID files
>         $id = $1;
>         $maxID = $id  if ($id > $maxID);
>         %Data = ();
>         ($status, $data) = &ReadFile("$UserDir/$dir/$file");
>         if ($status) {
>           %Data = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
>           $keep = 0;
>           foreach $item (qw(username password adminpw stylesheet)) {
>             $keep = 1  if (defined($Data{$item}) && ($Data{$item} ne ''));
>           }
>           if (!$keep) {
>             unlink "$UserDir/$dir/$file";
> #           print "$UserDir/$dir/$file" . '<br>';  # progress
>             $removed += 1;
>           }
>         }
>       }
>     }
>   }
>   print Ts('Removed %s files.', $removed) . '<br>';
>   print Ts('Recommended $StartUID setting is %s.', $maxID + 100) . '<br>';
>   print &GetCommonFooter();
> }
> #END_OF_OTHER_CODE
> 
> &DoWikiRequest()  if ($RunCGI && ($_ ne 'nocgi'));   # Do everything.
> 1; # In case we are loaded from elsewhere
> # == End of UseModWiki script. ===========================================
------
SandBox|1218122271
2c2
< # UseModWiki version 1.0.4 (December 1, 2007)
---
> # UseModWiki version 1.0.3 (September 12, 2007)
182c182
< @IsbnPre = ('http://search.barnesandnoble.com/booksearch/isbninquiry.asp?isbn=',
---
> @IsbnPre = ('http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=',
397,406d396
< sub QuoteHtml {
<   my ($html) = @_;
< 
<   $html =~ s/&/&amp;/g;
<   $html =~ s/</&lt;/g;
<   $html =~ s/>/&gt;/g;
<   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
<   return $html;
< }
< 
558c548
<   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId, 1);
---
>   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId);
752c742
<   my ($headList, $pagePrefix, $historyPrefix, $diffPrefix);
---
>   my ($headList, $historyPrefix, $diffPrefix);
778,780c768,769
<   $pagePrefix = $QuotedFullUrl . &ScriptLinkChar();
<   $diffPrefix = $pagePrefix . &QuoteHtml("action=browse&diff=4&id=");
<   $historyPrefix = $pagePrefix . &QuoteHtml("action=history&id=");
---
>   $diffPrefix = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
>   $historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
821c810
<                               $diffPrefix, $historyPrefix, $pagePrefix);
---
>                               $diffPrefix, $historyPrefix);
905c894
<         <link>${\($QuotedFullUrl . &ScriptLinkChar() . &QuoteHtml("$RCName"))}</link>
---
>         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
933,934c922,923
<   my ($pagename, $timestamp, $host, $userName, $userID, $summary, $isEdit,
<       $pagecount, $revision, $diffPrefix, $historyPrefix, $pagePrefix) = @_;
---
>   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
>       $isEdit, $pagecount, $revision, $diffPrefix, $historyPrefix) = @_;
951c940
<     $authorLink = 'link="' . $QuotedFullUrl . &ScriptLinkChar() . $author . '"';
---
>     $authorLink = "link=\"$QuotedFullUrl?$author\"";
967c956
<         <link>$pagePrefix$pagenameEsc</link>
---
>         <link>$QuotedFullUrl?$pagenameEsc</link>
1298c1287
<   my ($id, $title, $oldId, $backlinks) = @_;
---
>   my ($id, $title, $oldId) = @_;
1324c1313
<   if ($id and $backlinks) {
---
>   if ($id ne '') {
1518,1529c1507
< # Admin bar contributed by ElMoro (with some changes)
< sub GetPageLockLink {
<   my ($id, $status, $name) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
<   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
< }
< 
< sub GetAdminBar {
<   my ($id) = @_;
---
> sub GetSearchForm {
1532,1534c1510,1514
<   $result = T('Administration') . ': ';
<   if (-f &GetLockedPageFile($id))   { 
<     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
---
>   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
>   if ($SearchButton) {
>     $result .= $q->submit('dosearch', T('Go!'));
>   } else {  
>     $result .= &GetHiddenValue("dosearch", 1);
1536,1547d1515
<   else  {
<     $result .= &GetPageLockLink($id, 1, T('Lock page'));
<   }
<   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
<   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
<   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
<   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
<   if (-f "$DataDir/noedit") {
<     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
<   } else {
<     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
<   }
1551,1562d1518
< sub GetSearchForm {
<   my ($result);
< 
<   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
<   if ($SearchButton) {
<     $result .= $q->submit('dosearch', T('Go!'));
<   } else {  
<     $result .= &GetHiddenValue("dosearch", 1);
<   }
<   return $result;
< }
< 
1854a1811,1820
> sub QuoteHtml {
>   my ($html) = @_;
> 
>   $html =~ s/&/&amp;/g;
>   $html =~ s/</&lt;/g;
>   $html =~ s/>/&gt;/g;
>   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
>   return $html;
> }
> 
3283c3249
<   print &GetHeader($id, &QuoteHtml($header), '');
---
>   print &GetHeader('', &QuoteHtml($header), '');
3829c3795
<   print &GetCommonFooter();
---
>   print &GetMinimumFooter();
4159d4124
<     my $pref_url = $home_url . &ScriptLinkChar() . "action=editprefs";
4178c4143
<   $pref_url .)
---
>   ${home_url}?action=editprefs .)
4942c4907
<   print "<p>UseModWiki version 1.0.4</p>\n";
---
>   print "<p>UseModWiki version 1.0.3</p>\n";
4946,4947c4911,4921
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
---
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
>   my ($id, $status, $name) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
> }
> 
> sub GetAdminBar {
4950,4959c4923,4927
<   return  if (!&ValidIdOrDie($id));
<   print &GetHeader('', Ts('Delete %s', $id), '');
<   return  if (!&UserIsAdminOrError());
<   if ($ConfirmDel && !&GetParam('confirm', 0)) {
<     print '<p>';
<     print Ts('Confirm deletion of %s by following this link:', $id);
<     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
<     print '</p>';
<     print &GetCommonFooter();
<     return;
---
>   my ($result);
> 
>   $result = T('Administration') . ': ';
>   if (-f &GetLockedPageFile($id))   { 
>     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
4961,4963c4929,4937
<   print '<p>';
<   if ($id eq $HomePage)  {
<     print Ts('%s can not be deleted.', $HomePage);
---
>   else  {
>     $result .= &GetPageLockLink($id, 1, T('Lock page'));
>   }
>   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
>   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
>   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
>   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
>   if (-f "$DataDir/noedit") {
>     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
4965,4973c4939
<     if (-f &GetLockedPageFile($id))   {
<       print Ts('%s can not be deleted because it is locked.', $id);
<     } else {
<       # Must lock because of RC-editing
<       &RequestLock() or die(T('Could not get editing lock'));
<       DeletePage($id, 1, 1);
<       &ReleaseLock();
<       print Ts('%s has been deleted.', $id);
<     }
---
>     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
4975,4976c4941
<   print '</p>';
<   print &GetCommonFooter();
---
>   return $result;
4979,4983c4944,4957
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
<   print &GetHeader('', T('File Upload Page'), '');
<   if (!$AllUpload) {
<     return if (!&UserIsEditorOrError());
---
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
>   my ($id) = @_;
> 
>   return  if (!&ValidIdOrDie($id));
>   print &GetHeader('', Ts('Delete %s', $id), '');
>   return  if (!&UserIsAdminOrError());
>   if ($ConfirmDel && !&GetParam('confirm', 0)) {
>     print '<p>';
>     print Ts('Confirm deletion of %s by following this link:', $id);
>     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
>     print '</p>';
>     print &GetCommonFooter();
>     return;
4984a4959,4982
>   print '<p>';
>   if ($id eq $HomePage)  {
>     print Ts('%s can not be deleted.', $HomePage);
>   } else {
>     if (-f &GetLockedPageFile($id))   {
>       print Ts('%s can not be deleted because it is locked.', $id);
>     } else {
>       # Must lock because of RC-editing
>       &RequestLock() or die(T('Could not get editing lock'));
>       DeletePage($id, 1, 1);
>       &ReleaseLock();
>       print Ts('%s has been deleted.', $id);
>     }
>   }
>   print '</p>';
>   print &GetCommonFooter();
> }
> 
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
>   print &GetHeader('', T('File Upload Page'), '');
>   if (!$AllUpload) {
>     return if (!&UserIsEditorOrError());
>   }
------
SandBox|1218122638
2c2
< # UseModWiki version 1.0.3 (September 12, 2007)
---
> # UseModWiki version 1.0.4 (December 1, 2007)
182c182
< @IsbnPre = ('http://shop.barnesandnoble.com/bookSearch/isbnInquiry.asp?isbn=',
---
> @IsbnPre = ('http://search.barnesandnoble.com/booksearch/isbninquiry.asp?isbn=',
396a397,406
> sub QuoteHtml {
>   my ($html) = @_;
> 
>   $html =~ s/&/&amp;/g;
>   $html =~ s/</&lt;/g;
>   $html =~ s/>/&gt;/g;
>   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
>   return $html;
> }
> 
548c558
<   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId);
---
>   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId, 1);
742c752
<   my ($headList, $historyPrefix, $diffPrefix);
---
>   my ($headList, $pagePrefix, $historyPrefix, $diffPrefix);
768,769c778,780
<   $diffPrefix = $QuotedFullUrl . &QuoteHtml("?action=browse\&diff=4\&id=");
<   $historyPrefix = $QuotedFullUrl . &QuoteHtml("?action=history\&id=");
---
>   $pagePrefix = $QuotedFullUrl . &ScriptLinkChar();
>   $diffPrefix = $pagePrefix . &QuoteHtml("action=browse&diff=4&id=");
>   $historyPrefix = $pagePrefix . &QuoteHtml("action=history&id=");
810c821
<                               $diffPrefix, $historyPrefix);
---
>                               $diffPrefix, $historyPrefix, $pagePrefix);
894c905
<         <link>${\($QuotedFullUrl . &QuoteHtml("?$RCName"))}</link>
---
>         <link>${\($QuotedFullUrl . &ScriptLinkChar() . &QuoteHtml("$RCName"))}</link>
922,923c933,934
<   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
<       $isEdit, $pagecount, $revision, $diffPrefix, $historyPrefix) = @_;
---
>   my ($pagename, $timestamp, $host, $userName, $userID, $summary, $isEdit,
>       $pagecount, $revision, $diffPrefix, $historyPrefix, $pagePrefix) = @_;
940c951
<     $authorLink = "link=\"$QuotedFullUrl?$author\"";
---
>     $authorLink = 'link="' . $QuotedFullUrl . &ScriptLinkChar() . $author . '"';
956c967
<         <link>$QuotedFullUrl?$pagenameEsc</link>
---
>         <link>$pagePrefix$pagenameEsc</link>
1287c1298
<   my ($id, $title, $oldId) = @_;
---
>   my ($id, $title, $oldId, $backlinks) = @_;
1313c1324
<   if ($id ne '') {
---
>   if ($id and $backlinks) {
1507c1518,1529
< sub GetSearchForm {
---
> # Admin bar contributed by ElMoro (with some changes)
> sub GetPageLockLink {
>   my ($id, $status, $name) = @_;
> 
>   if ($FreeLinks) {
>     $id = &FreeToNormal($id);
>   }
>   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
> }
> 
> sub GetAdminBar {
>   my ($id) = @_;
1510,1514c1532,1534
<   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
<   if ($SearchButton) {
<     $result .= $q->submit('dosearch', T('Go!'));
<   } else {  
<     $result .= &GetHiddenValue("dosearch", 1);
---
>   $result = T('Administration') . ': ';
>   if (-f &GetLockedPageFile($id))   { 
>     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
1515a1536,1547
>   else  {
>     $result .= &GetPageLockLink($id, 1, T('Lock page'));
>   }
>   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
>   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
>   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
>   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
>   if (-f "$DataDir/noedit") {
>     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
>   } else {
>     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
>   }
1518a1551,1562
> sub GetSearchForm {
>   my ($result);
> 
>   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
>   if ($SearchButton) {
>     $result .= $q->submit('dosearch', T('Go!'));
>   } else {  
>     $result .= &GetHiddenValue("dosearch", 1);
>   }
>   return $result;
> }
> 
1811,1820d1854
< sub QuoteHtml {
<   my ($html) = @_;
< 
<   $html =~ s/&/&amp;/g;
<   $html =~ s/</&lt;/g;
<   $html =~ s/>/&gt;/g;
<   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
<   return $html;
< }
< 
3249c3283
<   print &GetHeader('', &QuoteHtml($header), '');
---
>   print &GetHeader($id, &QuoteHtml($header), '');
3795c3829
<   print &GetMinimumFooter();
---
>   print &GetCommonFooter();
4124a4159
>     my $pref_url = $home_url . &ScriptLinkChar() . "action=editprefs";
4143c4178
<   ${home_url}?action=editprefs .)
---
>   $pref_url .)
4907c4942
<   print "<p>UseModWiki version 1.0.3</p>\n";
---
>   print "<p>UseModWiki version 1.0.4</p>\n";
4911,4921c4946,4947
< # Admin bar contributed by ElMoro (with some changes)
< sub GetPageLockLink {
<   my ($id, $status, $name) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
<   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
< }
< 
< sub GetAdminBar {
---
> # Thanks to Phillip Riley for original code
> sub DoDeletePage {
4923,4927c4950,4959
<   my ($result);
< 
<   $result = T('Administration') . ': ';
<   if (-f &GetLockedPageFile($id))   { 
<     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
---
>   return  if (!&ValidIdOrDie($id));
>   print &GetHeader('', Ts('Delete %s', $id), '');
>   return  if (!&UserIsAdminOrError());
>   if ($ConfirmDel && !&GetParam('confirm', 0)) {
>     print '<p>';
>     print Ts('Confirm deletion of %s by following this link:', $id);
>     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
>     print '</p>';
>     print &GetCommonFooter();
>     return;
4929,4937c4961,4963
<   else  {
<     $result .= &GetPageLockLink($id, 1, T('Lock page'));
<   }
<   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
<   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
<   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
<   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
<   if (-f "$DataDir/noedit") {
<     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
---
>   print '<p>';
>   if ($id eq $HomePage)  {
>     print Ts('%s can not be deleted.', $HomePage);
4939c4965,4973
<     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
---
>     if (-f &GetLockedPageFile($id))   {
>       print Ts('%s can not be deleted because it is locked.', $id);
>     } else {
>       # Must lock because of RC-editing
>       &RequestLock() or die(T('Could not get editing lock'));
>       DeletePage($id, 1, 1);
>       &ReleaseLock();
>       print Ts('%s has been deleted.', $id);
>     }
4941c4975,4976
<   return $result;
---
>   print '</p>';
>   print &GetCommonFooter();
4944,4957c4979,4983
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
<   my ($id) = @_;
< 
<   return  if (!&ValidIdOrDie($id));
<   print &GetHeader('', Ts('Delete %s', $id), '');
<   return  if (!&UserIsAdminOrError());
<   if ($ConfirmDel && !&GetParam('confirm', 0)) {
<     print '<p>';
<     print Ts('Confirm deletion of %s by following this link:', $id);
<     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
<     print '</p>';
<     print &GetCommonFooter();
<     return;
---
> # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
> sub DoUpload {
>   print &GetHeader('', T('File Upload Page'), '');
>   if (!$AllUpload) {
>     return if (!&UserIsEditorOrError());
4959,4982d4984
<   print '<p>';
<   if ($id eq $HomePage)  {
<     print Ts('%s can not be deleted.', $HomePage);
<   } else {
<     if (-f &GetLockedPageFile($id))   {
<       print Ts('%s can not be deleted because it is locked.', $id);
<     } else {
<       # Must lock because of RC-editing
<       &RequestLock() or die(T('Could not get editing lock'));
<       DeletePage($id, 1, 1);
<       &ReleaseLock();
<       print Ts('%s has been deleted.', $id);
<     }
<   }
<   print '</p>';
<   print &GetCommonFooter();
< }
< 
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
<   print &GetHeader('', T('File Upload Page'), '');
<   if (!$AllUpload) {
<     return if (!&UserIsEditorOrError());
<   }
------
SandBox|1218178125
1,5174d0
< #!perl
< # UseModWiki version 1.0.4 (December 1, 2007)
< # Copyright (C) 2000-2003 Clifford A. Adams  <caadams@usemod.com>
< # Copyright (C) 2002-2003 Sunir Shah  <sunir@sunir.org>
< # Based on the GPLed AtisWiki 0.3  (C) 1998 Markus Denker
< #    <marcus@ira.uka.de>
< # ...which was based on
< #    the LGPLed CVWiki CVS-patches (C) 1997 Peter Merel
< #    and The Original WikiWikiWeb  (C) Ward Cunningham
< #        <ward@c2.com> (code reused with permission)
< # Email and ThinLine options by Jim Mahoney <mahoney@marlboro.edu>
< #
< # This program is free software; you can redistribute it and/or modify
< # it under the terms of the GNU General Public License as published by
< # the Free Software Foundation; either version 2 of the License, or
< # (at your option) any later version.
< #
< # This program is distributed in the hope that it will be useful,
< # but WITHOUT ANY WARRANTY; without even the implied warranty of
< # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< # GNU General Public License for more details.
< #
< # You should have received a copy of the GNU General Public License
< # along with this program; if not, write to the
< #    Free Software Foundation, Inc.
< #    59 Temple Place, Suite 330
< #    Boston, MA 02111-1307 USA
< 
< package UseModWiki;
< use strict;
< local $| = 1;  # Do not buffer output (localized for mod_perl)
< 
< # Configuration/constant variables:
< use vars qw(@RcDays @HtmlPairs @HtmlSingle
<   $TempDir $LockDir $DataDir $HtmlDir $UserDir $KeepDir $PageDir
<   $InterFile $RcFile $RcOldFile $IndexFile $FullUrl $SiteName $HomePage
<   $LogoUrl $RcDefault $IndentLimit $RecentTop $EditAllowed $UseDiff
<   $UseSubpage $UseCache $RawHtml $SimpleLinks $NonEnglish $LogoLeft
<   $KeepDays $HtmlTags $HtmlLinks $UseDiffLog $KeepMajor $KeepAuthor
<   $FreeUpper $EmailNotify $SendMail $EmailFrom $FastGlob $EmbedWiki
<   $ScriptTZ $BracketText $UseAmPm $UseConfig $UseIndex $UseLookup
<   $RedirType $AdminPass $EditPass $UseHeadings $NetworkFile $BracketWiki
<   $FreeLinks $WikiLinks $AdminDelete $FreeLinkPattern $RCName $RunCGI
<   $ShowEdits $ThinLine $LinkPattern $InterLinkPattern $InterSitePattern
<   $UrlProtocols $UrlPattern $ImageExtensions $RFCPattern $ISBNPattern
<   $FS $FS1 $FS2 $FS3 $CookieName $SiteBase $StyleSheet $NotFoundPg
<   $FooterNote $EditNote $MaxPost $NewText $NotifyDefault $HttpCharset
<   $UserGotoBar $DeletedPage $ReplaceFile @ReplaceableFiles $TableSyntax
<   $MetaKeywords $NamedAnchors $InterWikiMoniker $SiteDescription $RssLogoUrl
<   $NumberDates $EarlyRules $LateRules $NewFS $KeepSize $SlashLinks $BGColor
<   $UpperFirst $AdminBar $RepInterMap $DiffColor1 $DiffColor2 $ConfirmDel
<   $MaskHosts $LockCrash $ConfigFile $HistoryEdit $OldThinLine 
<   @IsbnNames @IsbnPre @IsbnPost $EmailFile $FavIcon $RssDays $UserHeader
<   $UserBody $StartUID $ParseParas $AuthorFooter $UseUpload $AllUpload
<   $UploadDir $UploadUrl $LimitFileUrl $MaintTrimRc $SearchButton 
<   $EditNameLink $UseMetaWiki @ImageSites $BracketImg );
< # Note: $NotifyDefault is kept because it was a config variable in 0.90
< # Other global variables:
< use vars qw(%Page %Section %Text %InterSite %SaveUrl %SaveNumUrl
<   %KeptRevisions %UserCookie %SetCookie %UserData %IndexHash %Translate
<   %LinkIndex $InterSiteInit $SaveUrlIndex $SaveNumUrlIndex $MainPage
<   $OpenPageName @KeptList @IndexList $IndexInit $TableMode
<   $q $Now $UserID $TimeZoneOffset $ScriptName $BrowseCode $OtherCode
<   $AnchoredLinkPattern @HeadingNumbers $TableOfContents $QuotedFullUrl
<   $ConfigError $UploadPattern );
< 
< # == Configuration =====================================================
< $DataDir     = "C:/wikidb"; # Main wiki directory
< $UseConfig   = 1;       # 1 = use config file,    0 = do not look for config
< $ConfigFile  = "$DataDir/config";   # Configuration file
< 
< # Default configuration (used if UseConfig is 0)
< $CookieName  = "Wiki";          # Name for this wiki (for multi-wiki sites)
< $SiteName    = "Wiki";          # Name of site (used for titles)
< $HomePage    = "HomePage";      # Home page (change space to _)
< $RCName      = "RecentChanges"; # Name of changes page (change space to _)
< $LogoUrl     = "/wiki.gif";     # URL for site logo ("" for no logo)
< $ENV{PATH}   = "/usr/bin/";     # Path used to find "diff"
< $ScriptTZ    = "";              # Local time zone ("" means do not print)
< $RcDefault   = 30;              # Default number of RecentChanges days
< @RcDays      = qw(1 3 7 30 90); # Days for links on RecentChanges
< $KeepDays    = 14;              # Days to keep old revisions
< $SiteBase    = "";              # Full URL for <BASE> header
< $FullUrl     = "";              # Set if the auto-detected URL is wrong
< $RedirType   = 1;               # 1 = CGI.pm, 2 = script, 3 = no redirect
< $AdminPass   = "";              # Set to non-blank to enable password(s)
< $EditPass    = "";              # Like AdminPass, but for editing only
< $StyleSheet  = "";              # URL for CSS stylesheet (like "/wiki.css")
< $NotFoundPg  = "";              # Page for not-found links ("" for blank pg)
< $EmailFrom   = "Wiki";          # Text for "From: " field of email notes.
< $SendMail    = "/usr/sbin/sendmail";  # Full path to sendmail executable
< $FooterNote  = "";              # HTML for bottom of every page
< $EditNote    = "";              # HTML notice above buttons on edit page
< $MaxPost     = 1024 * 210;      # Maximum 210K posts (about 200K for pages)
< $NewText     = "";              # New page text ("" for default message)
< $HttpCharset = "";              # Charset for pages, like "iso-8859-2"
< $UserGotoBar = "";              # HTML added to end of goto bar
< $InterWikiMoniker = '';         # InterWiki moniker for this wiki. (for RSS)
< $SiteDescription  = $SiteName;  # Description of this wiki. (for RSS)
< $RssLogoUrl  = '';              # Optional image for RSS feed
< $EarlyRules  = '';              # Local syntax rules for wiki->html (evaled)
< $LateRules   = '';              # Local syntax rules for wiki->html (evaled)
< $KeepSize    = 0;               # If non-zero, maximum size of keep file
< $BGColor     = 'white';         # Background color ('' to disable)
< $DiffColor1  = '#ffffaf';       # Background color of old/deleted text
< $DiffColor2  = '#cfffcf';       # Background color of new/added text
< $FavIcon     = '';              # URL of bookmark/favorites icon, or ''
< $RssDays     = 7;               # Default number of days in RSS feed
< $UserHeader  = '';              # Optional HTML header additional content
< $UserBody    = '';              # Optional <BODY> tag additional content
< $StartUID    = 1001;            # Starting number for user IDs
< $UploadDir   = '';              # Full path (like /foo/www/uploads) for files
< $UploadUrl   = '';              # Full URL (like http://foo.com/uploads)
< @ImageSites  = qw();            # Url prefixes of good image sites: ()=all
< 
< # Major options:
< $UseSubpage  = 1;           # 1 = use subpages,       0 = do not use subpages
< $UseCache    = 0;           # 1 = cache HTML pages,   0 = generate every page
< $EditAllowed = 1;           # 1 = editing allowed,    0 = read-only
< $RawHtml     = 0;           # 1 = allow <HTML> tag,   0 = no raw HTML in pages
< $HtmlTags    = 0;           # 1 = "unsafe" HTML tags, 0 = only minimal tags
< $UseDiff     = 0;           # 1 = use diff features,  0 = do not use diff
< $FreeLinks   = 1;           # 1 = use [[word]] links, 0 = LinkPattern only
< $WikiLinks   = 1;           # 1 = use LinkPattern,    0 = use [[word]] only
< $AdminDelete = 1;           # 1 = Admin only deletes, 0 = Editor can delete
< $RunCGI      = 1;           # 1 = Run script as CGI,  0 = Load but do not run
< $EmailNotify = 0;           # 1 = use email notices,  0 = no email on changes
< $EmbedWiki   = 0;           # 1 = no headers/footers, 0 = normal wiki pages
< $DeletedPage = 'DeletedPage';   # 0 = disable, 'PageName' = tag to delete page
< $ReplaceFile = 'ReplaceFile';   # 0 = disable, 'PageName' = indicator tag
< @ReplaceableFiles = ();     # List of allowed server files to replace
< $TableSyntax = 1;           # 1 = wiki syntax tables, 0 = no table syntax
< $NewFS       = 0;           # 1 = new multibyte $FS,  0 = old $FS
< $UseUpload   = 0;           # 1 = allow uploads,      0 = no uploads
< 
< # Minor options:
< $LogoLeft     = 0;      # 1 = logo on left,       0 = logo on right
< $RecentTop    = 1;      # 1 = recent on top,      0 = recent on bottom
< $UseDiffLog   = 1;      # 1 = save diffs to log,  0 = do not save diffs
< $KeepMajor    = 1;      # 1 = keep major rev,     0 = expire all revisions
< $KeepAuthor   = 1;      # 1 = keep author rev,    0 = expire all revisions
< $ShowEdits    = 0;      # 1 = show minor edits,   0 = hide edits by default
< $HtmlLinks    = 0;      # 1 = allow A HREF links, 0 = no raw HTML links
< $SimpleLinks  = 0;      # 1 = only letters,       0 = allow _ and numbers
< $NonEnglish   = 0;      # 1 = extra link chars,   0 = only A-Za-z chars
< $ThinLine     = 0;      # 1 = fancy <hr> tags,    0 = classic wiki <hr>
< $BracketText  = 1;      # 1 = allow [URL text],   0 = no link descriptions
< $UseAmPm      = 1;      # 1 = use am/pm in times, 0 = use 24-hour times
< $UseIndex     = 0;      # 1 = use index file,     0 = slow/reliable method
< $UseHeadings  = 1;      # 1 = allow = h1 text =,  0 = no header formatting
< $NetworkFile  = 1;      # 1 = allow remote file:, 0 = no file:// links
< $BracketWiki  = 0;      # 1 = [WikiLnk txt] link, 0 = no local descriptions
< $UseLookup    = 1;      # 1 = lookup host names,  0 = skip lookup (IP only)
< $FreeUpper    = 1;      # 1 = force upper case,   0 = do not force case
< $FastGlob     = 1;      # 1 = new faster code,    0 = old compatible code
< $MetaKeywords = 1;      # 1 = Google-friendly,    0 = search-engine averse
< $NamedAnchors = 1;      # 0 = no anchors, 1 = enable anchors,
<                         # 2 = enable but suppress display
< $SlashLinks   = 0;      # 1 = use script/action links, 0 = script?action
< $UpperFirst   = 1;      # 1 = free links start uppercase, 0 = no ucfirst
< $AdminBar     = 1;      # 1 = admins see admin links, 0 = no admin bar
< $RepInterMap  = 0;      # 1 = intermap is replacable, 0 = not replacable
< $ConfirmDel   = 1;      # 1 = delete link confirm page, 0 = immediate delete
< $MaskHosts    = 0;      # 1 = mask hosts/IPs,      0 = no masking
< $LockCrash    = 0;      # 1 = crash if lock stuck, 0 = auto clear locks
< $HistoryEdit  = 0;      # 1 = edit links on history page, 0 = no edit links
< $OldThinLine  = 0;      # 1 = old ==== thick line, 0 = ------ for thick line
< $NumberDates  = 0;      # 1 = 2003-6-17 dates,     0 = June 17, 2003 dates
< $ParseParas   = 0;      # 1 = new paragraph markup, 0 = old markup
< $AuthorFooter = 1;      # 1 = show last author in footer, 0 = do not show
< $AllUpload    = 0;      # 1 = anyone can upload,   0 = only editor/admins
< $LimitFileUrl = 1;      # 1 = limited use of file: URLs, 0 = no limits
< $MaintTrimRc  = 0;      # 1 = maintain action trims RC, 0 = only maintainrc
< $SearchButton = 0;      # 1 = search button on page, 0 = old behavior
< $EditNameLink = 0;      # 1 = edit links use name (CSS), 0 = '?' links
< $UseMetaWiki  = 0;      # 1 = add MetaWiki search links, 0 = no MW links
< $BracketImg   = 1;      # 1 = [url url.gif] becomes image link, 0 = no img
< 
< # Names of sites.  (The first entry is used for the number link.)
< @IsbnNames = ('bn.com', 'amazon.com', 'search');
< # Full URL of each site before the ISBN
< @IsbnPre = ('http://search.barnesandnoble.com/booksearch/isbninquiry.asp?isbn=',
<             'http://www.amazon.com/exec/obidos/ISBN=',
<             'http://www.pricescan.com/books/BookDetail.asp?isbn=');
< # Rest of URL of each site after the ISBN (usually '')
< @IsbnPost = ('', '', '');
< 
< # HTML tag lists, enabled if $HtmlTags is set.
< # Scripting is currently possible with these tags,
< # so they are *not* particularly "safe".
< # Tags that must be in <tag> ... </tag> pairs:
< @HtmlPairs = qw(b i u font big small sub sup h1 h2 h3 h4 h5 h6 cite code
<   em s strike strong tt var div center blockquote ol ul dl table caption);
< # Single tags (that do not require a closing /tag)
< @HtmlSingle = qw(br p hr li dt dd tr td th);
< @HtmlPairs = (@HtmlPairs, @HtmlSingle);  # All singles can also be pairs
< 
< # == You should not have to change anything below this line. =============
< $IndentLimit = 20;                  # Maximum depth of nested lists
< $PageDir     = "$DataDir/page";     # Stores page data
< $HtmlDir     = "$DataDir/html";     # Stores HTML versions
< $UserDir     = "$DataDir/user";     # Stores user data
< $KeepDir     = "$DataDir/keep";     # Stores kept (old) page data
< $TempDir     = "$DataDir/temp";     # Temporary files and locks
< $LockDir     = "$TempDir/lock";     # DB is locked if this exists
< $InterFile   = "$DataDir/intermap"; # Interwiki site->url map
< $RcFile      = "$DataDir/rclog";    # New RecentChanges logfile
< $RcOldFile   = "$DataDir/oldrclog"; # Old RecentChanges logfile
< $IndexFile   = "$DataDir/pageidx";  # List of all pages
< $EmailFile   = "$DataDir/emails";   # Email notification lists
< 
< if ($RepInterMap) {
<   push @ReplaceableFiles, $InterFile;
< }
< 
< # The "main" program, called at the end of this script file.
< sub DoWikiRequest {
<   if ($UseConfig && (-f $ConfigFile)) {
<     $ConfigError = '';
<     if (!do $ConfigFile) {   # Some error occurred
<       $ConfigError = $@;
<       if ($ConfigError eq '') {
<         # Unfortunately, if the last expr returns 0, one will get a false
<         # error above.  To remain compatible with existing installs the
<         # wiki must not report an error unless there is error text in $@.
<         # (Errors in "use strict" may not have error text.)
<         # Uncomment the line below if you want to catch use strict errors.
< #       $ConfigError = T('Unknown Error (no error text)');
<       }
<     }
<   }
<   &InitLinkPatterns();
<   if (!&DoCacheBrowse()) {
<     eval $BrowseCode;
<     &InitRequest() or return;
<     if (!&DoBrowseRequest()) {
<       eval $OtherCode;
<       &DoOtherRequest();
<     }
<   }
< }
< 
< # == Common and cache-browsing code ====================================
< sub InitLinkPatterns {
<   my ($UpperLetter, $LowerLetter, $AnyLetter, $LpA, $LpB, $QDelim);
< 
<   # Field separators are used in the URL-style patterns below.
<   if ($NewFS) {
<     $FS  = "\x1e\xff\xfe\x1e";    # An unlikely sequence for any charset
<   } else {
<     $FS  = "\xb3";    # The FS character is a superscript "3"
<   }
<   $FS1 = $FS . "1";   # The FS values are used to separate fields
<   $FS2 = $FS . "2";   # in stored hashtables and other data structures.
<   $FS3 = $FS . "3";   # The FS character is not allowed in user data.
<   $UpperLetter = "[A-Z";
<   $LowerLetter = "[a-z";
<   $AnyLetter   = "[A-Za-z";
<   if ($NonEnglish) {
<     $UpperLetter .= "\xc0-\xde";
<     $LowerLetter .= "\xdf-\xff";
<     if ($NewFS) {
<       $AnyLetter   .= "\x80-\xff";
<     } else {
<       $AnyLetter   .= "\xc0-\xff";
<     }
<   }
<   if (!$SimpleLinks) {
<     $AnyLetter .= "_0-9";
<   }
<   $UpperLetter .= "]"; $LowerLetter .= "]"; $AnyLetter .= "]";
<   # Main link pattern: lowercase between uppercase, then anything
<   $LpA = $UpperLetter . "+" . $LowerLetter . "+" . $UpperLetter
<          . $AnyLetter . "*";
<   # Optional subpage link pattern: uppercase, lowercase, then anything
<   $LpB = $UpperLetter . "+" . $LowerLetter . "+" . $AnyLetter . "*";
<   if ($UseSubpage) {
<     # Loose pattern: If subpage is used, subpage may be simple name
<     $LinkPattern = "((?:(?:$LpA)?\\/$LpB)|$LpA)";
<     # Strict pattern: both sides must be the main LinkPattern
<     # $LinkPattern = "((?:(?:$LpA)?\\/)?$LpA)";
<   } else {
<     $LinkPattern = "($LpA)";
<   }
<   $QDelim = '(?:"")?';     # Optional quote delimiter (not in output)
<   $AnchoredLinkPattern = $LinkPattern . '#(\\w+)' . $QDelim if $NamedAnchors;
<   $LinkPattern .= $QDelim;
<   # Inter-site convention: sites must start with uppercase letter
<   # (Uppercase letter avoids confusion with URLs)
<   $InterSitePattern = $UpperLetter . $AnyLetter . "+";
<   $InterLinkPattern = "((?:$InterSitePattern:[^\\]\\s\"<>$FS]+)$QDelim)";
<   if ($FreeLinks) {
<     # Note: the - character must be first in $AnyLetter definition
<     if ($NonEnglish) {
<       if ($NewFS) {
<         $AnyLetter = "[-,.()' _0-9A-Za-z\x80-\xff]";
<       } else {
<         $AnyLetter = "[-,.()' _0-9A-Za-z\xc0-\xff]";
<       }
<     } else {
<       $AnyLetter = "[-,.()' _0-9A-Za-z]";
<     }
<   }
<   $FreeLinkPattern = "($AnyLetter+)";
<   if ($UseSubpage) {
<     $FreeLinkPattern = "((?:(?:$AnyLetter+)?\\/)?$AnyLetter+)";
<   }
<   $FreeLinkPattern .= $QDelim;
<   # Url-style links are delimited by one of:
<   #   1.  Whitespace                           (kept in output)
<   #   2.  Left or right angle-bracket (< or >) (kept in output)
<   #   3.  Right square-bracket (])             (kept in output)
<   #   4.  A single double-quote (")            (kept in output)
<   #   5.  A $FS (field separator) character    (kept in output)
<   #   6.  A double double-quote ("")           (removed from output)
<   $UrlProtocols = "http|https|ftp|afs|news|nntp|mid|cid|mailto|wais|"
<                   . "prospero|telnet|gopher";
<   $UrlProtocols .= '|file'  if ($NetworkFile || !$LimitFileUrl);
<   $UrlPattern = "((?:(?:$UrlProtocols):[^\\]\\s\"<>$FS]+)$QDelim)";
<   $ImageExtensions = "(gif|jpg|png|bmp|jpeg|ico|tiff?)";
<   $RFCPattern = "RFC\\s?(\\d+)";
<   $ISBNPattern = "ISBN:?([0-9- xX]{10,})";
<   $UploadPattern = "upload:([^\\]\\s\"<>$FS]+)$QDelim";
< }
< 
< # Simple HTML cache
< sub DoCacheBrowse {
<   my ($query, $idFile, $text);
< 
<   return 0  if (!$UseCache);
<   $query = $ENV{'QUERY_STRING'};
<   if (($query eq "") && ($ENV{'REQUEST_METHOD'} eq "GET")) {
<     $query = $HomePage;  # Allow caching of home page.
<   }
<   if (!($query =~ /^$LinkPattern$/)) {
<     if (!($FreeLinks && ($query =~ /^$FreeLinkPattern$/))) {
<       return 0;  # Only use cache for simple links
<     }
<   }
<   $idFile = &GetHtmlCacheFile($query);
<   if (-f $idFile) {
<     local $/ = undef;   # Read complete files
<     open(INFILE, "<$idFile") or return 0;
<     $text = <INFILE>;
<     close INFILE;
<     print $text;
<     return 1;
<   }
<   return 0;
< }
< 
< sub GetHtmlCacheFile {
<   my ($id) = @_;
< 
<   return $HtmlDir . "/" . &GetPageDirectory($id) . "/$id.htm";
< }
< 
< sub GetPageDirectory {
<   my ($id) = @_;
< 
<   if ($id =~ /^([a-zA-Z])/) {
<     return uc($1);
<   }
<   return "other";
< }
< 
< sub T {
<   my ($text) = @_;
< 
<   if (defined($Translate{$text}) && ($Translate{$text} ne ''))  {
<     return $Translate{$text};
<   }
<   return $text;
< }
< 
< sub Ts {
<   my ($text, $string, $noquote) = @_;
< 
<   $string = &QuoteHtml($string) unless $noquote;
<   $text = T($text);
<   $text =~ s/\%s/$string/;
<   return $text;
< }
< 
< sub Tss {
<   my $text = $_[0];
<   my @args = @_;
< 
<   @args = map {
<     $_ = &QuoteHtml($_);
<   } @args;
<   $text = T($text);
<   $text =~ s/\%([1-9])/$args[$1]/ge;
<   return $text;
< }
< 
< sub QuoteHtml {
<   my ($html) = @_;
< 
<   $html =~ s/&/&amp;/g;
<   $html =~ s/</&lt;/g;
<   $html =~ s/>/&gt;/g;
<   $html =~ s/&amp;([#a-zA-Z0-9]+);/&$1;/g;  # Allow character references
<   return $html;
< }
< 
< # == Normal page-browsing and RecentChanges code =======================
< $BrowseCode = ""; # Comment next line to always compile (slower)
< #$BrowseCode = <<'#END_OF_BROWSE_CODE';
< use CGI;
< use CGI::Carp qw(fatalsToBrowser);
< 
< sub InitRequest {
<   my @ScriptPath = split('/', "$ENV{SCRIPT_NAME}");
< 
<   $CGI::POST_MAX = $MaxPost;
<   if ($UseUpload) {
<     $CGI::DISABLE_UPLOADS = 0;  # allow uploads
<   } else {
<     $CGI::DISABLE_UPLOADS = 1;  # no uploads
<   }
<   $q = new CGI;
<   # Fix some issues with editing UTF8 pages (if charset specified)
<   if ($HttpCharset ne '') {
<     $q->charset($HttpCharset);
<   }
<   $Now = time;                     # Reset in case script is persistent
<   $ScriptName = pop(@ScriptPath);  # Name used in links
<   $IndexInit = 0;                  # Must be reset for each request
<   $InterSiteInit = 0;
<   %InterSite = ();
<   $MainPage = ".";       # For subpages only, the name of the top-level page
<   $OpenPageName = "";    # Currently open page
<   &CreateDir($DataDir);  # Create directory if it doesn't exist
<   if (!-d $DataDir) {
<     &ReportError(Ts('Could not create %s', $DataDir) . ": $!");
<     return 0;
<   }
<   &InitCookie();         # Reads in user data
<   return 1;
< }
< 
< sub InitCookie {
<   %SetCookie = ();
<   $TimeZoneOffset = 0;
<   undef $q->{'.cookies'};  # Clear cache if it exists (for SpeedyCGI)
<   %UserData = ();          # Fix for persistent environments.
<   %UserCookie = $q->cookie($CookieName);
<   $UserID = $UserCookie{'id'};
<   $UserID =~ s/\D//g;  # Numeric only
<   if ($UserID < 200) {
<     $UserID = 111;
<   } else {
<     &LoadUserData($UserID);
<   }
<   if ($UserID > 199) {
<     if (($UserData{'id'}       != $UserCookie{'id'})      ||
<         ($UserData{'randkey'}  != $UserCookie{'randkey'})) {
<       $UserID = 113;
<       %UserData = ();   # Invalid.  Consider warning message.
<     }
<   }
<   if ($UserData{'tzoffset'} != 0) {
<     $TimeZoneOffset = $UserData{'tzoffset'} * (60 * 60);
<   }
< }
< 
< sub DoBrowseRequest {
<   my ($id, $action, $text);
< 
<   if (!$q->param) {             # No parameter
<     &BrowsePage($HomePage);
<     return 1;
<   }
<   $id = &GetParam('keywords', '');
<   if ($id) {                    # Just script?PageName
<     if ($FreeLinks && (!-f &GetPageFile($id))) {
<       $id = &FreeToNormal($id);
<     }
<     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
<       $id = $NotFoundPg;
<     }
<     &BrowsePage($id)  if &ValidIdOrDie($id);
<     return 1;
<   }
<   $action = lc(&GetParam('action', ''));
<   $id = &GetParam('id', '');
<   if ($action eq 'browse') {
<     if ($FreeLinks && (!-f &GetPageFile($id))) {
<       $id = &FreeToNormal($id);
<     }
<     if (($NotFoundPg ne '') && (!-f &GetPageFile($id))) {
<       $id = $NotFoundPg;
<     }
<     &BrowsePage($id)  if &ValidIdOrDie($id);
<     return 1;
<   } elsif ($action eq 'rc') {
<     &BrowsePage($RCName);
<     return 1;
<   } elsif ($action eq 'random') {
<     &DoRandom();
<     return 1;
<   } elsif ($action eq 'history') {
<     &DoHistory($id)   if &ValidIdOrDie($id);
<     return 1;
<   }
<   return 0;  # Request not handled
< }
< 
< sub BrowsePage {
<   my ($id) = @_;
<   my ($fullHtml, $oldId, $allDiff, $showDiff, $openKept);
<   my ($revision, $goodRevision, $diffRevision, $newText);
< 
<   &OpenPage($id);
<   &OpenDefaultText();
<   $openKept = 0;
<   $revision = &GetParam('revision', '');
<   $revision =~ s/\D//g;           # Remove non-numeric chars
<   $goodRevision = $revision;      # Non-blank only if exists
<   if ($revision ne '') {
<     &OpenKeptRevisions('text_default');
<     $openKept = 1;
<     if (!defined($KeptRevisions{$revision})) {
<       $goodRevision = '';
<     } else {
<       &OpenKeptRevision($revision);
<     }
<   }
<   # Raw mode: just untranslated wiki text
<   if (&GetParam('raw', 0)) {
<      print &GetHttpHeader('text/plain');
<      print $Text{'text'};
<      return;
<   }
<   $newText = $Text{'text'};     # For differences
<   # Handle a single-level redirect
<   $oldId = &GetParam('oldid', '');
<   if (($oldId eq '') && (substr($Text{'text'}, 0, 10) eq '#REDIRECT ')) {
<     $oldId = $id;
<     if (($FreeLinks) && ($Text{'text'} =~ /\#REDIRECT\s+\[\[.+\]\]/)) {
<       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+\[\[(.+)\]\]/);
<       $id = &FreeToNormal($id);
<     } else {
<       ($id) = ($Text{'text'} =~ /\#REDIRECT\s+(\S+)/);
<     }
<     if (&ValidId($id) eq '') {
<       # Consider revision in rebrowse?
<       &ReBrowsePage($id, $oldId, 0);
<       return;
<     } else {  # Not a valid target, so continue as normal page
<       $id = $oldId;
<       $oldId = '';
<     }
<   }
<   $MainPage = $id;
<   $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
<   $fullHtml = &GetHeader($id, &QuoteHtml($id), $oldId, 1);
<   if ($revision ne '') {
<     if (($revision eq $Page{'revision'}) || ($goodRevision ne '')) {
<       $fullHtml .= '<b>' . Ts('Showing revision %s', $revision) . "</b><br>";
<     } else {
<       $fullHtml .= '<b>' . Ts('Revision %s not available', $revision)
<                    . ' (' . T('showing current revision instead')
<                    . ')</b><br>';
<     }
<   }
<   $allDiff  = &GetParam('alldiff', 0);
<   if ($allDiff != 0) {
<     $allDiff = &GetParam('defaultdiff', 1);
<   }
<   if ((($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName))
<       && &GetParam('norcdiff', 1)) {
<     $allDiff = 0;  # Only show if specifically requested
<   }
<   $showDiff = &GetParam('diff', $allDiff);
<   if ($UseDiff && $showDiff) {
<     $diffRevision = $goodRevision;
<     $diffRevision = &GetParam('diffrevision', $diffRevision);
<     # Eventually try to avoid the following keep-loading if possible?
<     &OpenKeptRevisions('text_default')  if (!$openKept);
<     $fullHtml .= &GetDiffHTML($showDiff, $id, $diffRevision,
<                               $revision, $newText);
<     $fullHtml .= "<hr class=wikilinediff>\n";
<   }
<   $fullHtml .= '<div class=wikitext>';
<   $fullHtml .= &WikiToHTML($Text{'text'});
<   $fullHtml .= '</div>';
<   if (($id eq $RCName) || (T($RCName) eq $id) || (T($id) eq $RCName)) {
<     print $fullHtml;
<     print "<hr class=wikilinerc>\n";
<     print '<div class=wikirc>';
<     &DoRc(1);
<     print '</div>';
<     print &GetFooterText($id, $goodRevision);
<     return;
<   }
<   $fullHtml .= &GetFooterText($id, $goodRevision);
<   print $fullHtml;
<   return  if ($showDiff || ($revision ne ''));  # Don't cache special version
<   &UpdateHtmlCache($id, $fullHtml)  if ($UseCache && ($oldId eq ''));
< }
< 
< sub ReBrowsePage {
<   my ($id, $oldId, $isEdit) = @_;
< 
<   if ($oldId ne "") {   # Target of #REDIRECT (loop breaking)
<     print &GetRedirectPage("action=browse&id=$id&oldid=$oldId",
<                            $id, $isEdit);
<   } else {
<     print &GetRedirectPage($id, $id, $isEdit);
<   }
< }
< 
< sub DoRc {
<   my ($rcType) = @_;   # 0 = RSS, 1 = HTML
<   my ($fileData, $rcline, $i, $daysago, $lastTs, $ts, $idOnly);
<   my (@fullrc, $status, $oldFileData, $firstTs, $errorText, $showHTML);
<   my $starttime = 0;
<   my $showbar = 0;
< 
<   if (0 == $rcType) {
<     $showHTML = 0;
<   } else {
<     $showHTML = 1;
<   }
<   if (&GetParam("from", 0)) {
<     $starttime = &GetParam("from", 0);
<     if ($showHTML) {
<       print "<h2>" . Ts('Updates since %s', &TimeToText($starttime))
<             . "</h2>\n";
<     }
<   } else {
<     $daysago = &GetParam("days", 0);
<     $daysago = &GetParam("rcdays", 0)  if ($daysago == 0);
<     if ($daysago) {
<       $starttime = $Now - ((24*60*60)*$daysago);
<       if ($showHTML) {
<         print "<h2>" . Ts('Updates in the last %s day'
<                           . (($daysago != 1)?"s":""), $daysago) . "</h2>\n";
<       }
<       # Note: must have two translations (for "day" and "days")
<       # Following comment line is for translation helper script
<       # Ts('Updates in the last %s days', '');
<     }
<   }
<   if ($starttime == 0) {
<     if (0 == $rcType) {
<       $starttime = $Now - ((24*60*60)*$RssDays);
<     } else {
<       $starttime = $Now - ((24*60*60)*$RcDefault);
<     }
<     if ($showHTML) {
<       print "<h2>" . Ts('Updates in the last %s day'
<                         . (($RcDefault != 1)?"s":""), $RcDefault) . "</h2>\n";
<     }
<     # Translation of above line is identical to previous version
<   }
<   # Read rclog data (and oldrclog data if needed)
<   ($status, $fileData) = &ReadFile($RcFile);
<   $errorText = "";
<   if (!$status) {
<     # Save error text if needed.
<     $errorText = '<p><strong>' . Ts('Could not open %s log file', $RCName)
<                  . ":</strong> $RcFile<p>"
<                  . T('Error was') . ":\n<pre>$!</pre>\n" . '<p>'
<     . T('Note: This error is normal if no changes have been made.') . "\n";
<   }
<   @fullrc = split(/\n/, $fileData);
<   $firstTs = 0;
<   if (@fullrc > 0) {  # Only false if no lines in file
<     ($firstTs) = split(/$FS3/, $fullrc[0]);
<   }
<   if (($firstTs == 0) || ($starttime <= $firstTs)) {
<     ($status, $oldFileData) = &ReadFile($RcOldFile);
<     if ($status) {
<       @fullrc = split(/\n/, $oldFileData . $fileData);
<     } else {
<       if ($errorText ne "") {  # could not open either rclog file
<         print $errorText;
<         print "<p><strong>"
<               . Ts('Could not open old %s log file', $RCName)
<               . ":</strong> $RcOldFile<p>"
<               . T('Error was') . ":\n<pre>$!</pre>\n";
<         return;
<       }
<     }
<   }
<   $lastTs = 0;
<   if (@fullrc > 0) {  # Only false if no lines in file
<     ($lastTs) = split(/$FS3/, $fullrc[$#fullrc]);
<   }
<   $lastTs++  if (($Now - $lastTs) > 5);  # Skip last unless very recent
< 
<   $idOnly = &GetParam("rcidonly", "");
<   if ($idOnly && $showHTML) {
<     print '<b>(' . Ts('for %s only', &ScriptLink($idOnly, &QuoteHtml($idOnly)), 1)
<           . ')</b><br>';
<   }
<   if ($showHTML) {
<     foreach $i (@RcDays) {
<       print " | "  if $showbar;
<       $showbar = 1;
<       print &ScriptLink("action=rc&days=$i",
<                         Ts('%s day' . (($i != 1)?'s':''), $i));
<         # Note: must have two translations (for "day" and "days")
<         # Following comment line is for translation helper script
<         # Ts('%s days', '');
<     }
<     print "<br>" . &ScriptLink("action=rc&from=$lastTs",
<                                T('List new changes starting from'));
<     print " " . &TimeToText($lastTs) . "<br>\n";
<   }
<   $i = 0;
<   while ($i < @fullrc) {  # Optimization: skip old entries quickly
<     ($ts) = split(/$FS3/, $fullrc[$i]);
<     if ($ts >= $starttime) {
<       $i -= 1000  if ($i > 0);
<       last;
<     }
<     $i += 1000;
<   }
<   $i -= 1000  if (($i > 0) && ($i >= @fullrc));
<   for (; $i < @fullrc ; $i++) {
<     ($ts) = split(/$FS3/, $fullrc[$i]);
<     last if ($ts >= $starttime);
<   }
<   if ($i == @fullrc && $showHTML) {
<     print '<br><strong>' . Ts('No updates since %s',
<                               &TimeToText($starttime)) . "</strong><br>\n";
<   } else {
<     splice(@fullrc, 0, $i);  # Remove items before index $i
<     # Consider an end-time limit (items older than X)
<     if (0 == $rcType) {
<       print &GetRcRss(@fullrc);
<     } else {
<       print &GetRcHtml(@fullrc);
<     }
<   }
<   if ($showHTML) {
<     print '<p>' . Ts('Page generated %s', &TimeToText($Now)), "<br>\n";
<   }
< }
< 
< sub GetRc {
<   my $rcType = shift;
<   my @outrc = @_;
<   my ($rcline, $date, $newtop, $author, $inlist, $result);
<   my ($showedit, $link, $all, $idOnly, $headItem, $item);
<   my ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp);
<   my ($rcchangehist, $tEdit, $tChanges, $tDiff);
<   my ($headList, $pagePrefix, $historyPrefix, $diffPrefix);
<   my %extra = ();
<   my %changetime = ();
<   my %pagecount = ();
< 
<   # Slice minor edits
<   $showedit = &GetParam("rcshowedit", $ShowEdits);
<   $showedit = &GetParam("showedit", $showedit);
<   if ($showedit != 1) {
<     my @temprc = ();
<     foreach $rcline (@outrc) {
<       ($ts, $pagename, $summary, $isEdit, $host) = split(/$FS3/, $rcline);
<       if ($showedit == 0) {  # 0 = No edits
<         push(@temprc, $rcline)  if (!$isEdit);
<       } else {               # 2 = Only edits
<         push(@temprc, $rcline)  if ($isEdit);
<       }
<     }
<     @outrc = @temprc;
<   }
<   # Optimize param fetches out of main loop
<   $rcchangehist = &GetParam("rcchangehist", 1);
<   # Optimize translations out of main loop
<   $tEdit    = T('(edit)');
<   $tDiff    = T('(diff)');
<   $tChanges = T('changes');
<   $pagePrefix = $QuotedFullUrl . &ScriptLinkChar();
<   $diffPrefix = $pagePrefix . &QuoteHtml("action=browse&diff=4&id=");
<   $historyPrefix = $pagePrefix . &QuoteHtml("action=history&id=");
<   foreach $rcline (@outrc) {
<     ($ts, $pagename) = split(/$FS3/, $rcline);
<     $pagecount{$pagename}++;
<     $changetime{$pagename} = $ts;
<   }
<   $date = "";
<   $all = &GetParam("rcall", 0);
<   $all = &GetParam("all", $all);
<   $newtop = &GetParam("rcnewtop", $RecentTop);
<   $newtop = &GetParam("newtop", $newtop);
<   $idOnly = &GetParam("rcidonly", "");
<   $inlist = 0;
<   $headList = '';
<   $result = '';
<   @outrc = reverse @outrc if ($newtop);
<   foreach $rcline (@outrc) {
<     ($ts, $pagename, $summary, $isEdit, $host, $kind, $extraTemp)
<       = split(/$FS3/, $rcline);
<     next  if ((!$all) && ($ts < $changetime{$pagename}));
<     next  if (($idOnly ne "") && ($idOnly ne $pagename));
<     %extra = split(/$FS2/, $extraTemp, -1);
<     if ($date ne &CalcDay($ts)) {
<       $date = &CalcDay($ts);
<       if (1 == $rcType) {  # HTML
<         # add date, properly closing lists first
<         if ($inlist) {
<           $result .= "</UL>\n";
<           $inlist = 0;
<         }
<         $result .= "<p><strong>" . $date . "</strong></p>\n";
<         if (!$inlist) {
<           $result .= "<UL>\n";
<           $inlist = 1;
<         }
<       }
<     }
<     if (0 == $rcType) {  # RSS
<       ($headItem, $item) = &GetRssRcLine($pagename, $ts, $host,
<                               $extra{'name'}, $extra{'id'}, $summary, $isEdit,
<                               $pagecount{$pagename}, $extra{'revision'},
<                               $diffPrefix, $historyPrefix, $pagePrefix);
<       $headList .= $headItem;
<       $result   .= $item;
<     } else {  # HTML
<       $result .= &GetHtmlRcLine($pagename, $ts, $host, $extra{'name'},
<                          $extra{'id'}, $summary, $isEdit,
<                          $pagecount{$pagename}, $extra{'revision'},
<                          $tEdit, $tDiff, $tChanges, $all, $rcchangehist);
<     }
<   }
<   if (1 == $rcType) {
<     $result .= "</UL>\n"  if ($inlist);  # Close final tag
<   }
<   return ($headList, $result);  # Just ignore headList for HTML
< }
< 
< sub GetRcHtml {
<   my ($html, $extra);
< 
<   ($extra, $html) = &GetRc(1, @_);
<   return $html;
< }
< 
< sub GetHtmlRcLine {
<   my ($pagename, $timestamp, $host, $userName, $userID, $summary,
<       $isEdit, $pagecount, $revision, $tEdit, $tDiff, $tChanges, $all,
<       $rcchangehist) = @_;
<   my ($author, $sum, $edit, $count, $link, $html);
< 
<   $html = '';
<   $host = &QuoteHtml($host);
<   if (defined($userName) && defined($userID)) {
<     $author = &GetAuthorLink($host, $userName, $userID);
<   } else {
<     $author = &GetAuthorLink($host, "", 0);
<   }
<   $sum = "";
<   if (($summary ne "") && ($summary ne "*")) {
<     $summary = &QuoteHtml($summary);
<     $sum = "<strong>[$summary]</strong> ";
<   }
<   $edit = "";
<   $edit = "<em>$tEdit</em> "  if ($isEdit);
<   $count = "";
<   if ((!$all) && ($pagecount > 1)) {
<     $count = "($pagecount ";
<     if ($rcchangehist) {
<       $count .= &GetHistoryLink($pagename, $tChanges);
<     } else {
<       $count .= $tChanges;
<     }
<     $count .= ") ";
<   }
<   $link = "";
<   if ($UseDiff && &GetParam("diffrclink", 1)) {
<     $link .= &ScriptLinkDiff(4, $pagename, $tDiff, "") . "  ";
<   }
<   $link .= &GetPageLink($pagename);
<   $html .= "<li>$link ";
<   $html .=  &CalcTime($timestamp) . " $count$edit" . " $sum";
<   $html .= ". . . . . $author\n";
<   return $html;
< }
< 
< sub GetRcRss {
<   my ($rssHeader, $headList, $items);
< 
<   # Normally get URL from script, but allow override
<   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
<   $QuotedFullUrl = &QuoteHtml($FullUrl);
<   $SiteDescription = &QuoteHtml($SiteDescription);
< 
<   my $ChannelAbout = &QuoteHtml($FullUrl . &ScriptLinkChar()
<                                 . $ENV{QUERY_STRING});
<   $rssHeader = <<RSS ;
< <?xml version="1.0" encoding="ISO-8859-1"?>
< <rdf:RDF
<     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
<     xmlns="http://purl.org/rss/1.0/"
<     xmlns:dc="http://purl.org/dc/elements/1.1/"
<     xmlns:wiki="http://purl.org/rss/1.0/modules/wiki/"
< >
<     <channel rdf:about="$ChannelAbout">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <link>${\($QuotedFullUrl . &ScriptLinkChar() . &QuoteHtml("$RCName"))}</link>
<         <description>${\(&QuoteHtml($SiteDescription))}</description>
<         <wiki:interwiki>
<             <rdf:Description link="$QuotedFullUrl">
<                 <rdf:value>$InterWikiMoniker</rdf:value>
<             </rdf:Description>
<         </wiki:interwiki>
<         <items>
<             <rdf:Seq>
< RSS
<   ($headList, $items) = &GetRc(0, @_);
<   $rssHeader .= $headList;
<   return <<RSS ;
< $rssHeader
<             </rdf:Seq>
<         </items>
<     </channel>
<     <image rdf:about="${\(&QuoteHtml($RssLogoUrl))}">
<         <title>${\(&QuoteHtml($SiteName))}</title>
<         <url>$RssLogoUrl</url>
<         <link>$QuotedFullUrl</link>
<     </image>
< $items
< </rdf:RDF>
< RSS
< }
< 
< sub GetRssRcLine{
<   my ($pagename, $timestamp, $host, $userName, $userID, $summary, $isEdit,
<       $pagecount, $revision, $diffPrefix, $historyPrefix, $pagePrefix) = @_;
<   my ($pagenameEsc, $itemID, $description, $authorLink, $author, $status,
<       $importance, $date, $item, $headItem);
< 
<   $pagenameEsc = CGI::escape($pagename);
<   # Add to list of items in the <channel/>
<   $itemID = $FullUrl . &ScriptLinkChar()
<             . &GetOldPageParameters('browse', $pagenameEsc, $revision);
<   $itemID = &QuoteHtml($itemID);
<   $headItem = "                <rdf:li rdf:resource=\"$itemID\"/>\n";
<   # Add to list of items proper.
<   if (($summary ne "") && ($summary ne "*")) {
<     $description = &QuoteHtml($summary);
<   }
<   $host = &QuoteHtml($host);
<   if ($userName) {
<     $author = &QuoteHtml($userName);
<     $authorLink = 'link="' . $QuotedFullUrl . &ScriptLinkChar() . $author . '"';
<   } else {
<     $author = $host;
<   }
<   $status = (1 == $revision) ? 'new' : 'updated';
<   $importance = $isEdit ? 'minor' : 'major';
<   $timestamp += $TimeZoneOffset;
<   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($timestamp);
<   $year += 1900;
<   $date = sprintf("%4d-%02d-%02dT%02d:%02d:%02d+%02d:00",
<     $year, $mon+1, $mday, $hour, $min, $sec, $TimeZoneOffset/(60*60));
<   $pagename = &QuoteHtml($pagename);
<   # Write it out longhand
<   $item = <<RSS ;
<     <item rdf:about="$itemID">
<         <title>$pagename</title>
<         <link>$pagePrefix$pagenameEsc</link>
<         <description>$description</description>
<         <dc:date>$date</dc:date>
<         <dc:contributor>
<             <rdf:Description wiki:host="$host" $authorLink>
<                 <rdf:value>$author</rdf:value>
<             </rdf:Description>
<         </dc:contributor>
<         <wiki:status>$status</wiki:status>
<         <wiki:importance>$importance</wiki:importance>
<         <wiki:diff>$diffPrefix$pagenameEsc</wiki:diff>
<         <wiki:version>$revision</wiki:version>
<         <wiki:history>$historyPrefix$pagenameEsc</wiki:history>
<     </item>
< RSS
<   return ($headItem, $item);
< }
< 
< sub DoRss {
<   print "Content-type: text/xml\n\n";
<   &DoRc(0);
< }
< 
< sub DoRandom {
<   my ($id, @pageList);
< 
<   @pageList = &AllPagesList();  # Optimize?
<   $id = $pageList[int(rand($#pageList + 1))];
<   &ReBrowsePage($id, "", 0);
< }
< 
< sub DoHistory {
<   my ($id) = @_;
<   my ($html, $canEdit, $row, $newText);
< 
<   print &GetHeader('', Ts('History of %s', $id), '') . '<br>';
<   &OpenPage($id);
<   &OpenDefaultText();
<   $newText = $Text{'text'};
<   $canEdit = 0;
<   $canEdit = &UserCanEdit($id)  if ($HistoryEdit);
<   if ($UseDiff) {
<     print <<EOF ;
<       <form action="$ScriptName" METHOD="GET">
<           <input type="hidden" name="action" value="browse"/>
<           <input type="hidden" name="diff" value="1"/>
<           <input type="hidden" name="id" value="$id"/>
<       <table border="0" width="100%"><tr>
< EOF
<   }
<   $html = &GetHistoryLine($id, $Page{'text_default'}, $canEdit, $row++);
<   &OpenKeptRevisions('text_default');
<   foreach (reverse sort {$a <=> $b} keys %KeptRevisions) {
<     next  if ($_ eq "");  # (needed?)
<     $html .= &GetHistoryLine($id, $KeptRevisions{$_}, $canEdit, $row++);
<   }
<   print $html;
<   if ($UseDiff) {
<     my $label = T('Compare');
<     print "<tr><td align='center'><input type='submit' "
<           . "value='$label'/>&nbsp;&nbsp;</td></table></form>\n";
<     print "<hr class=wikilinediff>\n";
<     print &GetDiffHTML(&GetParam('defaultdiff', 1), $id, '', '', $newText);
<   }
<   print &GetCommonFooter();
< }
< 
< sub GetMaskedHost {
<   my ($text) = @_;
<   my ($logText);
< 
<   if (!$MaskHosts) {
<     return $text;
<   }
<   $logText = T('(logged)');
<   if (!($text =~ s/\d+$/$logText/)) { # IP address (ending numbers masked)
<     $text =~ s/^[^\.\(]+/$logText/;   # Host name: mask until first .
<   }
<   return $text;
< }
< 
< sub GetHistoryLine {
<   my ($id, $section, $canEdit, $row) = @_;
<   my ($html, $expirets, $rev, $summary, $host, $user, $uid, $ts, $minor);
<   my (%sect, %revtext);
< 
<   %sect = split(/$FS2/, $section, -1);
<   %revtext = split(/$FS3/, $sect{'data'});
<   $rev = $sect{'revision'};
<   $summary = $revtext{'summary'};
<   if ((defined($sect{'host'})) && ($sect{'host'} ne '')) {
<     $host = $sect{'host'};
<   } else {
<     $host = $sect{'ip'};
<   }
<   $host = &GetMaskedHost($host);
<   $user = $sect{'username'};
<   $uid = $sect{'id'};
<   $ts = $sect{'ts'};
<   $minor = '';
<   $minor = '<i>' . T('(edit)') . '</i> '  if ($revtext{'minor'});
<   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
<   if ($UseDiff) {
<     my ($c1, $c2);
<     $c1 = 'checked="checked"' if 1 == $row;
<     $c2 = 'checked="checked"' if 0 == $row;
<     $html .= "<tr><td align='center'><input type='radio' "
<              . "name='diffrevision' value='$rev' $c1/> ";
<     $html .= "<input type='radio' name='revision' value='$rev' $c2/></td><td>";
<   }
<   if (0 == $row) { # current revision
<     $html .= &GetPageLinkText($id, Ts('Revision %s', $rev)) . ' ';
<     if ($canEdit) {
<       $html .= &GetEditLink($id, T('Edit')) . ' ';
<     }
<   } else {
<     $html .= &GetOldPageLink('browse', $id, $rev,
<                              Ts('Revision %s', $rev)) . ' ';
<     if ($canEdit) {
<       $html .= &GetOldPageLink('edit',   $id, $rev, T('Edit')) . ' ';
<     }
<   }
<   $html .= ". . " . $minor . &TimeToText($ts) . " ";
<   $html .= T('by') . ' ' . &GetAuthorLink($host, $user, $uid) . " ";
<   if (defined($summary) && ($summary ne "") && ($summary ne "*")) {
<     $summary = &QuoteHtml($summary);   # Thanks Sunir! :-)
<     $html .= "<b>[$summary]</b> ";
<   }
<   $html .= $UseDiff ? "</tr>\n" : "<br>\n";
<   return $html;
< }
< 
< # ==== HTML and page-oriented functions ====
< sub ScriptLinkChar {
<   if ($SlashLinks) {
<     return '/';
<   }
<   return '?';
< }
< 
< sub ScriptLink {
<   my ($action, $text) = @_;
< 
<   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
<          . "\">$text</a>";
< }
< 
< sub ScriptLinkClass {
<   my ($action, $text, $class) = @_;
< 
<   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
<          . '" class="' . $class . "\">$text</a>";
< }
< 
< sub GetPageLinkText {
<   my ($id, $name) = @_;
< 
<   $id =~ s|^/|$MainPage/|;
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<     $name =~ s/_/ /g;
<   }
<   return &ScriptLinkClass($id, $name, 'wikipagelink');
< }
< 
< sub GetPageLink {
<   my ($id) = @_;
< 
<   return &GetPageLinkText($id, $id);
< }
< 
< sub GetEditLink {
<   my ($id, $name) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<     $name =~ s/_/ /g;
<   }
<   return &ScriptLinkClass("action=edit&id=$id", $name, 'wikipageedit');
< }
< 
< sub GetDeleteLink {
<   my ($id, $name, $confirm) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<     $name =~ s/_/ /g;
<   }
<   return &ScriptLink("action=delete&id=$id&confirm=$confirm", $name);
< }
< 
< sub GetOldPageParameters {
<   my ($kind, $id, $revision) = @_;
< 
<   $id = &FreeToNormal($id) if $FreeLinks;
<   return "action=$kind&id=$id&revision=$revision";
< }
< 
< sub GetOldPageLink {
<   my ($kind, $id, $revision, $name) = @_;
< 
<   $name =~ s/_/ /g if $FreeLinks;
<   return &ScriptLink(&GetOldPageParameters($kind, $id, $revision), $name);
< }
< 
< sub GetPageOrEditAnchoredLink {
<   my ($id, $anchor, $name) = @_;
<   my (@temp, $exists);
< 
<   if ($name eq "") {
<     $name = $id;
<     if ($FreeLinks) {
<       $name =~ s/_/ /g;
<     }
<   }
<   $id =~ s|^/|$MainPage/|;
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
<   $exists = 0;
<   if ($UseIndex) {
<     if (!$IndexInit) {
<       @temp = &AllPagesList();          # Also initializes hash
<     }
<     $exists = 1  if ($IndexHash{$id});
<   } elsif (-f &GetPageFile($id)) {      # Page file exists
<     $exists = 1;
<   }
<   if ($exists) {
<     $id = "$id#$anchor"  if $anchor;
<     $name = "$name#$anchor"  if $anchor && $NamedAnchors != 2;
<     return &GetPageLinkText($id, $name);
<   }
<   if ($FreeLinks && !$EditNameLink) {
<     if ($name =~ m| |) {  # Not a single word
<       $name = "[$name]";  # Add brackets so boundaries are obvious
<     }
<   }
<   if ($EditNameLink) {
<     return &GetEditLink($id, $name);
<   } else {
<     return $name . &GetEditLink($id, '?');
<   }
< }
< 
< sub GetPageOrEditLink {
<     my ($id, $name) = @_;
<     return &GetPageOrEditAnchoredLink($id, "", $name);
< }
< 
< sub GetBackLinksSearchLink {
<   my ($id) = @_;
<   my $name = $id;
< 
<   $id =~ s|.+/|/|;   # Subpage match: search for just /SubName
<   if ($FreeLinks) {
<     $name =~ s/_/ /g;  # Display with spaces
<     $id =~ s/_/+/g;    # Search for url-escaped spaces
<   }
<   return &ScriptLink("back=$id", $name);
< }
< 
< sub GetPrefsLink {
<   return &ScriptLink("action=editprefs", T('Preferences'));
< }
< 
< sub GetRandomLink {
<   return &ScriptLink("action=random", T('Random Page'));
< }
< 
< sub ScriptLinkDiff {
<   my ($diff, $id, $text, $rev) = @_;
< 
<   $rev = "&revision=$rev"  if ($rev ne "");
<   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
<   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
< }
< 
< sub ScriptLinkDiffRevision {
<   my ($diff, $id, $rev, $text) = @_;
< 
<   $rev = "&diffrevision=$rev"  if ($rev ne "");
<   $diff = &GetParam("defaultdiff", 1)  if ($diff == 4);
<   return &ScriptLink("action=browse&diff=$diff&id=$id$rev", $text);
< }
< 
< sub GetUploadLink {
<   return &ScriptLink('action=upload', T('Upload'));
< }
< 
< sub ScriptLinkTitle {
<   my ($action, $text, $title) = @_;
< 
<   if ($FreeLinks) {
<     $action =~ s/ /_/g;
<   }
<   return '<a href="' . $ScriptName . &ScriptLinkChar() . &UriEscape($action)
<          . "\" title=\"$title\">$text</a>";
< }
< 
< sub GetAuthorLink {
<   my ($host, $userName, $uid) = @_;
<   my ($html, $title, $userNameShow);
< 
<   $userNameShow = $userName;
<   if ($FreeLinks) {
<     $userName     =~ s/ /_/g;
<     $userNameShow =~ s/_/ /g;
<   }
<   if (&ValidId($userName) ne "") {  # Invalid under current rules
<     $userName = "";  # Just pretend it isn't there.
<   }
<   if (($uid > 0) && ($userName ne "")) {
<     $html = &ScriptLinkTitle($userName, $userNameShow,
<             Ts('ID %s', $uid) . ' ' . Ts('from %s', $host));
<   } else {
<     $html = $host;
<   }
<   return $html;
< }
< 
< sub GetHistoryLink {
<   my ($id, $text) = @_;
< 
<   if ($FreeLinks) {
<     $id =~ s/ /_/g;
<   }
<   return &ScriptLink("action=history&id=$id", $text);
< }
< 
< sub GetHeader {
<   my ($id, $title, $oldId, $backlinks) = @_;
<   my $header = "";
<   my $logoImage = "";
<   my $result = "";
<   my $embed = &GetParam('embed', $EmbedWiki);
<   my $altText = T('[Home]');
< 
<   $result = &GetHttpHeader('');
<   if ($FreeLinks) {
<     $title =~ s/_/ /g;   # Display as spaces
<   }
<   $result .= &GetHtmlHeader("$SiteName: $title");
<   return $result  if ($embed);
< 
<   $result .= '<div class=wikiheader>';
<   if ($oldId ne '') {
<     $result .= $q->h3('(' . Ts('redirected from %s', 
<                                &GetEditLink($oldId, &QuoteHtml($oldId)), 1) . ')');
<   }
<   if ((!$embed) && ($LogoUrl ne "")) {
<     $logoImage = "img src=\"$LogoUrl\" alt=\"$altText\" border=0";
<     if (!$LogoLeft) {
<       $logoImage .= " align=\"right\"";
<     }
<     $header = &ScriptLink($HomePage, "<$logoImage>");
<   }
<   if ($id and $backlinks) {
<     $result .= $q->h1($header . &GetBackLinksSearchLink($id));
<   } else {
<     $result .= $q->h1($header . $title);
<   }
<   if (&GetParam("toplinkbar", 1)) {
<     $result .= &GetGotoBar($id) . "<hr class=wikilineheader>";
<   }
<   $result .= '</div>';
<   return $result;
< }
< 
< sub GetHttpHeader {
<   my ($type) = @_;
<   my $cookie;
< 
<   $type = 'text/html'  if ($type eq '');
<   if (defined($SetCookie{'id'})) {
<     $cookie = "$CookieName="
<             . "rev&" . $SetCookie{'rev'}
<             . "&id&" . $SetCookie{'id'}
<             . "&randkey&" . $SetCookie{'randkey'};
<     $cookie .= ";expires=Fri, 08-Sep-2013 19:48:23 GMT";
<     if ($HttpCharset ne '') {
<       return $q->header(-cookie=>$cookie,
<                         -type=>"$type; charset=$HttpCharset");
<     }
<     return $q->header(-cookie=>$cookie);
<   }
<   if ($HttpCharset ne '') {
<     return $q->header(-type=>"$type; charset=$HttpCharset");
<   }
<   return $q->header(-type=>$type);
< }
< 
< sub GetHtmlHeader {
<   my ($title) = @_;
<   my ($dtd, $html, $bodyExtra, $stylesheet);
< 
<   $html = '';
<   $dtd = '-//IETF//DTD HTML//EN';
<   $html = qq(<!DOCTYPE HTML PUBLIC "$dtd">\n);
<   $title = $q->escapeHTML($title);
<   $html .= "<HTML><HEAD><TITLE>$title</TITLE>\n";
<   if ($FavIcon ne '') {
<     $html .= '<LINK REL="SHORTCUT ICON" HREF="' . $FavIcon . '">' 
<   }
<   if ($MetaKeywords) {
<       my $keywords = $OpenPageName;
<       $keywords =~ s/([a-z])([A-Z])/$1, $2/g;
<       $html .= "<META NAME='KEYWORDS' CONTENT='$keywords'/>\n" if $keywords;
<   }
<   # we don't want robots indexing our history or other admin pages
<   my $action = lc(&GetParam('action', ''));
<   unless (!$action or $action eq "rc" or $action eq "index") {
<     $html .= "<META NAME='robots' CONTENT='noindex,nofollow'>\n";
<   }
<   if ($SiteBase ne "") {
<     $html .= qq(<BASE HREF="$SiteBase">\n);
<   }
<   $stylesheet = &GetParam('stylesheet', $StyleSheet);
<   $stylesheet = $StyleSheet  if ($stylesheet eq '');
<   $stylesheet = ''  if ($stylesheet eq '*');  # Allow removing override
<   if ($stylesheet ne '') {
<     $html .= qq(<LINK REL="stylesheet" HREF="$stylesheet">\n);
<   }
<   $html .= $UserHeader;
<   $bodyExtra = '';
<   if ($UserBody ne '') {
<     $bodyExtra = ' ' . $UserBody;
<   }
<   if ($BGColor ne '') {
<     $bodyExtra .= qq( BGCOLOR="$BGColor");
<   }
<   $html .= "</HEAD><BODY$bodyExtra>\n";
<   return $html;
< }
< 
< sub GetFooterText {
<   my ($id, $rev) = @_;
<   my $result;
< 
<   if (&GetParam('embed', $EmbedWiki)) {
<     return $q->end_html;
<   }
<   $result = '<div class=wikifooter>';
<   $result .= "<hr class=wikilinefooter>\n";
<   $result .= &GetFormStart();
<   $result .= &GetGotoBar($id);
<   if (&UserCanEdit($id, 0)) {
<     if ($rev ne '') {
<       $result .= &GetOldPageLink('edit',   $id, $rev,
<                                  Ts('Edit revision %s of this page', $rev));
<     } else {
<       $result .= &GetEditLink($id, T('Edit text of this page'));
<     }
<   } else {
<     $result .= T('This page is read-only');
<   }
<   $result .= ' | ';
<   $result .= &GetHistoryLink($id, T('View other revisions'));
<   if ($rev ne '') {
<     $result .= ' | ';
<     $result .= &GetPageLinkText($id, T('View current revision'));
<   }
<   if ($UseMetaWiki) {
<     $result .= ' | <a href="http://sunir.org/apps/meta.pl?' . &UriEscape($id) . '">'
<                . T('Search MetaWiki') . '</a>';
<   }
<   if ($Section{'revision'} > 0) {
<     $result .= '<br>';
<     if ($rev eq '') {  # Only for most current rev
<       $result .= T('Last edited');
<     } else {
<       $result .= T('Edited');
<     }
<     $result .= ' ' . &TimeToText($Section{ts});
<     if ($AuthorFooter) {
<       $result .= ' ' . Ts('by %s', &GetAuthorLink($Section{'host'},
<                                      $Section{'username'}, $Section{'id'}), 1);
<     }
<   }
<   if ($UseDiff) {
<     $result .= ' ' . &ScriptLinkDiff(4, $id, T('(diff)'), $rev);
<   }
<   $result .= '<br>' . &GetSearchForm();
<   if ($AdminBar && &UserIsAdmin()) {
<     $result .= '<br>' . &GetAdminBar($id);
<   }
<   if ($DataDir =~ m|/tmp/|) {
<     $result .= '<br><b>' . T('Warning') . ':</b> '
<                . Ts('Database is stored in temporary directory %s',
<                     $DataDir) . '<br>';
<   }
<   if ($ConfigError ne '') {
<     $result .= '<br><b>' . T('Config file error:') . '</b> '
<                . $ConfigError . '<br>';
<   }
<   $result .= $q->endform;
<   if ($FooterNote ne '') {
<     $result .= T($FooterNote);
<   }
<   $result .= '</div>';
<   $result .= &GetMinimumFooter();
<   return $result;
< }
< 
< sub GetCommonFooter {
<   my ($html);
< 
<   $html = '<div class=wikifooter>' . '<hr class=wikilinefooter>'
<           . &GetFormStart() . &GetGotoBar('')
<           . &GetSearchForm() . $q->endform;
<   if ($FooterNote ne '') {
<     $html .= T($FooterNote);
<   }
<   $html .= '</div>' . $q->end_html;
<   return $html;
< }
< 
< sub GetMinimumFooter {
<   return $q->end_html;
< }
< 
< sub GetFormStart {
<   return $q->startform("POST", "$ScriptName",
<                        "application/x-www-form-urlencoded");
< }
< 
< sub GetGotoBar {
<   my ($id) = @_;
<   my ($main, $bartext);
< 
<   $bartext  = &GetPageLink($HomePage);
<   if ($id =~ m|/|) {
<     $main = $id;
<     $main =~ s|/.*||;  # Only the main page name (remove subpage)
<     $bartext .= " | " . &GetPageLink($main);
<   }
<   $bartext .= " | " . &GetPageLink($RCName);
<   $bartext .= " | " . &GetPrefsLink();
<   if ($UseUpload && &UserCanUpload()) {
<     $bartext .= " | " . &GetUploadLink();
<   }
<   if (&GetParam("linkrandom", 0)) {
<     $bartext .= " | " . &GetRandomLink();
<   }
<   if ($UserGotoBar ne '') {
<     $bartext .= " | " . $UserGotoBar;
<   }
<   $bartext .= "<br>\n";
<   return $bartext;
< }
< 
< # Admin bar contributed by ElMoro (with some changes)
< sub GetPageLockLink {
<   my ($id, $status, $name) = @_;
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
<   return &ScriptLink("action=pagelock&set=$status&id=$id", $name);
< }
< 
< sub GetAdminBar {
<   my ($id) = @_;
<   my ($result);
< 
<   $result = T('Administration') . ': ';
<   if (-f &GetLockedPageFile($id))   { 
<     $result .= &GetPageLockLink($id, 0, T('Unlock page'));
<   }
<   else  {
<     $result .= &GetPageLockLink($id, 1, T('Lock page'));
<   }
<   $result .= " | " . &GetDeleteLink($id, T('Delete this page'), 0);
<   $result .= " | " . &ScriptLink("action=editbanned", T("Edit Banned List"));
<   $result .= " | " . &ScriptLink("action=maintain", T("Run Maintenance"));
<   $result .= " | " . &ScriptLink("action=editlinks", T("Edit/Rename pages")); 
<   if (-f "$DataDir/noedit") {
<     $result .= " | " . &ScriptLink("action=editlock&set=0", T("Unlock site")); 
<   } else {
<     $result .= " | " . &ScriptLink("action=editlock&set=1", T("Lock site"));
<   }
<   return $result;
< }
< 
< sub GetSearchForm {
<   my ($result);
< 
<   $result = T('Search:') . ' ' . $q->textfield(-name=>'search', -size=>20);
<   if ($SearchButton) {
<     $result .= $q->submit('dosearch', T('Go!'));
<   } else {  
<     $result .= &GetHiddenValue("dosearch", 1);
<   }
<   return $result;
< }
< 
< sub GetRedirectPage {
<   my ($newid, $name, $isEdit) = @_;
<   my ($url, $html);
<   my ($nameLink);
< 
<   # Normally get URL from script, but allow override.
<   $FullUrl = $q->url(-full=>1)  if ($FullUrl eq "");
<   $url = $FullUrl . &ScriptLinkChar() . &UriEscape($newid);
<   $nameLink = "<a href=\"$url\">$name</a>";
<   if ($RedirType < 3) {
<     if ($RedirType == 1) {             # Use CGI.pm
<       # NOTE: do NOT use -method (does not work with old CGI.pm versions)
<       # Thanks to Daniel Neri for fixing this problem.
<       $html = $q->redirect(-uri=>$url);
<     } else {                           # Minimal header
<       $html  = "Status: 302 Moved\n";
<       $html .= "Location: $url\n";
<       $html .= "Content-Type: text/html\n";  # Needed for browser failure
<       $html .= "\n";
<     }
<     $html .= "\n" . Ts('Your browser should go to the %s page.', $newid);
<     $html .= ' ' . Ts('If it does not, click %s to continue.', $nameLink);
<   } else {
<     if ($isEdit) {
<       $html  = &GetHeader('', T('Thanks for editing...'), '');
<       $html .= Ts('Thank you for editing %s.', $nameLink);
<     } else {
<       $html  = &GetHeader('', T('Link to another page...'), '');
<     }
<     $html .= "\n<p>";
<     $html .= Ts('Follow the %s link to continue.', $nameLink);
<     $html .= &GetMinimumFooter();
<   }
<   return $html;
< }
< 
< # ==== Common wiki markup ====
< sub RestoreSavedText {
<   my ($text) = @_;
< 
<   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
<   return $text;
< }
< 
< sub RemoveFS {
<   my ($text) = @_;
< 
<   # Note: must remove all $FS, and $FS may be multi-byte/char separator
<   $text =~ s/($FS)+(\d)/$2/g;
<   return $text;
< }
< 
< sub WikiToHTML {
<   my ($pageText) = @_;
<   $TableMode = 0;
< 
<   %SaveUrl = ();
<   %SaveNumUrl = ();
<   $SaveUrlIndex = 0;
<   $SaveNumUrlIndex = 0;
<   $pageText = &RemoveFS($pageText);
<   if ($RawHtml) {
<     $pageText =~ s/<html>((.|\n)*?)<\/html>/&StoreRaw($1)/ige;
<   }
<   $pageText = &QuoteHtml($pageText);
<   $pageText =~ s/\\ *\r?\n/ /g;          # Join lines with backslash at end
<   if ($ParseParas) {
<     # Note: The following 3 rules may span paragraphs, so they are
<     #       copied from CommonMarkup
<     $pageText =~
<         s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
<     $pageText =~
<         s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
<     $pageText =~
<         s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
<     $pageText =~ s/((.|\n)+?\n)\s*(\n|$)/&ParseParagraph($1)/geo;
<     $pageText =~ s/(.*)<\/p>(.+)$/$1.&ParseParagraph($2)/seo;
<   } else {
<     $pageText = &CommonMarkup($pageText, 1, 0);   # Multi-line markup
<     $pageText = &WikiLinesToHtml($pageText);      # Line-oriented markup
<   }
<   while (@HeadingNumbers) {
<     pop @HeadingNumbers;
<     $TableOfContents .= "</dd></dl>\n\n";
<   }
<   $pageText =~ s/&lt;toc&gt;/$TableOfContents/gi;
<   if ($LateRules ne '') {
<     $pageText = &EvalLocalRules($LateRules, $pageText, 0);
<   }
<   return &RestoreSavedText($pageText);
< }
< 
< sub CommonMarkup {
<   my ($text, $useImage, $doLines) = @_;
<   local $_ = $text;
< 
<   if ($doLines < 2) { # 2 = do line-oriented only
<     # The <nowiki> tag stores text with no markup (except quoting HTML)
<     s/\&lt;nowiki\&gt;((.|\n)*?)\&lt;\/nowiki\&gt;/&StoreRaw($1)/ige;
<     # The <pre> tag wraps the stored text with the HTML <pre> tag
<     s/\&lt;pre\&gt;((.|\n)*?)\&lt;\/pre\&gt;/&StorePre($1, "pre")/ige;
<     s/\&lt;code\&gt;((.|\n)*?)\&lt;\/code\&gt;/&StorePre($1, "code")/ige;
<     if ($EarlyRules ne '') {
<       $_ = &EvalLocalRules($EarlyRules, $_, !$useImage);
<     }
<     s/\[\#(\w+)\]/&StoreHref(" name=\"$1\"")/ge if $NamedAnchors;
<     if ($HtmlTags) {
<       my ($t);
<       foreach $t (@HtmlPairs) {
<         s/\&lt;$t(\s[^<>]+?)?\&gt;(.*?)\&lt;\/$t\&gt;/<$t$1>$2<\/$t>/gis;
<       }
<       foreach $t (@HtmlSingle) {
<         s/\&lt;$t(\s[^<>]+?)?\&gt;/<$t$1>/gi;
<       }
<     } else {
<       # Note that these tags are restricted to a single line
<       s/\&lt;b\&gt;(.*?)\&lt;\/b\&gt;/<b>$1<\/b>/gi;
<       s/\&lt;i\&gt;(.*?)\&lt;\/i\&gt;/<i>$1<\/i>/gi;
<       s/\&lt;strong\&gt;(.*?)\&lt;\/strong\&gt;/<strong>$1<\/strong>/gi;
<       s/\&lt;em\&gt;(.*?)\&lt;\/em\&gt;/<em>$1<\/em>/gi;
<     }
<     s/\&lt;tt\&gt;(.*?)\&lt;\/tt\&gt;/<tt>$1<\/tt>/gis;  # <tt> (MeatBall)
<     s/\&lt;br\&gt;/<br>/gi;  # Allow simple line break anywhere
<     if ($HtmlLinks) {
<       s/\&lt;A(\s[^<>]+?)\&gt;(.*?)\&lt;\/a\&gt;/&StoreHref($1, $2)/gise;
<     }
<     if ($FreeLinks) {
<       # Consider: should local free-link descriptions be conditional?
<       # Also, consider that one could write [[Bad Page|Good Page]]?
<       s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&StorePageOrEditLink($1, $2)/geo;
<       s/\[\[$FreeLinkPattern\]\]/&StorePageOrEditLink($1, "")/geo;
<     }
<     if ($BracketText) {  # Links like [URL text of link]
<       s/\[$UrlPattern\s+([^\]]+?)\]/&StoreBracketUrl($1, $2, $useImage)/geos;
<       s/\[$InterLinkPattern\s+([^\]]+?)\]/&StoreBracketInterPage($1, $2,
<                                                              $useImage)/geos;
<       if ($WikiLinks && $BracketWiki) {  # Local bracket-links
<         s/\[$LinkPattern\s+([^\]]+?)\]/&StoreBracketLink($1, $2)/geos;
<         s/\[$AnchoredLinkPattern\s+([^\]]+?)\]/&StoreBracketAnchoredLink($1,
<                                                $2, $3)/geos if $NamedAnchors;
<       }
<     }
<     s/\[$UrlPattern\]/&StoreBracketUrl($1, "", 0)/geo;
<     s/\[$InterLinkPattern\]/&StoreBracketInterPage($1, "", 0)/geo;
<     s/\b$UrlPattern/&StoreUrl($1, $useImage)/geo;
<     s/\b$InterLinkPattern/&StoreInterPage($1, $useImage)/geo;
<     if ($UseUpload) {
<       s/$UploadPattern/&StoreUpload($1)/geo;
<     }
<     if ($WikiLinks) {
<       s/$AnchoredLinkPattern/&StoreRaw(&GetPageOrEditAnchoredLink($1,
<                              $2, ""))/geo if $NamedAnchors;
<       # CAA: Putting \b in front of $LinkPattern breaks /SubPage links
<       #      (subpage links without the main page)
<       s/$LinkPattern/&GetPageOrEditLink($1, "")/geo;
<     }
<     s/\b$RFCPattern/&StoreRFC($1)/geo;
<     s/\b$ISBNPattern/&StoreISBN($1)/geo;
<     if ($ThinLine) {
<       if ($OldThinLine) {  # Backwards compatible, conflicts with headers
<         s/====+/<hr noshade class=wikiline size=2>/g;
<       } else {             # New behavior--no conflict
<         s/------+/<hr noshade class=wikiline size=2>/g;
<       }
<       s/----+/<hr noshade class=wikiline size=1>/g;
<     } else {
<       s/----+/<hr class=wikiline>/g;
<     }
<   }
<   if ($doLines) { # 0 = no line-oriented, 1 or 2 = do line-oriented
<     # The quote markup patterns avoid overlapping tags (with 5 quotes)
<     # by matching the inner quotes for the strong pattern.
<     s/('*)'''(.*?)'''/$1<strong>$2<\/strong>/g;
<     s/''(.*?)''/<em>$1<\/em>/g;
<     if ($UseHeadings) {
<       s/(^|\n)\s*(\=+)\s+([^\n]+)\s+\=+/&WikiHeading($1, $2, $3)/geo;
<     }
<     if ($TableMode) {
<       s/((\|\|)+)/"<\/TD><TD COLSPAN=\"" . (length($1)\/2) . "\">"/ge;
<     }
<   }
<   return $_;
< }
< 
< sub EmptyCellsToNbsp {
<   my ($row) = @_;
< 
<   $row =~ s/(?<=\|\|)\s+(?=\|\|)/&nbsp;/g;
<   $row =~ s/^\s+(?=\|\|)/&nbsp;/;
<   $row =~ s/(?<=\|\|)\s+$/&nbsp;/;
<   return $row;
< }
< 
< sub WikiLinesToHtml {
<   my ($pageText) = @_;
<   my ($pageHtml, @htmlStack, $code, $codeAttributes, $depth, $oldCode);
< 
<   @htmlStack = ();
<   $depth = 0;
<   $pageHtml = "";
<   foreach (split(/\n/, $pageText)) {  # Process lines one-at-a-time
<     $code = '';
<     $codeAttributes = '';
<     $TableMode = 0;
<     $_ .= "\n";
<     if (s/^(\;+)([^:]+\:?)\:/<dt>$2<dd>/) {
<       $code = "DL";
<       $depth = length $1;
<     } elsif (s/^(\:+)/<dt><dd>/) {
<       $code = "DL";
<       $depth = length $1;
<     } elsif (s/^(\*+)/<li>/) {
<       $code = "UL";
<       $depth = length $1;
<     } elsif (s/^(\#+)/<li>/) {
<       $code = "OL";
<       $depth = length $1;
<     } elsif ($TableSyntax &&
<              s/^((\|\|)+)(.*)\|\|\s*$/"<TR VALIGN='CENTER' "
<                                       . "ALIGN='CENTER'><TD colspan='"
<                                . (length($1)\/2) . "'>" . EmptyCellsToNbsp($3) . "<\/TD><\/TR>\n"/e) {
<       $code = 'TABLE';
<       $codeAttributes = "BORDER='1'";
<       $TableMode = 1;
<       $depth = 1;
<     } elsif (/^[ \t].*\S/) {
<       $code = "PRE";
<       $depth = 1;
<     } else {
<       $depth = 0;
<     }
<     while (@htmlStack > $depth) {   # Close tags as needed
<       $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
<     }
<     if ($depth > 0) {
<       $depth = $IndentLimit  if ($depth > $IndentLimit);
<       if (@htmlStack) {  # Non-empty stack
<         $oldCode = pop(@htmlStack);
<         if ($oldCode ne $code) {
<           $pageHtml .= "</$oldCode><$code>\n";
<         }
<         push(@htmlStack, $code);
<       }
<       while (@htmlStack < $depth) {
<         push(@htmlStack, $code);
<         $pageHtml .= "<$code $codeAttributes>\n";
<       }
<     }
<     if (!$ParseParas) {
<       s/^\s*$/<p>\n/;                      # Blank lines become <p> tags
<     }
<     $pageHtml .= &CommonMarkup($_, 1, 2);  # Line-oriented common markup
<   }
<   while (@htmlStack > 0) {       # Clear stack
<     $pageHtml .=  "</" . pop(@htmlStack) . ">\n";
<   }
<   return $pageHtml;
< }
< 
< sub EvalLocalRules {
<   my ($rules, $origText, $isDiff) = @_;
<   my ($text, $reportError, $errorText);
< 
<   $text = $origText;
<   $reportError = 1;
<   # Basic idea: the $rules should change $text, possibly with different
<   # behavior if $isDiff is true (no images or color changes?)
<   # Note: for fun, the $rules could also change $reportError and $origText
<   if (!eval $rules) {
<     $errorText = $@;
<     if ($errorText eq '') {
<       # Search for "Unknown Error" for the reason the next line is commented
< #     $errorText = T('Unknown Error (no error text)');
<     }
<     if ($errorText ne '') {
<       $text = $origText;    # Consider: should partial results be kept?
<       if ($reportError) {
<         $text .= '<hr><b>' . T('Local rule error:') . '</b><br>'
<                  . &QuoteHtml($errorText);
<       }
<     }
<   }
<   return $text;
< }
<  
< sub UriEscape {
<   my ($uri) = @_;
<   $uri =~ s/([\x00-\x1f\x7f-\xff])/sprintf("%%%02X", ord($1))/ge;
<   $uri =~ s/\&/\&amp;/g;
<   return $uri;
< }
< 
< sub ParseParagraph {
<   my ($text) = @_;
< 
<   $text = &CommonMarkup($text, 1, 0);   # Multi-line markup
<   $text = &WikiLinesToHtml($text);      # Line-oriented markup
<   return "<p>$text</p>\n";
< }
< 
< sub StoreInterPage {
<   my ($id, $useImage) = @_;
<   my ($link, $extra);
< 
<   ($link, $extra) = &InterPageLink($id, $useImage);
<   # Next line ensures no empty links are stored
<   $link = &StoreRaw($link)  if ($link ne "");
<   return $link . $extra;
< }
< 
< sub InterPageLink {
<   my ($id, $useImage) = @_;
<   my ($name, $site, $remotePage, $url, $punct);
< 
<   ($id, $punct) = &SplitUrlPunct($id);
<   $name = $id;
<   ($site, $remotePage) = split(/:/, $id, 2);
<   $url = &GetSiteUrl($site);
<   return ("", $id . $punct)  if ($url eq "");
<   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
<   $url .= $remotePage;
<   return (&UrlLinkOrImage($url, $name, $useImage), $punct);
< }
< 
< sub StoreBracketInterPage {
<   my ($id, $text, $useImage) = @_;
<   my ($site, $remotePage, $url, $index);
< 
<   ($site, $remotePage) = split(/:/, $id, 2);
<   $remotePage =~ s/&amp;/&/g;  # Unquote common URL HTML
<   $url = &GetSiteUrl($site);
<   if ($text ne "") {
<     return "[$id $text]"  if ($url eq "");
<   } else {
<     return "[$id]"  if ($url eq "");
<     $text = &GetBracketUrlIndex($id);
<   }
<   $url .= $remotePage;
<   if ($BracketImg && $useImage && &ImageAllowed($text)) {
<     $text = "<img src=\"$text\">";
<   } else {
<     $text = "[$text]";
<   }
<   return &StoreRaw("<a href=\"$url\">$text</a>");
< }
< 
< sub GetBracketUrlIndex {
<   my ($id) = @_;
<   my ($index, $key);
< 
<   # Consider plain array?
<   if ($SaveNumUrl{$id} > 0) {
<     return $SaveNumUrl{$id};
<   }
<   $SaveNumUrlIndex++;  # Start with 1
<   $SaveNumUrl{$id} = $SaveNumUrlIndex;
<   return $SaveNumUrlIndex;
< }
< 
< sub GetSiteUrl {
<   my ($site) = @_;
<   my ($data, $status);
< 
<   if (!$InterSiteInit) {
<     ($status, $data) = &ReadFile($InterFile);
<     if ($status) {
<       %InterSite = split(/\s+/, $data);  # Consider defensive code
<     }
<     # Check for definitions to allow file to override automatic settings
<     if (!defined($InterSite{'LocalWiki'})) {
<       $InterSite{'LocalWiki'} = $ScriptName . &ScriptLinkChar();
<     }
<     if (!defined($InterSite{'Local'})) {
<       $InterSite{'Local'} = $ScriptName . &ScriptLinkChar();
<     }
<     $InterSiteInit = 1;  # Init only once per request
<   }
<   return $InterSite{$site}  if (defined($InterSite{$site}));
<   return '';
< }
< 
< sub StoreRaw {
<   my ($html) = @_;
< 
<   $SaveUrl{$SaveUrlIndex} = $html;
<   return $FS . $SaveUrlIndex++ . $FS;
< }
< 
< sub StorePre {
<   my ($html, $tag) = @_;
< 
<   return &StoreRaw("<$tag>" . $html . "</$tag>");
< }
< 
< sub StoreHref {
<   my ($anchor, $text) = @_;
< 
<   return "<a" . &StoreRaw($anchor) . ">$text</a>";
< }
< 
< sub StoreUrl {
<   my ($name, $useImage) = @_;
<   my ($link, $extra);
< 
<   ($link, $extra) = &UrlLink($name, $useImage);
<   # Next line ensures no empty links are stored
<   $link = &StoreRaw($link)  if ($link ne "");
<   return $link . $extra;
< }
< 
< sub UrlLink {
<   my ($rawname, $useImage) = @_;
<   my ($name, $punct);
< 
<   ($name, $punct) = &SplitUrlPunct($rawname);
<   if ($LimitFileUrl && ($NetworkFile && $name =~ m|^file:|)) {
<     # Only do remote file:// links. No file:///c|/windows.
<     if ($name =~ m|^file://[^/]|) {
<       return ("<a href=\"$name\">$name</a>", $punct);
<     }
<     return ($rawname, '');
<   }
<   return (&UrlLinkOrImage($name, $name, $useImage), $punct);
< }
< 
< sub UrlLinkOrImage {
<   my ($url, $name, $useImage) = @_;
< 
<   # Restricted image URLs so that mailto:foo@bar.gif is not an image
<   if ($useImage && &ImageAllowed($url)) {
<     return "<img src=\"$url\">";
<   }
<   return "<a href=\"$url\">$name</a>";
< }
< 
< sub ImageAllowed {
<   my ($url) = @_;
<   my ($site, $imagePrefixes);
< 
<   $imagePrefixes = 'http:|https:|ftp:';
<   $imagePrefixes .= '|file:'  if (!$LimitFileUrl);
<   return 0  unless ($url =~ /^($imagePrefixes).+\.$ImageExtensions$/i);
<   return 0  if ($url =~ /"/);      # No HTML-breaking quotes allowed
<   return 1  if (@ImageSites < 1);  # Most common case: () means all allowed
<   return 0  if ($ImageSites[0] eq 'none');  # Special case: none allowed
<   foreach $site (@ImageSites) {
<     return 1  if ($site eq substr($url, 0, length($site)));  # Match prefix
<   }
<   return 0;
< }
< 
< sub StoreBracketUrl {
<   my ($url, $text, $useImage) = @_;
< 
<   if ($text eq "") {
<     $text = &GetBracketUrlIndex($url);
<   } elsif ($text =~ /^$InterLinkPattern$/) {
<     my @interlink = split(/:/, $text, 2);
<     $text = &GetSiteUrl($interlink[0]) . $interlink[1];
<   }
<   if ($BracketImg && $useImage && &ImageAllowed($text)) {
<     $text = "<img src=\"$text\">";
<   } else {
<     $text = "[$text]";
<   }
<   return &StoreRaw("<a href=\"$url\">$text</a>");
< }
< 
< sub StoreBracketLink {
<   my ($name, $text) = @_;
< 
<   return &StoreRaw(&GetPageLinkText($name, "[$text]"));
< }
< 
< sub StoreBracketAnchoredLink {
<   my ($name, $anchor, $text) = @_;
< 
<   return &StoreRaw(&GetPageLinkText("$name#$anchor", "[$text]"));
< }
< 
< sub StorePageOrEditLink {
<   my ($page, $name) = @_;
< 
<   if ($FreeLinks) {
<     $page =~ s/^\s+//;      # Trim extra spaces
<     $page =~ s/\s+$//;
<     $page =~ s|\s*/\s*|/|;  # ...also before/after subpages
<   }
<   $name =~ s/^\s+//;
<   $name =~ s/\s+$//;
<   return &StoreRaw(&GetPageOrEditLink($page, $name));
< }
< 
< sub StoreRFC {
<   my ($num) = @_;
< 
<   return &StoreRaw(&RFCLink($num));
< }
< 
< sub RFCLink {
<   my ($num) = @_;
< 
<   return "<a href=\"http://www.faqs.org/rfcs/rfc${num}.html\">RFC $num</a>";
< }
< 
< sub StoreUpload {
<   my ($url) = @_;
< 
<   return &StoreRaw(&UploadLink($url));
< }
< 
< sub UploadLink {
<   my ($filename) = @_;
<   my ($html, $url);
<  
<   return $filename  if ($UploadUrl eq '');  # No bad links if misconfigured
<   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
<   $url = $UploadUrl . $filename;
<   $html = '<a href="' . $url . '">';
<   if (&ImageAllowed($url)) {
<     $html .= '<img src="' . $url . '" alt="upload:' . $filename . '">';
<   } else {
<     $html .= 'upload:' . $filename;
<   }
<   $html .= '</a>';
<   return $html;
< }
< 
< sub StoreISBN {
<   my ($num) = @_;
< 
<   return &StoreRaw(&ISBNLink($num));
< }
< 
< sub ISBNALink {
<   my ($num, $pre, $post, $text) = @_;
< 
<   return '<a href="' . $pre . $num . $post . '">' . $text . '</a>';
< }
< 
< sub ISBNLink {
<   my ($rawnum) = @_;
<   my ($rawprint, $html, $num, $numSites, $i);
< 
<   $num = $rawnum;
<   $rawprint = $rawnum;
<   $rawprint =~ s/ +$//;
<   $num =~ s/[- ]//g;
<   $numSites = scalar @IsbnNames;  # Number of entries
<   if ((length($num) != 10) || ($numSites < 1)) {
<     return "ISBN $rawnum";
<   }
<   $html = &ISBNALink($num, $IsbnPre[0], $IsbnPost[0], 'ISBN ' . $rawprint);
<   if ($numSites > 1) {
<     $html .= ' (';
<     $i = 1;
<     while ($i < $numSites) {
<       $html .= &ISBNALink($num, $IsbnPre[$i], $IsbnPost[$i], $IsbnNames[$i]);
<       if ($i < ($numSites - 1)) {  # Not the last site
<         $html .= ', ';
<       }
<       $i++;
<     }
<     $html .= ')';
<   }
<   $html .= " "  if ($rawnum =~ / $/);  # Add space if old ISBN had space.
<   return $html;
< }
< 
< sub SplitUrlPunct {
<   my ($url) = @_;
<   my ($punct);
< 
<   if ($url =~ s/\"\"$//) {
<     return ($url, "");   # Delete double-quote delimiters here
<   }
<   $punct = "";
<   if ($NewFS) {
<     ($punct) = ($url =~ /([^a-zA-Z0-9\/\x80-\xff]+)$/);
<     $url =~ s/([^a-zA-Z0-9\/\x80-\xff]+)$//;
<   } else {
<     ($punct) = ($url =~ /([^a-zA-Z0-9\/\xc0-\xff]+)$/);
<     $url =~ s/([^a-zA-Z0-9\/\xc0-\xff]+)$//;
<   }
<   return ($url, $punct);
< }
< 
< sub StripUrlPunct {
<   my ($url) = @_;
<   my ($junk);
< 
<   ($url, $junk) = &SplitUrlPunct($url);
<   return $url;
< }
< 
< sub WikiHeadingNumber {
<     my ($depth, $text) = @_;
<     my ($anchor, $number);
< 
<     return '' unless --$depth > 0;  # Don't number H1s because it looks stupid
<     while (scalar @HeadingNumbers < ($depth-1)) {
<         push @HeadingNumbers, 1;
<         $TableOfContents .= '<dl><dt> </dt><dd>';
<     }
<     if (scalar @HeadingNumbers < $depth) {
<         push @HeadingNumbers, 0;
<         $TableOfContents .= '<dl><dt> </dt><dd>';
<     }
<     while (scalar @HeadingNumbers > $depth) {
<         pop @HeadingNumbers;
<         $TableOfContents .= "</dd></dl>\n\n";
<     }
<     $HeadingNumbers[$#HeadingNumbers]++;
<     $number = (join '.', @HeadingNumbers) . '. ';
<     # Remove embedded links. THIS IS FRAGILE!
<     $text = &RestoreSavedText($text);
<     $text =~ s/\<a\s[^\>]*?\>\?\<\/a\>//si; # No such page syntax
<     $text =~ s/\<a\s[^\>]*?\>(.*?)\<\/a\>/$1/si;
<     # Cook anchor by canonicalizing $text.
<     $anchor = $text;
<     $anchor =~ s/\<.*?\>//g; 
<     $anchor =~ s/\W/_/g;   
<     $anchor =~ s/__+/_/g;
<     $anchor =~ s/^_//;
<     $anchor =~ s/_$//;
<     # Last ditch effort
<     $anchor = '_' . (join '_', @HeadingNumbers) unless $anchor;
<     $TableOfContents .= $number . &ScriptLink("$OpenPageName#$anchor",$text)
<                         . "</dd>\n<dt> </dt><dd>";
<     return &StoreHref(" name=\"$anchor\"") . $number;
< }
< 
< sub WikiHeading {
<   my ($pre, $depth, $text) = @_;
< 
<   $depth = length($depth);
<   $depth = 6  if ($depth > 6);
<   $text =~ s/^\s*#\s+/&WikiHeadingNumber($depth,$')/e; # $' == $POSTMATCH
<   return $pre . "<H$depth>$text</H$depth>\n";
< }
< 
< # ==== Difference markup and HTML ====
< sub GetDiffHTML {
<   my ($diffType, $id, $revOld, $revNew, $newText) = @_;
<   my ($html, $diffText, $diffTextTwo, $priorName, $links, $usecomma);
<   my ($major, $minor, $author, $useMajor, $useMinor, $useAuthor, $cacheName);
< 
<   $links = "(";
<   $usecomma = 0;
<   $major  = &ScriptLinkDiff(1, $id, T('major diff'), "");
<   $minor  = &ScriptLinkDiff(2, $id, T('minor diff'), "");
<   $author = &ScriptLinkDiff(3, $id, T('author diff'), "");
<   $useMajor  = 1;
<   $useMinor  = 1;
<   $useAuthor = 1;
<   $diffType = &GetParam("defaultdiff", 1)  if ($diffType == 4);
<   if ($diffType == 1) {
<     $priorName = T('major');
<     $cacheName = 'major';
<     $useMajor  = 0;
<   } elsif ($diffType == 2) {
<     $priorName = T('minor');
<     $cacheName = 'minor';
<     $useMinor  = 0;
<   } elsif ($diffType == 3) {
<     $priorName = T('author');
<     $cacheName = 'author';
<     $useAuthor = 0;
<   }
<   if ($revOld ne "") {
<     # Note: OpenKeptRevisions must have been done by caller.
<     # Eventually optimize if same as cached revision
<     $diffText = &GetKeptDiff($newText, $revOld, 1);  # 1 = get lock
<     if ($diffText eq "") {
<       $diffText = T('(The revisions are identical or unavailable.)');
<     }
<   } else {
<     $diffText  = &GetCacheDiff($cacheName);
<   }
<   $useMajor  = 0  if ($useMajor  && ($diffText eq &GetCacheDiff("major")));
<   $useMinor  = 0  if ($useMinor  && ($diffText eq &GetCacheDiff("minor")));
<   $useAuthor = 0  if ($useAuthor && ($diffText eq &GetCacheDiff("author")));
<   $useMajor  = 0  if ((!defined(&GetPageCache('oldmajor'))) ||
<                       (&GetPageCache("oldmajor") < 1));
<   $useAuthor = 0  if ((!defined(&GetPageCache('oldauthor'))) ||
<                       (&GetPageCache("oldauthor") < 1));
<   if ($useMajor) {
<     $links .= $major;
<     $usecomma = 1;
<   }
<   if ($useMinor) {
<     $links .= ", "  if ($usecomma);
<     $links .= $minor;
<     $usecomma = 1;
<   }
<   if ($useAuthor) {
<     $links .= ", "  if ($usecomma);
<     $links .= $author;
<   }
<   if (!($useMajor || $useMinor || $useAuthor)) {
<     $links .= T('no other diffs');
<   }
<   $links .= ")";
<   if ((!defined($diffText)) || ($diffText eq "")) {
<     $diffText = T('No diff available.');
<   }
<   if ($revOld ne "") {
<     my $currentRevision = T('current revision');
<     $currentRevision = Ts('revision %s', $revNew) if $revNew;
<     $html = '<b>'
<       . Tss("Difference (from revision %1 to %2)", $revOld, $currentRevision)
<       . "</b>\n" . "$links<br>" . &DiffToHTML($diffText);
<   } else {
<     if (($diffType != 2) &&
<         ((!defined(&GetPageCache("old$cacheName"))) ||
<          (&GetPageCache("old$cacheName") < 1))) {
<       $html = '<b>'
<               . Ts('No diff available--this is the first %s revision.',
<                    $priorName) . "</b>\n$links";
<     } else {
<       $html = '<b>'
<               . Ts('Difference (from prior %s revision)', $priorName)
<               . "</b>\n$links<br>" . &DiffToHTML($diffText);
<     }
<   }
<   @HeadingNumbers = ();
<   $TableOfContents = '';
<   return $html;
< }
< 
< sub GetCacheDiff {
<   my ($type) = @_;
<   my ($diffText);
< 
<   $diffText = &GetPageCache("diff_default_$type");
<   $diffText = &GetCacheDiff('minor')  if ($diffText eq "1");
<   $diffText = &GetCacheDiff('major')  if ($diffText eq "2");
<   return $diffText;
< }
< 
< # Must be done after minor diff is set and OpenKeptRevisions called
< sub GetKeptDiff {
<   my ($newText, $oldRevision, $lock) = @_;
<   my (%sect, %data, $oldText);
< 
<   $oldText = "";
<   if (defined($KeptRevisions{$oldRevision})) {
<     %sect = split(/$FS2/, $KeptRevisions{$oldRevision}, -1);
<     %data = split(/$FS3/, $sect{'data'}, -1);
<     $oldText = $data{'text'};
<   }
<   return ""  if ($oldText eq "");  # Old revision not found
<   return &GetDiff($oldText, $newText, $lock);
< }
< 
< sub GetDiff {
<   my ($old, $new, $lock) = @_;
<   my ($diff_out, $oldName, $newName);
< 
<   &CreateDir($TempDir);
<   $oldName = "$TempDir/old_diff";
<   $newName = "$TempDir/new_diff";
<   if ($lock) {
<     &RequestDiffLock() or return "";
<     $oldName .= "_locked";
<     $newName .= "_locked";
<   }
<   &WriteStringToFile($oldName, $old);
<   &WriteStringToFile($newName, $new);
<   $diff_out = `diff $oldName $newName`;
<   &ReleaseDiffLock()  if ($lock);
<   $diff_out =~ s/\\ No newline.*\n//g;   # Get rid of common complaint.
<   # No need to unlink temp files--next diff will just overwrite.
<   return $diff_out;
< }
< 
< sub DiffToHTML {
<   my ($html) = @_;
<   my ($tChanged, $tRemoved, $tAdded);
< 
<   $tChanged = T('Changed:');
<   $tRemoved = T('Removed:');
<   $tAdded   = T('Added:');
<   $html =~ s/\n--+//g;
<   # Note: Need spaces before <br> to be different from diff section.
<   $html =~ s/(^|\n)(\d+.*c.*)/$1 <br><strong>$tChanged $2<\/strong><br>/g;
<   $html =~ s/(^|\n)(\d+.*d.*)/$1 <br><strong>$tRemoved $2<\/strong><br>/g;
<   $html =~ s/(^|\n)(\d+.*a.*)/$1 <br><strong>$tAdded $2<\/strong><br>/g;
<   $html =~ s/\n((<.*\n)+)/&ColorDiff($1, $DiffColor1, 0)/ge;
<   $html =~ s/\n((>.*\n)+)/&ColorDiff($1, $DiffColor2, 1)/ge;
<   return $html;
< }
< 
< sub ColorDiff {
<   my ($diff, $color, $type) = @_;
<   my ($colorHtml, $classHtml);
< 
<   $diff =~ s/(^|\n)[<>]/$1/g;
<   $diff = &QuoteHtml($diff);
<   # Do some of the Wiki markup rules:
<   %SaveUrl = ();
<   %SaveNumUrl = ();
<   $SaveUrlIndex = 0;
<   $SaveNumUrlIndex = 0;
<   $diff = &RemoveFS($diff);
<   $diff = &CommonMarkup($diff, 0, 1);      # No images, all patterns
<   if ($LateRules ne '') {
<     $diff = &EvalLocalRules($LateRules, $diff, 1);
<   }
<   1 while $diff =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
<   $diff =~ s/\r?\n/<br>/g;
<   $colorHtml = '';
<   if ($color ne '') {
<     $colorHtml = " bgcolor=$color";
<   }
<   if ($type) {
<     $classHtml = ' class=wikidiffnew';
<   } else {
<     $classHtml = ' class=wikidiffold';
<   }
<   return "<table width=\"95\%\"$colorHtml$classHtml><tr><td>\n" . $diff
<          . "</td></tr></table>\n";
< }
< 
< # ==== Database (Page, Section, Text, Kept, User) functions ====
< sub OpenNewPage {
<   my ($id) = @_;
< 
<   %Page = ();
<   $Page{'version'} = 3;      # Data format version
<   $Page{'revision'} = 0;     # Number of edited times
<   $Page{'tscreate'} = $Now;  # Set once at creation
<   $Page{'ts'} = $Now;        # Updated every edit
< }
< 
< sub OpenNewSection {
<   my ($name, $data) = @_;
< 
<   %Section = ();
<   $Section{'name'} = $name;
<   $Section{'version'} = 1;      # Data format version
<   $Section{'revision'} = 0;     # Number of edited times
<   $Section{'tscreate'} = $Now;  # Set once at creation
<   $Section{'ts'} = $Now;        # Updated every edit
<   $Section{'ip'} = $ENV{REMOTE_ADDR};
<   $Section{'host'} = '';        # Updated only for real edits (can be slow)
<   $Section{'id'} = $UserID;
<   $Section{'username'} = &GetParam("username", "");
<   $Section{'data'} = $data;
<   $Page{$name} = join($FS2, %Section);  # Replace with save?
< }
< 
< sub OpenNewText {
<   my ($name) = @_;  # Name of text (usually "default")
<   %Text = ();
<   if ($NewText ne '') {
<     $Text{'text'} = T($NewText);
<   } else {
<     $Text{'text'} = T('Describe the new page here.') . "\n";
<   }
<   $Text{'text'} .= "\n"  if (substr($Text{'text'}, -1, 1) ne "\n");
<   $Text{'minor'} = 0;      # Default as major edit
<   $Text{'newauthor'} = 1;  # Default as new author
<   $Text{'summary'} = '';
<   &OpenNewSection("text_$name", join($FS3, %Text));
< }
< 
< sub GetPageFile {
<   my ($id) = @_;
< 
<   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.db";
< }
< 
< sub OpenPage {
<   my ($id) = @_;
<   my ($fname, $data);
< 
<   if ($OpenPageName eq $id) {
<     return;
<   }
<   %Section = ();
<   %Text = ();
<   $fname = &GetPageFile($id);
<   if (-f $fname) {
<     $data = &ReadFileOrDie($fname);
<     %Page = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<   } else {
<     &OpenNewPage($id);
<   }
<   if ($Page{'version'} != 3) {
<     &UpdatePageVersion();
<   }
<   $OpenPageName = $id;
< }
< 
< sub OpenSection {
<   my ($name) = @_;
< 
<   if (!defined($Page{$name})) {
<     &OpenNewSection($name, "");
<   } else {
<     %Section = split(/$FS2/, $Page{$name}, -1);
<   }
< }
< 
< sub OpenText {
<   my ($name) = @_;
< 
<   if (!defined($Page{"text_$name"})) {
<     &OpenNewText($name);
<   } else {
<     &OpenSection("text_$name");
<     %Text = split(/$FS3/, $Section{'data'}, -1);
<   }
< }
< 
< sub OpenDefaultText {
<   &OpenText('default');
< }
< 
< # Called after OpenKeptRevisions
< sub OpenKeptRevision {
<   my ($revision) = @_;
< 
<   %Section = split(/$FS2/, $KeptRevisions{$revision}, -1);
<   %Text = split(/$FS3/, $Section{'data'}, -1);
< }
< 
< sub GetPageCache {
<   my ($name) = @_;
< 
<   return $Page{"cache_$name"};
< }
< 
< # Always call SavePage within a lock.
< sub SavePage {
<   my $file = &GetPageFile($OpenPageName);
< 
<   $Page{'revision'} += 1;    # Number of edited times
<   $Page{'ts'} = $Now;        # Updated every edit
<   &CreatePageDir($PageDir, $OpenPageName);
<   &WriteStringToFile($file, join($FS1, %Page));
< }
< 
< sub SaveSection {
<   my ($name, $data) = @_;
< 
<   $Section{'revision'} += 1;   # Number of edited times
<   $Section{'ts'} = $Now;       # Updated every edit
<   $Section{'ip'} = $ENV{REMOTE_ADDR};
<   $Section{'id'} = $UserID;
<   $Section{'username'} = &GetParam("username", "");
<   $Section{'data'} = $data;
<   $Page{$name} = join($FS2, %Section);
< }
< 
< sub SaveText {
<   my ($name) = @_;
< 
<   &SaveSection("text_$name", join($FS3, %Text));
< }
< 
< sub SaveDefaultText {
<   &SaveText('default');
< }
< 
< sub SetPageCache {
<   my ($name, $data) = @_;
< 
<   $Page{"cache_$name"} = $data;
< }
< 
< sub UpdatePageVersion {
<   &ReportError(T('Bad page version (or corrupt page).'));
< }
< 
< sub KeepFileName {
<   return $KeepDir . "/" . &GetPageDirectory($OpenPageName)
<          . "/$OpenPageName.kp";
< }
< 
< sub SaveKeepSection {
<   my $file = &KeepFileName();
<   my $data;
< 
<   return  if ($Section{'revision'} < 1);  # Don't keep "empty" revision
<   $Section{'keepts'} = $Now;
<   $data = $FS1 . join($FS2, %Section);
<   &CreatePageDir($KeepDir, $OpenPageName);
<   &AppendStringToFileLimited($file, $data, $KeepSize);
< }
< 
< sub ExpireKeepFile {
<   my ($fname, $data, @kplist, %tempSection, $expirets);
<   my ($anyExpire, $anyKeep, $expire, %keepFlag, $sectName, $sectRev);
<   my ($oldMajor, $oldAuthor);
< 
<   $fname = &KeepFileName();
<   return  if (!(-f $fname));
<   $data = &ReadFileOrDie($fname);
<   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<   return  if (length(@kplist) < 1);  # Also empty
<   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
<   return  if (length(@kplist) < 1);  # Also empty
<   %tempSection = split(/$FS2/, $kplist[0], -1);
<   if (!defined($tempSection{'keepts'})) {
<     return;  # Bad keep file
<   }
<   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
<   return  if ($tempSection{'keepts'} >= $expirets);  # Nothing old enough
<   $anyExpire = 0;
<   $anyKeep   = 0;
<   %keepFlag  = ();
<   $oldMajor  = &GetPageCache('oldmajor');
<   $oldAuthor = &GetPageCache('oldauthor');
<   foreach (reverse @kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     $sectRev = $tempSection{'revision'};
<     $expire = 0;
<     if ($sectName eq "text_default") {
<       if (($KeepMajor  && ($sectRev == $oldMajor)) ||
<           ($KeepAuthor && ($sectRev == $oldAuthor))) {
<         $expire = 0;
<       } elsif ($tempSection{'keepts'} < $expirets) {
<         $expire = 1;
<       }
<     } else {
<       if ($tempSection{'keepts'} < $expirets) {
<         $expire = 1;
<       }
<     }
<     if (!$expire) {
<       $keepFlag{$sectRev . "," . $sectName} = 1;
<       $anyKeep = 1;
<     } else {
<       $anyExpire = 1;
<     }
<   }
<   if (!$anyKeep) {  # Empty, so remove file
<     unlink($fname);
<     return;
<   }
<   return  if (!$anyExpire);  # No sections expired
<   open (OUT, ">$fname") or die (Ts('cant write %s', $fname) . ": $!");
<   foreach (@kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     $sectRev = $tempSection{'revision'};
<     if ($keepFlag{$sectRev . "," . $sectName}) {
<       print OUT $FS1, $_;
<     }
<   }
<   close(OUT);
< }
< 
< sub OpenKeptList {
<   my ($fname, $data);
< 
<   @KeptList = ();
<   $fname = &KeepFileName();
<   return  if (!(-f $fname));
<   $data = &ReadFileOrDie($fname);
<   @KeptList = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
< }
< 
< sub OpenKeptRevisions {
<   my ($name) = @_;  # Name of section
<   my ($fname, $data, %tempSection);
< 
<   %KeptRevisions = ();
<   &OpenKeptList();
<   foreach (@KeptList) {
<     %tempSection = split(/$FS2/, $_, -1);
<     next  if ($tempSection{'name'} ne $name);
<     $KeptRevisions{$tempSection{'revision'}} = $_;
<   }
< }
< 
< sub LoadUserData {
<   my ($data, $status);
< 
<   %UserData = ();
<   ($status, $data) = &ReadFile(&UserDataFilename($UserID));
<   if (!$status) {
<     $UserID = 112;  # Could not open file.  Consider warning message?
<     return;
<   }
<   %UserData = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
< }
< 
< sub UserDataFilename {
<   my ($id) = @_;
< 
<   return ""  if ($id < 1);
<   return $UserDir . "/" . ($id % 10) . "/$id.db";
< }
< 
< # ==== Misc. functions ====
< sub ReportError {
<   my ($errmsg) = @_;
< 
<   print $q->header, $q->start_html, "<H2>", &QuoteHtml($errmsg), "</H2>", $q->end_html;
< }
< 
< sub ValidId {
<   my ($id) = @_;
< 
<   if (length($id) > 120) {
<     return Ts('Page name is too long: %s', $id);
<   }
<   if ($id =~ m| |) {
<     return Ts('Page name may not contain space characters: %s', $id);
<   }
<   if ($UseSubpage) {
<     if ($id =~ m|.*/.*/|) {
<       return Ts('Too many / characters in page %s', $id);
<     }
<     if ($id =~ /^\//) {
<       return Ts('Invalid Page %s (subpage without main page)', $id);
<     }
<     if ($id =~ /\/$/) {
<       return Ts('Invalid Page %s (missing subpage name)', $id);
<     }
<   }
<   if ($FreeLinks) {
<     $id =~ s/ /_/g;
<     if (!$UseSubpage) {
<       if ($id =~ /\//) {
<         return Ts('Invalid Page %s (/ not allowed)', $id);
<       }
<     }
<     if (!($id =~ m|^$FreeLinkPattern$|)) {
<       return Ts('Invalid Page %s', $id);
<     }
<     if ($id =~ m|\.db$|) {
<       return Ts('Invalid Page %s (must not end with .db)', $id);
<     }
<     if ($id =~ m|\.lck$|) {
<       return Ts('Invalid Page %s (must not end with .lck)', $id);
<     }
<     return "";
<   } else {
<     if (!($id =~ /^$LinkPattern$/)) {
<       return Ts('Invalid Page %s', $id);
<     }
<   }
<   return "";
< }
< 
< sub ValidIdOrDie {
<   my ($id) = @_;
<   my $error;
< 
<   $error = &ValidId($id);
<   if ($error ne "") {
<     &ReportError($error);
<     return 0;
<   }
<   return 1;
< }
< 
< sub UserCanEdit {
<   my ($id, $deepCheck) = @_;
< 
<   # Optimized for the "everyone can edit" case (don't check passwords)
<   if (($id ne "") && (-f &GetLockedPageFile($id))) {
<     return 1  if (&UserIsAdmin());  # Requires more privledges
<     # Consider option for editor-level to edit these pages?
<     return 0;
<   }
<   if (!$EditAllowed) {
<     return 1  if (&UserIsEditor());
<     return 0;
<   }
<   if (-f "$DataDir/noedit") {
<     return 1  if (&UserIsEditor());
<     return 0;
<   }
<   if ($deepCheck) {   # Deeper but slower checks (not every page)
<     return 1  if (&UserIsEditor());
<     return 0  if (&UserIsBanned());
<   }
<   return 1;
< }
< 
< sub UserIsBanned {
<   my ($host, $ip, $data, $status);
< 
<   ($status, $data) = &ReadFile("$DataDir/banlist");
<   return 0  if (!$status);  # No file exists, so no ban
<   $data =~ s/\r//g;
<   $ip = $ENV{'REMOTE_ADDR'};
<   $host = &GetRemoteHost(0);
<   foreach (split(/\n/, $data)) {
<     next  if ((/^\s*$/) || (/^#/));  # Skip empty, spaces, or comments
<     return 1  if ($ip   =~ /$_/i);
<     return 1  if ($host =~ /$_/i);
<   }
<   return 0;
< }
< 
< sub UserIsAdmin {
<   my (@pwlist, $userPassword);
< 
<   return 0  if ($AdminPass eq "");
<   $userPassword = &GetParam("adminpw", "");
<   return 0  if ($userPassword eq "");
<   foreach (split(/\s+/, $AdminPass)) {
<     next  if ($_ eq "");
<     return 1  if ($userPassword eq $_);
<   }
<   return 0;
< }
< 
< sub UserIsEditor {
<   my (@pwlist, $userPassword);
< 
<   return 1  if (&UserIsAdmin());             # Admin includes editor
<   return 0  if ($EditPass eq "");
<   $userPassword = &GetParam("adminpw", "");  # Used for both
<   return 0  if ($userPassword eq "");
<   foreach (split(/\s+/, $EditPass)) {
<     next  if ($_ eq "");
<     return 1  if ($userPassword eq $_);
<   }
<   return 0;
< }
< 
< sub UserCanUpload {
<   return 1  if (&UserIsEditor());
<   return $AllUpload;
< }
< 
< sub GetLockedPageFile {
<   my ($id) = @_;
< 
<   return $PageDir . "/" . &GetPageDirectory($id) . "/$id.lck";
< }
< 
< sub RequestLockDir {
<   my ($name, $tries, $wait, $errorDie) = @_;
<   my ($lockName, $n);
< 
<   &CreateDir($TempDir);
<   $lockName = $LockDir . $name;
<   $n = 0;
<   while (mkdir($lockName, 0555) == 0) {
<     if ($! != 17) {
<       die(Ts('can not make %s', $LockDir) . ": $!\n")  if $errorDie;
<       return 0;
<     }
<     return 0  if ($n++ >= $tries); 
<     sleep($wait);
<   }
<   return 1;
< }
< 
< sub ReleaseLockDir {
<   my ($name) = @_;
< 
<   rmdir($LockDir . $name);
< }
< 
< sub RequestLock {
<   # 10 tries, 3 second wait, possibly die on error
<   return &RequestLockDir("main", 10, 3, $LockCrash);
< }
< 
< sub ReleaseLock {
<   &ReleaseLockDir('main');
< }
< 
< sub ForceReleaseLock {
<   my ($name) = @_;
<   my $forced;
< 
<   # First try to obtain lock (in case of normal edit lock)
<   # 5 tries, 3 second wait, do not die on error
<   $forced = !&RequestLockDir($name, 5, 3, 0);
<   &ReleaseLockDir($name);  # Release the lock, even if we didn't get it.
<   return $forced;
< }
< 
< sub RequestCacheLock {
<   # 4 tries, 2 second wait, do not die on error
<   return &RequestLockDir('cache', 4, 2, 0);
< }
< 
< sub ReleaseCacheLock {
<   &ReleaseLockDir('cache');
< }
< 
< sub RequestDiffLock {
<   # 4 tries, 2 second wait, do not die on error
<   return &RequestLockDir('diff', 4, 2, 0);
< }
< 
< sub ReleaseDiffLock {
<   &ReleaseLockDir('diff');
< }
< 
< # Index lock is not very important--just return error if not available
< sub RequestIndexLock {
<   # 1 try, 2 second wait, do not die on error
<   return &RequestLockDir('index', 1, 2, 0);
< }
< 
< sub ReleaseIndexLock {
<   &ReleaseLockDir('index');
< }
< 
< sub ReadFile {
<   my ($fileName) = @_;
<   my ($data);
<   local $/ = undef;   # Read complete files
< 
<   if (open(IN, "<$fileName")) {
<     $data=<IN>;
<     close IN;
<     return (1, $data);
<   }
<   return (0, "");
< }
< 
< sub ReadFileOrDie {
<   my ($fileName) = @_;
<   my ($status, $data);
< 
<   ($status, $data) = &ReadFile($fileName);
<   if (!$status) {
<     die(Ts('Can not open %s', $fileName) . ": $!");
<   }
<   return $data;
< }
< 
< sub WriteStringToFile {
<   my ($file, $string) = @_;
< 
<   open (OUT, ">$file") or die(Ts('cant write %s', $file) . ": $!");
<   print OUT  $string;
<   close(OUT);
< }
< 
< sub AppendStringToFile {
<   my ($file, $string) = @_;
< 
<   open (OUT, ">>$file") or die(Ts('cant write %s', $file) . ": $!");
<   print OUT  $string;
<   close(OUT);
< }
< 
< sub AppendStringToFileLimited {
<   my ($file, $string, $limit) = @_;
< 
<   if (($limit < 1) || (((-s $file) + length($string)) <= $limit)) {
<     &AppendStringToFile($file, $string);
<   }
< }
< 
< sub CreateDir {
<   my ($newdir) = @_;
< 
<   mkdir($newdir, 0775)  if (!(-d $newdir));
< }
< 
< sub CreatePageDir {
<   my ($dir, $id) = @_;
<   my $subdir;
< 
<   &CreateDir($dir);  # Make sure main page exists
<   $subdir = $dir . "/" . &GetPageDirectory($id);
<   &CreateDir($subdir);
<   if ($id =~ m|([^/]+)/|) {
<     $subdir = $subdir . "/" . $1;
<     &CreateDir($subdir);
<   }
< }
< 
< sub UpdateHtmlCache {
<   my ($id, $html) = @_;
<   my $idFile;
< 
<   $idFile = &GetHtmlCacheFile($id);
<   &CreatePageDir($HtmlDir, $id);
<   if (&RequestCacheLock()) {
<     &WriteStringToFile($idFile, $html);
<     &ReleaseCacheLock();
<   }
< }
< 
< sub GenerateAllPagesList {
<   my (@pages, @dirs, $id, $dir, @pageFiles, @subpageFiles, $subId);
< 
<   @pages = ();
<   if ($FastGlob) {
<     # The following was inspired by the FastGlob code by Marc W. Mengel.
<     # Thanks to Bob Showalter for pointing out the improvement.
<     opendir(PAGELIST, $PageDir);
<     @dirs = readdir(PAGELIST);
<     closedir(PAGELIST);
<     @dirs = sort(@dirs);
<     foreach $dir (@dirs) {
<       next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs or files
<       opendir(PAGELIST, "$PageDir/$dir");
<       @pageFiles = readdir(PAGELIST);
<       closedir(PAGELIST);
<       foreach $id (@pageFiles) {
<         next  if (($id eq '.') || ($id eq '..'));
<         if (substr($id, -3) eq '.db') {
<           push(@pages, substr($id, 0, -3));
<         } elsif (substr($id, -4) ne '.lck') {
<           opendir(PAGELIST, "$PageDir/$dir/$id");
<           @subpageFiles = readdir(PAGELIST);
<           closedir(PAGELIST);
<           foreach $subId (@subpageFiles) {
<             if (substr($subId, -3) eq '.db') {
<               push(@pages, "$id/" . substr($subId, 0, -3));
<             }
<           }
<         }
<       }
<     }
<   } else {
<     # Old slow/compatible method.
<     @dirs = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z other);
<     foreach $dir (@dirs) {
<       if (-e "$PageDir/$dir") {  # Thanks to Tim Holt
<         while (<$PageDir/$dir/*.db $PageDir/$dir/*/*.db>) {
<           s|^$PageDir/||;
<           m|^[^/]+/(\S*).db|;
<           $id = $1;
<           push(@pages, $id);
<         }
<       }
<     }
<   }
<   return sort(@pages);
< }
< 
< sub AllPagesList {
<   my ($rawIndex, $refresh, $status);
< 
<   if (!$UseIndex) {
<     return &GenerateAllPagesList();
<   }
<   $refresh = &GetParam("refresh", 0);
<   if ($IndexInit && !$refresh) {
<     # Note for mod_perl: $IndexInit is reset for each query
<     # Eventually consider some timestamp-solution to keep cache?
<     return @IndexList;
<   }
<   if ((!$refresh) && (-f $IndexFile)) {
<     ($status, $rawIndex) = &ReadFile($IndexFile);
<     if ($status) {
<       %IndexHash = split(/\s+/, $rawIndex);
<       @IndexList = sort(keys %IndexHash);
<       $IndexInit = 1;
<       return @IndexList;
<     }
<     # If open fails just refresh the index
<   }
<   @IndexList = ();
<   %IndexHash = ();
<   @IndexList = &GenerateAllPagesList();
<   foreach (@IndexList) {
<     $IndexHash{$_} = 1;
<   }
<   $IndexInit = 1;  # Initialized for this run of the script
<   # Try to write out the list for future runs
<   &RequestIndexLock() or return @IndexList;
<   &WriteStringToFile($IndexFile, join(" ", %IndexHash));
<   &ReleaseIndexLock();
<   return @IndexList;
< }
< 
< sub CalcDay {
<   my ($ts) = @_;
< 
<   $ts += $TimeZoneOffset;
<   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
<   if ($NumberDates) {
<     return ($year + 1900) . '-' . ($mon+1) . '-' . $mday;
<   }
<   return ("January", "February", "March", "April", "May", "June",
<           "July", "August", "September", "October", "November",
<           "December")[$mon]. " " . $mday . ", " . ($year+1900);
< }
< 
< sub CalcTime {
<   my ($ts) = @_;
<   my ($ampm, $mytz);
< 
<   $ts += $TimeZoneOffset;
<   my ($sec, $min, $hour, $mday, $mon, $year) = localtime($ts);
<   $mytz = "";
<   if (($TimeZoneOffset == 0) && ($ScriptTZ ne "")) {
<     $mytz = " " . $ScriptTZ;
<   }
<   $ampm = "";
<   if ($UseAmPm) {
<     $ampm = " am";
<     if ($hour > 11) {
<       $ampm = " pm";
<       $hour = $hour - 12;
<     }
<     $hour = 12   if ($hour == 0);
<   }
<   $min = "0" . $min   if ($min<10);
<   return $hour . ":" . $min . $ampm . $mytz;
< }
< 
< sub TimeToText {
<   my ($t) = @_;
< 
<   return &CalcDay($t) . " " . &CalcTime($t);
< }
< 
< sub GetParam {
<   my ($name, $default) = @_;
<   my $result;
< 
<   $result = $q->param($name);
<   if (!defined($result)) {
<     if (defined($UserData{$name})) {
<       $result = $UserData{$name};
<     } else {
<       $result = $default;
<     }
<   }
<   return $result;
< }
< 
< sub GetHiddenValue {
<   my ($name, $value) = @_;
< 
<   $q->param($name, $value);
<   return $q->hidden($name);
< }
< 
< sub GetRemoteHost {
<   my ($doMask) = @_;
<   my ($rhost, $iaddr);
< 
<   $rhost = $ENV{REMOTE_HOST};
<   if ($UseLookup && ($rhost eq "")) {
<     # Catch errors (including bad input) without aborting the script
<     eval 'use Socket; $iaddr = inet_aton($ENV{REMOTE_ADDR});'
<          . '$rhost = gethostbyaddr($iaddr, AF_INET)';
<   }
<   if ($rhost eq "") {
<     $rhost = $ENV{REMOTE_ADDR};
<   }
<   $rhost = &GetMaskedHost($rhost)  if ($doMask);
<   return $rhost;
< }
< 
< sub FreeToNormal {
<   my ($id) = @_;
< 
<   $id =~ s/ /_/g;
<   $id = ucfirst($id)  if ($UpperFirst || $FreeUpper);
<   if (index($id, '_') > -1) {  # Quick check for any space/underscores
<     $id =~ s/__+/_/g;
<     $id =~ s/^_//;
<     $id =~ s/_$//;
<     if ($UseSubpage) {
<       $id =~ s|_/|/|g;
<       $id =~ s|/_|/|g;
<     }
<   }
<   if ($FreeUpper) {
<     # Note that letters after ' are *not* capitalized
<     if ($id =~ m|[-_.,\(\)/][a-z]|) {    # Quick check for non-canonical case
<       $id =~ s|([-_.,\(\)/])([a-z])|$1 . uc($2)|ge;
<     }
<   }
<   return $id;
< }
< #END_OF_BROWSE_CODE
< 
< # == Page-editing and other special-action code ========================
< $OtherCode = ""; # Comment next line to always compile (slower)
< #$OtherCode = <<'#END_OF_OTHER_CODE';
< 
< sub DoOtherRequest {
<   my ($id, $action, $text, $search);
< 
<   $action = &GetParam("action", "");
<   $id = &GetParam("id", "");
<   if ($action ne "") {
<     $action = lc($action);
<     if      ($action eq "edit") {
<       &DoEdit($id, 0, 0, "", 0)  if &ValidIdOrDie($id);
<     } elsif ($action eq "unlock") {
<       &DoUnlock();
<     } elsif ($action eq "index") {
<       &DoIndex();
<     } elsif ($action eq "links") {
<       &DoLinks();
<     } elsif ($action eq "maintain") {
<       &DoMaintain();
<     } elsif ($action eq "pagelock") {
<       &DoPageLock();
<     } elsif ($action eq "editlock") {
<       &DoEditLock();
<     } elsif ($action eq "editprefs") {
<       &DoEditPrefs();
<     } elsif ($action eq "editbanned") {
<       &DoEditBanned();
<     } elsif ($action eq "editlinks") {
<       &DoEditLinks();
<     } elsif ($action eq "login") {
<       &DoEnterLogin();
<     } elsif ($action eq "newlogin") {
<       $UserID = 0;
<       &DoEditPrefs();  # Also creates new ID
<     } elsif ($action eq "version") {
<       &DoShowVersion();
<     } elsif ($action eq "rss") {
<       &DoRss();
<     } elsif ($action eq "delete") {
<       &DoDeletePage($id);
<     } elsif ($UseUpload && ($action eq "upload")) {
<       &DoUpload();
<     } elsif ($action eq "maintainrc") {
<       &DoMaintainRc();
<     } elsif ($action eq "convert") {
<       &DoConvert();
<     } elsif ($action eq "trimusers") {
<       &DoTrimUsers();
<     } else {
<       &ReportError(Ts('Invalid action parameter %s', $action));
<     }
<     return;
<   }
<   if (&GetParam("edit_prefs", 0)) {
<     &DoUpdatePrefs();
<     return;
<   }
<   if (&GetParam("edit_ban", 0)) {
<     &DoUpdateBanned();
<     return;
<   }
<   if (&GetParam("enter_login", 0)) {
<     &DoLogin();
<     return;
<   }
<   if (&GetParam("edit_links", 0)) {
<     &DoUpdateLinks();
<     return;
<   }
<   if ($UseUpload && (&GetParam("upload", 0))) {
<     &SaveUpload();
<     return;
<   }
<   $search = &GetParam("search", "");
<   if (($search ne "") || (&GetParam("dosearch", "") ne "")) {
<     &DoSearch($search);
<     return;
<   } else {
<     $search = &GetParam("back","");
<     if ($search ne "") {
<       &DoBackLinks($search);
<       return;
<     }
<   }
<   # Handle posted pages
<   if (&GetParam("oldtime", "") ne "") {
<     $id = &GetParam("title", "");
<     &DoPost()  if &ValidIdOrDie($id);
<     return;
<   }
<   &ReportError(T('Invalid URL.'));
< }
< 
< sub DoEdit {
<   my ($id, $isConflict, $oldTime, $newText, $preview) = @_;
<   my ($header, $editRows, $editCols, $userName, $revision, $oldText);
<   my ($summary, $isEdit, $pageTime);
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);  # Take care of users like Markus Lude :-)
<   }
<   if (!&UserCanEdit($id, 1)) {
<     print &GetHeader('', T('Editing Denied'), '');
<     if (&UserIsBanned()) {
<       print T('Editing not allowed: user, ip, or network is blocked.');
<       print "<p>";
<       print T('Contact the wiki administrator for more information.');
<     } else {
<       print Ts('Editing not allowed: %s is read-only.', $SiteName);
<     }
<     print &GetCommonFooter();
<     return;
<   }
<   # Consider sending a new user-ID cookie if user does not have one
<   &OpenPage($id);
<   &OpenDefaultText();
<   $pageTime = $Section{'ts'};
<   $header = Ts('Editing %s', $id);
<   # Old revision handling
<   $revision = &GetParam('revision', '');
<   $revision =~ s/\D//g;  # Remove non-numeric chars
<   if ($revision ne '') {
<     &OpenKeptRevisions('text_default');
<     if (!defined($KeptRevisions{$revision})) {
<       $revision = '';
<       # Consider better solution like error message?
<     } else {
<       &OpenKeptRevision($revision);
<       $header = Ts('Editing revision %s of ', $revision ) . $id;
<     }
<   }
<   $oldText = $Text{'text'};
<   if ($preview && !$isConflict) {
<     $oldText = $newText;
<   }
<   $editRows = &GetParam("editrows", 20);
<   $editCols = &GetParam("editcols", 65);
<   print &GetHeader($id, &QuoteHtml($header), '');
<   if ($revision ne '') {
<     print "\n<b>"
<           . Ts('Editing old revision %s.', $revision) . "  "
<     . T('Saving this page will replace the latest revision with this text.')
<           . '</b><br>'
<   }
<   if ($isConflict) {
<     $editRows -= 10  if ($editRows > 19);
<     print "\n<H1>" . T('Edit Conflict!') . "</H1>\n";
<     if ($isConflict>1) {
<       # The main purpose of a new warning is to display more text
<       # and move the save button down from its old location.
<       print "\n<H2>" . T('(This is a new conflict)') . "</H2>\n";
<     }
<     print "<p><strong>",
<           T('Someone saved this page after you started editing.'), " ",
<           T('The top textbox contains the saved text.'), " ",
<           T('Only the text in the top textbox will be saved.'),
<           "</strong><br>\n",
<           T('Scroll down to see your edited text.'), "<br>\n";
<     print T('Last save time:'), ' ', &TimeToText($oldTime),
<           " (", T('Current time is:'), ' ', &TimeToText($Now), ")<br>\n";
<   }
<   print &GetFormStart();
<   print &GetHiddenValue("title", $id), "\n",
<         &GetHiddenValue("oldtime", $pageTime), "\n",
<         &GetHiddenValue("oldconflict", $isConflict), "\n";
<   if ($revision ne "") {
<     print &GetHiddenValue("revision", $revision), "\n";
<   }
<   print &GetTextArea('text', $oldText, $editRows, $editCols);
<   $summary = &GetParam("summary", "*");
<   print "<p>", T('Summary:'),
<         $q->textfield(-name=>'summary',
<                       -default=>$summary, -override=>1,
<                       -size=>60, -maxlength=>200);
<   if (&GetParam("recent_edit") eq "on") {
<     print "<br>", $q->checkbox(-name=>'recent_edit', -checked=>1,
<                                -label=>T('This change is a minor edit.'));
<   } else {
<     print "<br>", $q->checkbox(-name=>'recent_edit',
<                                -label=>T('This change is a minor edit.'));
<   }
<   if ($EmailNotify) {
<     print "&nbsp;&nbsp;&nbsp;" .
<            $q->checkbox(-name=> 'do_email_notify',
<       -label=>Ts('Send email notification that %s has been changed.', $id));
<   }
<   print "<br>";
<   if ($EditNote ne '') {
<     print T($EditNote) . '<br>';  # Allow translation
<   }
<   print $q->submit(-name=>'Save', -value=>T('Save')), "\n";
<   $userName = &GetParam("username", "");
<   if ($userName ne "") {
<     print ' (', T('Your user name is'), ' ',
<           &GetPageLink($userName) . ') ';
<   } else {
<     print ' (', Ts('Visit %s to set your user name.', &GetPrefsLink(), 1), ') ';
<   }
<   print $q->submit(-name=>'Preview', -value=>T('Preview')), "\n";
<   if ($isConflict) {
<     print "\n<br><hr><p><strong>", T('This is the text you submitted:'),
<           "</strong><p>",
<           &GetTextArea('newtext', $newText, $editRows, $editCols),
<           "<p>\n";
<   }
<   if ($preview) {
<     print '<div class=wikipreview>';
<     print "<hr class=wikilinepreview>\n";
<     print "<h2>", T('Preview:'), "</h2>\n";
<     if ($isConflict) {
<       print "<b>",
<             T('NOTE: This preview shows the revision of the other author.'),
<             "</b><hr>\n";
<     }
<     $MainPage = $id;
<     $MainPage =~ s|/.*||;  # Only the main page name (remove subpage)
<     print &WikiToHTML($oldText) . "<hr class=wikilinepreview>\n";
<     print "<h2>", T('Preview only, not yet saved'), "</h2>\n";
<     print '</div>';
<   }
<   print $q->endform;
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetHistoryLink($id, T('View other revisions')) . "<br>\n";
<     print &GetGotoBar($id);
<     print '</div>';
<   }
<   print &GetMinimumFooter();
< }
< 
< sub GetTextArea {
<   my ($name, $text, $rows, $cols) = @_;
< 
<   if (&GetParam("editwide", 1)) {
<     return $q->textarea(-name=>$name, -default=>$text,
<                         -rows=>$rows, -columns=>$cols, -override=>1,
<                         -style=>'width:100%', -wrap=>'virtual');
<   }
<   return $q->textarea(-name=>$name, -default=>$text,
<                       -rows=>$rows, -columns=>$cols, -override=>1,
<                       -wrap=>'virtual');
< }
< 
< sub DoEditPrefs {
<   my ($check, $recentName, %labels);
< 
<   $recentName = $RCName;
<   $recentName =~ s/_/ /g;
<   &DoNewLogin()  if ($UserID < 400);
<   print &GetHeader('', T('Editing Preferences'), '');
<   print '<div class=wikipref>';
<   print &GetFormStart();
<   print GetHiddenValue("edit_prefs", 1), "\n";
<   print '<b>' . T('User Information:') . "</b>\n";
<   print '<br>' . Ts('Your User ID number: %s', $UserID) . "\n";
<   print '<br>' . T('UserName:') . ' ', &GetFormText('username', "", 20, 50);
<   print ' ' . T('(blank to remove, or valid page name)');
<   print '<br>' . T('Set Password:') . ' ',
<         $q->password_field(-name=>'p_password', -value=>'*', 
<                            -size=>15, -maxlength=>50),
<         ' ', T('(blank to remove password)'), '<br>(',
<         T('Passwords allow sharing preferences between multiple systems.'),
<         ' ', T('Passwords are completely optional.'), ')';
<   if (($AdminPass ne '') || ($EditPass ne '')) {
<     print '<br>', T('Administrator Password:'), ' ',
<           $q->password_field(-name=>'p_adminpw', -value=>'*', 
<                              -size=>15, -maxlength=>50),
<           ' ', T('(blank to remove password)'), '<br>',
<           T('(Administrator passwords are used for special maintenance.)');
<   }
<   if ($EmailNotify) {
<     print "<br>";
<     print &GetFormCheck('notify', 1,
<           T('Include this address in the site email list.')), ' ',
<           T('(Uncheck the box to remove the address.)');
<     print '<br>', T('Email Address:'), ' ',
<           &GetFormText('email', "", 30, 60);
<   }
<   print "<hr class=wikilinepref><b>$recentName:</b>\n";
<   print '<br>', T('Default days to display:'), ' ',
<         &GetFormText('rcdays', $RcDefault, 4, 9);
<   print "<br>", &GetFormCheck('rcnewtop', $RecentTop,
<                               T('Most recent changes on top'));
<   print "<br>", &GetFormCheck('rcall', 0,
<                               T('Show all changes (not just most recent)'));
<   %labels = (0=>T('Hide minor edits'), 1=>T('Show minor edits'),
<              2=>T('Show only minor edits'));
<   print '<br>', T('Minor edit display:'), ' ';
<   print $q->popup_menu(-name=>'p_rcshowedit',
<                        -values=>[0,1,2], -labels=>\%labels,
<                        -default=>&GetParam("rcshowedit", $ShowEdits));
<   print "<br>", &GetFormCheck('rcchangehist', 1,
<                               T('Use "changes" as link to history'));
<   if ($UseDiff) {
<     print '<hr class=wikilinepref><b>', T('Differences:'), "</b>\n";
<     print "<br>", &GetFormCheck('diffrclink', 1,
<                                 Ts('Show (diff) links on %s', $recentName));
<     print "<br>", &GetFormCheck('alldiff', 0,
<                                 T('Show differences on all pages'));
<     print "  (",  &GetFormCheck('norcdiff', 1,
<                                 Ts('No differences on %s', $recentName)), ")";
<     %labels = (1=>T('Major'), 2=>T('Minor'), 3=>T('Author'));
<     print '<br>', T('Default difference type:'), ' ';
<     print $q->popup_menu(-name=>'p_defaultdiff',
<                          -values=>[1,2,3], -labels=>\%labels,
<                          -default=>&GetParam("defaultdiff", 1));
<   }
<   print '<hr class=wikilinepref><b>', T('Misc:'), "</b>\n";
<   # Note: TZ offset is added by TimeToText, so pre-subtract to cancel.
<   print '<br>', T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset);
<   print '<br>', T('Time Zone offset (hours):'), ' ',
<         &GetFormText('tzoffset', 0, 4, 9);
<   print '<br>', &GetFormCheck('editwide', 1,
<                               T('Use 100% wide edit area (if supported)'));
<   print '<br>',
<         T('Edit area rows:'), ' ', &GetFormText('editrows', 20, 4, 4),
<         ' ', T('columns:'),   ' ', &GetFormText('editcols', 65, 4, 4);
< 
<   print '<br>', &GetFormCheck('toplinkbar', 1,
<                               T('Show link bar on top'));
<   print '<br>', &GetFormCheck('linkrandom', 0,
<                               T('Add "Random Page" link to link bar'));
<   print '<br>' . T('StyleSheet URL:') . ' ',
<         &GetFormText('stylesheet', "", 30, 150);
<   print '<br>', $q->submit(-name=>'Save', -value=>T('Save')), "\n";
<   print $q->endform;
<   print '</div>';
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
<   print &GetMinimumFooter();
< }
< 
< sub GetFormText {
<   my ($name, $default, $size, $max) = @_;
<   my $text = &GetParam($name, $default);
< 
<   return $q->textfield(-name=>"p_$name", -default=>$text,
<                        -override=>1, -size=>$size, -maxlength=>$max);
< }
< 
< sub GetFormCheck {
<   my ($name, $default, $label) = @_;
<   my $checked = (&GetParam($name, $default) > 0);
< 
<   return $q->checkbox(-name=>"p_$name", -override=>1, -checked=>$checked,
<                       -label=>$label);
< }
< 
< sub DoUpdatePrefs {
<   my ($username, $password, $stylesheet);
< 
<   # All link bar settings should be updated before printing the header
<   &UpdatePrefCheckbox("toplinkbar");
<   &UpdatePrefCheckbox("linkrandom");
<   print &GetHeader('', T('Saving Preferences'), '');
<   print '<br>';
<   if ($UserID < 1001) {
<     print '<b>',
<           Ts('Invalid UserID %s, preferences not saved.', $UserID), '</b>';
<     if ($UserID == 111) {
<       print '<br>',
<             T('(Preferences require cookies, but no cookie was sent.)');
<     }
<     print &GetCommonFooter();
<     return;
<   }
<   $username = &GetParam("p_username",  "");
<   if ($FreeLinks) {
<     $username =~ s/^\[\[(.+)\]\]/$1/;  # Remove [[ and ]] if added
<     $username =  &FreeToNormal($username);
<     $username =~ s/_/ /g;
<   }
<   if ($username eq "") {
<     print T('UserName removed.'), '<br>';
<     undef $UserData{'username'};
<   } elsif ((!$FreeLinks) && (!($username =~ /^$LinkPattern$/))) {
<     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
<   } elsif ($FreeLinks && (!($username =~ /^$FreeLinkPattern$/))) {
<     print Ts('Invalid UserName %s: not saved.', $username), "<br>\n";
<   } elsif (length($username) > 50) {  # Too long
<     print T('UserName must be 50 characters or less. (not saved)'), "<br>\n";
<   } else {
<     print Ts('UserName %s saved.', $username), '<br>';
<     $UserData{'username'} = $username;
<   }
<   $password = &GetParam("p_password",  "");
<   if ($password eq "") {
<     print T('Password removed.'), '<br>';
<     undef $UserData{'password'};
<   } elsif ($password ne "*") {
<     print T('Password changed.'), '<br>';
<     $UserData{'password'} = $password;
<   }
<   if (($AdminPass ne "") || ($EditPass ne "")) {
<     $password = &GetParam("p_adminpw",  "");
<     if ($password eq "") {
<       print T('Administrator password removed.'), '<br>';
<       undef $UserData{'adminpw'};
<     } elsif ($password ne "*") {
<       print T('Administrator password changed.'), '<br>';
<       $UserData{'adminpw'} = $password;
<       if (&UserIsAdmin()) {
<         print T('User has administrative abilities.'), '<br>';
<       } elsif (&UserIsEditor()) {
<         print T('User has editor abilities.'), '<br>';
<       } else {
<         print T('User does not have administrative abilities.'), ' ',
<               T('(Password does not match administrative password(s).)'),
<               '<br>';
<       }
<     }
<   }
<   if ($EmailNotify) {
<     &UpdatePrefCheckbox("notify");
<     &UpdateEmailList();
<   }
<   &UpdatePrefNumber("rcdays", 0, 0, 999999);
<   &UpdatePrefCheckbox("rcnewtop");
<   &UpdatePrefCheckbox("rcall");
<   &UpdatePrefCheckbox("rcchangehist");
<   &UpdatePrefCheckbox("editwide");
<   if ($UseDiff) {
<     &UpdatePrefCheckbox("norcdiff");
<     &UpdatePrefCheckbox("diffrclink");
<     &UpdatePrefCheckbox("alldiff");
<     &UpdatePrefNumber("defaultdiff", 1, 1, 3);
<   }
<   &UpdatePrefNumber("rcshowedit", 1, 0, 2);
<   &UpdatePrefNumber("tzoffset", 0, -999, 999);
<   &UpdatePrefNumber("editrows", 1, 1, 999);
<   &UpdatePrefNumber("editcols", 1, 1, 999);
<   print T('Server time:'), ' ', &TimeToText($Now-$TimeZoneOffset), '<br>';
<   $TimeZoneOffset = &GetParam("tzoffset", 0) * (60 * 60);
<   print T('Local time:'), ' ', &TimeToText($Now), '<br>';
<   $stylesheet = &GetParam('p_stylesheet', '');
<   if ($stylesheet eq '') {
<     if (&GetParam('stylesheet', '') ne '') {
<       print T('StyleSheet URL removed.'), '<br>';
<     }
<     undef $UserData{'stylesheet'};
<   } else {
<     $stylesheet =~ s/[">]//g;  # Remove characters that would cause problems
<     $UserData{'stylesheet'} = $stylesheet;
<     print T('StyleSheet setting saved.'), '<br>';
<   }
<   &SaveUserData();
<   print '<b>', T('Preferences saved.'), '</b>';
<   print &GetCommonFooter();
< }
< 
< # add or remove email address from preferences to $EmailFile
< sub UpdateEmailList {
<   my (@old_emails);
< 
<   local $/ = "\n";  # don't slurp whole files in this sub.
<   if (my $new_email = $UserData{'email'} = &GetParam("p_email", "")) {
<     my $notify = $UserData{'notify'};
<     if (-f $EmailFile) {
<       open(NOTIFY, $EmailFile)
<         or die(Ts('Could not read from %s:', $EmailFile) . " $!\n");
<       @old_emails = <NOTIFY>;
<       close(NOTIFY);
<     } else {
<       @old_emails = ();
<     }
<     my $already_in_list = grep /$new_email/, @old_emails;
<     if ($notify and (not $already_in_list)) {
<       &RequestLock() or die(T('Could not get mail lock'));
<       if (!open(NOTIFY, ">>$EmailFile")) {
<         &ReleaseLock();  # Don't leave hangling locks
<         die(Ts('Could not append to %s:', $EmailFile) . " $!\n");
<       }
<       print NOTIFY $new_email, "\n";
<       close(NOTIFY);
<       &ReleaseLock();
<     }
<     elsif ((not $notify) and $already_in_list) {
<       &RequestLock() or die(T('Could not get mail lock'));
<       if (!open(NOTIFY, ">$EmailFile")) {
<         &ReleaseLock();
<         die(Ts('Could not overwrite %s:', "$EmailFile") . " $!\n");
<       }
<       foreach (@old_emails) {
<         print NOTIFY "$_" unless /$new_email/;
<       }
<       close(NOTIFY);
<       &ReleaseLock();
<     }
<   }
< }
< 
< sub UpdatePrefCheckbox {
<   my ($param) = @_;
<   my $temp = &GetParam("p_$param", "*");
< 
<   $UserData{$param} = 1  if ($temp eq "on");
<   $UserData{$param} = 0  if ($temp eq "*");
<   # It is possible to skip updating by using another value, like "2"
< }
< 
< sub UpdatePrefNumber {
<   my ($param, $integer, $min, $max) = @_;
<   my $temp = &GetParam("p_$param", "*");
< 
<   return  if ($temp eq "*");
<   $temp =~ s/[^-\d\.]//g;
<   $temp =~ s/\..*//  if ($integer);
<   return  if ($temp eq "");
<   return  if (($temp < $min) || ($temp > $max));
<   $UserData{$param} = $temp;
< }
< 
< sub DoIndex {
<   print &GetHeader('', T('Index of all pages'), '');
<   print '<br>';
<   &PrintPageList(&AllPagesList());
<   print &GetCommonFooter();
< }
< 
< # Create a new user file/cookie pair
< sub DoNewLogin {
<   # Consider warning if cookie already exists
<   # (maybe use "replace=1" parameter)
<   &CreateUserDir();
<   $SetCookie{'id'} = &GetNewUserId();
<   $SetCookie{'randkey'} = int(rand(1000000000));
<   $SetCookie{'rev'} = 1;
<   %UserCookie = %SetCookie;
<   $UserID = $SetCookie{'id'};
<   # The cookie will be transmitted in the next header
<   %UserData = %UserCookie;
<   $UserData{'createtime'} = $Now;
<   $UserData{'createip'} = $ENV{REMOTE_ADDR};
<   &SaveUserData();
< }
< 
< sub DoEnterLogin {
<   print &GetHeader('', T('Login'), "");
<   print &GetFormStart();
<   print &GetHiddenValue('enter_login', 1), "\n";
<   print '<br>', T('User ID number:'), ' ',
<         $q->textfield(-name=>'p_userid', -value=>'',
<                       -size=>15, -maxlength=>50);
<   print '<br>', T('Password:'), ' ',
<         $q->password_field(-name=>'p_password', -value=>'', 
<                            -size=>15, -maxlength=>50);
<   print '<br>', $q->submit(-name=>'Login', -value=>T('Login')), "\n";
<   print $q->endform;
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
<   print &GetMinimumFooter();
< }
< 
< sub DoLogin {
<   my ($uid, $password, $success);
< 
<   $success = 0;
<   $uid = &GetParam("p_userid", "");
<   $uid =~ s/\D//g;
<   $password = &GetParam("p_password",  "");
<   if (($uid > 199) && ($password ne "") && ($password ne "*")) {
<     $UserID = $uid;
<     &LoadUserData();
<     if ($UserID > 199) {
<       if (defined($UserData{'password'}) &&
<           ($UserData{'password'} eq $password)) {
<         $SetCookie{'id'} = $uid;
<         $SetCookie{'randkey'} = $UserData{'randkey'};
<         $SetCookie{'rev'} = 1;
<         $success = 1;
<       }
<     }
<   }
<   print &GetHeader('', T('Login Results'), '');
<   if ($success) {
<     print Ts('Login for user ID %s complete.', $uid);
<   } else {
<     print Ts('Login for user ID %s failed.', $uid);
<   }
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
<   print &GetMinimumFooter();
< }
< 
< sub GetNewUserId {
<   my ($id);
< 
<   $id = $StartUID;
<   while (-f &UserDataFilename($id+1000)) {
<     $id += 1000;
<   }
<   while (-f &UserDataFilename($id+100)) {
<     $id += 100;
<   }
<   while (-f &UserDataFilename($id+10)) {
<     $id += 10;
<   }
<   &RequestLock() or die(T('Could not get user-ID lock'));
<   while (-f &UserDataFilename($id)) {
<     $id++;
<   }
<   &WriteStringToFile(&UserDataFilename($id), "lock");  # reserve the ID
<   &ReleaseLock();
<   return $id;
< }
< 
< # Consider user-level lock?
< sub SaveUserData {
<   my ($userFile, $data);
< 
<   &CreateUserDir();
<   $userFile = &UserDataFilename($UserID);
<   $data = join($FS1, %UserData);
<   &WriteStringToFile($userFile, $data);
< }
< 
< sub CreateUserDir {
<   my ($n, $subdir);
< 
<   if (!(-d "$UserDir/0")) {
<     &CreateDir($UserDir);
< 
<     foreach $n (0..9) {
<       $subdir = "$UserDir/$n";
<       &CreateDir($subdir);
<     }
<   }
< }
< 
< sub DoSearch {
<   my ($string) = @_;
< 
<   if ($string eq '') {
<     &DoIndex();
<     return;
<   }
<   print &GetHeader('', &QuoteHtml(Ts('Search for: %s', $string)), '');
<   print '<br>';
<   &PrintPageList(&SearchTitleAndBody($string));
<   print &GetCommonFooter();
< }
< 
< sub DoBackLinks {
<   my ($string) = @_;
< 
<   print &GetHeader('', &QuoteHtml(Ts('Backlinks for: %s', $string)), '');
<   print '<br>';
<   # At this time the backlinks are mostly a renamed search.
<   # An initial attempt to match links only failed on subpages and free links.
<   # Escape some possibly problematic characters:
<   $string =~ s/([-'().,])/\\$1/g; 
<   &PrintPageList(&SearchTitleAndBody($string));
<   print &GetCommonFooter();
< }
< 
< sub PrintPageList {
<   my $pagename;
< 
<   print "<h2>", Ts('%s pages found:', ($#_ + 1)), "</h2>\n";
<   foreach $pagename (@_) {
<     print ".... "  if ($pagename =~ m|/|);
<     print &GetPageLink($pagename), "<br>\n";
<   }
< }
< 
< sub DoLinks {
<   print &GetHeader('', &QuoteHtml(T('Full Link List')), '');
<   print "<hr><pre>\n\n\n\n\n";  # Extra lines to get below the logo
<   &PrintLinkList(&GetFullLinkList());
<   print "</pre>\n";
<   print &GetCommonFooter();
< }
< 
< sub PrintLinkList {
<   my ($pagelines, $page, $names, $editlink);
<   my ($link, $extra, @links, %pgExists);
< 
<   %pgExists = ();
<   foreach $page (&AllPagesList()) {
<     $pgExists{$page} = 1;
<   }
<   $names = &GetParam("names", 1);
<   $editlink = &GetParam("editlink", 0);
<   foreach $pagelines (@_) {
<     @links = ();
<     foreach $page (split(' ', $pagelines)) {
<       if ($page =~ /\:/) {  # URL or InterWiki form
<         if ($page =~ /$UrlPattern/) {
<           ($link, $extra) = &UrlLink($page, 0);  # No images
<         } else {
<           ($link, $extra) = &InterPageLink($page, 0);  # No images
<         }
<       } else {
<         if ($pgExists{$page}) {
<           $link = &GetPageLink($page);
<         } else {
<           $link = $page;
<           if ($editlink) {
<             $link .= &GetEditLink($page, "?");
<           }
<         }
<       }
<       push(@links, $link);
<     }
<     if (!$names) {
<       shift(@links);
<     }
<     print join(' ', @links), "\n";
<   }
< }
< 
< sub GetFullLinkList {
<   my ($name, $unique, $sort, $exists, $empty, $link, $search);
<   my ($pagelink, $interlink, $urllink);
<   my (@found, @links, @newlinks, @pglist, %pgExists, %seen, $main);
< 
<   $unique = &GetParam("unique", 1);
<   $sort = &GetParam("sort", 1);
<   $pagelink = &GetParam("page", 1);
<   $interlink = &GetParam("inter", 0);
<   $urllink = &GetParam("url", 0);
<   $exists = &GetParam("exists", 2);
<   $empty = &GetParam("empty", 0);
<   $search = &GetParam("search", "");
<   if (($interlink == 2) || ($urllink == 2)) {
<     $pagelink = 0;
<   }
<   %pgExists = ();
<   @pglist = &AllPagesList();
<   foreach $name (@pglist) {
<     $pgExists{$name} = 1;
<   }
<   %seen = ();
<   foreach $name (@pglist) {
<     @newlinks = ();
<     if ($unique != 2) {
<       %seen = ();
<     }
<     @links = &GetPageLinks($name, $pagelink, $interlink, $urllink);
<     if ($UseSubpage) {
<       $main = $name;
<       $main =~ s/\/.*//;
<     }
<     foreach $link (@links) {
<       if ($UseSubpage && ($link =~ /^\//)) {
<         $link = $main . $link;
<       }
<       $seen{$link}++;
<       if (($unique > 0) && ($seen{$link} != 1)) {
<         next;
<       }
<       if (($exists == 0) && ($pgExists{$link} == 1)) {
<         next;
<       }
<       if (($exists == 1) && ($pgExists{$link} != 1)) {
<         next;
<       }
<       if (($search ne "") && !($link =~ /$search/)) {
<         next;
<       }
<       push(@newlinks, $link);
<     }
<     @links = @newlinks;
<     if ($sort) {
<       @links = sort(@links);
<     }
<     unshift (@links, $name);
<     if ($empty || ($#links > 0)) {  # If only one item, list is empty.
<       push(@found, join(' ', @links));
<     }
<   }
<   return @found;
< }
< 
< sub GetPageLinks {
<   my ($name, $pagelink, $interlink, $urllink) = @_;
<   my ($text, @links);
< 
<   @links = ();
<   &OpenPage($name);
<   &OpenDefaultText();
<   $text = $Text{'text'};
<   $text =~ s/<html>((.|\n)*?)<\/html>/ /ig;
<   $text =~ s/<nowiki>(.|\n)*?\<\/nowiki>/ /ig;
<   $text =~ s/<pre>(.|\n)*?\<\/pre>/ /ig;
<   $text =~ s/<code>(.|\n)*?\<\/code>/ /ig;
<   if ($interlink) {
<     $text =~ s/''+/ /g;  # Quotes can adjacent to inter-site links
<     $text =~ s/$InterLinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
<   } else {
<     $text =~ s/$InterLinkPattern/ /g;
<   }
<   if ($urllink) {
<     $text =~ s/''+/ /g;  # Quotes can adjacent to URLs
<     $text =~ s/$UrlPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
<   } else {
<     $text =~ s/$UrlPattern/ /g;
<   }
<   if ($pagelink) {
<     if ($FreeLinks) {
<       my $fl = $FreeLinkPattern;
<       $text =~ s/\[\[$fl\|[^\]]+\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
<       $text =~ s/\[\[$fl\]\]/push(@links, &FreeToNormal($1)), ' '/ge;
<     }
<     if ($WikiLinks) {
<       $text =~ s/$LinkPattern/push(@links, &StripUrlPunct($1)), ' '/ge;
<     }
<   }
<   return @links;
< }
< 
< sub DoPost {
<   my ($editDiff, $old, $newAuthor, $pgtime, $oldrev, $preview, $user);
<   my $string = &GetParam("text", undef);
<   my $id = &GetParam("title", "");
<   my $summary = &GetParam("summary", "");
<   my $oldtime = &GetParam("oldtime", "");
<   my $oldconflict = &GetParam("oldconflict", "");
<   my $isEdit = 0;
<   my $editTime = $Now;
<   my $authorAddr = $ENV{REMOTE_ADDR};
< 
<   if ($FreeLinks) {
<     $id = &FreeToNormal($id);
<   }
<   if (!&UserCanEdit($id, 1)) {
<     # This is an internal interface--we don't need to explain
<     &ReportError(Ts('Editing not allowed for %s.', $id));
<     return;
<   }
<   if (($id eq   'SampleUndefinedPage')    ||
<       ($id eq T('SampleUndefinedPage'))   ||
<       ($id eq   'Sample_Undefined_Page')  ||
<       ($id eq T('Sample_Undefined_Page'))) {
<     &ReportError(Ts('%s cannot be defined.', $id));
<     return;
<   }
<   $string  = &RemoveFS($string);
<   $summary = &RemoveFS($summary);
<   $summary =~ s/[\r\n]//g;
<   if (length($summary) > 300) {  # Too long (longer than form allows)
<     $summary = substr($summary, 0, 300);
<   }
<   # Add a newline to the end of the string (if it doesn't have one)
<   $string .= "\n"  if (!($string =~ /\n$/));
<   # Lock before getting old page to prevent races
<   # Consider extracting lock section into sub, and eval-wrap it?
<   # (A few called routines can die, leaving locks.)
<   if ($LockCrash) {
<     &RequestLock() or die(T('Could not get editing lock'));
<   } else {
<     if (!&RequestLock()) {
<       &ForceReleaseLock('main');
<     }
<     # Clear all other locks.
<     &ForceReleaseLock('cache');
<     &ForceReleaseLock('diff');
<     &ForceReleaseLock('index');
<   }
<   &OpenPage($id);
<   &OpenDefaultText();
<   $old = $Text{'text'};
<   $oldrev = $Section{'revision'};
<   $pgtime = $Section{'ts'};
<   $preview = 0;
<   $preview = 1  if (&GetParam("Preview", "") ne "");
<   if (!$preview && ($old eq $string)) {  # No changes (ok for preview)
<     &ReleaseLock();
<     &ReBrowsePage($id, "", 1);
<     return;
<   }
<   if (($UserID > 399) || ($Section{'id'} > 399))  {
<     $newAuthor = ($UserID ne $Section{'id'});       # known user(s)
<   } else {
<     $newAuthor = ($Section{'ip'} ne $authorAddr);  # hostname fallback
<   }
<   $newAuthor = 1  if ($oldrev == 0);  # New page
<   $newAuthor = 0  if (!$newAuthor);   # Standard flag form, not empty
<   # Detect editing conflicts and resubmit edit
<   if (($oldrev > 0) && ($newAuthor && ($oldtime != $pgtime))) {
<     &ReleaseLock();
<     if ($oldconflict > 0) {  # Conflict again...
<       &DoEdit($id, 2, $pgtime, $string, $preview);
<     } else {
<       &DoEdit($id, 1, $pgtime, $string, $preview);
<     }
<     return;
<   }
<   if ($preview) {
<     &ReleaseLock();
<     &DoEdit($id, 0, $pgtime, $string, 1);
<     return;
<   }
<   $user = &GetParam("username", "");
<   # If the person doing editing chooses, send out email notification
<   if ($EmailNotify) {
<     &EmailNotify($id, $user) if &GetParam("do_email_notify", "") eq 'on';
<   }
<   if (&GetParam("recent_edit", "") eq 'on') {
<     $isEdit = 1;
<   }
<   if (!$isEdit) {
<     &SetPageCache('oldmajor', $Section{'revision'});
<   }
<   if ($newAuthor) {
<     &SetPageCache('oldauthor', $Section{'revision'});
<   }
<   &SaveKeepSection();
<   &ExpireKeepFile();
<   if ($UseDiff) {
<     &UpdateDiffs($id, $editTime, $old, $string, $isEdit, $newAuthor);
<   }
<   $Text{'text'} = $string;
<   $Text{'minor'} = $isEdit;
<   $Text{'newauthor'} = $newAuthor;
<   $Text{'summary'} = $summary;
<   $Section{'host'} = &GetRemoteHost(1);
<   &SaveDefaultText(); 
<   &SavePage();
<   &WriteRcLog($id, $summary, $isEdit, $editTime, $Section{'revision'},
<               $user, $Section{'host'});
<   if ($UseCache) {
<     &UnlinkHtmlCache($id);         # Old cached copy is invalid
<     if ($Page{'revision'} < 2) {   # If this is a new page...
<       &NewPageCacheClear($id);     # ...uncache pages linked to this one.
<     }
<   }
<   if ($UseIndex && ($Page{'revision'} == 1)) {
<     unlink($IndexFile);  # Regenerate index on next request
<   }
<   &ReleaseLock();
<   &ReBrowsePage($id, "", 1);
< }
< 
< sub UpdateDiffs {
<   my ($id, $editTime, $old, $new, $isEdit, $newAuthor) = @_;
<   my ($editDiff, $oldMajor, $oldAuthor);
< 
<   $editDiff  = &GetDiff($old, $new, 0);     # 0 = already in lock
<   $oldMajor  = &GetPageCache('oldmajor');
<   $oldAuthor = &GetPageCache('oldauthor');
<   if ($UseDiffLog) {
<     &WriteDiff($id, $editTime, $editDiff);
<   }
<   &SetPageCache('diff_default_minor', $editDiff);
<   if ($isEdit || !$newAuthor) {
<     &OpenKeptRevisions('text_default');
<   }
<   if (!$isEdit) {
<     &SetPageCache('diff_default_major', "1");
<   } else {
<     &SetPageCache('diff_default_major', &GetKeptDiff($new, $oldMajor, 0));
<   }
<   if ($newAuthor) {
<     &SetPageCache('diff_default_author', "1");
<   } elsif ($oldMajor == $oldAuthor) {
<     &SetPageCache('diff_default_author', "2");
<   } else {
<     &SetPageCache('diff_default_author', &GetKeptDiff($new, $oldAuthor, 0));
<   }
< }
< 
< # Translation note: the email messages are still sent in English
< # Send an email message.
< sub SendEmail {
<   my ($to, $from, $reply, $subject, $message) = @_;
< 
<   # sendmail options:
<   #    -odq : send mail to queue (i.e. later when convenient)
<   #    -oi  : do not wait for "." line to exit
<   #    -t   : headers determine recipient.
<   open (SENDMAIL, "| $SendMail -oi -t ") or die "Can't send email: $!\n";
<   print SENDMAIL <<"EOF";
< From: $from
< To: $to
< Reply-to: $reply
< Subject: $subject\n
< $message
< EOF
<   close(SENDMAIL) or warn "sendmail didn't close nicely";
< }
< 
< ## Email folks who want to know a note that a page has been modified. - JimM.
< sub EmailNotify {
<   local $/ = "\n";   # don't slurp whole files in this sub.
< 
<   if ($EmailNotify) {
<     my ($id, $user) = @_;
<     if ($user) {
<       $user = " by $user";
<     }
<     my $address;
<     return  if (!-f $EmailFile);  # No notifications yet
<     open(EMAIL, $EmailFile)
<       or die "Can't open $EmailFile: $!\n";
<     $address = join ",", <EMAIL>;
<     $address =~ s/\n//g;
<     close(EMAIL);
<     my $home_url = $q->url();
<     my $page_url = $home_url . &ScriptLinkChar() . &UriEscape($id);
<     my $pref_url = $home_url . &ScriptLinkChar() . "action=editprefs";
<     my $editors_summary = $q->param("summary");
<     if (($editors_summary eq "*") or ($editors_summary eq "")){
<       $editors_summary = "";
<     }
<     else {
<       $editors_summary = "\n Summary: $editors_summary";
<     }
<     my $content = <<"END_MAIL_CONTENT";
< 
<  The $SiteName page $id at
<    $page_url
<  has been changed$user to revision $Page{revision}. $editors_summary
< 
<  (Replying to this notification will
<   send email to the entire mailing list,
<   so only do that if you mean to.
< 
<   To remove yourself from this list, visit
<   $pref_url .)
< END_MAIL_CONTENT
<     my $subject = "The $id page at $SiteName has been changed.";
<     # I'm setting the "reply-to" field to be the same as the "to:" field
<     # which seems appropriate for a mailing list, especially since the
<     # $EmailFrom string needn't be a real email address.
<     &SendEmail($address, $EmailFrom, $address, $subject, $content);
<   }
< }
< 
< sub SearchTitleAndBody {
<   my ($string) = @_;
<   my ($name, $freeName, @found);
< 
<   foreach $name (&AllPagesList()) {
<     &OpenPage($name);
<     &OpenDefaultText();
<     if (($Text{'text'} =~ /$string/i) || ($name =~ /$string/i)) {
<       push(@found, $name);
<     } elsif ($FreeLinks) {
<       if ($name =~ m/_/) {
<         $freeName = $name;
<         $freeName =~ s/_/ /g;
<         if ($freeName =~ /$string/i) {
<           push(@found, $name);
<         }
<       } elsif ($string =~ m/ /) {
<         $freeName = $string;
<         $freeName =~ s/ /_/g;
<         if ($Text{'text'} =~ /$freeName/i) {
<           push(@found, $name);
<         }
<       }
<     }
<   }
<   return @found;
< }
< 
< sub SearchBody {
<   my ($string) = @_;
<   my ($name, @found);
< 
<   foreach $name (&AllPagesList()) {
<     &OpenPage($name);
<     &OpenDefaultText();
<     if ($Text{'text'} =~ /$string/i){
<       push(@found, $name);
<     }
<   }
<   return @found;
< }
< 
< sub UnlinkHtmlCache {
<   my ($id) = @_;
<   my $idFile;
< 
<   $idFile = &GetHtmlCacheFile($id);
<   if (-f $idFile) {
<     unlink($idFile);
<   }
< }
< 
< sub NewPageCacheClear {
<   my ($id) = @_;
<   my $name;
< 
<   return if (!$UseCache);
<   $id =~ s|.+/|/|;  # If subpage, search for just the subpage
<   # The following code used to search the body for the $id
<   foreach $name (&AllPagesList()) {  # Remove all to be safe
<     &UnlinkHtmlCache($name);
<   }
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub DoUnlock {
<   my $LockMessage = T('Normal Unlock.');
< 
<   print &GetHeader('', T('Removing edit lock'), '');
<   print '<p>', T('This operation may take several seconds...'), "\n";
<   if (&ForceReleaseLock('main')) {
<     $LockMessage = T('Forced Unlock.');
<   }
<   &ForceReleaseLock('cache');
<   &ForceReleaseLock('diff');
<   &ForceReleaseLock('index');
<   print "<br><h2>$LockMessage</h2>";
<   print &GetCommonFooter();
< }
< 
< # Note: all diff and recent-list operations should be done within locks.
< sub WriteRcLog {
<   my ($id, $summary, $isEdit, $editTime, $revision, $name, $rhost) = @_;
<   my ($extraTemp, %extra);
< 
<   %extra = ();
<   $extra{'id'} = $UserID          if ($UserID > 0);
<   $extra{'name'} = $name          if ($name ne "");
<   $extra{'revision'} = $revision  if ($revision ne "");
<   $extraTemp = join($FS2, %extra);
<   # The two fields at the end of a line are kind and extension-hash
<   my $rc_line = join($FS3, $editTime, $id, $summary,
<                      $isEdit, $rhost, "0", $extraTemp);
<   if (!open(OUT, ">>$RcFile")) {
<     die(Ts('%s log error:', $RCName) . " $!");
<   }
<   print OUT  $rc_line . "\n";
<   close(OUT);
< }
< 
< sub WriteDiff {
<   my ($id, $editTime, $diffString) = @_;
< 
<   open (OUT, ">>$DataDir/diff_log") or die(T('can not write diff_log'));
<   print OUT  "------\n" . $id . "|" . $editTime . "\n";
<   print OUT  $diffString;
<   close(OUT);
< }
< 
< # Actions are vetoable if someone edits the page before
< # the keep expiry time. For example, page deletion. If
< # no one edits the page by the time the keep expiry time
< # elapses, then no one has vetoed the last action, and the
< # action is accepted.
< # See http://www.usemod.com/cgi-bin/mb.pl?PageDeletion
< sub ProcessVetos {
<   my ($expirets);
< 
<   $expirets = $Now - ($KeepDays * 24 * 60 * 60);
<   return (0, T('(done)'))  unless $Page{'ts'} < $expirets;
<   if ($DeletedPage && $Text{'text'} =~ /^\s*$DeletedPage\W*?(\n|$)/o) {
<     &DeletePage($OpenPageName, 1, 1);
<     return (1, T('(deleted)'));
<   }
<   if ($ReplaceFile && $Text{'text'} =~ /^\s*$ReplaceFile\:\s*(\S+)/o) {
<     my $fname = $1;
<     # Only replace an allowed, existing file.
<     if ((grep {$_ eq $fname} @ReplaceableFiles) && -e $fname) {
<        if ($Text{'text'} =~ /.*<pre>.*?\n(.*?)\s*<\/pre>/ims)
<        {
<          my $string = $1;
<          $string =~ s/\r\n/\n/gms;
<          open (OUT, ">$fname") or return 0;
<          print OUT $string;
<          close OUT;
<          return (0, T('(replaced)'));
<       }
<     }
<   }
<   return (0, T('(done)'));
< }
< 
< sub DoMaintain {
<   my ($name, $fname, $data, $message, $status);
<   print &GetHeader('', T('Maintenance on all pages'), '');
<   print "<br>";
<   $fname = "$DataDir/maintain";
<   if (!&UserIsAdmin()) {
<     if ((-f $fname) && ((-M $fname) < 0.5)) {
<       print T('Maintenance not done.'), ' ';
<       print T('(Maintenance can only be done once every 12 hours.)');
<       print ' ', T('Remove the "maintain" file or wait.');
<       print &GetCommonFooter();
<       return;
<     }
<   }
<   &RequestLock() or die(T('Could not get maintain-lock'));
<   foreach $name (&AllPagesList()) {
<     &OpenPage($name);
<     &OpenDefaultText();
<     ($status, $message) = &ProcessVetos();
<     &ExpireKeepFile() unless $status;
<     print ".... "  if ($name =~ m|/|);
<     print &GetPageLink($name);
<     print " $message<br>\n";
<   }
<   &WriteStringToFile($fname, Ts('Maintenance done at %s', &TimeToText($Now)));
<   &ReleaseLock();
<   # Do any rename/deletion commands
<   # (Must be outside lock because it will grab its own lock)
<   $fname = "$DataDir/editlinks";
<   if (-f $fname) {
<     $data = &ReadFileOrDie($fname);
<     print '<hr>', T('Processing rename/delete commands:'), "<br>\n";
<     &UpdateLinksList($data, 1, 1);  # Always update RC and links
<     unlink("$fname.old");
<     rename($fname, "$fname.old");
<   }
<   if ($MaintTrimRc) {
<     &RequestLock() or die(T('Could not get lock for RC maintenance'));
<     $status = &TrimRc();  # Consider error messages?
<     &ReleaseLock();
<   }
<   print &GetCommonFooter();
< }
< 
< # Must be called within a lock.
< # Thanks to Alex Schroeder for original code
< sub TrimRc {
<   my (@rc, @temp, $starttime, $days, $status, $data, $i, $ts);
< 
<   # Determine the number of days to go back
<   $days = 0;
<   foreach (@RcDays) {
<     $days = $_  if $_ > $days;
<   }
<   $starttime = $Now - $days * 24 * 60 * 60;
<   return 1  if (!-f $RcFile);  # No work if no file exists
<   ($status, $data) = &ReadFile($RcFile);
<   if (!$status) {
<     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
<           . ":</strong> $RcFile<p>"
<           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
<     return 0;
<   }
<   # Move the old stuff from rc to temp
<   @rc = split(/\n/, $data);
<   for ($i = 0; $i < @rc; $i++) {
<     ($ts) = split(/$FS3/, $rc[$i]);
<     last  if ($ts >= $starttime);
<   }
<   return 1  if ($i < 1);  # No lines to move from new to old
<   @temp = splice(@rc, 0, $i);
<   # Write new files and backups
<   if (!open(OUT, ">>$RcOldFile")) {
<     print '<p><strong>' . Ts('Could not open %s log file', $RCName)
<           . ":</strong> $RcOldFile<p>"
<           . T('Error was') . ":\n<pre>$!</" . "pre>\n" . '<p>';
<     return 0;
<   }
<   print OUT  join("\n", @temp) . "\n";
<   close(OUT);
<   &WriteStringToFile($RcFile . '.old', $data);
<   $data = join("\n", @rc);
<   $data .= "\n"  if ($data ne '');  # If no entries, don't add blank line
<   &WriteStringToFile($RcFile, $data);
<   return 1;
< }
< 
< sub DoMaintainRc {
<   print &GetHeader('', T('Maintaining RC log'), '');
<   return  if (!&UserIsAdminOrError());
<   &RequestLock() or die(T('Could not get lock for RC maintenance'));
<   if (&TrimRc()) {
<     print '<br>' . T('RC maintenance done.') . '<br>';
<   } else {
<     print '<br>' . T('RC maintenance not done.') . '<br>';
<   }
<   &ReleaseLock();
<   print &GetCommonFooter();
< }
< 
< sub UserIsEditorOrError {
<   if (!&UserIsEditor()) {
<     print '<p>', T('This operation is restricted to site editors only...');
<     print &GetCommonFooter();
<     return 0;
<   }
<   return 1;
< }
< 
< sub UserIsAdminOrError {
<   if (!&UserIsAdmin()) {
<     print '<p>', T('This operation is restricted to administrators only...');
<     print &GetCommonFooter();
<     return 0;
<   }
<   return 1;
< }
< 
< sub DoEditLock {
<   my ($fname);
< 
<   print &GetHeader('', T('Set or Remove global edit lock'), '');
<   return  if (!&UserIsAdminOrError());
<   $fname = "$DataDir/noedit";
<   if (&GetParam("set", 1)) {
<     &WriteStringToFile($fname, "editing locked.");
<   } else {
<     unlink($fname);
<   }
<   if (-f $fname) {
<     print '<p>', T('Edit lock created.'), '<br>';
<   } else {
<     print '<p>', T('Edit lock removed.'), '<br>';
<   }
<   print &GetCommonFooter();
< }
< 
< sub DoPageLock {
<   my ($fname, $id);
< 
<   print &GetHeader('', T('Set or Remove page edit lock'), '');
<   # Consider allowing page lock/unlock at editor level?
<   return  if (!&UserIsAdminOrError());
<   $id = &GetParam("id", "");
<   if ($id eq "") {
<     print '<p>', T('Missing page id to lock/unlock...');
<     return;
<   }
<   return  if (!&ValidIdOrDie($id));       # Consider nicer error?
<   $fname = &GetLockedPageFile($id);
<   if (&GetParam("set", 1)) {
<     &WriteStringToFile($fname, "editing locked.");
<   } else {
<     unlink($fname);
<   }
<   if (-f $fname) {
<     print '<p>', Ts('Lock for %s created.', $id), '<br>';
<   } else {
<     print '<p>', Ts('Lock for %s removed.', $id), '<br>';
<   }
<   print &GetCommonFooter();
< }
< 
< sub DoEditBanned {
<   my ($banList, $status);
< 
<   print &GetHeader('', T('Editing Banned list'), '');
<   return  if (!&UserIsAdminOrError());
<   ($status, $banList) = &ReadFile("$DataDir/banlist");
<   $banList = ""  if (!$status);
<   print &GetFormStart();
<   print GetHiddenValue("edit_ban", 1), "\n";
<   print "<b>Banned IP/network/host list:</b><br>\n";
<   print "<p>Each entry is either a commented line (starting with #), ",
<         "or a Perl regular expression (matching either an IP address or ",
<         "a hostname).  <b>Note:</b> To test the ban on yourself, you must ",
<         "give up your admin access (remove password in Preferences).";
<   print "<p>Example:<br>",
<         "# blocks hosts ending with .foocorp.com<br>",
<         "\\.foocorp\\.com\$<br>",
<         "# blocks exact IP address<br>",
<         "^123\\.21\\.3\\.9\$<br>",
<         "# blocks whole 123.21.3.* IP network<br>",
<         "^123\\.21\\.3\\.\\d+\$<p>";
<   print &GetTextArea('banlist', $banList, 12, 50);
<   print "<br>", $q->submit(-name=>'Save'), "\n";
<   print $q->endform;
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
<   print &GetMinimumFooter();
< }
< 
< sub DoUpdateBanned {
<   my ($newList, $fname);
< 
<   print &GetHeader('', T('Updating Banned list'), '');
<   return  if (!&UserIsAdminOrError());
<   $fname = "$DataDir/banlist";
<   $newList = &GetParam("banlist", "#Empty file");
<   if ($newList eq "") {
<     print "<p>", T('Empty banned list or error.');
<     print "<p>", T('Resubmit with at least one space character to remove.');
<   } elsif ($newList =~ /^\s*$/s) {
<     unlink($fname);
<     print "<p>", T('Removed banned list');
<   } else {
<     &WriteStringToFile($fname, $newList);
<     print "<p>", T('Updated banned list');
<   }
<   print &GetCommonFooter();
< }
< 
< # ==== Editing/Deleting pages and links ====
< sub DoEditLinks {
<   print &GetHeader('', T('Editing Links'), '');
<   if ($AdminDelete) {
<     return  if (!&UserIsAdminOrError());
<   } else {
<     return  if (!&UserIsEditorOrError());
<   }
<   print &GetFormStart();
<   print GetHiddenValue("edit_links", 1), "\n";
<   print "<b>Editing/Deleting page titles:</b><br>\n";
<   print "<p>Enter one command on each line.  Commands are:<br>",
<         "<tt>!PageName</tt> -- deletes the page called PageName<br>\n",
<         "<tt>=OldPageName=NewPageName</tt> -- Renames OldPageName ",
<         "to NewPageName and updates links to OldPageName.<br>\n",
<         "<tt>|OldPageName|NewPageName</tt> -- Changes links to OldPageName ",
<         "to NewPageName.",
<         " (Used to rename links to non-existing pages.)<br>\n",
<         "<b>Note: page names are case-sensitive!</b>\n";
<   print &GetTextArea('commandlist', "", 12, 50);
<   print $q->checkbox(-name=>"p_changerc", -override=>1, -checked=>1,
<                       -label=>"Edit $RCName");
<   print "<br>\n";
<   print $q->checkbox(-name=>"p_changetext", -override=>1, -checked=>1,
<                       -label=>"Substitute text for rename");
<   print "<br>", $q->submit(-name=>'Edit'), "\n";
<   print $q->endform;
<   if (!&GetParam('embed', $EmbedWiki)) {
<     print '<div class=wikifooter>';
<     print "<hr class=wikilinefooter>\n";
<     print &GetGotoBar('');
<     print '</div>';
<   }
<   print &GetMinimumFooter();
< }
< 
< sub UpdateLinksList {
<   my ($commandList, $doRC, $doText) = @_;
< 
<   if ($doText) {
<     &BuildLinkIndex();
<   }
<   &RequestLock() or die T('UpdateLinksList could not get main lock');
<   unlink($IndexFile)  if ($UseIndex);
<   foreach (split(/\n/, $commandList)) {
<     s/\s+$//g;
<     next  if (!(/^[=!|]/));  # Only valid commands.
<     print "Processing $_<br>\n";
<     if (/^\!(.+)/) {
<       &DeletePage($1, $doRC, $doText);
<     } elsif (/^\=(?:\[\[)?([^]=]+)(?:\]\])?\=(?:\[\[)?([^]=]+)(?:\]\])?/) {
<       &RenamePage($1, $2, $doRC, $doText);
<     } elsif (/^\|(?:\[\[)?([^]|]+)(?:\]\])?\|(?:\[\[)?([^]|]+)(?:\]\])?/) {
<       &RenameTextLinks($1, $2);
<     }
<   }
<   &NewPageCacheClear(".");  # Clear cache (needs testing?)
<   unlink($IndexFile)  if ($UseIndex);
<   &ReleaseLock();
< }
< 
< sub BuildLinkIndex {
<   my (@pglist, $page, @links, $link, %seen);
< 
<   @pglist = &AllPagesList();
<   %LinkIndex = ();
<   foreach $page (@pglist) {
<     &BuildLinkIndexPage($page);
<   }
< }
< 
< sub BuildLinkIndexPage {
<   my ($page) = @_;
<   my (@links, $link, %seen);
< 
<   @links = &GetPageLinks($page, 1, 0, 0);
<   %seen = ();
<   foreach $link (@links) {
<     if (defined($LinkIndex{$link})) {
<       if (!$seen{$link}) {
<         $LinkIndex{$link} .= " " . $page;
<       }
<     } else {
<       $LinkIndex{$link} .= " " . $page;
<     }
<     $seen{$link} = 1;
<   }
< }
< 
< sub DoUpdateLinks {
<   my ($commandList, $doRC, $doText);
< 
<   print &GetHeader('', T('Updating Links'), '');
<   if ($AdminDelete) {
<     return  if (!&UserIsAdminOrError());
<   } else {
<     return  if (!&UserIsEditorOrError());
<   }
<   $commandList = &GetParam("commandlist", "");
<   $doRC   = &GetParam("p_changerc", "0");
<   $doRC   = 1  if ($doRC eq "on");
<   $doText = &GetParam("p_changetext", "0");
<   $doText = 1  if ($doText eq "on");
<   if ($commandList eq "") {
<     print "<p>", T('Empty command list or error.');
<   } else {
<     &UpdateLinksList($commandList, $doRC, $doText);
<     print "<p>", T('Finished command list.');
<   }
<   print &GetCommonFooter();
< }
< 
< sub EditRecentChanges {
<   my ($action, $old, $new) = @_;
< 
<   &EditRecentChangesFile($RcFile,    $action, $old, $new, 1);
<   &EditRecentChangesFile($RcOldFile, $action, $old, $new, 0);
< }
< 
< sub EditRecentChangesFile {
<   my ($fname, $action, $old, $new, $printError) = @_;
<   my ($status, $fileData, $errorText, $rcline, @rclist);
<   my ($outrc, $ts, $page, $junk);
< 
<   ($status, $fileData) = &ReadFile($fname);
<   if (!$status) {
<     # Save error text if needed.
<     $errorText = "<p><strong>"
<                  . Ts('Could not open %s log file:', $RCName)
<                  . "</strong> $fname"
<                  . "<p>" . T('Error was:') . "\n<pre>$!</pre>\n";
<     print $errorText  if ($printError);
<     return;
<   }
<   $outrc = "";
<   @rclist = split(/\n/, $fileData);
<   foreach $rcline (@rclist) {
<     ($ts, $page, $junk) = split(/$FS3/, $rcline);
<     if ($page eq $old) {
<       if ($action == 1) {  # Delete
<         ; # Do nothing (don't add line to new RC)
<       } elsif ($action == 2) {
<         $junk = $rcline;
<         $junk =~ s/^(\d+$FS3)$old($FS3)/"$1$new$2"/ge;
<         $outrc .= $junk . "\n";
<       }
<     } else {
<       $outrc .= $rcline . "\n";
<     }
<   }
<   &WriteStringToFile($fname . ".old", $fileData);  # Backup copy
<   &WriteStringToFile($fname, $outrc);
< }
< 
< # Delete and rename must be done inside locks.
< sub DeletePage {
<   my ($page, $doRC, $doText) = @_;
<   my ($fname, $status);
< 
<   $page =~ s/ /_/g;
<   $page =~ s/\[+//;
<   $page =~ s/\]+//;
<   $status = &ValidId($page);
<   if ($status ne "") {
<     print Tss('Delete-Page: page %1 is invalid, error is: %2', $page, $status)
<           . "<br>\n";
<     return;
<   }
<   $fname = &GetPageFile($page);
<   unlink($fname)  if (-f $fname);
<   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
<   unlink($fname)  if (-f $fname);
<   unlink($IndexFile)  if ($UseIndex);
<   &EditRecentChanges(1, $page, "")  if ($doRC);  # Delete page
<   # Currently don't do anything with page text
< }
< 
< # Given text, returns substituted text
< sub SubstituteTextLinks {
<   my ($old, $new, $text) = @_;
< 
<   # Much of this is taken from the common markup
<   %SaveUrl = ();
<   $SaveUrlIndex = 0;
<   $text =~ s/$FS(\d)/$1/g;              # Remove separators (paranoia)
<   if ($RawHtml) {
<     $text =~ s/(<html>((.|\n)*?)<\/html>)/&StoreRaw($1)/ige;
<   }
<   $text =~ s/(<pre>((.|\n)*?)<\/pre>)/&StoreRaw($1)/ige;
<   $text =~ s/(<code>((.|\n)*?)<\/code>)/&StoreRaw($1)/ige;
<   $text =~ s/(<nowiki>((.|\n)*?)<\/nowiki>)/&StoreRaw($1)/ige;
<   if ($FreeLinks) {
<     $text =~
<      s/\[\[$FreeLinkPattern\|([^\]]+)\]\]/&SubFreeLink($1,$2,$old,$new)/geo;
<     $text =~ s/\[\[$FreeLinkPattern\]\]/&SubFreeLink($1,"",$old,$new)/geo;
<   }
<   if ($BracketText) {  # Links like [URL text of link]
<     $text =~ s/(\[$UrlPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
<     $text =~ s/(\[$InterLinkPattern\s+([^\]]+?)\])/&StoreRaw($1)/geo;
<   }
<   $text =~ s/(\[?$UrlPattern\]?)/&StoreRaw($1)/geo;
<   $text =~ s/(\[?$InterLinkPattern\]?)/&StoreRaw($1)/geo;
<   if ($WikiLinks) {
<     $text =~ s/$LinkPattern/&SubWikiLink($1, $old, $new)/geo;
<   }
<   # Thanks to David Claughton for the following fix
<   1 while $text =~ s/$FS(\d+)$FS/$SaveUrl{$1}/ge;   # Restore saved text
<   return $text;
< }
< 
< sub SubFreeLink {
<   my ($link, $name, $old, $new) = @_;
<   my ($oldlink);
< 
<   $oldlink = $link;
<   $link =~ s/^\s+//;
<   $link =~ s/\s+$//;
<   if (($link eq $old) || (&FreeToNormal($old) eq &FreeToNormal($link))) {
<     $link = $new;
<   } else {
<     $link = $oldlink;  # Preserve spaces if no match
<   }
<   $link = "[[$link";
<   if ($name ne "") {
<     $link .= "|$name";
<   }
<   $link .= "]]";
<   return &StoreRaw($link);
< }
< 
< sub SubWikiLink {
<   my ($link, $old, $new) = @_;
<   my ($newBracket);
< 
<   $newBracket = 0;
<   if ($link eq $old) {
<     $link = $new;
<     if (!($new =~ /^$LinkPattern$/)) {
<       $link = "[[$link]]";
<     }
<   }
<   return &StoreRaw($link);
< }
< 
< # Rename is mostly copied from expire
< sub RenameKeepText {
<   my ($page, $old, $new) = @_;
<   my ($fname, $status, $data, @kplist, %tempSection, $changed);
<   my ($sectName, $newText);
< 
<   $fname = $KeepDir . "/" . &GetPageDirectory($page) .  "/$page.kp";
<   return  if (!(-f $fname));
<   ($status, $data) = &ReadFile($fname);
<   return  if (!$status);
<   @kplist = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<   return  if (length(@kplist) < 1);  # Also empty
<   shift(@kplist)  if ($kplist[0] eq "");  # First can be empty
<   return  if (length(@kplist) < 1);  # Also empty
<   %tempSection = split(/$FS2/, $kplist[0], -1);
<   if (!defined($tempSection{'keepts'})) {
<     return;
<   }
<   # First pass: optimize for nothing changed
<   $changed = 0;
<   foreach (@kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     if ($sectName =~ /^(text_)/) {
<       %Text = split(/$FS3/, $tempSection{'data'}, -1);
<       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
<       $changed = 1  if ($Text{'text'} ne $newText);
<     }
<   }
<   return  if (!$changed);  # No sections changed
<   open (OUT, ">$fname") or return;
<   foreach (@kplist) {
<     %tempSection = split(/$FS2/, $_, -1);
<     $sectName = $tempSection{'name'};
<     if ($sectName =~ /^(text_)/) {
<       %Text = split(/$FS3/, $tempSection{'data'}, -1);
<       $newText = &SubstituteTextLinks($old, $new, $Text{'text'});
<       $Text{'text'} = $newText;
<       $tempSection{'data'} = join($FS3, %Text);
<       print OUT $FS1, join($FS2, %tempSection);
<     } else {
<       print OUT $FS1, $_;
<     }
<   }
<   close(OUT);
< }
< 
< sub RenameTextLinks {
<   my ($old, $new) = @_;
<   my ($changed, $file, $page, $section, $oldText, $newText, $status);
<   my ($oldCanonical, @pageList);
< 
<   $old =~ s/ /_/g;
<   $oldCanonical = &FreeToNormal($old);
<   $new =~ s/ /_/g;
<   $status = &ValidId($old);
<   if ($status ne "") {
<     print Tss('Rename-Text: old page %1 is invalid, error is: %2', $old, $status)
<           . "<br>\n";
<     return;
<   }
<   $status = &ValidId($new);
<   if ($status ne "") {
<     print Tss('Rename-Text: new page %1 is invalid, error is: %2', $new, $status)
<           . "<br>\n";
<     return;
<   }
<   $old =~ s/_/ /g;
<   $new =~ s/_/ /g;
<   # Note: the LinkIndex must be built prior to this routine
<   return  if (!defined($LinkIndex{$oldCanonical}));
<   @pageList = split(' ', $LinkIndex{$oldCanonical});
<   foreach $page (@pageList) {
<     $changed = 0;
<     &OpenPage($page);
<     foreach $section (keys %Page) {
<       if ($section =~ /^text_/) {
<         &OpenSection($section);
<         %Text = split(/$FS3/, $Section{'data'}, -1);
<         $oldText = $Text{'text'};
<         $newText = &SubstituteTextLinks($old, $new, $oldText);
<         if ($oldText ne $newText) {
<           $Text{'text'} = $newText;
<           $Section{'data'} = join($FS3, %Text);
<           $Page{$section} = join($FS2, %Section);
<           $changed = 1;
<         }
<       } elsif ($section =~ /^cache_diff/) {
<         $oldText = $Page{$section};
<         $newText = &SubstituteTextLinks($old, $new, $oldText);
<         if ($oldText ne $newText) {
<           $Page{$section} = $newText;
<           $changed = 1;
<         }
<       }
<       # Add other text-sections (categories) here
<     }
<     if ($changed) {
<       $file = &GetPageFile($page);
<       &WriteStringToFile($file, join($FS1, %Page));
<     }
<     &RenameKeepText($page, $old, $new);
<   }
< }
< 
< sub RenamePage {
<   my ($old, $new, $doRC, $doText) = @_;
<   my ($oldfname, $newfname, $oldkeep, $newkeep, $status);
< 
<   $old =~ s/ /_/g;
<   $new = &FreeToNormal($new);
<   $status = &ValidId($old);
<   if ($status ne "") {
<     print Tss('Rename: old page %1 is invalid, error is: %2', $old, $status)
<           . "<br>\n";
<     return;
<   }
<   $status = &ValidId($new);
<   if ($status ne "") {
<     print Tss('Rename: new page %1 is invalid, error is: %2', $new, $status)
<           . "<br>\n";
<     return;
<   }
<   $newfname = &GetPageFile($new);
<   if (-f $newfname) {
<     print Ts('Rename: new page %s already exists--not renamed.', $new)
<           . "<br>\n";
<     return;
<   }
<   $oldfname = &GetPageFile($old);
<   if (!(-f $oldfname)) {
<     print Ts('Rename: old page %s does not exist--nothing done.', $old)
<           . "<br>\n";
<     return;
<   }
<   &CreatePageDir($PageDir, $new);  # It might not exist yet
<   rename($oldfname, $newfname);
<   &CreatePageDir($KeepDir, $new);
<   $oldkeep = $KeepDir . "/" . &GetPageDirectory($old) .  "/$old.kp";
<   $newkeep = $KeepDir . "/" . &GetPageDirectory($new) .  "/$new.kp";
<   unlink($newkeep)  if (-f $newkeep);  # Clean up if needed.
<   rename($oldkeep,  $newkeep);
<   unlink($IndexFile)  if ($UseIndex);
<   &EditRecentChanges(2, $old, $new)  if ($doRC);
<   if ($doText) {
<     &BuildLinkIndexPage($new);  # Keep index up-to-date
<     &RenameTextLinks($old, $new);
<   }
< }
< 
< sub DoShowVersion {
<   print &GetHeader('', T('Displaying Wiki Version'), '');
<   print "<p>UseModWiki version 1.0.4</p>\n";
<   print &GetCommonFooter();
< }
< 
< # Thanks to Phillip Riley for original code
< sub DoDeletePage {
<   my ($id) = @_;
< 
<   return  if (!&ValidIdOrDie($id));
<   print &GetHeader('', Ts('Delete %s', $id), '');
<   return  if (!&UserIsAdminOrError());
<   if ($ConfirmDel && !&GetParam('confirm', 0)) {
<     print '<p>';
<     print Ts('Confirm deletion of %s by following this link:', $id);
<     print '<br>' . &GetDeleteLink($id, T('Confirm Delete'), 1);
<     print '</p>';
<     print &GetCommonFooter();
<     return;
<   }
<   print '<p>';
<   if ($id eq $HomePage)  {
<     print Ts('%s can not be deleted.', $HomePage);
<   } else {
<     if (-f &GetLockedPageFile($id))   {
<       print Ts('%s can not be deleted because it is locked.', $id);
<     } else {
<       # Must lock because of RC-editing
<       &RequestLock() or die(T('Could not get editing lock'));
<       DeletePage($id, 1, 1);
<       &ReleaseLock();
<       print Ts('%s has been deleted.', $id);
<     }
<   }
<   print '</p>';
<   print &GetCommonFooter();
< }
< 
< # Thanks to Ross Kowalski and Iliyan Jeliazkov for original uploading code
< sub DoUpload {
<   print &GetHeader('', T('File Upload Page'), '');
<   if (!$AllUpload) {
<     return if (!&UserIsEditorOrError());
<   }
<   print '<p>' . Ts('The current upload size limit is %s.', $MaxPost) . ' '
<         . Ts('Change the %s variable to increase this limit.', '$MaxPost');
<   print '</p><br>';
<   print '<FORM METHOD="post" ACTION="' . $ScriptName
<         . '" ENCTYPE="multipart/form-data">';
<   print '<input type="hidden" name="upload" value="1" />';
<   print T('File to Upload:'), ' <INPUT TYPE="file" NAME="file"><br><BR>';
<   print '<INPUT TYPE="submit" NAME="Submit" VALUE="', T('Upload'), '">';
<   print '</FORM>';
<   print &GetCommonFooter(); 
< }
< 
< sub SaveUpload {
<   my ($filename, $printFilename, $uploadFilehandle);
<  
<   print &GetHeader('', T('Upload Finished'), '');
<   if (!$AllUpload) {
<     return  if (!&UserIsEditorOrError());
<   }
<   $UploadDir .= '/'  if (substr($UploadDir, -1, 1) ne '/');  # End with /
<   $UploadUrl .= '/'  if (substr($UploadUrl, -1, 1) ne '/');  # End with /
<   $filename = $q->param('file');
<   $filename =~ s/.*[\/\\](.*)/$1/;  # Only name after last \ or /
<   $uploadFilehandle = $q->upload('file');
<   open UPLOADFILE, ">$UploadDir$filename";
<   binmode UPLOADFILE;
<   while (<$uploadFilehandle>) { print UPLOADFILE; }
<   close UPLOADFILE;
<   print T('The wiki link to your file is:') . "\n<br><BR>";
<   $printFilename = $filename;
<   $printFilename =~ s/ /\%20/g;  # Replace spaces with escaped spaces
<   print "upload:" . $printFilename . "<BR><BR>\n";
<   if ($filename =~ /$ImageExtensions$/i) {
<     print '<HR><img src="' . $UploadUrl . $filename . '">' . "\n";
<   }
<   print &GetCommonFooter();
< }
< 
< sub ConvertFsFile {
<   my ($oldFS, $newFS, $fname) = @_;
<   my ($oldData, $newData, $status);
< 
<   return  if (!-f $fname);  # Convert only existing regular files
<   ($status, $oldData) = &ReadFile($fname);
<   if (!$status) {
<     print '<br><strong>' . Ts('Could not open file %s', $fname)
<           . ':</strong>' . T('Error was') . ":\n<pre>$!</pre>\n" . '<br>';
<     return;
<   }
<   $newData = $oldData;
<   $newData =~ s/$oldFS(\d)/$newFS . $1/ge;
<   return  if ($oldData eq $newData);  # Do not write if the same
<   &WriteStringToFile($fname, $newData);
< # print $fname . '<br>';    # progress report
< }
< 
< # Converts up to 3 dirs deep  (like page/A/Apple/subpage.db)
< # Note that top level directory (page/keep/user) contains only dirs
< sub ConvertFsDir {
<   my ($oldFS, $newFS, $topDir) = @_;
<   my (@dirs, @files, @subFiles, $dir, $file, $subFile, $fname, $subFname);
< 
<   opendir(DIRLIST, $topDir);
<   @dirs = readdir(DIRLIST);
<   closedir(DIRLIST);
<   @dirs = sort(@dirs);
<   foreach $dir (@dirs) {
<     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
<     next  if (!-d "$topDir/$dir");          # Top level directories only
<     next  if (-f "$topDir/$dir.cvt");       # Skip if already converted
<     opendir(DIRLIST, "$topDir/$dir");
<     @files = readdir(DIRLIST);
<     closedir(DIRLIST);
<     foreach $file (@files) {
<       next  if (($file eq '.') || ($file eq '..'));
<       $fname = "$topDir/$dir/$file";
<       if (-f $fname) {
< #       print $fname . '<br>';   # progress
<         &ConvertFsFile($oldFS, $newFS, $fname);
<       } elsif (-d $fname) {
<         opendir(DIRLIST, $fname);
<         @subFiles = readdir(DIRLIST);
<         closedir(DIRLIST);
<         foreach $subFile (@subFiles) {
<           next  if (($subFile eq '.') || ($subFile eq '..'));
<           $subFname = "$fname/$subFile";
<           if (-f $subFname) {
< #           print $subFname . '<br>';   # progress
<             &ConvertFsFile($oldFS, $newFS, $subFname);
<           }
<         }
<       }
<     }
<   &WriteStringToFile("$topDir/$dir.cvt", 'converted');
<   }
< }
< 
< sub ConvertFsCleanup {
<   my ($topDir) = @_;
<   my (@dirs, $dir);
< 
<   opendir(DIRLIST, $topDir);
<   @dirs = readdir(DIRLIST);
<   closedir(DIRLIST);
<   foreach $dir (@dirs) {
<     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
<     next  if (!-f "$topDir/$dir");          # Remove only files...
<     next  unless ($dir =~ m/\.cvt$/);       # ...that end with .cvt
<     unlink "$topDir/$dir";
<   }
< }
< 
< sub DoConvert {
<   my $oldFS = "\xb3";
<   my $newFS = "\x1e\xff\xfe\x1e";
< 
<   print &GetHeader('', T('Convert wiki DB'), '');
<   return if (!&UserIsAdminOrError());
<   if ($FS ne $newFS) {
<     print Ts('You must change the %s option before converting the wiki DB.',
<              '$NewFS') . '<br>';
<     return;
<   }
<   &WriteStringToFile("$DataDir/noedit", 'editing locked.');
<   print T('Wiki DB locked for conversion.') . '<br>';
<   print T('Converting Wiki DB...') . '<br>';
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog");
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/rclog.old");
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog");
<   &ConvertFsFile($oldFS, $newFS, "$DataDir/oldrclog.old");
<   &ConvertFsDir($oldFS, $newFS, $PageDir);
<   &ConvertFsDir($oldFS, $newFS, $KeepDir);
<   &ConvertFsDir($oldFS, $newFS, $UserDir);
<   &ConvertFsCleanup($PageDir);
<   &ConvertFsCleanup($KeepDir);
<   &ConvertFsCleanup($UserDir);
<   print T('Finished converting wiki DB.') . '<br>';
<   print Ts('Remove file %s to unlock wiki for editing.', "$DataDir/noedit")
<         . '<br>';
<   print &GetCommonFooter();
< }
< 
< # Remove user-id files if no useful preferences set
< sub DoTrimUsers {
<   my (%Data, $status, $data, $maxID, $id, $removed, $keep);
<   my (@dirs, @files, $dir, $file, $item);
< 
<   print &GetHeader('', T('Trim wiki users'), '');
<   return if (!&UserIsAdminOrError());
<   $removed = 0;
<   $maxID = 1001;
<   opendir(DIRLIST, $UserDir);
<   @dirs = readdir(DIRLIST);
<   closedir(DIRLIST);
<   foreach $dir (@dirs) {
<     next  if (substr($dir, 0, 1) eq '.');   # No ., .., or .dirs
<     next  if (!-d "$UserDir/$dir");         # Top level directories only
<     opendir(DIRLIST, "$UserDir/$dir");
<     @files = readdir(DIRLIST);
<     closedir(DIRLIST);
<     foreach $file (@files) {
<       if ($file =~ m/(\d+).db/) {  # Only numeric ID files
<         $id = $1;
<         $maxID = $id  if ($id > $maxID);
<         %Data = ();
<         ($status, $data) = &ReadFile("$UserDir/$dir/$file");
<         if ($status) {
<           %Data = split(/$FS1/, $data, -1);  # -1 keeps trailing null fields
<           $keep = 0;
<           foreach $item (qw(username password adminpw stylesheet)) {
<             $keep = 1  if (defined($Data{$item}) && ($Data{$item} ne ''));
<           }
<           if (!$keep) {
<             unlink "$UserDir/$dir/$file";
< #           print "$UserDir/$dir/$file" . '<br>';  # progress
<             $removed += 1;
<           }
<         }
<       }
<     }
<   }
<   print Ts('Removed %s files.', $removed) . '<br>';
<   print Ts('Recommended $StartUID setting is %s.', $maxID + 100) . '<br>';
<   print &GetCommonFooter();
< }
< #END_OF_OTHER_CODE
< 
< &DoWikiRequest()  if ($RunCGI && ($_ ne 'nocgi'));   # Do everything.
< 1; # In case we are loaded from elsewhere
< # == End of UseModWiki script. ===========================================
5175a2
> 
------
WikiCodeBox|1218208814
------
FlashSWF/ExampleDiceland|1218267433
------
FlashSWF/ExampleDiceland|1218267447
------
FlashSWF/ExampleTimeNow|1218268507
1c1
< #MAGIC Flash name=FlashSWF/TimeNow.swf height=200 width=270
---
> #MAGIC Flash name=FlashSWF/TimeNow.swf height=300 width=370
------
FlashSWF/ExampleTimeNow|1218268530
1c1
< #MAGIC Flash name=FlashSWF/TimeNow.swf height=300 width=370
---
> #MAGIC Flash name=FlashSWF/TimeNow.swf height=200 width=270
------
GRoWWII/OtherWorlds|1218308589
1c1
< ====== Describe the new page here. =
---
> == Other Pulp Sci-Fi Universes =
------
GRoWWII|1218308603
39a39,40
>  /OtherWorlds
> 
------
GRoWWII/OtherWorlds|1218310974
1,2c1,39
< == Other Pulp Sci-Fi Universes =
< 
---
> = Pulp Sci-Fi Universes =
> There are a number of existing alternate worlds settings for the Second World War.  The majority of them are novels or role-playing games.  A few exist as board-games.  One or two exist as movies or computer games.  Here's a quick list of each category of influences.  Where possible, I've provided links to [WikiPedia:WikiPedia WikiPedia].
> 
> == Movies and Serials =
> * [http://en.wikipedia.org/wiki/Flash_gordon Flash Gordon]
> * [http://en.wikipedia.org/wiki/Buck_rogers Buck Rogers]
> * [http://en.wikipedia.org/wiki/Commander_Cody_and_His_Lost_Planet_Airmen Commander Cody]
> * [http://en.wikipedia.org/wiki/Iron_Sky Iron Sky: Nazis on the Moon]
> * [http://en.wikipedia.org/wiki/Hellboy Hellboy]
> * [http://en.wikipedia.org/wiki/Rocketeer The Rocketeer]
> * [http://en.wikipedia.org/wiki/Sky_Captain Sky Captain and the World of Tomorrow]
> 
> == Computer Games =
> * [http://en.wikipedia.org/wiki/Castle_Wolfenstein Castle Wolfenstein]
> * [http://en.wikipedia.org/wiki/Ring_of_Red Ring of Red]
> 
> == Models and Art =
> * [http://en.wikipedia.org/wiki/Maschinen_Krieger_ZbV_3000 Maschinen Krieger]
> * [http://steamwars.com/gallery.htm Steam Wars]
> * [http://www.cee-gee.net/Movies/Movies.htm Code Guardian]
> 
> == Miniatures Gaming =
> 
> * [http://www.darksondesigns.com/aeww2.html AE-WWII]
> * [http://en.wikipedia.org/wiki/Crimson_Skies Crimson Skies]
> * [http://en.wikipedia.org/wiki/Gear_Krieg Gear Krieg]
> 
> == Role-playing Games =
> 
> * Secrets of the Third Reich
> * Victory: War of Bronze
> * [http://battlegroundweirdwarii.com/ Weird War II]
> 
> == Real Life =
> * [http://en.wikipedia.org/wiki/Machina_Speculatrix#The_.22tortoises.22 Machina Speculatrix]
> * [http://en.wikipedia.org/wiki/P-1000 Landkreuser ]
> * [http://en.wikipedia.org/wiki/Image:Fairey_Rotodyne.jpg Gyrodynes]
> * [http://en.wikipedia.org/wiki/Ekranoplan Ekranoplanes]
> * [http://en.wikipedia.org/wiki/Nikola_Tesla Nikola Tesla]
------
WikiInfo|1218394255
1c1
< ====== Describe the new page here. =
---
> #REDIRECT NobleWiki
------
NobleWiki|1218427442
81,82d81
< ||<tt><nowiki>$FooterText</nowiki></tt>||This was needlessly eliminated, and shall return.||
< 
------
NobleWiki|1218463887
98a99,109
> === Code-related Features =
> These items I think I'll need to complete before I submit the code to SourceForge.
> 
> !!Features Planned|width=200!!Description!!
> ||Update <tt>PRINT</tt>||All of the incidences of the <tt>PRINT</tt> command in the code need to be replaced with a String glob.  This will make the code more flexible.||
> ||Localization||I see the <tt>trans.pl</tt> and <tt>umtrans.pl</tt>.  I'm not sure that this is the best way to support I18N.  For example, the wiki engine should be able to serve up content localized to a specific language when given a preference.  This requires sub-directories by language in the database such as <tt>//en/content1</tt>  or <tt>//ja/content2</tt>.||
> ||Lock List||The administrator view needs to be able to determine which pages have been locked, and which pages are private.||
> ||Visitor's Log||This would be an audit trail of visitors by IP address and possibly by logon ID.||
> ||Home Page Binding||Once Preferences are set and a logon ID is determined, the visitor should be given the option to create a Home Page or to redirect to it if it already exists.||
> 
> 
------
NobleWiki|1218463944
100c100
< These items I think I'll need to complete before I submit the code to SourceForge.
---
> These items I think I'll need to complete before I submit the code to [http://www.sourceforge.net SourceForge]
------
FlashSWF/ExampleTimeNow|1218464143
1c1
< #MAGIC Flash name=FlashSWF/TimeNow.swf height=200 width=270
---
> #MAGIC Flash name=FlashSWF/TimeNow.swf height=400 width=540
------
FlashSWF/ExampleTimeNow|1218464172
1c1
< #MAGIC Flash name=FlashSWF/TimeNow.swf height=400 width=540
---
> #MAGIC Flash name=FlashSWF/TimeNow.swf height=200 width=270
------
WikiImages|1218518263
98a99,104
> Each of the above was written in a pattern similar to the following:
> 
> <pre>
> ||upload:SAMPLE.nnn||
> </pre>
> 
------
WikiImages|1218519664
98a98,99
> ||upload:SAMPLE.blend||upload:SAMPLE.java||
> 
------
WikiImages|1218555646
19c19
< !!Extension|class=first|width=200!!TThese are often either the final product or used as reference material.!!
---
> !!Extension|class=first|width=200!!These are often either the final product or used as reference material.!!
27a28,32
> !!Extension|class=first|width=200!!These are miscellaneous types allowed.!!
> ||.java||Java file.||
> ||.blend||Blender3D file.||
> ||.zip||Archive file.||
> 
------
NobleWiki|1218728404
88d87
< ||<tt><nowiki>{{comments}}</nowiki></tt>||Allow comments to be added if inserted at bottom of page.  Comments would be a separate file structure and accessed via a new tab and input would be GUI-based instead of using the Edit-box. Uses sub-pages named as <tt><nowiki>/CommentsPage</nowiki></tt> or <tt><nowiki>/CommentsSubPage</nowiki></tt>.||
94d92
< ||<tt><nowiki>{{code|syntax}}</nowiki></tt>||Add syntax highlighting for common language files like perl, actionscript, javascript, css, xml, and html. The output will be contained within <tt><nowiki><code class='syntax'></code></nowiki></tt> blocks and dynamically higlighted using javascript.||
------
AdminActions|1222315184
26c26
< ||[LocalWiki:action=edit&amp;id=Actions edit&amp;id=pagename] || edit page||
---
> ||[LocalWiki:action=edit&amp;id=SandBox edit&amp;id=pagename] || edit page||
------
RelatedEntries/WikiAdministration|1222315463
1,5c1,5
< AdminFeatures
< WikiAdmin
< AdminActions
< InterMap
< PrivateUserGroups
---
>  AdminFeatures
>  WikiAdmin
>  AdminActions
>  InterMap
>  PrivateUserGroups
------
NobleWiki|1222315536
5c5
< This wiki for Noble Pursuit Games is derived from the freely available [Wiki:UseModWIki UseMod 1.03] wiki engine available as the Wiki:UseModWiki site.  The base install of the NobleWiki engine includes everything listed within the [WikiMinimums StarterPages].
---
> This wiki for Noble Pursuit Games is derived from the freely available [Wiki:UseModWIki UseMod 1.04] wiki engine available as the Wiki:UseModWiki site.  The base install of the NobleWiki engine includes everything listed within the [WikiMinimums StarterPages].
------
PrivateUserGroups|1222315901
3c3,38
< Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName}</nowiki></tt> or <tt><nowiki>{r:UserName}</nowiki></tt> to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an [AuthError Authorization Error] page 
---
> Editors may create an authorization filter for access to any page by creating a sub-page with a list of usernames.  Users in the list are allowed either Editor access or Read-only access.  Create the sub-page with each user name on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName}</nowiki></tt> or <tt><nowiki>{r:UserName}</nowiki></tt> to indicate can edit or can read. Guests and non-listed users otherwise attempting to access the page will receive an [AuthError Authorization Error] page.
> 
> ====== Example-1 =
> Suppose we've modified the SandBox by adding the following to it:
> 
> <tt><nowiki>{e:JohnDoe}</nowiki></tt>
> 
> The above will allow the username <nowiki>JohnDoe</nowiki> and only him to edit the page; all others may read the page.
> 
> 
> ====== Example-2 =
> Suppose we've modified the SandBox by adding the following to it:
> 
> <tt><nowiki>{e:JohnDoe}</nowiki></tt>
> <tt><nowiki>{e:JaneSmith}</nowiki></tt>
> 
> The above will allow the usernames <nowiki>JohnDoe</nowiki> and <nowiki>JaneSmith</nowiki> to edit the page; all others may read the page.
> 
> 
> ====== Example-3 =
> Suppose we've modified the SandBox by adding the following to it:
> 
> <tt><nowiki>{r:JaneSmith}</nowiki></tt>
> 
> The above will allow the username <nowiki>JaneSmith</nowiki> to __read__ the page; no others may access the page.
> 
> 
> ====== Example-4 =
> Suppose we've modified the SandBox by adding the following to it:
> 
> <tt><nowiki>{e:JohnDoe}</nowiki></tt>
> <tt><nowiki>{r:JaneSmith}</nowiki></tt>
> 
> The above will allow the usernames <nowiki>JohnDoe</nowiki> and <nowiki>JaneSmith</nowiki> to read the page; no others may read the page.  <nowiki>JohnDoe</nowiki> may also edit the page.
> 
> 
------
RelatedEntries/WikiHelp|1222322297
1c1,14
< ====== Describe the new page here. =
---
>  WikiStyleGuide
>  WikiMarkup
>  WikiTOCs
>  WikiHeadings
>  WikiLists
>  WikiTables
>  WikiImages
>  WikiURLs
>  WikiTemplates
>  WikiGallery
>  WikiFlash 
>  WikiTemplates
>  WikiUploads
>  WikiCodeBox 
------
RelatedEntries/WikiEditing|1222322458
0a1,16
>  
> 
>  WikiStyleGuide
>  WikiMarkup
>  WikiTOCs
>  WikiHeadings
>  WikiLists
>  WikiTables
>  WikiImages
>  WikiURLs
>  WikiTemplates
>  WikiGallery
>  WikiFlash
>  WikiTemplates
>  WikiUploads
>  WikiCodeBox
7,21d17
< WikiStyleGuide
< WikiMarkup
< WikiTOCs
< WikiHeadings
< WikiLists
< WikiTables
< WikiImages
< WikiURLs
< WikiTemplates
< WikiGallery
< WikiFlash
< WikiTemplates
< WikiUploads
< WikiCodeBox
< 
------
RelatedEntries/WikiHelp|1222322543
1,14c1
<  WikiStyleGuide
<  WikiMarkup
<  WikiTOCs
<  WikiHeadings
<  WikiLists
<  WikiTables
<  WikiImages
<  WikiURLs
<  WikiTemplates
<  WikiGallery
<  WikiFlash 
<  WikiTemplates
<  WikiUploads
<  WikiCodeBox 
---
> DeletedPage
------
PrivateUserGroups|1222326214
6c6
< Suppose we've modified the SandBox by adding the following to it:
---
> Suppose we've modified the SandBox by adding the following to a subpage <nowiki>/Authorization</nowiki>:
14c14
< Suppose we've modified the SandBox by adding the following to it:
---
> Multiple editors are simply additions of extra names in a row:
23c23
< Suppose we've modified the SandBox by adding the following to it:
---
> To cause a page to be entirely private except for particular usernames:
31c31
< Suppose we've modified the SandBox by adding the following to it:
---
> Mixing and matching is allowed as well:
------
RelatedEntries/WikiEditing|1222413515
14d13
<  WikiTemplates
------
NobleWiki|1222414398
20c20
< ||Auto Signature||Insert <tt><nowiki>~~~</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>~~~~</nowiki></tt> to append timestamp.||
---
> ||Auto Signature||Insert <tt><nowiki>~~~</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>$$$$</nowiki></tt> to append timestamp.||
------
WikiEditing|1222414690
27a27,29
> * Using <tt><nowiki>~~~~</nowiki></tt> will sign your name if you've signed in via the [LocalWiki:action=editprefs Preferences].  This is useful for quick comments.
> * Using <tt><nowiki>$$$$</nowiki></tt> will sign your name followed by a timestamp if you've signed in via the [LocalWiki:action=editprefs Preferences]
> 
------
WikiEditing|1222414719
28c28
< * Using <tt><nowiki>$$$$</nowiki></tt> will sign your name followed by a timestamp if you've signed in via the [LocalWiki:action=editprefs Preferences]
---
> * Using <tt><nowiki>$$$$</nowiki></tt> will sign your name followed by a timestamp if you've signed in via the [LocalWiki:action=editprefs Preferences].
------
Free|1222414771
2a3
> Single Word page
------
Free|1222414981
1,3c1,3
< ====== Describe the new page here. =
< 
< Single Word page
---
> ===== TASK: Free Link Example =
> 
> This page was created using the FreeLinks feature.  It isn't a WikiWord; it's a single word.  FreeLinks can be created by any Editor or Admin.  Guests may not create FreeLinks.
------
FreeLinks|1222415012
1c1
< ====== Describe the new page here. =
---
> @REDIRECT Free
------
FreeLinks|1222415023
1c1
< @REDIRECT Free
---
> #REDIRECT Free
------
WikiURLs|1222415144
23,24c23,24
< A URL to a wiki entry can be created using a single word instead of a WikiWord by enclosing that single word with pairs of square brackets like <tt><nowiki>[[WheeFree]]</nowiki></tt>.  Optionally specify the actual display text after a pipe as in <tt><nowiki>[[HomePage|Go home]]</nowiki></tt>
< * [[WheeFree]]
---
> A URL to a wiki entry can be created using a single word instead of a WikiWord by enclosing that single word with pairs of square brackets like <tt><nowiki>[[Free]]</nowiki></tt>.  Optionally specify the actual display text after a pipe as in <tt><nowiki>[[HomePage|Go home]]</nowiki></tt>.
> * [[Free]]
------
Free|1222415257
3c3
< This page was created using the FreeLinks feature.  It isn't a WikiWord; it's a single word.  FreeLinks can be created by any Editor or Admin.  Guests may not create FreeLinks.
---
> This page was created using the [LocalWiki:WikiURLs#freelinks feature].  It isn't a WikiWord; it's a single word.  Single word pages can only be created by any Editor or Admin.  Guests may not create single-word pages.
------
Free|1222415297
3c3
< This page was created using the [LocalWiki:WikiURLs#freelinks feature].  It isn't a WikiWord; it's a single word.  Single word pages can only be created by any Editor or Admin.  Guests may not create single-word pages.
---
> This page was created using the [LocalWiki:WikiURLs#freelinks feature].  It isn't a WikiWord; it's a single word.  Single word pages can only be created by any EditorRole or AdminRole.  GuestRole may not create single-word pages.
------
EditorRole|1222415440
1,2c1,3
< ====== Describe the new page here. =
< 
---
> ===== DEFINITION: Wiki Editor =
> 
> A Wiki Editor is a user that has provided the proper editor password via the [LocalWiki:action=editprefs Preferences] screen.  Editors are allowed to visit locked pages, and create PrivateUserGroups.
------
GuestRole|1222415597
1,2c1,3
< ====== Describe the new page here. =
< 
---
> ===== DEFINITION: Wiki Guest =
> 
> A Guest is any user that visits this wiki but doesn't sign in as an [EditorRole editor] or [AdminRole administrator].  The guest may distinguish himself from other anonymous users of this wiki by editing their [LocalWiki:action=editprefs Preferences] and providing a username.
------
Free|1222415637
1c1
< ===== TASK: Free Link Example =
---
> ===== DEFINITION: Single Word Page =
------
EditorRole|1222420850
3c3
< A Wiki Editor is a user that has provided the proper editor password via the [LocalWiki:action=editprefs Preferences] screen.  Editors are allowed to visit locked pages, and create PrivateUserGroups.
---
> A Wiki Editor is a user that has provided the proper editor password via the [LocalWiki:action=editprefs Preferences] screen.  Editors are allowed to upload and manage assets, and create PrivateUserGroups.
------
NobleWiki|1222421302
44a44,45
> ||Expanded <tt><nowiki>FreeLinks and $LinkPattern</nowiki></tt>||Pages that are formed with a single word instead of a WikiWord may only be created by EditorRole and AdminRole.  All [LocalWiki:WikiStyleGuide sub-pages] must conform to the WikiWord pattern on both sides of the slash; i.e.; <tt><nowiki>PrimaryPage/SubPage</nowiki></tt> instead of just <tt><nowiki>PrimaryPage/Word</nowiki></tt>||
> 
------
Free|1222421422
3c3
< This page was created using the [LocalWiki:WikiURLs#freelinks feature].  It isn't a WikiWord; it's a single word.  Single word pages can only be created by any EditorRole or AdminRole.  GuestRole may not create single-word pages.
---
> This page was created using the [LocalWiki:WikiURLs#freelinks feature].  It isn't a WikiName; it's a single word.  Single word pages can only be created by any EditorRole or AdminRole.  GuestRole may not create single-word pages.
------
NobleWiki|1222421609
108a107,108
> ||GMT Offset Detection||This could be done via JavaScript and passed automatically to the CGI whenever a page is edited.  Of course, also preset this in the Preferences page as well.||
> 
------
JavaScript|1222485091
1c1,7
< ====== Describe the new page here. =
---
> ===== DEFINITION: JavaScript =
> 
> A Web Browser programming language designed to enhance user experience.  Without JavaScript, all actions on a Web page that is to present dynamic information must make a round-trip call to the CGI code on the server.  JavaScript is used principally to manage forms validation, but many other subtle additions to a user experience can be had.  A key example is the ImageGallery.  The major script libraries used in the NobleWiki are as follows:
> 
> * jQuery - the base-line scripting libary that allows for cross-platform/cross-browser support.
> * UFO - Unobtrusive Flash Object; allows embedding of Flash SWFs and graceful error notification in case the Flash player version is wrong.
> * LightBox - Allows for the behavior of the ImageGallery.
------
JavaScript|1222485728
5,7c5,9
< * jQuery - the base-line scripting libary that allows for cross-platform/cross-browser support.
< * UFO - Unobtrusive Flash Object; allows embedding of Flash SWFs and graceful error notification in case the Flash player version is wrong.
< * LightBox - Allows for the behavior of the ImageGallery.
---
> # jQuery - the base-line scripting libary that allows for cross-platform/cross-browser support.
> # UFO - Unobtrusive Flash Object; allows embedding of Flash SWFs and graceful error notification in case the Flash player version is wrong.
> # LightBox - Allows for the behavior of the ImageGallery.
> 
> .
------
JavaScript|1222485767
5,7c5,7
< # jQuery - the base-line scripting libary that allows for cross-platform/cross-browser support.
< # UFO - Unobtrusive Flash Object; allows embedding of Flash SWFs and graceful error notification in case the Flash player version is wrong.
< # LightBox - Allows for the behavior of the ImageGallery.
---
> * jQuery - the base-line scripting libary that allows for cross-platform/cross-browser support.
> * UFO - Unobtrusive Flash Object; allows embedding of Flash SWFs and graceful error notification in case the Flash player version is wrong.
> * <nowiki>LightBox</nowiki> - Allows for the behavior of the ImageGallery.
------
JavaScript|1222486051
9,10d7
< .
< 
------
JavaScript|1222488328
------
JavaScript|1222488340
8c8
< * jQuery - the base-line scripting libary that allows for cross-platform/cross-browser support.
---
> * jQuery - the base-line scripting library that allows for cross-platform/cross-browser support.
------
JavaScript|1222488536
------
JavaScript|1222488841
------
JavaScript|1222522295
------
FeaturedContent|1222523082
------
FlashSWF/ExampleTimeNow|1222524872
------
RelatedEntries/WikiEditing|1222525614
1,2c1
<  
< 
---
> 
------
RelatedEntries/WikiEditing|1222525625
1c1,2
< 
---
>  
> 
------
RelatedEntries/WikiEditing|1222525702
------
RelatedEntries/WikiEditing|1222526195
1,2c1
<  
< 
---
> 
------
RelatedEntries/WikiAdministration|1222526743
0a1,2
>  
> 
------
RelatedEntries/WikiEditing|1222526758
1c1,2
< 
---
>  
> 
------
ContactUs|1222527466
1,8c1
< = Contact Information =
< We're just a small team of developers.  Well, just one developer and a bunch of friends.  Well, okay; just one developer and people that I get to hang out with once in a while.
< 
< === E-Mail Address =
< kitrok@yahoo.com
< 
< 
< 
---
> #REDIRECT WikiContacts
------
WikiContacts|1222527480
3,4c2,5
< Wow, should I really put some contact information here?  I think I'll just create a Web form and allow the output to go to a database for me to read at leisure.
< 
---
> We're just a small team of developers.  Well, just one developer and a bunch of friends.  Well, okay; just one developer and people that I get to hang out with once in a while.
> 
> === E-Mail Address =
> kitrok@yahoo.com
------
NobleWiki|1222551650
44c44
< ||Expanded <tt><nowiki>FreeLinks and $LinkPattern</nowiki></tt>||Pages that are formed with a single word instead of a WikiWord may only be created by EditorRole and AdminRole.  All [LocalWiki:WikiStyleGuide sub-pages] must conform to the WikiWord pattern on both sides of the slash; i.e.; <tt><nowiki>PrimaryPage/SubPage</nowiki></tt> instead of just <tt><nowiki>PrimaryPage/Word</nowiki></tt>||
---
> ||Expanded <tt><nowiki>FreeLinks and $LinkPattern</nowiki></tt>||Pages that are formed with a single word instead of a WikiWord may only be created by EditorRole and AdminRole.||
------
NobleWiki|1222569327
45a45,46
> ||View User Contributions||Use <tt><nowiki>action=rc&userid=RobertKurcina</nowiki></tt> to see all contributions by a given userid.  This is made available in each RecentChanges history line as well.||
> 
------
WikiTemplates/TemplateExample|1222570091
4c4
< ||Image||$VARIABLE1$||
---
> ||Image|width=100|class=first||$VARIABLE1$|align=left ||
------
ExampleTemplate|1222570145
------
WikiTemplates/TemplateExample|1222570429
8c8
< ||bracketed url ||$VARIABLE5$}||
---
> ||bracketed url ||$VARIABLE5$||
------
WikiTemplates|1222570574
64c64
< Place all templates as sub-pages under <nowiki>WikiTemplates</nowiki> as slash '/' and then the template name as in <nowiki>/Profile</nowiki>.  Or, if the templates are external to this page, prefix them with <tt>Template</tt> as the keyword.
---
> Place all templates as sub-pages under WikiTemplates as slash '/' and then the template name as in /TemplateExample.  Or, if the templates are external to this page, prefix them with <tt>Template</tt> as the keyword for it's WikiName.
------
AdminActions|1222572574
19a20
> ||[LocalWiki:action=history&amp;id=Actions history&amp;id=pagename&amp;userid=username] || history of changes made by username||
------
SandBox|1222578976
0a1,3
> = Heading =
> 
> ~~~~
2d4
< 
------
HomePage_Notes|1222579102
1,2c1
< ====== Describe the new page here. =
< 
---
> SampleFile
------
RelatedEntries/WikiAdministration_Notes|1222579122
1,2c1
< ====== Describe the new page here. =
< 
---
> Samepl file
------
NobleWiki|1222579495
68c68,69
< ||UseMod:WikiPatches/PrivateUserGroups||Modified from original.  Each user name must be on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName} or {r:UserName}</nowiki></tt> to indicate can edit or can read.  Otherwise an Authrization Error page will appear [ AuthError ]||
---
> ||UseMod:WikiPatches/PrivateUserGroups||Modified from original.  Each user name must be on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName} or {r:UserName}</nowiki></tt> to indicate can edit or can read.  Otherwise an Authorization Error page will appear [ AuthError ]||
> ||UseMod:WikiPatches/TalkPage||Modified from original such that each page potentially has a 'Notes' page.  See NotesPages.||
------
NotesPages|1222579744
1,2c1,3
< ====== Describe the new page here. =
< 
---
> ===== DEFINITION: Notes Page =
> 
> Every WikiPage has the potential to have a Notes page that is the page's WikiName appended by the term '_Notes'.  These pages are available for primary pages and sub-pages.  Notes pages are intended to keep ideas, ramblings, and discussions regarding the content of the associated parent page.
------
NobleWiki|1222580870
69c69
< ||UseMod:WikiPatches/TalkPage||Modified from original such that each page potentially has a 'Notes' page.  See NotesPages.||
---
> ||UseMod:WikiPatches/UserTalkSpace||Modified from original such that each page potentially has a 'Notes' page.  See NotesPages.||
------
SandBox|1222585632
3a5
> [[[Notes]]]
------
SandBox|1222585656
5c5
< [[[Notes]]]
---
> [[[HelloWorld people are at it again]]]
------
SandBox|1222585930
5a6,9
> [[[HelloWorld people are at it again]]]
> [[[HelloWorld people are at it again]]]
> [[[HelloWorld people are at it again]]]
> [[[HelloWorld people are at it again]]]
------
SandBox|1222585941
5,9c5,9
< [[[HelloWorld people are at it again]]]
< [[[HelloWorld people are at it again]]]
< [[[HelloWorld people are at it again]]]
< [[[HelloWorld people are at it again]]]
< [[[HelloWorld people are at it again]]]
---
> [[[HelloWorld1 people are at it again]]]
> [[[HelloWorld2 people are at it again]]]
> [[[HelloWorld3 people are at it again]]]
> [[[HelloWorld4 people are at it again]]]
> [[[HelloWorld5 people are at it again]]]
------
SandBox|1222586859
5c5
< [[[HelloWorld1 people are at it again]]]
---
> [[[HelloWorld1 people are at it again SuperDuper]]]
------
SandBox|1222587748
5c5,6
< [[[HelloWorld1 people are at it again SuperDuper]]]
---
> [[[HelloWorld1 people are at it again SuperDuper]]]Something very interesting goes here.
> 
------
SandBox|1222588365
5c5
< [[[HelloWorld1 people are at it again SuperDuper]]]Something very interesting goes here.
---
> [[[HelloWorld1 see http://www.yahoo.com/]]] Something very interesting goes here.
------
NobleWiki|1222590087
70a70,71
> ||UseMod:WikiPatches/FooterNotes||Allows for plain-text citations.  See FootNotes page.||
> 
------
HomePage_Notes|1222591087
1c1,2
< SampleFile
---
>  
>  SampleFile
------
Free|1222622144
------
NobleWiki|1222623113
0a1
> = The NobleWiki Engine =
------
WikiBugs|1222623178
10c10
< ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans incorrectly lists legitimate sub pages||OPEN||
---
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans incorrectly lists legitimate sub pages||FIXED-2008.09.28||
------
WikiBugs|1222623230
5c5
< ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||OPEN||
---
> ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||FIXED-2008.09.27||
------
AdminActions|1222623692
22a22,23
> ||[LocalWiki:action=orphans] || list pages that are not linked.||
> 
------
AdminActions|1222623772
22c22
< ||[LocalWiki:action=orphans] || list pages that are not linked.||
---
> ||[LocalWiki:action=orphans action=orphans] || list pages that are not linked.||
------
FootNotes|1222626408
1,2c1,31
< ====== Describe the new page here. =
< 
---
> ===== DEFINITION: Footer Notes =
> 
> Footer notes can be created in two ways; as one-way links and as reference entries.  One way links are created using a single pair of square brackets around an InterWiki, LocalWiki, or URL with no second term.  Reference links are bi-directional within a page and will generated at the bottom a a page a References section.
> 
> ===== EXAMPLE: One-way Links =
> <pre>
> Note via <nowiki>LocalWiki</nowiki>. [LocalWiki:NothingNew]
> Note via internal URL. [http://wiki.kurcina.org/testing]
> Note with URL. [http://www.google.com/]
> Note via InterMap [Wiki:WardCunningham]
> </pre>
> 
> Created this:
> 
> Note via <nowiki>LocalWiki</nowiki>. [LocalWiki:NothingNew]
> Note via internal URL. [http://wiki.kurcina.org/testing]
> Note with URL. [http://www.google.com/]
> Note via InterMap [Wiki:WardCunningham]
> 
> ===== EXAMPLE: Reference Links =
> <pre>
> A fascinating search engine. [[[See more at http://www.google.com/]]]
> Another powerful way to search the Web. [[[Ibid.]]]
> All of my statements of fact are true. [[[Citation disputed by http://en.wikipedia.org.]]]
> </pre>
> 
> Created this:
> 
> A fascinating search engine. [[[See more at http://www.google.com/]]]
> Another powerful way to search the Web. [[[Ibid.]]]
> All of my statements of fact are true. [[[Citation disputed by http://en.wikipedia.org.]]]
------
WikiHelp|1222627551
4d3
< == Related Entries =
------
RelatedEntries/WikiEditing|1222627583
1c1
<  
---
> == Related Entries =
------
RelatedEntries/WikiAdministration|1222627601
1c1
<  
---
> == Related Entries =
------
RelatedEntries/WikiTour|1222627694
1,2c1,7
< ====== Describe the new page here. =
< 
---
> == Related Entries =
> 
>  WikiEditing
>  WikiBugs
>  WikiMinimums
>  CategoryCategory
>  ListOfWantedPages
------
AdminActions|1222627775
113d112
< == Related Entries =
------
NobleWiki|1222627792
113,118c113
< == Related Entries =
<  WikiEditing
<  WikiBugs
<  WikiMinimums
<  CategoryCategory
<  ListOfWantedPages
---
> {{template:RelatedEntries/WikiTour}}
------
AdminFeatures|1222627816
63d61
< == Related Entries =
------
WikiEditing|1222627903
64d63
< == Related Entries =
------
WikiFlash|1222627917
34d31
< == Related Entries =
------
WikiGallery|1222627928
59d57
< == Related Entries =
------
WikiHeadings|1222627942
22d21
< == Related Entries =
------
WikiImages|1222627952
111d107
< == Related Entries =
------
WikiLists|1222627963
53d52
< == Related Entries =
------
WikiMarkup|1222627973
89d88
< == Related Entries =
------
WikiStyleGuide|1222627991
30d29
< == Related Entries =
------
WikiTOCs|1222628005
39d38
< == Related Entries =
------
WikiTables|1222628022
79d77
< == Related Entries =
------
WikiTemplates|1222628032
66d65
< == Related Entries =
------
WikiURLs|1222628111
34d33
< == Related Entries =
------
WikiUploads|1222628125
49d48
< == Related Entries =
------
WikiUploads|1222628143
51d49
< [[Category:Nova]]
------
RelatedEntries/WikiAdministration_Notes|1222628432
1c1
< Samepl file
---
> DeletedPage
------
AdminActions|1222629000
23a23,25
> ||[LocalWiki:action=browse&raw=1&id=pagename action=browse&raw=1&id=pagename ] || browse a page and view its Wiki markup in raw mode||
> ||[LocalWiki:action=browse&embed=1&id=pagename action=browse&embed=1&id=pagename ] || browse a page but do not include the header or footer||
> 
------
NobleWiki_Notes|1222631135
1,2c1
< ====== Describe the new page here. =
< 
---
> #REDIRECT WikiBugs
------
WikiBugs|1222631224
14a15
> ||2008.09.28||~~~~||
------
WikiBugs|1222631365
15c15,16
< ||2008.09.28||~~~~||
---
> ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Auto-signature doesn't really store the editor's name||OPEN||
> ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Need to update T(), Ts(), Tss() and to remove all double-quotes expressions for taint||OPEN||
------
RobertKurcina|1222631670
1,2c1,10
< ====== Describe the new page here. =
< 
---
> = Heading =
> 
> ~~~~
> 
> [[[HelloWorld1 see http://www.yahoo.com/]]] Something very interesting goes here.
> 
> [[[HelloWorld2 people are at it again]]]
> [[[HelloWorld3 people are at it again]]]
> [[[HelloWorld4 people are at it again]]]
> [[[HelloWorld5 people are at it again]]]
------
RobertKurcina|1222632300
1,10c1
< = Heading =
< 
< ~~~~
< 
< [[[HelloWorld1 see http://www.yahoo.com/]]] Something very interesting goes here.
< 
< [[[HelloWorld2 people are at it again]]]
< [[[HelloWorld3 people are at it again]]]
< [[[HelloWorld4 people are at it again]]]
< [[[HelloWorld5 people are at it again]]]
---
> DeletedPage
------
SandBox|1222664313
10a12,17
> A hyperlink to http://www.yahoo.com/
> //
> //
> //
> //
> A long line with creole line breaks in itA long//line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole // line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in //itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in it
------
RelatedEntries/WikiEditing|1222678890
1c1
< == Related Entries =
---
> 
------
RelatedEntries/WikiEditing|1222679003
1c1
< 
---
> ==== Related Entries =
------
WikiBugs|1222701407
14,16c14,17
< ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output||FIXED-2007.12.03||
< ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Auto-signature doesn't really store the editor's name||OPEN||
< ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Need to update T(), Ts(), Tss() and to remove all double-quotes expressions for taint||OPEN||
---
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output.||FIXED-2007.12.03||
> ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Auto-signature doesn't really store the editor's name.||OPEN||
> ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Need to update T(), Ts(), Tss() and to remove all double-quotes expressions for taint.||OPEN||
> ||2008.09.29||[HomePage/RobertKurcina RobertKurcina]||Table of Contents doesn't properly number when including templates with their own headings.||OPEN||
------
RelatedEntries/WikiAdministration_Notes|1222747248
1c1
< DeletedPage
---
> #DELETE
------
RelatedEntries/WikiAdministration_Notes|1222748921
1c1
< #DELETE
---
> DeletePage
------
GRoWWII|1222751872
3c3
< <toc 225>
---
> {{toc 225}}
------
NobleWiki|1222751885
3c3
< <toc>
---
> {{toc}}
------
CategoryWiki|1222751906
1c1
< <toc>
---
> {{toc}}
------
NobleWiki|1222751934
37c37
< ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] may be assigned a pixel width parameter as in <tt><nowiki><toc NNN></nowiki></tt>||
---
> ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] may be assigned a pixel width parameter as in <tt><nowiki>{{toc NNN}}</nowiki></tt>||
------
WikiMinimums|1222751954
3c3
< <toc>
---
> {{toc}}
------
WikiStyleGuide|1222751967
4,5c4
< <toc>
< 
---
> {{toc}}
------
WikiTOCs|1222751982
4c3
< <toc 250>
---
> {{toc}}
------
GRoWWII|1222752134
41c41
<  #SUBPAGES
---
>  {{subpages}}
------
HomePage|1222752143
20c20
<  #SUBPAGES
---
>  {{subpages}}
------
ImageGallery|1222752152
5c5
<  #SUBPAGES
---
>  {{subpages}}
------
NobleWiki|1222752193
55c55
< ||UseMod:WikiPatches/EmbeddedSubpageList||Allows placement of <nowiki><subpage></nowiki> on any page, and wiki engine will generate list of subpages associated with it.||
---
> ||UseMod:WikiPatches/EmbeddedSubpageList||Allows placement of <nowiki>{{subpages}}</nowiki> on any page, and wiki engine will generate list of subpages associated with it.||
------
RelatedEntries|1222752208
11c11
<  #SUBPAGES
---
>  {{subpages}}
------
WikiEditing|1222752241
5c5
< <toc 170>
---
> {{toc}}
------
AdminFeatures|1222752298
1c1
< <toc>
---
> {{toc}}
------
WikiTemplates|1222752311
4c4
< <toc>
---
> {{toc}}
------
WikiUploads|1222752326
11c11
< <toc>
---
> {{toc}}
------
WikiURLs|1222752341
6c6
< <toc 225>
---
> {{toc}}
------
WikiTables|1222752373
4c4
< <toc>
---
> {{toc}}
------
AdminActions|1222752401
1c1
< <toc>
---
> {{toc}}
------
WikiMarkup|1222752418
3c3
< <toc>
---
> {{toc}}
------
WikiLists|1222752426
1c1
< <toc>
---
> {{toc}}
------
WikiImages|1222752437
3c2
< <toc>
---
> {{toc}}
------
WikiGallery|1222752445
1c1
< <toc>
---
> {{toc}}
------
WikiFlash|1222752468
1,2c1
< <toc>
< 
---
> {{toc}}
------
WikiCodeBox|1222752493
4c3
< <toc>
---
> {{toc}}
------
NoblePursuit|1222752508
2c2
< <toc 180>
---
> {{toc}}
------
NobleMission|1222752529
4c4
< <toc 250>
---
> {{toc}}
------
MagicContent|1222752547
3c3
< <toc>
---
> {{toc}}
------
GameDesignsInProgress|1222752556
1c1
< <toc>
---
> {{toc}}
40c40
<  [http://forums.kurcina.org/cgi-bin/groww2/index.cgi Giant Robots of World War II Forums] 
---
>  [http://forums.kurcina.org/cgi-bin/groww2/index.cgi Giant Robots of World War II Forums]
------
GRoWWII/TOandE|1222752569
3,4c3
< <toc 200>
< 
---
> {{toc}}
------
BulletinBoardCode|1222752588
4,5c3
< <toc>
< 
---
> {{toc}}
------
WikiTOCs|1222752692
2c2
< The Table of Contents shown here was created automatically by the wiki engine.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section.  If the TOC needs to be of a specific width, insert that value in pixels right before the closing angle bracket as in <tt><nowiki><toc NNN></nowiki></tt>
---
> The Table of Contents shown here was created automatically by the wiki engine.  Position the actual table of contents - like the one shown above - by inserting <tt><nowiki><toc></nowiki></tt> at the desired position.  The resultant TOC will contain links generated which lead to their corresponding sections.  Any text added after the last section appears to be part of the last section.  If the TOC needs to be of a specific width, insert that value in pixels right before the closing angle bracket as in <tt><nowiki>{{toc:NNN}}</nowiki></tt>
------
WikiDelete|1222761373
1,2c1
< ====== Describe the new page here. =
< 
---
> ||DELETED: This page is scheduled for deletion|style=color:red;font-size:14pt;padding:10px;||
------
RelatedEntries/WikiAdministration_Notes|1222761414
1c1
< DeletePage
---
> {{template:WikiDelete}}
------
WikiDelete|1222761573
1c1,2
< ||DELETED: This page is scheduled for deletion|style=color:red;font-size:14pt;padding:10px;||
---
> ||DELETED|style=color:red;font-size:14pt;padding:10px;font-weight:bold;||
> This page is scheduled for deletion.
------
RecentChanges|1222762697
------
RecentChanges|1222762722
1c1
< Use this page to see what's new.
---
> ===== Use this page to see what's new =
------
RecentChanges|1222762748
1c1
< ===== Use this page to see what's new =
---
> Use this page to see what's new
------
AdminActions|1222831793
0a1
> = Admin Actions =
------
PageNotFound|1222844539
1,3c1,4
< ===== ERROR! Page Not Found =
< The page you requested doesn't exist.
< 
---
> = Page doesn't exist =
> 
> The page you requested doesn't exist in the database. //
> To create this page, click [LocalWiki:action=editreferer here].
------
NobleWiki|1222847633
47a47,48
> ||Redirect to Edit Page||By setting action=referer in the <tt><nowiki>$NotFoundPage</nowiki></tt>, the hyperlink created will redirect to the edit page for the name of the page. This is useful to automatically generate edit requests for Notes pages.||
> 
------
Main|1222849975
1,2c1
< ====== Describe the new page here. =
< 
---
> {{redirect:HomePage}}
------
AuthError|1222850406
1,2c1
< #REDIRECT PageNotFound
< 
---
> {{redirect:PageNotFound}}
------
HomePage/Kitrok|1222850598
1c1
< #REDIRECT HomePage/RobertKurcina
---
> {{redirect:HomePage/RobertKurcina}}
------
HtmlPairs|1222850650
1,3c1
< #REDIRECT HtmlTags
< 
< Keep all Html config info on tags page, but set up redirects to act as symbolic-links (shortcuts) from other three variable names
---
> DeletedPage
------
HtmlSingle|1222850672
1,3c1
< #REDIRECT HtmlTags
< 
< Discuss all four Html config vars on one page, but keep links from other three
---
> DeletedPage
------
MagicFlash|1222850688
1c1
< #REDIRECT WikiFlash
---
> {{redirect:WikiFlash}}
------
MagicWanted|1222850707
1,2c1
< #REDIRECT ListOfWantedPages
< 
---
> {{redirect:ListOfWantedPages}}
------
NobleWiki_Notes|1222850719
1c1
< #REDIRECT WikiBugs
---
> {{redirect:WikiBugs}}
------
RawHtml|1222850731
1,3c1
< #REDIRECT HtmlTags
< 
< combined these two pages but kept RawHtml as separate name for the combined page. River, 2001-12-02
---
> DeletedPage
------
SessionReports|1222850746
1c1
< #REDIRECT GamingSessionReports
---
> {{redirect:GamingSessionReports}}
------
StarterPages|1222850763
1,2c1
< #REDIRECT WikiMinimums
< 
---
> {{redirect:WikiMinimums}}
------
TourBusStop|1222850779
1c1
< #REDIRECT NobleWiki
---
> {{redirect:NobleWiki}}
------
WikiDefects|1222850790
1c1
< #REDIRECT WikiBugs
---
> {{redirect:WikiBugs}}
------
WikiInfo|1222850806
1,2c1
< #REDIRECT NobleWiki
< 
---
> {{redirect:NobleWiki}}
------
FrontPage|1222850814
1,2c1
< #REDIRECT Homepage
< 
---
> {{redirect:HomePage}}
------
FreeLinks|1222850819
1,2c1
< #REDIRECT Free
< 
---
> {{redirect:[[Free]]}}
------
FreeLinks|1222850826
1c1
< {{redirect:[[Free]]}}
---
> {{redirect:[Free]}}
------
FreeLinks|1222850833
1c1
< {{redirect:[Free]}}
---
> {{redirect: [Free]}}
------
FreeLinks|1222850880
1c1
< {{redirect: [Free]}}
---
> {{redirect: [[Free]]}}
------
DeletingPages|1222850886
1c1
< #REDIRECT AdminDelete
---
> {{redirect:AdminDelete}}
------
ContactUs|1222850890
1c1
< #REDIRECT WikiContacts
---
> {{redirect:WikiContacts}}
------
AdminRole|1222850896
1c1
< #REDIRECT WikiAdmin
---
> {{redirect:WikiAdmin}}
------
AuthError|1222850908
1c1
< {{redirect:PageNotFound}}
---
> DeletedPage
------
RobertKurcina|1222851133
1c1
< DeletedPage
---
> {{delete}}
------
AuthError|1222851165
1c1
< DeletedPage
---
> {{delete}}
------
HtmlPairs|1222851173
1c1
< DeletedPage
---
> {{delete}}
------
HtmlSingle|1222851180
1c1
< DeletedPage
---
> {{delete}}
------
RawHtml|1222851188
1c1
< DeletedPage
---
> {{delete}}
------
AdminDelete|1222851306
3c3
< Place DeletedPage on a line by itself at the top of the page.  This will flag the page for deletion after 60 days.  If you really need a page deleted immediately, make a note of it in the change summary, and a WikiAdmin can delete the page immediately if they concur that it should be deleted without delay.
---
> Place <tt><nowiki>DeletedPage</nowiki></tt> on a line by itself at the top of the page.  This will flag the page for deletion after 60 days.  If you really need a page deleted immediately, make a note of it in the change summary, and a WikiAdmin can delete the page immediately if they concur that it should be deleted without delay.
------
AdminDelete|1222851826
3c3
< Place <tt><nowiki>DeletedPage</nowiki></tt> on a line by itself at the top of the page.  This will flag the page for deletion after 60 days.  If you really need a page deleted immediately, make a note of it in the change summary, and a WikiAdmin can delete the page immediately if they concur that it should be deleted without delay.
---
> Place <tt><nowiki>{{delete}}</nowiki></tt> on a line by itself at the top of the page.  This will flag the page for deletion after 60 days.  If you really need a page deleted immediately, make a note of it in the change summary, and a WikiAdmin can delete the page immediately if they concur that it should be deleted without delay.
------
WikiEditing|1222852082
38,39c38,40
<   <nowiki>#REDIRECT TargetPage</nowiki>
<   <nowiki>#REDIRECT TargetPage/SubPage</nowiki>
---
>   <nowiki>{{redirect:TargetPage}}</nowiki>
>   <nowiki>{{redirect:TargetPage/SubPage}}</nowiki>
>   <nowiki>{{redirect:[[Freelink]]}}</nowiki>
55c56
<   #SUBPAGES TargetPage
---
>   {{subpages:TargetPage}}
------
WikiEditing|1222852230
44c44
<   <nowiki>#INCLUDE filename</nowiki>
---
>   <nowiki>{{include:filename}}</nowiki>
47c47
<  #INCLUDE something.html
---
>  {{include:something.html}}
------
FlashSWF/ExampleDiceRoller|1222852865
1c1
< #MAGIC Flash name=FlashSWF/CDieD6.swf height=250 width=200
---
> {{command: Flash name=FlashSWF/CDieD6.swf height=250 width=200}}
------
WikiFlash|1222852964
22c22
< If a SWF file is of importance or great curiosity, it should be placed upon a page by itself using the Magic Content directive.  As such, the page will not have a preview feature; it must be saved in order to render the results.  Here's an example of how the syntax would appear:
---
> If a SWF file is of importance or great curiosity, it should be placed upon a page by itself using the <tt><nowiki>{{command}}</nowiki></tt> directive.  As such, the page will not have a preview feature; it must be saved in order to render the results.  Here's an example of how the syntax would appear:
25c25
<   #MAGIC Flash name=FlashSWF/diceland.swf height=300 width=200
---
>   {{command: Flash name=FlashSWF/diceland.swf height=300 width=200}}
------
FlashSWF/ExampleDiceland|1222852991
1c1
< #MAGIC Flash name=FlashSWF/diceland.swf height=200 width=270
---
> {{command: Flash name=FlashSWF/diceland.swf height=200 width=270}}
------
FlashSWF/ExampleTimeNow|1222853157
1c1
< #MAGIC Flash name=FlashSWF/TimeNow.swf height=200 width=270
---
> {{command: Flash name=FlashSWF/TimeNow.swf height=200 width=270}}
------
HomePage|1222853172
1c1
< #MAGIC @check Discuss numbered=Y
---
> {{command: @check Discuss numbered=Y}}
------
ListOfWantedPages|1222853227
1c1
< #MAGIC WantedPages threshold=0
---
> {{command: WantedPages threshold=0}}
------
MagicAll|1222853240
1,2c1
< #MAGIC AllPages list=ol
< 
---
> {{command: AllPages list=ol}}
------
MagicCommands|1222853250
1,2c1
< #MAGIC @solo ListCommands
< 
---
> {{command: @solo ListCommands}}
------
MagicDiscussion|1222853284
3c3
< By adding the MagicContent command <tt>#MAGIC Discuss</tt> to a wiki page, a feedback form will appear that can be filled out by any user that has logged in with a userID.  Any feedback that has been received will be written into the filesystem under <tt><nowiki>$DiscussDir</nowiki></tt>.  The feedback form can be locked by either setting the <tt>locked=Y</tt> option for the command.
---
> By adding the MagicContent command <tt>{{command: Discuss}}</tt> to a wiki page, a feedback form will appear that can be filled out by any user that has logged in with a userID.  Any feedback that has been received will be written into the filesystem under <tt><nowiki>$DiscussDir</nowiki></tt>.  The feedback form can be locked by either setting the <tt>locked=Y</tt> option for the command.
------
NobleWiki|1222853318
26c26
< ||Flash Object||Flash SWFs may be added using the <tt><nowiki>#MAGIC Flash</nowiki></tt> directive and module. See WikiFlash for more information.||
---
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki>{{command: Flash}}</nowiki></tt> directive and module. See WikiFlash for more information.||
43c43
< ||Discuss Page||This is a work-in-progress.  Essentially add <tt><nowiki>#MAGIC Discuss</nowiki></tt> in order to activate discussion form and feedback set for a page.  Deactivate form but leave feedback in place by adding parameter locked=true.||
---
> ||Discuss Page||This is a work-in-progress.  Essentially add <tt><nowiki>{{command:  Discuss}}</nowiki></tt> in order to activate discussion form and feedback set for a page.  Deactivate form but leave feedback in place by adding parameter locked=true.||
------
WikiEditing|1222853357
51c51
<   #MAGIC ModuleName param1=value1 param2=value2 ...
---
>   {{command: ModuleName param1=value1 param2=value2 ...}}
62c62
<   #MAGIC Flash name=diceland.swf height=300 width=200
---
>   {{command: Flash name=diceland.swf height=300 width=200}}
------
MagicContent|1222853527
8c8
< #MAGIC [@position] command [key=value key=value ...]
---
> {{command: Module key=value|key=value|key=value ...]}}
14c14
< #MAGIC @top AllPages list=ol
---
> {{command: AllPages list=ol|position=top}}
20c20
< The <tt>#MAGIC</tt> directive may appear only once and as the first line of a wiki page. Only the first directive is processed; all of the others are ignored.  
---
> The <tt>{{command}}</tt> directive may appear only once and as the first line of a wiki page. Only the first directive is processed; all of the others are ignored.  
------
FlashSWF/ExampleDiceland|1222853561
1c1
< {{command: Flash name=FlashSWF/diceland.swf height=200 width=270}}
---
> {{command: Flash name=FlashSWF/diceland.swf|height=200|width=270}}
------
FlashSWF/ExampleDiceland|1222853618
1c1
< {{command: Flash name=FlashSWF/diceland.swf|height=200|width=270}}
---
> {{command: Flash name=FlashSWF/diceland.swf height=200 width=270}}
------
About|1222854064
1,2c1
< ====== Describe the new page here. =
< 
---
> {{redirect:NobleWiki}}
------
Contents|1222854105
1,2c1
< ====== Describe the new page here. =
< 
---
> {{redirect:CategoryCategory}}
------
Featured|1222854131
1,2c1
< ====== Describe the new page here. =
< 
---
> {{redirect:FeaturedContent}}
------
Help|1222854156
1,2c1
< ====== Describe the new page here. =
< 
---
> {{redirect:WikiHelp}}
------
MagicBlog|1222854404
1,2c1
< ====== Describe the new page here. =
< 
---
> {{redirect:SandBox}}
------
SandBox|1222854419
1,17c1
< = Heading =
< 
< ~~~~
< 
< [[[HelloWorld1 see http://www.yahoo.com/]]] Something very interesting goes here.
< 
< [[[HelloWorld2 people are at it again]]]
< [[[HelloWorld3 people are at it again]]]
< [[[HelloWorld4 people are at it again]]]
< [[[HelloWorld5 people are at it again]]]
< 
< A hyperlink to http://www.yahoo.com/
< //
< //
< //
< //
< A long line with creole line breaks in itA long//line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole // line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in //itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in itA long line with creole line breaks in it
---
> {{redirect:MagicBlog}}
------
HomePage|1222854539
1c1
< {{command: @check Discuss numbered=Y}}
---
> {{command: Discuss numbered=Y}}
------
HomePage|1222854556
1c1
< {{command: Discuss numbered=Y}}
---
> {{command @check Discuss numbered=Y}}
------
HomePage|1222854565
1c1
< {{command @check Discuss numbered=Y}}
---
> {{command: @check Discuss numbered=Y}}
------
MagicBlog_Notes|1222918780
1,2c1
< ====== Describe the new page here. =
< 
---
> {{template: ExampleTemplate}}
------
MagicBlog_Notes|1222918806
1c1
< {{template: ExampleTemplate}}
---
> {{template:ExampleTemplate}}
------
FlashSWF|1222919379
5c5
<  #SUBPAGES
---
> {{subpages}}
------
FlashSWF|1222919393
5c5
< {{subpages}}
---
>  {{subpages}}
------
NobleWiki|1222919493
69c69
< ||UseMod:WikiPatches/SubPages||Modified synatx.  <tt><nowiki>#SUBPAGES</nowiki></tt>Inserts all of a page's sub-pages.  Optional page name as in <tt><nowiki>#SUBPAGES somepage</nowiki></tt> will show that page's subpages||
---
> ||UseMod:WikiPatches/SubPages||Modified syntax  <tt><nowiki>{{subpages}}</nowiki></tt>Inserts all of a page's sub-pages.  Optional page name as in <tt><nowiki>{{subpages:PageName}}</nowiki></tt> will show that page's subpages||
------
WikiTemplates|1222919599
68c68
<  #SUBPAGES
---
>  {{subpages}}
------
MagicBlog|1222924494
1c1
< {{redirect:SandBox}}
---
> {{color: blue|fred}}
------
NobleWiki|1222925584
48a48,49
> ||Block Colors||Introduced custom coloring with <tt><nowiki>{{block:key=value|key=value|..}}</nowiki></tt> where key is bgcolor, color, or padding [in pixels].  bgcolor and color accept and standard CSS color names.||
> 
------
NobleWiki|1222925733
3c3
< {{toc}}
---
> <toc>
------
NobleWiki|1222925896
3c3
< <toc>
---
> {{toc}}
------
CategoryWiki|1222936269
1c1
< {{toc}}
---
> <toc>
------
NobleWiki|1222936364
3c3
< {{toc}}
---
> <toc>
------
NobleWiki|1222936386
3c3
< <toc>
---
> {{toc}}
------
ReallyLongPage|1222939161
2c2
< Don't edit this page.  It's meant to demonstrate how named anchors work.  It's back link is from the WikiURLs page.  The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anchor]Demonstrating Anchors =</nowiki></tt>.
---
> Don't edit this page.  It's meant to demonstrate how named anchors work.  It's back link is from the WikiURLs page.  The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anchor] Demonstrating Anchors =</nowiki></tt>.
------
RelatedEntries/WikiTour|1222961455
7a9
> {{template:WikiEditing}}
------
RelatedEntries/WikiTour|1222961606
9d7
< {{template:WikiEditing}}
------
WikiMarkup|1222962094
51c51
< Continue a line of text by using a "\" backslash. This can be useful for breaking up long lines of text in line sensitive sections such as lists or indented text,
---
> Continue a line of text by using a "\\" backslash. This can be useful for breaking up long lines of text in line sensitive sections such as lists or indented text,
53,59c53,54
<  * This bullet\\
<  <br>point could have a long\\
<  <br>sentence that takes several lines.
< 
< * This bullet\
< point could have a long\
< sentence that takes several lines.
---
> <tt><nowiki>* This bullet\\point could have a long\\sentence that takes several lines.</nowiki></tt>
> * This bullet\\point could have a long\\sentence that takes several lines.
------
WikiMarkup|1222962119
52,53c52,53
< eg
< <tt><nowiki>* This bullet\\point could have a long\\sentence that takes several lines.</nowiki></tt>
---
> eg;
>  <tt><nowiki>* This bullet\\point could have a long\\sentence that takes several lines.</nowiki></tt>
------
FootNotes|1222962294
3c3
< Footer notes can be created in two ways; as one-way links and as reference entries.  One way links are created using a single pair of square brackets around an InterWiki, LocalWiki, or URL with no second term.  Reference links are bi-directional within a page and will generated at the bottom a a page a References section.
---
> Footer notes can be created in two ways; as one-way links and as reference entries.  One way links are created using a single pair of square brackets around an InterWMap, LocalWiki, or URL with no second term.  Reference links are bi-directional within a page and will generated at the bottom a a page a References section.
------
FootNotes|1222962304
3c3
< Footer notes can be created in two ways; as one-way links and as reference entries.  One way links are created using a single pair of square brackets around an InterWMap, LocalWiki, or URL with no second term.  Reference links are bi-directional within a page and will generated at the bottom a a page a References section.
---
> Footer notes can be created in two ways; as one-way links and as reference entries.  One way links are created using a single pair of square brackets around an InterMap, LocalWiki, or URL with no second term.  Reference links are bi-directional within a page and will generated at the bottom a a page a References section.
------
FootNotes|1222962330
3c3
< Footer notes can be created in two ways; as one-way links and as reference entries.  One way links are created using a single pair of square brackets around an InterMap, LocalWiki, or URL with no second term.  Reference links are bi-directional within a page and will generated at the bottom a a page a References section.
---
> Footer notes can be created in two ways; as one-way links and as reference entries.  One way links are created using a single pair of square brackets around an InterMap or URL with no second term.  Reference links are bi-directional within a page and will generated at the bottom a a page a References section.
------
RelatedEntries/WikiAdministration|1223011102
1,2d0
< == Related Entries =
< 
------
RelatedEntries/WikiAdministration|1223011110
0a1
>  
------
RelatedEntries/WikiEditing|1223011119
1,2c1
< ==== Related Entries =
< 
---
> 
------
RelatedEntries/WikiEditing|1223011126
1c1,2
< 
---
>  
> 
------
RelatedEntries/WikiTour|1223011135
1,2c1
< == Related Entries =
< 
---
> 
------
RelatedEntries/WikiTour|1223011141
1c1
< 
---
>  
------
AdminActions|1223011189
115a115
> == Related Entries =
------
AdminFeatures|1223011197
61a61
> == Related Entries =
------
NobleWiki|1223011211
114a114
> == Related Entries =
------
WikiFlash|1223011226
30a30
> == Related Entries =
------
WikiEditing|1223011244
64a64
> == Related Entries =
------
WikiGallery|1223011252
57a57
> == Related Entries =
------
WikiHeadings|1223011262
21a21
> == Related Entries =
------
WikiImages|1223011287
106a106
> == Related Entries =
------
WikiLists|1223011300
52a52
> == Related Entries =
------
WikiMarkup|1223011312
83a84
> == Related Entries =
------
WikiStyleGuide|1223011345
28a29
> == Related Entries =
------
WikiTOCs|1223011360
37a38
> == Related Entries =
------
WikiTables|1223011370
77a78
> == Related Entries =
------
WikiTemplates|1223011382
65a66
> == Related Entries =
------
WikiURLs|1223011396
33a34
> == Related Entries =
------
ReallyLongPage|1223011828
1c1
< = [#anchor]Demonstrating Anchors =
---
> = [#anchor] Demonstrating Anchors =
------
WikiUploads|1223011985
47c47
< Any assets that are moved will clobber - erase, and over-write - any existing assets in the destination if their filenames are the same.  This can be a quick way to 
---
> Any assets that are moved will clobber - erase, and over-write - any existing assets in the destination if their filenames are the same.  This can be a quick way to replace a file.
------
HomePage|1223020203
1c1
< {{command: @check Discuss numbered=Y}}
---
> {{command: Discuss numbered=Y}}
------
PageNotFound|1223021621
3c3
< The page you requested doesn't exist in the database. //
---
> The page you requested doesn't exist in the database. \\
------
PageNotFound|1223021631
3c3
< The page you requested doesn't exist in the database. \\
---
> The page you requested doesn't exist in the database. \\ 
------
PageNotFound|1223021640
3c3
< The page you requested doesn't exist in the database. \\ 
---
> The page you requested doesn't exist in the database.\\ 
------
PageNotFound|1223021710
3,4c3
< The page you requested doesn't exist in the database.\\ 
< To create this page, click [LocalWiki:action=editreferer here].
---
> The page you requested doesn't exist in the database\\To create this page, click [LocalWiki:action=editreferer here].
------
PageNotFound|1223021759
3c3
< The page you requested doesn't exist in the database\\To create this page, click [LocalWiki:action=editreferer here].
---
> The page you requested doesn't exist in the database.\\To create this page, click [LocalWiki:action=editreferer here].
------
PageNotFound|1223022626
1c1
< = Page doesn't exist =
---
> = Page requested doesn't exist =
------
WikiMinimums|1223025022
19c19
< **ListOfWantedPages
---
> **ListOfWantedPages
------
WikiMinimums|1223025143
112a114,117
> == Environment =
> *Apache HTTP Server [ a Web server ]
> *perl [ a programming language ]
> *Microsoft Windows 2000 or Linux
------
ReallyLongPage|1223352976
1c1,2
< = [#anchor] Demonstrating Anchors =
---
> {{toc}}
> == [#anchor] Demonstrating Anchors =
14c15
< The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#nextanchor]Demonstrating Anchors =</nowiki></tt>.
---
> The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#nextanchor] Demonstrating Anchors =</nowiki></tt>.
26c27
< The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anotheranchor]Demonstrating Anchors =</nowiki></tt>.
---
> The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anotheranchor] Demonstrating Anchors =</nowiki></tt>.
------
GRoWWII|1223353040
3c3
< {{toc 225}}
---
> {{toc}}
7,10c7,10
< Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a historical mission or a selected free-form scenario.  Units are purchased via Order-of-Battle points [ OP ] and range from the light but versatile Infantry unit to the more devastating 
< Atomic Robots.  Each unit type has a matching Information card that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
< 
< Objective Markers are also placed upon the battlefield as goals for acquisition during play which translate into victory points.  Victory points are also awarded for eliminating enemy units.  At the end of the game  usually 6 turns long  the player with the most points wins!
---
> Players wage combat upon a battlefield comprised of multi-hex tiles with forces purchased from among the various types available in attempts to achieve victory in a &#65533;historical&#65533; mission or a selected free-form scenario.  Units are purchased via &#65533;Order-of-Battle&#65533; points [ OP ] and range from the light but versatile &#65533;Infantry&#65533; unit to the more devastating 
> &#65533;Atomic Robots&#65533;.  Each unit type has a matching &#65533;Information card&#65533; that details the special abilities that the unit is capable of.  These abilities alter the basic rules of game play to provide for more interesting battlefield interactions.
> 
> Objective Markers are also placed upon the battlefield as goals for acquisition during play which translate into victory points.  Victory points are also awarded for eliminating enemy units.  At the end of the game &#65533; usually 6 turns long &#65533; the player with the most points wins!
13c13
< This game is a fanciful but detailed look at how to prosecute warfare at the operational level.  Unlike many such games that employ hundreds of unit counters to recreate such a simulation, this one focuses on the interaction of ten or twenty.  
---
> This game is a fanciful but detailed look at how to prosecute warfare at the &#65533;operational level&#65533;.  Unlike many such games that employ hundreds of unit counters to recreate such a simulation, this one focuses on the interaction of ten or twenty.  
16c16
< Here are the key differences of operational level games when compared to tactical level games that deal with smaller units like men, squads, or platoons:
---
> Here are the key differences of operational level games when compared to &#65533;tactical level&#65533; games that deal with smaller units like men, squads, or platoons:
19c19
< This operational level game deals with units that are companies and battalions.  Theres about a thousand soldiers or one-hundred vehicles in a battalion.  Or, maybe it just contains 10 really humongous robots and their nervous human handlers.  
---
> This operational level game deals with units that are companies and battalions.  There&#65533;s about a thousand soldiers or one-hundred vehicles in a battalion.  Or, maybe it just contains 10 really humongous robots and their nervous human handlers.  
24c24
< Imagine reaching out your hands in front of you, and whirling about to cover your back.  You probably could cover about 3 feet in a radius around you; anybody coming within range would probably get smacked, or at least move cautiously by.  Now do this with a machine gun, with mortars, with cannons, with giant robot beam weapons.  And then, multiply that by several hundred or several thousand rounds of weapons fire by nearly as many soldiers or tanks covering several hundred meters all about.  Thats Zone-of-Control.
---
> Imagine reaching out your hands in front of you, and whirling about to cover your back.  You probably could cover about 3 feet in a radius around you; anybody coming within range would probably get smacked, or at least move cautiously by.  Now do this with a machine gun, with mortars, with cannons, with giant robot beam weapons.  And then, multiply that by several hundred or several thousand rounds of weapons fire by nearly as many soldiers or tanks covering several hundred meters all about.  That&#65533;s Zone-of-Control.
27c27
< In the scale of tactical level games, the firefights go pretty quickly; maybe five to twenty minutes pass in game-time depending on the scale of the simulation.  Ammo does run out, but probably not fuel.  You can always reload.  In operation level games, supply is critical.  Being in supply - within the distance of the supply truck convoys  can be the difference between having your units perforated, running for cover, or pressing the battle-line victoriously forward.
---
> In the scale of tactical level games, the firefights go pretty quickly; maybe five to twenty minutes pass in game-time depending on the scale of the simulation.  Ammo does run out, but probably not fuel.  You can always reload.  In operation level games, supply is critical.  Being &#65533;in supply&#65533; - within the distance of the supply truck convoys &#65533; can be the difference between having your units perforated, running for cover, or pressing the battle-line victoriously forward.
30c30
< At the tactical level, the heroic commanders could probably shout orders to their equally heroic underlings, and maybe get some things done by all as a team.  It doesnt work that well with the units that are way across the hill, especially when each unit represents the average response of possibly hundreds of disorganized warriors awaiting instruction.  Without Line-of-Command, units will not be able to participate in the glory of taking down that mammoth tank or draw the line against the rogue sentinel robot together.
---
> At the tactical level, the heroic commanders could probably shout orders to their equally heroic underlings, and maybe get some things done by all as a team.  It doesn&#65533;t work that well with the units that are way across the hill, especially when each unit represents the average response of possibly hundreds of disorganized warriors awaiting instruction.  Without Line-of-Command, units will not be able to participate in the glory of taking down that mammoth tank or draw the line against the rogue sentinel robot together.
------
WikiURLs|1223353893
0a1
> [#top]
------
WikiURLs|1223354031
13c13
< Named URL links allow anything within square brackets to be shown but link to something else.  For example, this <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage]</nowiki></tt> creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage]
---
> Named URL links allow anything within square brackets to be shown but link to something else.  For example, this <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage]</nowiki></tt> creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage].  And this one links to the [LocalWiki:WikiURLs#top top]
------
WikiURLs|1223354139
13c13
< Named URL links allow anything within square brackets to be shown but link to something else.  For example, this <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage]</nowiki></tt> creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage].  And this one links to the [LocalWiki:WikiURLs#top top]
---
> Named URL links allow anything within square brackets to be shown but link to something else.  For example, this <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage]</nowiki></tt> creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage].  And this one links to the [LocalWiki:#top top]
21c21
< Anchors are links within a given page.  Anchors must be specified using the syntax <tt><nowiki>[#anchor]</nowiki></tt>.  They can then be referenced by affixing them to any URL by using a hashmark '#' followed by the anchor like so <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage#anotheranchor Another Anchor]</nowiki></tt>.  This creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage#anotheranchor Another Anchor]
---
> Anchors are links within a given page.  Anchors must be specified using the syntax <tt><nowiki>[#anchor]</nowiki></tt>.  They can then be referenced by affixing them to any URL by using a hashmark '#' followed by the anchor like so <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage#anotheranchor Another Anchor]</nowiki></tt>.  This creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage#anotheranchor Another Anchor].   And this one links to the [LocalWiki:WikiURLs#top top].
------
MagicBlog|1223354208
1c1,4
< {{color: blue|fred}}
---
>  
> 
> 
>  [WikiURLs#top linked]
------
ReallyLongPage|1223362392
2c2
< == [#anchor] Demonstrating Anchors =
---
> == #anchor Demonstrating Anchors =
14c14
< == [#nextanchor] Demonstrating Anchors =
---
> == #nextanchor Demonstrating Anchors =
26c26
< === [#anotheranchor] Demonstrating Anchors =
---
> === #anotheranchor Demonstrating Anchors =
------
ReallyLongPage|1223363033
1,2c1
< {{toc}}
< == #anchor Demonstrating Anchors =
---
> = [#anchor] Demonstrating Anchors =
14,15c13,14
< == #nextanchor Demonstrating Anchors =
< The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#nextanchor] Demonstrating Anchors =</nowiki></tt>.
---
> == [#nextanchor] Demonstrating Anchors =
> The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#nextanchor]Demonstrating Anchors =</nowiki></tt>.
26,27c25,26
< === #anotheranchor Demonstrating Anchors =
< The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anotheranchor] Demonstrating Anchors =</nowiki></tt>.
---
> === [#anotheranchor] Demonstrating Anchors =
> The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anotheranchor]Demonstrating Anchors =</nowiki></tt>.
------
PageNotFound|1223365099
1c1
< = Page requested doesn't exist =
---
> == Page requested doesn't exist =
------
ReallyLongPage|1223610980
1,2c1,13
< = [#anchor] Demonstrating Anchors =
< Don't edit this page.  It's meant to demonstrate how named anchors work.  It's back link is from the WikiURLs page.  The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anchor] Demonstrating Anchors =</nowiki></tt>.
---
> = Anchors =
> Don't edit this page.  It's meant to demonstrate how named anchors work.  It's back link is from the WikiURLs page. Anchors are allowed in headers and also as standalone.  
> 
> ;Basic Syntax: All anchors are created using these square brackets, where the word 'anchor' is the name of the anchor.  The wiki engine will parse that bit of markup and make it available from any other page. 
> :<tt><nowiki>[#anchor]</nowiki></tt>
> 
> ;Header Anchors: Headers may also utilize anchors and the syntax is similar.  The headers that utilize anchors must be a level two or smaller, just like the one in the examples used above and below.  Level one headers [ H1 ] will not be parsed for anchors.
> :<tt><nowiki>== [#anchor] Header Text Goes Here =</nowiki></tt>
> :
> ;Tables of Content Anchors: If the <tt><nowiki>{{toc}}</nowiki></tt> command is used to create a TOC, the wiki engine will automatically generate anchors for each header equal to the name of the header text itself.
> 
> == [#anchor] Demonstrating Anchors =
> The anchor for this header, albeit hidden, is coded as <tt><nowiki>= [#anchor] Demonstrating Anchors =</nowiki></tt>.
------
WikiURLs|1223611254
10c10
< Plain URL links directly provide the hyperlink address using the standard HTML syntax. For example, this <tt><nowiki>http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage</nowiki></tt> creates http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage
---
> Plain URL links directly provide the hyperlink address using the standard HTML syntax. For example, this <tt><nowiki>http://wiki.kurcina.org/cgi-bin/index.cgi?WikiAnchors</nowiki></tt> creates http://wiki.kurcina.org/cgi-bin/index.cgi?WikiAnchors
13c13
< Named URL links allow anything within square brackets to be shown but link to something else.  For example, this <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage]</nowiki></tt> creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage ReallyLongPage].  And this one links to the [LocalWiki:#top top]
---
> Named URL links allow anything within square brackets to be shown but link to something else.  For example, this <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?WikiAnchors WikiAnchors]</nowiki></tt> creates [http://wiki.kurcina.org/cgi-bin/index.cgi?WikiAnchors WikiAnchors].  And this one links to the [LocalWiki:#top top]
21c21
< Anchors are links within a given page.  Anchors must be specified using the syntax <tt><nowiki>[#anchor]</nowiki></tt>.  They can then be referenced by affixing them to any URL by using a hashmark '#' followed by the anchor like so <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage#anotheranchor Another Anchor]</nowiki></tt>.  This creates [http://wiki.kurcina.org/cgi-bin/index.cgi?ReallyLongPage#anotheranchor Another Anchor].   And this one links to the [LocalWiki:WikiURLs#top top].
---
> Anchors are links within a given page.  Anchors must be specified using the syntax <tt><nowiki>[#anchor]</nowiki></tt>.  They can then be referenced by affixing them to any URL by using a hashmark '#' followed by the anchor like so <tt><nowiki>[http://wiki.kurcina.org/cgi-bin/index.cgi?WikiAnchors#anotheranchor Another Anchor]</nowiki></tt>.  This creates [http://wiki.kurcina.org/cgi-bin/index.cgi?WikiAnchors#anotheranchor Another Anchor].   And this one links to the [LocalWiki:WikiURLs#top top].
------
ImageGallery/ExampleGallery|1223640810
4,21c4,21
< thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip1
< thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip2
< thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip3
< thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip4
< thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip5
< thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip6
< thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip7
< thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip8
< thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip9
< thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip10
< thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip11
< thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip12
< thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip13
< thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip14
< thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=pity caption for tooltip15
< thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=pity caption for tooltip16
< thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=pity caption for tooltip17
< thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=pity caption for tooltip18
---
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=caption for tooltip1
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=caption for tooltip2
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=caption for tooltip3
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=caption for tooltip4
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=caption for tooltip5
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=caption for tooltip6
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=caption for tooltip7
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=caption for tooltip8
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=caption for tooltip9
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=caption for tooltip10
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=caption for tooltip11
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=caption for tooltip12
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=caption for tooltip13
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=caption for tooltip14
> thumb=ExampleGallery/thumb_image3.jpg|image=ExampleGallery/image3.jpg|title=caption for tooltip15
> thumb=ExampleGallery/thumb_image4.jpg|image=ExampleGallery/image4.jpg|title=caption for tooltip16
> thumb=ExampleGallery/thumb_image1.jpg|image=ExampleGallery/image1.jpg|title=caption for tooltip17
> thumb=ExampleGallery/thumb_image2.jpg|image=ExampleGallery/image2.jpg|title=caption for tooltip18
------
CategoryCategory|1223641707
2c2
< This is a list of categories created for the NobleWiki.  The WikiName''''s for the categories all begin with a <tt>Category</tt> prefix. The purpose of each category entry is to group related information.  Other prefixes are available, and can also be created in order to organize custom information. 
---
> This is a list of categories created for the NobleWiki.  The [WikiName WikiNames] for the categories all begin with a <tt>Category</tt> prefix. The purpose of each category entry is to group related information.  Other prefixes are available, and can also be created in order to organize custom information. 
------
NobleWiki|1223650312
94,95c94,97
< ||<tt><nowiki>{{section|WikiPage|header}}</nowiki></tt>||Non-recursively insert the section text for any page of the identified TOC header||
< ||<tt><nowiki>{{CSS|media|stylesheet}}</nowiki></tt>||Added at top of an editor's home-page to alter CSS used before rendering any wiki page.||
---
> ||<tt><nowiki>{{latex|events}}</nowiki></tt>|class=first||Create LaTex markup for support of scientific notation||
> ||<tt><nowiki>{{syntax|language}}</nowiki></tt>|class=first||Switch between the various markup languages.  Support Markdown, Creole.||
> ||<tt><nowiki>{{section|WikiPage|header}}</nowiki></tt>||Non-recursively transclude the section text for any page of the identified TOC header||
> ||<tt><nowiki>{{css|media|stylesheet}}</nowiki></tt>||Added at top of an editor's home-page to alter CSS used before rendering any wiki page.||
------
FlashSWF/ExampleDiceRoller|1223835605
1c1
< {{command: Flash name=FlashSWF/CDieD6.swf height=250 width=200}}
---
> {{magic: Flash name=FlashSWF/CDieD6.swf height=250 width=200}}
------
FlashSWF/ExampleDiceland|1223835632
1c1
< {{command: Flash name=FlashSWF/diceland.swf height=200 width=270}}
---
> {{magic: Flash name=FlashSWF/diceland.swf height=200 width=270}}
------
FlashSWF/ExampleTimeNow|1223835643
1c1
< {{command: Flash name=FlashSWF/TimeNow.swf height=200 width=270}}
---
> {{magic: Flash name=FlashSWF/TimeNow.swf height=200 width=270}}
------
HomePage|1223835655
1c1
< {{command: Discuss numbered=Y}}
---
> {{magic: Discuss numbered=Y}}
------
ListOfWantedPages|1223835675
1c1
< {{command: WantedPages threshold=0}}
---
> {{magic: WantedPages threshold=0}}
------
MagicAll|1223835686
1c1
< {{command: AllPages list=ol}}
---
> {{magic: AllPages list=ol}}
------
MagicCommands|1223835695
1c1
< {{command: @solo ListCommands}}
---
> {{magic: @solo ListCommands}}
------
MagicContent|1223835739
8c8
< {{command: Module key=value|key=value|key=value ...]}}
---
> {{magic: Module key=value|key=value|key=value ...]}}
14c14
< {{command: AllPages list=ol|position=top}}
---
> {{magic: AllPages list=ol|position=top}}
20c20
< The <tt>{{command}}</tt> directive may appear only once and as the first line of a wiki page. Only the first directive is processed; all of the others are ignored.  
---
> The <tt>{{magic}}</tt> directive may appear only once and as the first line of a wiki page. Only the first directive is processed; all of the others are ignored.  
------
MagicDiscussion|1223835752
3c3
< By adding the MagicContent command <tt>{{command: Discuss}}</tt> to a wiki page, a feedback form will appear that can be filled out by any user that has logged in with a userID.  Any feedback that has been received will be written into the filesystem under <tt><nowiki>$DiscussDir</nowiki></tt>.  The feedback form can be locked by either setting the <tt>locked=Y</tt> option for the command.
---
> By adding the MagicContent command <tt>{{magic: Discuss}}</tt> to a wiki page, a feedback form will appear that can be filled out by any user that has logged in with a userID.  Any feedback that has been received will be written into the filesystem under <tt><nowiki>$DiscussDir</nowiki></tt>.  The feedback form can be locked by either setting the <tt>locked=Y</tt> option for the command.
------
NobleWiki|1223835779
26c26
< ||Flash Object||Flash SWFs may be added using the <tt><nowiki>{{command: Flash}}</nowiki></tt> directive and module. See WikiFlash for more information.||
---
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki>{{magic: Flash}}</nowiki></tt> directive and module. See WikiFlash for more information.||
43c43
< ||Discuss Page||This is a work-in-progress.  Essentially add <tt><nowiki>{{command:  Discuss}}</nowiki></tt> in order to activate discussion form and feedback set for a page.  Deactivate form but leave feedback in place by adding parameter locked=true.||
---
> ||Discuss Page||This is a work-in-progress.  Essentially add <tt><nowiki>{{magic: Discuss}}</nowiki></tt> in order to activate discussion form and feedback set for a page.  Deactivate form but leave feedback in place by adding parameter locked=true.||
------
WikiFlash|1223835802
22c22
< If a SWF file is of importance or great curiosity, it should be placed upon a page by itself using the <tt><nowiki>{{command}}</nowiki></tt> directive.  As such, the page will not have a preview feature; it must be saved in order to render the results.  Here's an example of how the syntax would appear:
---
> If a SWF file is of importance or great curiosity, it should be placed upon a page by itself using the <tt><nowiki>{{magic}}</nowiki></tt> directive.  As such, the page will not have a preview feature; it must be saved in order to render the results.  Here's an example of how the syntax would appear:
25c25
<   {{command: Flash name=FlashSWF/diceland.swf height=300 width=200}}
---
>   {{magic: Flash name=FlashSWF/diceland.swf height=300 width=200}}
------
WikiCommands|1223836983
1c1,29
< [Describe the new page here]
---
> == Special Commands =
> WikiCommands are instructions to generate very specific behaviors within a page.  Most of these commands can be used multiple times within a page, but they all must appear on a line by themselves.  All commands are of the format:
> 
> <pre>
>  {{command}}
>  {{command:data}}
>  {{command:key=value|data}}
> </pre>
> 
> Where <tt>command</tt> is any of the following:
> 
> <pre>
>  block:
>  template
>  toc
>  flash
>  bbcode
>  data
>  gallery
>  code
>  subpages:
>  include
>  replace
>  redirect
>  delete}}
>  command
> </pre>
> 
> The opening and closing pairs of curly braces will need to wrapped around the command and any data that is provided.  Commands need to be placed on a line by themselves. 
------
WikiCommands|1223836996
25c25
<  delete}}
---
>  delete
29c29
< The opening and closing pairs of curly braces will need to wrapped around the command and any data that is provided.  Commands need to be placed on a line by themselves. 
---
> The opening and closing pairs of curly braces will need to wrapped around the command and any data that is provided.  Commands need to be placed on a line by themselves.
------
WikiCommands|1223837659
13d13
<  block:
18d17
<  data
21,23c20
<  subpages:
<  include
<  replace
---
>  subpages
26c23,27
<  command
---
>  magic
>  include  [ not yet tested]
>  replace  [ not yet tested]
>  data     [ not yet implemented ]
>  block    [ not yet implemented ]
------
WikiCommands|1223837669
------
RelatedEntries/WikiEditing|1223849349
3d2
<  WikiStyleGuide
4a4
>  WikiStyleGuide
15a16
>  WikiCommands
------
WikiCommands|1223849465
7a8
>  {{command:key=value|key=value|...key=value|data}}
------
WikiBugs|1223871452
15d14
< ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Auto-signature doesn't really store the editor's name.||OPEN||
------
NobleWiki|1223871493
21c21
< ||Auto Signature||Insert <tt><nowiki>~~~</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>$$$$</nowiki></tt> to append timestamp.||
---
> ||Auto Signature||Insert <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] ]</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] at 2008.10.12 21:18 ]</nowiki></tt> to append timestamp.||
------
WikiBugs|1223873444
16a17
> ||2008.10.12||[HomePage/RobertKurcina RobertKurcina]||Seems that the rename pages doesn't catch all variations of links.  esp. sub-pages.||OPEN||
------
JavaScript|1224648009
5,7c5,7
< * jQuery - the base-line scripting library that allows for cross-platform/cross-browser support.
< * UFO - Unobtrusive Flash Object; allows embedding of Flash SWFs and graceful error notification in case the Flash player version is wrong.
< * <nowiki>LightBox</nowiki> - Allows for the behavior of the ImageGallery.
---
> ;jQuery:the base-line scripting library that allows for cross-platform/cross-browser support.
> ;UFO - Unobtrusive Flash Object:allows embedding of Flash SWFs and graceful error notification in case the Flash player version is wrong.
> ;<nowiki>LightBox</nowiki>:Allows for the behavior of the ImageGallery.
------
VisitorRole|1224661831
3c3
< Visitors are extremely important to any wiki's vitality; visitors read the pages and many get inspired to contribute.  Some visitors are BadPeople but most are extremely helpful, curious people.
---
> Visitors are extremely important to any wiki's vitality; visitors read the pages and many get inspired to contribute.  Some visitors are [[BadPeople]] but most are extremely helpful, curious people.
------
VisitorRole|1224661998
3c2
< Visitors are extremely important to any wiki's vitality; visitors read the pages and many get inspired to contribute.  Some visitors are [[BadPeople]] but most are extremely helpful, curious people.
---
> Visitors are extremely important to any wiki's vitality; visitors read the pages and many get inspired to contribute.  Some visitors are BadPeople but most are extremely helpful, curious people.
------
VisitorRole|1224662590
------
SandBox|1225862191
1c1
< {{redirect:MagicBlog}}
---
> No longer here
------
SandBox|1225862513
1c1
< No longer here
---
> No longer here yo.
------
SandBox|1225864055
1c1
< No longer here yo.
---
> What
------
SandBox|1225864176
1c1
< What
---
> What to
------
SandBox|1225866509
1c1
< What to
---
> What to where
------
SandBox|1225867087
1c1
< What to where
---
> == Add your content here =
------
SandBox|1225867154
1c1
< == Add your content here =
---
> what
------
SandBox|1225868576
1c1
< what
---
> what1
------
SandBox|1225868749
1c1
< what1
---
> what11
------
SandBox|1225868775
1c1
< what11
---
> what112
------
SandBox|1225868983
1c1
< what112
---
> what1123
------
SandBox|1225870359
1c1
< what1123
---
> what4
------
SandBox|1225870378
1c1
< what4
---
> what5
------
SandBox|1225870399
1c1
< what5
---
> what3
------
SandBox|1225870413
1c1
< what3
---
> what2
------
SandBox|1225870603
1c1
< what2
---
> what23
------
SandBox|1225870724
1c1
< what23
---
> what2333
------
SandBox|1225870742
1c1
< what2333
---
> what23332
------
SandBox|1225895839
1c1
< what23332
---
> {{redirect:MagicBlog}}
------
PrivateUserGroups|1225900814
8c8,10
< <tt><nowiki>{e:JohnDoe}</nowiki></tt>
---
> <pre>
> {e:JohnDoe}
> </pre>
16,17c17,20
< <tt><nowiki>{e:JohnDoe}</nowiki></tt>
< <tt><nowiki>{e:JaneSmith}</nowiki></tt>
---
> <pre>
> {e:JohnDoe}
> {e:JaneSmith}
> </pre>
25c27,29
< <tt><nowiki>{r:JaneSmith}</nowiki></tt>
---
> <pre>
> {r:JaneSmith}
> </pre>
33,34c36,39
< <tt><nowiki>{e:JohnDoe}</nowiki></tt>
< <tt><nowiki>{r:JaneSmith}</nowiki></tt>
---
> <pre>
> {e:JohnDoe}
> {r:JaneSmith}
> </pre>
------
AuthError|1225949722
1c1,3
< {{delete}}
---
> == Authorization Error =
> 
> You don't have permissions to view the page you've requested; it belongs to a PrivateUserGroup.
------
AuthError|1225950091
3c3
< You don't have permissions to view the page you've requested; it belongs to a PrivateUserGroup.
---
> You don't have permissions to view the page you've requested; it belongs to a [PrivateUserGroups Private User Group].
------
NobleWiki|1225951340
26d26
< ||Flash Object||Flash SWFs may be added using the <tt><nowiki>{{magic: Flash}}</nowiki></tt> directive and module. See WikiFlash for more information.||
------
NobleWiki|1225951382
26a26
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki>{{magic: Flash}}</nowiki></tt> directive and module. See WikiFlash for more information.||
------
NobleWiki|1225951400
26c26
< ||Flash Object||Flash SWFs may be added using the <tt><nowiki>{{magic: Flash}}</nowiki></tt> directive and module. See WikiFlash for more information.||
---
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki></nowiki></tt> directive and module. See WikiFlash for more information.||
------
WikiDelete|1225952453
1c1
< ||DELETED|style=color:red;font-size:14pt;padding:10px;font-weight:bold;||
---
> ||DELETED|style=color:white;background-color:red;font-size:14pt;padding:10px;font-weight:bold;||
------
WikiDelete|1225952489
1c1
< ||DELETED|style=color:white;background-color:red;font-size:14pt;padding:10px;font-weight:bold;||
---
> ||DELETED|style=color:white;background-color:red;font-size:18pt;padding:10px;font-weight:bold;||
------
SandBox|1225988283
1d0
< {{redirect:MagicBlog}}
2a2
> 
------
WikiCommands|1226030123
17a18
>  block
------
WikiCommands|1226030291
28d27
<  block    [ not yet implemented ]
------
SandBox|1226034068
0a1
> {{box:alert|title=Something Grand|message=November rules}}
2d2
< 
------
MessageBox|1226075623
1c1,12
< [Describe the new page here]
---
> {{box:error|title=Something Grand}}
> {{box:alert|title=Something Grand}}
> {{box:warn|title=Something Grand}}
> {{box:info|title=Something Grand}}
> 
> {{box:update|title=Something Grand}}
> {{box:todo|title=Something Grand}}
> {{box:delete|title=Something Grand}}
> 
> {{box:lock|title=Something Grand}}
> {{box:ready|title=Something Grand}}
> {{box:reject|title=Something Grand}}
------
MessageBox|1226117081
11,12c11,12
< {{box:ready|title=Something Grand}}
< {{box:reject|title=Something Grand}}
---
> {{box:yes|title=Something Grand}}
> {{box:no|title=Something Grand}}
------
WikiCommands|1226125620
17a18
>  box
------
WikiDelete|1226125845
1,2c1
< ||DELETED|style=color:white;background-color:red;font-size:18pt;padding:10px;font-weight:bold;||
< This page is scheduled for deletion.
---
> {{box:delete|title=Deleted!|message=This page has been scheduled for deletion.}}
------
WikiCommands|1226126597
13,29c13,27
< <pre>
<  template
<  toc
<  flash
<  bbcode
<  box
<  block
<  gallery
<  code
<  subpages
<  redirect
<  delete
<  magic
<  include  [ not yet tested]
<  replace  [ not yet tested]
<  data     [ not yet implemented ]
< </pre>
---
>  [LocalWiki:search={{template template]
>  [LocalWiki:search={{toc toc]
>  [LocalWiki:search={{flash flash]
>  [LocalWiki:search={{bbcode bbcode ]
>  [LocalWiki:search={{box box]
>  [LocalWiki:search={{block block]
>  [LocalWiki:search={{gallery gallery]
>  [LocalWiki:search={{code code]
>  [LocalWiki:search={{subpages subpages]
>  [LocalWiki:search={{redirect redirect]
>  [LocalWiki:search={{delete delete]
>  [LocalWiki:search={{magic magic]
>  [LocalWiki:search={{include include]  [ not yet tested]
>  [LocalWiki:search={{replace replace] [ not yet tested]
>  [LocalWiki:search={{data data]   [ not yet implemented ]
------
NobleWiki|1226128615
49a49,50
> ||Message Boxes||Introduced custom coloring with <tt><nowiki>{{box:type|message=value}}</nowiki></tt> where type is one of error, alert, warn, info, update, todo, yes, no, delete, or lock. See MessageBox for more information. ||
> 
------
MessageBox|1226131706
1,12c1,25
< {{box:error|title=Something Grand}}
< {{box:alert|title=Something Grand}}
< {{box:warn|title=Something Grand}}
< {{box:info|title=Something Grand}}
< 
< {{box:update|title=Something Grand}}
< {{box:todo|title=Something Grand}}
< {{box:delete|title=Something Grand}}
< 
< {{box:lock|title=Something Grand}}
< {{box:yes|title=Something Grand}}
< {{box:no|title=Something Grand}}
---
> == Message Boxes =
> [MessageBox MessageBoxes] are a sort of WikiCommands.  Similiar to other commands allowed in NobleWiki, it follows one of these two syntax patterns:
> 
> <pre>
> {{box:type|message=value}}
> {{box:type|title=value|message=value}}
> </pre>
> 
> The type corresponds to one of the following as shown in the table below.  As can be seen, the icon and field color is dependent on the type. THe only require value is for the message.  If the title is left empty, the wiki will pre-populate the value. 
> 
> !!Notification Types|width=125!!Syntax|width=400!!Example!!
> ||Alert[#alert]||<pre>{{box:alert|message=This page requires revision.}}</pre>||{{box:alert|message=This page requires revision.}}||
> ||Warning[#warning]||<pre>{{box:warn|message=Please be careful.}}</pre>||{{box:warn|message=Please be careful.}}||
> ||Information||<pre>{{box:info|message=More details below...}}</pre>||{{box:info|message=More details below...}}||
> ||Update||<pre>{{box:update|message=Something Grand}}</pre>||{{box:update|message=Something Grand}}||
> 
> !!Reserved Types|width=125!!Syntax|width=400!!Example!!
> ||Error||<pre>{{box:error|message=Something is wrong with this page.}}</pre>||{{box:error|message=Something is wrong with this page.}}||
> ||Locked Page||<pre>{{box:lock|message=This page is locked.}}</pre>||{{box:lock|message=This page is locked.}}||
> ||Deleted Page||<pre>{{box:delete|message=This page is scheduled for deletion...}}</pre>||{{box:delete|message=This page is scheduled for deletion...}}||
> 
> !!Status Types|width=125!!Syntax|width=400!!Example!!
> ||TODO||<pre>{{box:todo|message=Page under construction...}}</pre>||{{box:todo|message=Page under construction...}}||
> ||Yes||<pre>{{box:yes|message=Content has been approved.}}</pre>||{{box:yes|message=SContent has been approved.}}||
> ||No||<pre>{{box:no|message=Content has been rejected.}}</pre>||{{box:no|message=Content has been rejected.}}||
------
NobleWiki|1226132421
50a50,55
> ||Source View||When a page is locked for Guests, the Edit feature will display a READONLY textarea.||
> ||Dynamic GotoBar||The GotoBar for users and admins have been consolidated.  By default only the top bar will show, but the Preferences section will allow a bottom one to appear.  The elements of the bars will dynamically enable or disable according to the page or action being viewed.||
> ||Dynamic Navigation Menu||The left-navigation incorporates user and admin options, and like the GotoBar will enable or disable the items.||
> ||System Info||The [LocalWiki:action=version action=version] page has been expanded with verbose but static information.||
> ||Page Creation Prompt||The <tt><nowiki>PageNotFound</nowiki></tt> result will now prompt the user to create a new page if their search request involved a legitimate page name as qualified by the <tt><nowiki>$LinkPattern</nowiki></tt> variable in the wiki code.||
> 
------
NobleWiki|1226132495
51,52c51,52
< ||Dynamic GotoBar||The GotoBar for users and admins have been consolidated.  By default only the top bar will show, but the Preferences section will allow a bottom one to appear.  The elements of the bars will dynamically enable or disable according to the page or action being viewed.||
< ||Dynamic Navigation Menu||The left-navigation incorporates user and admin options, and like the GotoBar will enable or disable the items.||
---
> ||<tt><nowiki>Dynamic GotoBar</nowiki></tt>||The <tt><nowiki>GotoBar</nowiki></tt>for users and admins have been consolidated.  By default only the top bar will show, but the Preferences section will allow a bottom one to appear.  The elements of the bars will dynamically enable or disable according to the page or action being viewed.||
> ||Dynamic Navigation Menu||The left-navigation incorporates user and admin options, and like the <tt><nowiki>GotoBar</nowiki></tt>will enable or disable the items.||
------
NobleWiki|1226132675
55a55,57
> ||Description Text||Descriptions for a page can be created while editing the wikitext for it.  These will display for search results.||
> ||Formatted Search Results||Search results will display in two columns if a custom threshold of results found is exceeded.||
> 
------
NobleWiki|1226133435
9,11c9,11
< This version of the <nowiki>UseMod</nowiki>wiki engine is highly customized, and adds the following features not available in the standard wiki.pl. 
< 
< !!Difference&nbsp;Things!!Description!!
---
> This version of the <nowiki>UseMod</nowiki>wiki engine is highly customized, and adds the following features not available in the standard UseMod:wiki.pl. 
> 
> !!Major&nbsp;Things|width=300!!Description!!
13d12
< ||Naming Filter||Provide multiple keywords with or with negated terms to filter the names returned from <tt>backlinks</tt>, <tt>search</tt>, or the asset management interface.||
17d15
< ||Edit Box||The edit box and other textareas are always 100% width in every browser implementation.||
19,23d16
< ||Lock-out Indicators||Added small symbols to allow quick access to editing a page from the title, and symbols to indicate that a page is locked.  <tt>'&not;'</tt> is that symbol prefixed to a locked page.||
< ||Title attribute||Added a title attribute to all links where possible||
< ||Auto Signature||Insert <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] ]</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] at 2008.10.12 21:18 ]</nowiki></tt> to append timestamp.||
< ||Bracketed Image URLs with options||<tt><nowiki>[URL upload:image|<options>]</nowiki></tt> There's a number of options available now for images including title, description, boxclear, boxwidth, boxfloat, float, and clear.  The last are for images within a caption box if description is provided.  If description is provided but not title, then the title will show "FIGURE X" where X is computed as the current number of un-titled images||
< ||Left Navigation||Created 2-column layout with left navigation. Subroutine added <tt><nowiki>GetLeftNav()</nowiki></tt>.||
25d17
< ||Table Sorting||Added jQuery Tablesorter 2.0 to engage any table created properly.  See WikiTables for more information.||
31,35d22
< ||index.cgi||The wiki.pl script has been renamed.||
< ||Cancel button|class=first||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
< ||IE6 textarea||Added <tt><nowiki><div style='width:100%;'>...</div></nowiki></tt> around the textarea in <tt><nowiki>sub GetTextArea {}</nowiki></tt> to enable 100% width in IE6||
< ||Recent Changes||Instead of <tt>$FS3</tt> to split the recent changes log, use <tt>\W</tt>.  For example <tt>($ts) = split( /\W/, $fullrc[$i] );</tt>.  Seems to work better for WIN32.||
< ||Page Lock Icon||Added a small icon to the right of the page title to show that a page is locked or editable.||
37,42d23
< ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] may be assigned a pixel width parameter as in <tt><nowiki>{{toc NNN}}</nowiki></tt>||
< ||Expanded Config||Added a number of configuration variables.||
< ||Windows Config||Set <tt><nowiki>$Windows = 1</nowiki></tt> to remove CGITemp files after uploading assets.||
< ||Print Link List||Updated this presentation to have a table.  Any non-existent pages identified will show with the 'Create this entry' icon.||
< ||Disabled regex Search||A checkbox near the search form when marked will disable the default search mechanism that allows search terms to be interpreted as regex values.||
< ||Disable regex back-links||The <tt><nowiki>DoBackLinks</nowiki></tt> subroutine no longer uses search terms as regular expressions.||
57a39,58
> !!Minor&nbsp;Things|width=300!!Description!!
> ||Cancel button|class=first||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
> ||Print Link List||Updated this presentation to have a table.  Any non-existent pages identified will show with the 'Create this entry' icon.||
> ||Recent Changes||Instead of <tt>$FS3</tt> to split the recent changes log, use <tt>\W</tt>.  For example <tt>($ts) = split( /\W/, $fullrc[$i] );</tt>.  Seems to work better for WIN32.||
> ||Page Lock Icon||Added a small icon to the right of the page title to show that a page is locked or editable.||
> ||index.cgi||The wiki.pl script has been renamed.||
> ||IE6 textarea||Added <tt><nowiki><div style='width:100%;'>...</div></nowiki></tt> around the textarea in <tt><nowiki>sub GetTextArea {}</nowiki></tt> to enable 100% width in IE6||
> ||Table Sorting||Added jQuery Tablesorter 2.0 to engage any table created properly.  See WikiTables for more information.||
> ||Disabled regex Search||A checkbox near the search form when marked will disable the default search mechanism that allows search terms to be interpreted as regex values.||
> ||Disable regex back-links||The <tt><nowiki>DoBackLinks</nowiki></tt> subroutine no longer uses search terms as regular expressions.||
> ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] may be assigned a pixel width parameter as in <tt><nowiki>{{toc NNN}}</nowiki></tt>||
> ||Expanded Config||Added a number of configuration variables.||
> ||Windows Config||Set <tt><nowiki>$Windows = 1</nowiki></tt> to remove CGITemp files after uploading assets.||
> ||Title attribute||Added a title attribute to all links where possible||
> ||Auto Signature||Insert <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] ]</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] at 2008.10.12 21:18 ]</nowiki></tt> to append timestamp.||
> ||Bracketed Image URLs with options||<tt><nowiki>[URL upload:image|<options>]</nowiki></tt> There's a number of options available now for images including title, description, boxclear, boxwidth, boxfloat, float, and clear.  The last are for images within a caption box if description is provided.  If description is provided but not title, then the title will show "FIGURE X" where X is computed as the current number of un-titled images||
> ||Edit Box||The edit box and other textareas are always 100% width in every browser implementation.||
> ||Lock-out Indicators||Added small symbols to allow quick access to editing a page from the title, and symbols to indicate that a page is locked.  <tt>'&not;'</tt> is that symbol prefixed to a locked page.||
> ||Naming Filter||Provide multiple keywords with or with negated terms to filter the names returned from <tt>backlinks</tt>, <tt>search</tt>, or the asset management interface.||
> 
84,85c85,86
< !!Patches Under Consideration!!Description!!
< ||UseMod:WikiPatches/EmbeddedBacklinks|class=first|width=300||want||
---
> !!Patches Under Consideration|width=300!!Description!!
> ||UseMod:WikiPatches/EmbeddedBacklinks|class=first||This should be made an option in the preferences to show all LINKS IN and LINKS OUT of a currently viewed page; perhaps placed at the bottom or top as a matter of choice.||
87c88,89
< ||UseMod:WikiPatches/SurgeProtector||want, unsure if useful||
---
> ||UseMod:WikiPatches/SurgeProtector||hould make it more difficult for spam submission.||
> ||MeatBall:EditHash||Should make it more difficult for spam submission.||
92c94
< !!Broken Things!!Description!!
---
> !!Broken Things|width=300!!Description!!
100c102
< !!Features Planned!!Description!!
---
> !!Features Planned|width=300!!Description!!
117c119
< !!Features Planned|width=200!!Description!!
---
> !!Features Planned|width=300!!Description!!
------
NobleWiki|1226134281
102c102
< !!Features Planned|width=300!!Description!!
---
> !!New Commands Planned|width=300!!Description!!
115a115,118
> ||<tt><nowiki>{{widget|type}}</nowiki></tt>||Wdigets will be pre-defined as right-hand elements for a HomePage view; calendar, blog roll, rss feeds, tag cloud, favorites, etc.||
> ||<tt><nowiki>{{embed|type||</nowiki></tt>||This is a generalized way to embed applets for java, flash, Quicktime, Windows Media Player, etc.||
> ||<tt><nowiki>{{category|names}}</nowiki></tt>||Using a category tag should do two things; create an entry in the appropriate category page, and create a list of pages in place.||
> 
125a129,132
> ||Namespaces||This would create separate directories for sets of pages that will not be searched/indexed unless explicitly invoked.||
> ||<nowiki>WikiFarm</nowiki>||This will create a separate set of directories for each wiki instance, to include data and configuration files.  The idea is to have single CGI script but allow multiple wiki sites without having to modify the HTTPd configuration files.||
> ||Authentication||The existing UseMod:UseMod system for user management doesn't really support roles, groups, and management of page collections.  By enhancing this feature the NobleWiki engine becomes more realistic as an option for use by others.||
> 
------
WikiCommands|1226134384
18c18
<  [LocalWiki:search={{block block]
---
>  [LocalWiki:search={{color color]
------
NobleWiki|1226134481
29c29
< ||Block Colors||Introduced custom coloring with <tt><nowiki>{{block:key=value|key=value|..}}</nowiki></tt> where key is bgcolor, color, or padding [in pixels].  bgcolor and color accept and standard CSS color names.||
---
> ||Block Colors||Introduced custom coloring with <tt><nowiki>{{color:key=value|key=value|..}}</nowiki></tt> where key is bgcolor, color, or padding [in pixels].  bgcolor and color accept standard CSS color names.||
------
NobleWiki|1226134553
116c116
< ||<tt><nowiki>{{embed|type||</nowiki></tt>||This is a generalized way to embed applets for java, flash, Quicktime, Windows Media Player, etc.||
---
> ||<tt><nowiki>{{embed|type</nowiki></tt>||This is a generalized way to embed applets for java, flash, Quicktime, Windows Media Player, etc.||
------
BulletinBoardCode|1226175391
29a31,33
> == Using BBCode via Feedback Forms =
> If BBCode is used via the feedback forms for MagicDiscussion or MagicBlog entries, the <tt><nowiki>{{bbcode:}}</nowiki></tt> wrappers are not needed.  Use the available BBCode exactly as seen in the examples below in a form and NobleWiki will parse them correctly.
> 
------
HtmlEntities|1226198337
1c1,4
< [Describe the new page here]
---
> == HTML Entities Reference =
> 
> Here are selected HTML Entities that can be used when creating a WikiPage.  More definitions can be found at [http://htmlhelp.com/reference/html40/entities/ WDC].
> .
------
HtmlEntities|1226198973
4c5,228
< .
---
> !!Common Symbol|width=300!!Code!!Result!!
> ||no-break space = non-breaking space  ||&nbsp;  ||
> ||inverted exclamation mark ||&iexcl; ||
> ||cent sign ||&cent; ||
> ||pound sign ||&pound; ||
> ||currency sign ||&curren; ||
> ||yen sign = yuan sign ||&yen; ||
> ||broken bar = broken vertical bar ||&brvbar; ||
> ||section sign ||&sect; ||
> ||diaeresis = spacing diaeresis ||&uml; ||
> ||copyright sign ||&copy; ||
> ||feminine ordinal indicator ||&ordf; ||
> ||left-pointing double angle quotation mark = left pointing guillemet ||&laquo; ||
> ||not sign ||&not; ||
> ||soft hyphen = discretionary hyphen ||&shy; ||
> ||registered sign = registered trade mark sign ||&reg; ||
> ||macron = spacing macron = overline = APL overbar ||&macr; ||
> ||degree sign ||&deg; ||
> ||plus-minus sign = plus-or-minus sign ||&plusmn; ||
> ||superscript two = superscript digit two = squared ||&sup2; ||
> ||superscript three = superscript digit three = cubed ||&sup3; ||
> ||acute accent = spacing acute ||&acute; ||
> ||micro sign ||&micro; ||
> ||pilcrow sign = paragraph sign ||&para; ||
> ||middle dot = Georgian comma = Greek middle dot ||&middot; ||
> ||cedilla = spacing cedilla ||&cedil; ||
> ||superscript one = superscript digit one ||&sup1; ||
> ||masculine ordinal indicator ||&ordm; ||
> ||right-pointing double angle quotation mark = right pointing guillemet ||&raquo; ||
> ||ulgar fraction one quarter = fraction one quarter ||&frac14; ||
> ||vulgar fraction one half = fraction one half ||&frac12; ||
> ||vulgar fraction three quarters = fraction three quarters ||&frac34; ||
> ||inverted question mark = turned question mark ||&iquest; ||
> ||Latin capital letter A with grave = ||Latin capital letter A grave ||&Agrave; ||
> ||Latin capital letter A with acute ||&Aacute; ||
> ||Latin capital letter A with circumflex ||&Acirc; ||
> ||Latin capital letter A with tilde ||&Atilde; ||
> ||Latin capital letter A with diaeresis ||&Auml; ||
> ||Latin capital letter A with ring above = ||Latin capital letter A ring ||&Aring; ||
> ||Latin capital letter AE = ||Latin capital ligature AE ||&AElig; ||
> ||Latin capital letter C with cedilla ||&Ccedil; ||
> ||Latin capital letter E with grave ||&Egrave; ||
> ||Latin capital letter E with acute ||&Eacute; ||
> ||Latin capital letter E with circumflex ||&Ecirc; ||
> ||Latin capital letter E with diaeresis ||&Euml; ||
> ||Latin capital letter I with grave ||&Igrave; ||
> ||Latin capital letter I with acute ||&Iacute; ||
> ||Latin capital letter I with circumflex ||&Icirc; ||
> ||Latin capital letter I with diaeresis ||&Iuml; ||
> ||Latin capital letter ETH ||&ETH; ||
> ||Latin capital letter N with tilde ||&Ntilde; ||
> ||Latin capital letter O with grave ||&Ograve; ||
> ||Latin capital letter O with acute ||&Oacute; ||
> ||Latin capital letter O with circumflex ||&Ocirc; ||
> ||Latin capital letter O with tilde ||&Otilde; ||
> ||Latin capital letter O with diaeresis ||&Ouml; ||
> ||multiplication sign ||&times; ||
> ||Latin capital letter O slash ||&Oslash; ||
> ||Latin capital letter U with grave ||&Ugrave; ||
> ||Latin capital letter U with acute ||&Uacute; ||
> ||Latin capital letter U with circumflex ||&Ucirc; ||
> ||Latin capital letter U with diaeresis ||&Uuml; ||
> ||Latin capital letter Y with acute ||&Yacute; ||
> ||Latin capital letter THORN ||&THORN; ||
> ||Latin small letter sharp s = ess-zed ||&szlig; ||
> ||Latin small letter a with grave = ||Latin small letter a grave ||&agrave; ||
> ||Latin small letter a with acute ||&aacute; ||
> ||Latin small letter a with circumflex ||&acirc; ||
> ||Latin small letter a with tilde ||&atilde; ||
> ||Latin small letter a with diaeresis ||&auml; ||
> ||Latin small letter a with ring above = ||Latin small letter a ring ||&aring; ||
> ||Latin small letter ae = ||Latin small ligature ae ||&aelig; ||
> ||Latin small letter c with cedilla ||&ccedil; ||
> ||Latin small letter e with grave ||&egrave; ||
> ||Latin small letter e with acute ||&eacute; ||
> ||Latin small letter e with circumflex ||&ecirc; ||
> ||Latin small letter e with diaeresis ||&euml; ||
> ||Latin small letter i with grave ||&igrave; ||
> ||Latin small letter i with acute ||&iacute; ||
> ||Latin small letter i with circumflex ||&icirc; ||
> ||Latin small letter i with diaeresis ||&iuml; ||
> ||Latin small letter eth ||&eth; ||
> ||Latin small letter n with tilde ||&ntilde; ||
> ||Latin small letter o with grave ||&ograve; ||
> ||Latin small letter o with acute ||&oacute; ||
> ||Latin small letter o with circumflex ||&ocirc; ||
> ||Latin small letter o with tilde ||&otilde; ||
> ||Latin small letter o with diaeresis ||&ouml; ||
> ||division sign ||&divide; ||
> ||Latin small letter o with stroke = ||Latin small letter o slash ||&oslash; ||
> ||Latin small letter u with grave ||&ugrave; ||
> ||Latin small letter u with acute ||&uacute; ||
> ||Latin small letter u with circumflex ||&ucirc; ||
> ||Latin small letter u with diaeresis ||&uuml; ||
> ||Latin small letter y with acute ||&yacute; ||
> ||Latin small letter thorn ||&thorn; ||
> ||Latin small letter y with diaeresis ||&yuml; ||
> ||dagger  ||&dagger;  ||
> ||double dagger ||&Dagger; ||
> ||per mille sign ||&permil; ||
> ||Latin small f with hook = function = florin  ||&fnof;  ||
> ||Greek capital letter alpha ||&Alpha; ||
> ||Greek capital letter beta ||&Beta; ||
> ||Greek capital letter gamma ||&Gamma; ||
> ||Greek capital letter delta ||&Delta; ||
> ||Greek capital letter epsilon ||&Epsilon; ||
> ||Greek capital letter zeta ||&Zeta; ||
> ||Greek capital letter eta ||&Eta; ||
> ||Greek capital letter theta ||&Theta; ||
> ||Greek capital letter iota ||&Iota; ||
> ||Greek capital letter kappa ||&Kappa; ||
> ||Greek capital letter lambda ||&Lambda; ||
> ||Greek capital letter mu ||&Mu; ||
> ||Greek capital letter nu ||&Nu; ||
> ||Greek capital letter xi ||&Xi; ||
> ||Greek capital letter omicron ||&Omicron; ||
> ||Greek capital letter pi ||&Pi; ||
> ||Greek capital letter rho ||&Rho; ||
> ||Greek capital letter sigma ||&Sigma; ||
> ||Greek capital letter tau ||&Tau; ||
> ||Greek capital letter upsilon ||&Upsilon; ||
> ||Greek capital letter phi ||&Phi; ||
> ||Greek capital letter chi ||&Chi; ||
> ||Greek capital letter psi ||&Psi; ||
> ||Greek capital letter omega ||&Omega; ||
> ||Greek small letter alpha ||&alpha; ||
> ||Greek small letter beta ||&beta; ||
> ||Greek small letter gamma ||&gamma; ||
> ||Greek small letter delta ||&delta; ||
> ||Greek small letter epsilon ||&epsilon; ||
> ||Greek small letter zeta ||&zeta; ||
> ||Greek small letter eta ||&eta; ||
> ||Greek small letter theta ||&theta; ||
> ||Greek small letter iota ||&iota; ||
> ||Greek small letter kappa ||&kappa; ||
> ||Greek small letter lambda ||&lambda; ||
> ||Greek small letter mu ||&mu; ||
> ||Greek small letter nu ||&nu; ||
> ||Greek small letter xi ||&xi; ||
> ||Greek small letter omicron ||&omicron; ||
> ||Greek small letter pi ||&pi; ||
> ||Greek small letter rho ||&rho; ||
> ||Greek small letter final sigma ||&sigmaf; ||
> ||Greek small letter sigma ||&sigma; ||
> ||Greek small letter tau ||&tau; ||
> ||Greek small letter upsilon ||&upsilon; ||
> ||Greek small letter phi ||&phi; ||
> ||Greek small letter chi ||&chi; ||
> ||Greek small letter psi ||&psi; ||
> ||Greek small letter omega ||&omega; ||
> ||Greek small letter theta symbol ||&thetasym; ||
> ||Greek upsilon with hook symbol ||&upsih; ||
> ||Greek pi symbol ||&piv; ||
> ||bullet = black small circle ||&bull; ||
> ||horizontal ellipsis = three dot leader ||&hellip; ||
> ||prime = minutes = feet ||&prime; ||
> ||double prime = seconds = inches ||&Prime; ||
> ||overline = spacing overscore ||&oline; ||
> ||fraction slash ||&frasl; ||
> ||script capital P = power set = Weierstrass p ||&weierp; ||
> ||blackletter capital I = imaginary part ||&image; ||
> ||blackletter capital R = real part symbol ||&real; ||
> ||trade mark sign ||&trade; ||
> ||alef symbol = first transfinite cardinal ||&alefsym; ||
> ||leftwards arrow ||&larr; ||
> ||upwards arrow ||&uarr; ||
> ||rightwards arrow ||&rarr; ||
> ||downwards arrow ||&darr; ||
> ||left right arrow ||&harr; ||
> ||downwards arrow with corner leftwards = carriage return ||&crarr; ||
> ||leftwards double arrow ||&lArr; ||
> ||upwards double arrow ||&uArr; ||
> ||rightwards double arrow ||&rArr; ||
> ||downwards double arrow ||&dArr; ||
> ||left right double arrow ||&hArr; ||
> ||for all ||&forall; ||
> ||partial differential ||&part; ||
> ||there exists ||&exist; ||
> ||empty set = null set = diameter ||&empty; ||
> ||nabla = backward difference ||&nabla; ||
> ||element of ||&isin; ||
> ||not an element of ||&notin; ||
> ||contains as member ||&ni; ||
> ||n-ary product = product sign ||&prod; ||
> ||n-ary sumation ||&sum; ||
> ||minus sign ||&minus; ||
> ||asterisk operator ||&lowast; ||
> ||square root = radical sign ||&radic; ||
> ||proportional to ||&prop; ||
> ||infinity ||&infin; ||
> ||angle ||&ang; ||
> ||logical and = wedge ||&and; ||
> ||logical or = vee ||&or; ||
> ||intersection = cap ||&cap; ||
> ||union = cup ||&cup; ||
> ||integral ||&int; ||
> ||therefore ||&there4; ||
> ||tilde operator = varies with = similar to ||&sim; ||
> ||approximately equal to ||&cong; ||
> ||almost equal to = asymptotic to ||&asymp; ||
> ||not equal to ||&ne; ||
> ||identical to ||&equiv; ||
> ||less-than or equal to ||&le; ||
> ||Greater-than or equal to ||&ge; ||
> ||subset of ||&sub; ||
> ||superset of ||&sup; ||
> ||not a subset of ||&nsub; ||
> ||subset of or equal to ||&sube; ||
> ||superset of or equal to ||&supe; ||
> ||circled plus = direct sum ||&oplus; ||
> ||circled times = vector product ||&otimes; ||
> ||up tack = orthogonal to = perpendicular ||&perp; ||
> ||dot operator ||&sdot; ||
> ||left ceiling = APL upstile ||&lceil; ||
> ||right ceiling ||&rceil; ||
> ||left floor = APL downstile ||&lfloor; ||
> ||right floor ||&rfloor; ||
> ||left-pointing angle bracket = bra ||&lang; ||
> ||right-pointing angle bracket = ket ||&rang; ||
> ||lozenge ||&loz; ||
> ||black spade suit ||&spades; ||
> ||black club suit = shamrock ||&clubs; ||
> ||black heart suit = valentine ||&hearts; ||
> ||black diamond suit ||&diams; ||
------
HtmlEntities|1226199135
38c38
< ||Latin capital letter A with grave = ||Latin capital letter A grave ||&Agrave; ||
---
> ||Latin capital letter A grave ||&Agrave; ||
43,44c43,44
< ||Latin capital letter A with ring above = ||Latin capital letter A ring ||&Aring; ||
< ||Latin capital letter AE = ||Latin capital ligature AE ||&AElig; ||
---
> ||Latin capital letter A ring ||&Aring; ||
> ||Latin capital ligature AE ||&AElig; ||
94c94
< ||Latin small letter o with stroke = ||Latin small letter o slash ||&oslash; ||
---
> ||Latin small letter o slash ||&oslash; ||
222,223d221
< ||left-pointing angle bracket = bra ||&lang; ||
< ||right-pointing angle bracket = ket ||&rang; ||
------
HtmlEntities|1226202215
3,226c3,62
< Here are selected HTML Entities that can be used when creating a WikiPage.  More definitions can be found at [http://htmlhelp.com/reference/html40/entities/ WDC].
< 
< !!Common Symbol|width=300!!Code!!Result!!
< ||no-break space = non-breaking space  ||&nbsp;  ||
< ||inverted exclamation mark ||&iexcl; ||
< ||cent sign ||&cent; ||
< ||pound sign ||&pound; ||
< ||currency sign ||&curren; ||
< ||yen sign = yuan sign ||&yen; ||
< ||broken bar = broken vertical bar ||&brvbar; ||
< ||section sign ||&sect; ||
< ||diaeresis = spacing diaeresis ||&uml; ||
< ||copyright sign ||&copy; ||
< ||feminine ordinal indicator ||&ordf; ||
< ||left-pointing double angle quotation mark = left pointing guillemet ||&laquo; ||
< ||not sign ||&not; ||
< ||soft hyphen = discretionary hyphen ||&shy; ||
< ||registered sign = registered trade mark sign ||&reg; ||
< ||macron = spacing macron = overline = APL overbar ||&macr; ||
< ||degree sign ||&deg; ||
< ||plus-minus sign = plus-or-minus sign ||&plusmn; ||
< ||superscript two = superscript digit two = squared ||&sup2; ||
< ||superscript three = superscript digit three = cubed ||&sup3; ||
< ||acute accent = spacing acute ||&acute; ||
< ||micro sign ||&micro; ||
< ||pilcrow sign = paragraph sign ||&para; ||
< ||middle dot = Georgian comma = Greek middle dot ||&middot; ||
< ||cedilla = spacing cedilla ||&cedil; ||
< ||superscript one = superscript digit one ||&sup1; ||
< ||masculine ordinal indicator ||&ordm; ||
< ||right-pointing double angle quotation mark = right pointing guillemet ||&raquo; ||
< ||ulgar fraction one quarter = fraction one quarter ||&frac14; ||
< ||vulgar fraction one half = fraction one half ||&frac12; ||
< ||vulgar fraction three quarters = fraction three quarters ||&frac34; ||
< ||inverted question mark = turned question mark ||&iquest; ||
< ||Latin capital letter A grave ||&Agrave; ||
< ||Latin capital letter A with acute ||&Aacute; ||
< ||Latin capital letter A with circumflex ||&Acirc; ||
< ||Latin capital letter A with tilde ||&Atilde; ||
< ||Latin capital letter A with diaeresis ||&Auml; ||
< ||Latin capital letter A ring ||&Aring; ||
< ||Latin capital ligature AE ||&AElig; ||
< ||Latin capital letter C with cedilla ||&Ccedil; ||
< ||Latin capital letter E with grave ||&Egrave; ||
< ||Latin capital letter E with acute ||&Eacute; ||
< ||Latin capital letter E with circumflex ||&Ecirc; ||
< ||Latin capital letter E with diaeresis ||&Euml; ||
< ||Latin capital letter I with grave ||&Igrave; ||
< ||Latin capital letter I with acute ||&Iacute; ||
< ||Latin capital letter I with circumflex ||&Icirc; ||
< ||Latin capital letter I with diaeresis ||&Iuml; ||
< ||Latin capital letter ETH ||&ETH; ||
< ||Latin capital letter N with tilde ||&Ntilde; ||
< ||Latin capital letter O with grave ||&Ograve; ||
< ||Latin capital letter O with acute ||&Oacute; ||
< ||Latin capital letter O with circumflex ||&Ocirc; ||
< ||Latin capital letter O with tilde ||&Otilde; ||
< ||Latin capital letter O with diaeresis ||&Ouml; ||
< ||multiplication sign ||&times; ||
< ||Latin capital letter O slash ||&Oslash; ||
< ||Latin capital letter U with grave ||&Ugrave; ||
< ||Latin capital letter U with acute ||&Uacute; ||
< ||Latin capital letter U with circumflex ||&Ucirc; ||
< ||Latin capital letter U with diaeresis ||&Uuml; ||
< ||Latin capital letter Y with acute ||&Yacute; ||
< ||Latin capital letter THORN ||&THORN; ||
< ||Latin small letter sharp s = ess-zed ||&szlig; ||
< ||Latin small letter a with grave = ||Latin small letter a grave ||&agrave; ||
< ||Latin small letter a with acute ||&aacute; ||
< ||Latin small letter a with circumflex ||&acirc; ||
< ||Latin small letter a with tilde ||&atilde; ||
< ||Latin small letter a with diaeresis ||&auml; ||
< ||Latin small letter a with ring above = ||Latin small letter a ring ||&aring; ||
< ||Latin small letter ae = ||Latin small ligature ae ||&aelig; ||
< ||Latin small letter c with cedilla ||&ccedil; ||
< ||Latin small letter e with grave ||&egrave; ||
< ||Latin small letter e with acute ||&eacute; ||
< ||Latin small letter e with circumflex ||&ecirc; ||
< ||Latin small letter e with diaeresis ||&euml; ||
< ||Latin small letter i with grave ||&igrave; ||
< ||Latin small letter i with acute ||&iacute; ||
< ||Latin small letter i with circumflex ||&icirc; ||
< ||Latin small letter i with diaeresis ||&iuml; ||
< ||Latin small letter eth ||&eth; ||
< ||Latin small letter n with tilde ||&ntilde; ||
< ||Latin small letter o with grave ||&ograve; ||
< ||Latin small letter o with acute ||&oacute; ||
< ||Latin small letter o with circumflex ||&ocirc; ||
< ||Latin small letter o with tilde ||&otilde; ||
< ||Latin small letter o with diaeresis ||&ouml; ||
< ||division sign ||&divide; ||
< ||Latin small letter o slash ||&oslash; ||
< ||Latin small letter u with grave ||&ugrave; ||
< ||Latin small letter u with acute ||&uacute; ||
< ||Latin small letter u with circumflex ||&ucirc; ||
< ||Latin small letter u with diaeresis ||&uuml; ||
< ||Latin small letter y with acute ||&yacute; ||
< ||Latin small letter thorn ||&thorn; ||
< ||Latin small letter y with diaeresis ||&yuml; ||
< ||dagger  ||&dagger;  ||
< ||double dagger ||&Dagger; ||
< ||per mille sign ||&permil; ||
< ||Latin small f with hook = function = florin  ||&fnof;  ||
< ||Greek capital letter alpha ||&Alpha; ||
< ||Greek capital letter beta ||&Beta; ||
< ||Greek capital letter gamma ||&Gamma; ||
< ||Greek capital letter delta ||&Delta; ||
< ||Greek capital letter epsilon ||&Epsilon; ||
< ||Greek capital letter zeta ||&Zeta; ||
< ||Greek capital letter eta ||&Eta; ||
< ||Greek capital letter theta ||&Theta; ||
< ||Greek capital letter iota ||&Iota; ||
< ||Greek capital letter kappa ||&Kappa; ||
< ||Greek capital letter lambda ||&Lambda; ||
< ||Greek capital letter mu ||&Mu; ||
< ||Greek capital letter nu ||&Nu; ||
< ||Greek capital letter xi ||&Xi; ||
< ||Greek capital letter omicron ||&Omicron; ||
< ||Greek capital letter pi ||&Pi; ||
< ||Greek capital letter rho ||&Rho; ||
< ||Greek capital letter sigma ||&Sigma; ||
< ||Greek capital letter tau ||&Tau; ||
< ||Greek capital letter upsilon ||&Upsilon; ||
< ||Greek capital letter phi ||&Phi; ||
< ||Greek capital letter chi ||&Chi; ||
< ||Greek capital letter psi ||&Psi; ||
< ||Greek capital letter omega ||&Omega; ||
< ||Greek small letter alpha ||&alpha; ||
< ||Greek small letter beta ||&beta; ||
< ||Greek small letter gamma ||&gamma; ||
< ||Greek small letter delta ||&delta; ||
< ||Greek small letter epsilon ||&epsilon; ||
< ||Greek small letter zeta ||&zeta; ||
< ||Greek small letter eta ||&eta; ||
< ||Greek small letter theta ||&theta; ||
< ||Greek small letter iota ||&iota; ||
< ||Greek small letter kappa ||&kappa; ||
< ||Greek small letter lambda ||&lambda; ||
< ||Greek small letter mu ||&mu; ||
< ||Greek small letter nu ||&nu; ||
< ||Greek small letter xi ||&xi; ||
< ||Greek small letter omicron ||&omicron; ||
< ||Greek small letter pi ||&pi; ||
< ||Greek small letter rho ||&rho; ||
< ||Greek small letter final sigma ||&sigmaf; ||
< ||Greek small letter sigma ||&sigma; ||
< ||Greek small letter tau ||&tau; ||
< ||Greek small letter upsilon ||&upsilon; ||
< ||Greek small letter phi ||&phi; ||
< ||Greek small letter chi ||&chi; ||
< ||Greek small letter psi ||&psi; ||
< ||Greek small letter omega ||&omega; ||
< ||Greek small letter theta symbol ||&thetasym; ||
< ||Greek upsilon with hook symbol ||&upsih; ||
< ||Greek pi symbol ||&piv; ||
< ||bullet = black small circle ||&bull; ||
< ||horizontal ellipsis = three dot leader ||&hellip; ||
< ||prime = minutes = feet ||&prime; ||
< ||double prime = seconds = inches ||&Prime; ||
< ||overline = spacing overscore ||&oline; ||
< ||fraction slash ||&frasl; ||
< ||script capital P = power set = Weierstrass p ||&weierp; ||
< ||blackletter capital I = imaginary part ||&image; ||
< ||blackletter capital R = real part symbol ||&real; ||
< ||trade mark sign ||&trade; ||
< ||alef symbol = first transfinite cardinal ||&alefsym; ||
< ||leftwards arrow ||&larr; ||
< ||upwards arrow ||&uarr; ||
< ||rightwards arrow ||&rarr; ||
< ||downwards arrow ||&darr; ||
< ||left right arrow ||&harr; ||
< ||downwards arrow with corner leftwards = carriage return ||&crarr; ||
< ||leftwards double arrow ||&lArr; ||
< ||upwards double arrow ||&uArr; ||
< ||rightwards double arrow ||&rArr; ||
< ||downwards double arrow ||&dArr; ||
< ||left right double arrow ||&hArr; ||
< ||for all ||&forall; ||
< ||partial differential ||&part; ||
< ||there exists ||&exist; ||
< ||empty set = null set = diameter ||&empty; ||
< ||nabla = backward difference ||&nabla; ||
< ||element of ||&isin; ||
< ||not an element of ||&notin; ||
< ||contains as member ||&ni; ||
< ||n-ary product = product sign ||&prod; ||
< ||n-ary sumation ||&sum; ||
< ||minus sign ||&minus; ||
< ||asterisk operator ||&lowast; ||
< ||square root = radical sign ||&radic; ||
< ||proportional to ||&prop; ||
< ||infinity ||&infin; ||
< ||angle ||&ang; ||
< ||logical and = wedge ||&and; ||
< ||logical or = vee ||&or; ||
< ||intersection = cap ||&cap; ||
< ||union = cup ||&cup; ||
< ||integral ||&int; ||
< ||therefore ||&there4; ||
< ||tilde operator = varies with = similar to ||&sim; ||
< ||approximately equal to ||&cong; ||
< ||almost equal to = asymptotic to ||&asymp; ||
< ||not equal to ||&ne; ||
< ||identical to ||&equiv; ||
< ||less-than or equal to ||&le; ||
< ||Greater-than or equal to ||&ge; ||
< ||subset of ||&sub; ||
< ||superset of ||&sup; ||
< ||not a subset of ||&nsub; ||
< ||subset of or equal to ||&sube; ||
< ||superset of or equal to ||&supe; ||
< ||circled plus = direct sum ||&oplus; ||
< ||circled times = vector product ||&otimes; ||
< ||up tack = orthogonal to = perpendicular ||&perp; ||
< ||dot operator ||&sdot; ||
< ||left ceiling = APL upstile ||&lceil; ||
< ||right ceiling ||&rceil; ||
< ||left floor = APL downstile ||&lfloor; ||
< ||right floor ||&rfloor; ||
< ||lozenge ||&loz; ||
< ||black spade suit ||&spades; ||
< ||black club suit = shamrock ||&clubs; ||
< ||black heart suit = valentine ||&hearts; ||
< ||black diamond suit ||&diams; ||
---
> Here are selected HTML Entities that can be used when creating a WikiPage.
> 
> !!Common Symbols|width=300!!Symbol|width=100!!Code!!
> ||Section  ||&sect;||&amp;sect;||
> ||Copyright ||&copy;||&amp;copy;||
> ||Registered trademark ||&reg;||&amp;reg;||
> ||Trademark ||&trade;||&amp;trade;||
> ||Degrees  ||&deg;||&amp;deg;||
> ||Dagger ||&dagger;||&amp;dagger;||
> ||Double dagger ||&Dagger;||&amp;Dagger;||
> ||Paragraph symbol (pilcrow)  ||&para;||&amp;para;||
> 
> !!Arrows|width=300!!Symbol|width=100!!Code!!
> ||Leftward arrow  ||&#x2190;||&amp;#x2190;||
> ||Rightward arrow ||&#x2192;||&amp;#x2192;||
> ||Upward arrow ||&#x2191;||&amp;#x2191;||
> ||Downward arrow ||&#x2193;||&amp;#x2193;||
> ||Left right arrow ||&#x2194;||&amp;#x2194;||
> ||Leftward double arrow ||&#x21D0;||&amp;#x21D0;||
> ||Rightward double arrow  ||&#x21D2;||&amp;#x21D2;||
> ||Upward double arrow ||&#x21D1;||&amp;#x21D1;||
> ||Downward double arrow ||&#x21D3;||&amp;#x21D3;||
> ||Left right double arrow ||&#x21D4;||&amp;#x21D4;||
> 
> !!Math Symbols|width=300!!Symbol|width=100!!Code!!
> ||Plus or minus  ||&plusmn;||&amp;plusmn;||
> ||Multiplication sign ||&times;||&amp;times;||
> ||Division sign ||&divide;||&amp;divide;||
> ||Less-than or equal-to  ||&le;||&amp;le;||
> ||Greater-than or equal-to ||&ge;||&amp;ge;||
> ||Not equal to ||&ne;||&amp;ne;||
> ||Approximately equal to  ||&cong;||&amp;cong;||
> ||Almost equal to ||&asymp;||&amp;asymp;||
> ||Identical to ||&equiv;||&amp;equiv;||
> ||Infinity ||&infin;||&amp;infin;||
> 
> !!Planet|width=300!!Symbol|width=100!!Code!!
> ||Mercury  ||&#x263F;||&amp;#x263F;||
> ||Venus (also female symbol) ||&#x2640;||&amp;#x2640;||
> ||Earth ||&#x2641;||&amp;#x2641;||
> ||Mars (also male symbol) ||&#x2642;||&amp;#x2642;||
> ||Jupiter ||&#x2643;||&amp;#x2643;||
> ||Saturn ||&#x2644;||&amp;#x2644;||
> ||Uranus ||&#x2645;||&amp;#x2645;||
> ||Neptune ||&#x2646;||&amp;#x2646;||
> ||Pluto ||&#x2647;||&amp;#x2647;||
> 
> !!Signs of the Zodiac|width=300!!Symbol|width=100!!Code!!
> ||Aries  ||&#x2648;||&amp;#x2648;||
> ||Taurus ||&#x2649;||&amp;#x2649;||
> ||Gemini ||&#x264A;||&amp;#x264A;||
> ||Cancer ||&#x264B;||&amp;#x264B;||
> ||Leo ||&#x264C;||&amp;#x264C;||
> ||Virgo ||&#x264D;||&amp;#x264D;||
> ||Libra ||&#x264E;||&amp;#x264E;||
> ||Scorpio ||&#x264F;||&amp;#x264F;||
> ||Sagittarius ||&#x2650;||&amp;#x2650;||
> ||Capricorn ||&#x2651;||&amp;#x2651;||
> ||Aquarius ||&#x2652;||&amp;#x2652;||
> ||Pisces ||&#x2653;||&amp;#x2653;||
------
WikiBugs/OpenDefects|1226203580
1c1,15
< [Describe the new page here]
---
> !!Date!!Contributor!!Description!!Status!!
> ||2007.10.14||[HomePage/RobertKurcina RobertKurcina]||List Orphans appears to list valid pages||FIXED-2007.11.02||
> ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||FIXED-2008.09.27||
> ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the UseMod:MagicContent will show pages that have been created but may exist as a Wiki sub-page or as an external link.||FIXED-2007.10.13||
> ||2007.11.05||[HomePage/RobertKurcina RobertKurcina]||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||FIXED-2007.11.05||
> ||2007.11.16||[HomePage/RobertKurcina RobertKurcina]||The enhanced table option switches work for the last cell of a row only when it ends with a blank space||OPEN||
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||Appears to be that bracket images within table cells fail to resolve.  See any of the home page images||FIXED-2007.11.27||
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans incorrectly lists legitimate sub pages||FIXED-2008.09.28||
> ||2007.11.19||[HomePage/RobertKurcina RobertKurcina]||The various Admin bar links should be enabled or disable to match the left nav.||OPEN||
> ||2007.11.24||[HomePage/RobertKurcina RobertKurcina]||Table last column; the property seems to be picked up by the previous column.||OPEN||
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Seems that the back-links or <tt><nowiki>GetFullLinkList</nowiki></tt> subroutines ignore spaces, periods, and capitilization when performing a search.||FIXED-2007.12.01||
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output.||FIXED-2007.12.03||
> ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Need to update T(), Ts(), Tss() and to remove all double-quotes expressions for taint.||OPEN||
> ||2008.09.29||[HomePage/RobertKurcina RobertKurcina]||Table of Contents doesn't properly number when including templates with their own headings.||OPEN||
> ||2008.10.12||[HomePage/RobertKurcina RobertKurcina]||Seems that the rename pages doesn't catch all variations of links.  esp. sub-pages.||OPEN||
------
WikiBugs/ClosedDefects|1226203609
1c1,15
< [Describe the new page here]
---
> !!Date!!Contributor!!Description!!Status!!
> ||2007.10.14||[HomePage/RobertKurcina RobertKurcina]||List Orphans appears to list valid pages||FIXED-2007.11.02||
> ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||FIXED-2008.09.27||
> ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the UseMod:MagicContent will show pages that have been created but may exist as a Wiki sub-page or as an external link.||FIXED-2007.10.13||
> ||2007.11.05||[HomePage/RobertKurcina RobertKurcina]||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||FIXED-2007.11.05||
> ||2007.11.16||[HomePage/RobertKurcina RobertKurcina]||The enhanced table option switches work for the last cell of a row only when it ends with a blank space||OPEN||
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||Appears to be that bracket images within table cells fail to resolve.  See any of the home page images||FIXED-2007.11.27||
> ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans incorrectly lists legitimate sub pages||FIXED-2008.09.28||
> ||2007.11.19||[HomePage/RobertKurcina RobertKurcina]||The various Admin bar links should be enabled or disable to match the left nav.||OPEN||
> ||2007.11.24||[HomePage/RobertKurcina RobertKurcina]||Table last column; the property seems to be picked up by the previous column.||OPEN||
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Seems that the back-links or <tt><nowiki>GetFullLinkList</nowiki></tt> subroutines ignore spaces, periods, and capitilization when performing a search.||FIXED-2007.12.01||
> ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output.||FIXED-2007.12.03||
> ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Need to update T(), Ts(), Tss() and to remove all double-quotes expressions for taint.||OPEN||
> ||2008.09.29||[HomePage/RobertKurcina RobertKurcina]||Table of Contents doesn't properly number when including templates with their own headings.||OPEN||
> ||2008.10.12||[HomePage/RobertKurcina RobertKurcina]||Seems that the rename pages doesn't catch all variations of links.  esp. sub-pages.||OPEN||
------
WikiBugs|1226203857
0a1
> == Known Defects =
3,17c4,7
< !!Date!!Contributor!!Description!!Status!!
< ||2007.10.14||[HomePage/RobertKurcina RobertKurcina]||List Orphans appears to list valid pages||FIXED-2007.11.02||
< ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||FIXED-2008.09.27||
< ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the UseMod:MagicContent will show pages that have been created but may exist as a Wiki sub-page or as an external link.||FIXED-2007.10.13||
< ||2007.11.05||[HomePage/RobertKurcina RobertKurcina]||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||FIXED-2007.11.05||
< ||2007.11.16||[HomePage/RobertKurcina RobertKurcina]||The enhanced table option switches work for the last cell of a row only when it ends with a blank space||OPEN||
< ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||Appears to be that bracket images within table cells fail to resolve.  See any of the home page images||FIXED-2007.11.27||
< ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans incorrectly lists legitimate sub pages||FIXED-2008.09.28||
< ||2007.11.19||[HomePage/RobertKurcina RobertKurcina]||The various Admin bar links should be enabled or disable to match the left nav.||OPEN||
< ||2007.11.24||[HomePage/RobertKurcina RobertKurcina]||Table last column; the property seems to be picked up by the previous column.||OPEN||
< ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Seems that the back-links or <tt><nowiki>GetFullLinkList</nowiki></tt> subroutines ignore spaces, periods, and capitilization when performing a search.||FIXED-2007.12.01||
< ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output.||FIXED-2007.12.03||
< ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Need to update T(), Ts(), Tss() and to remove all double-quotes expressions for taint.||OPEN||
< ||2008.09.29||[HomePage/RobertKurcina RobertKurcina]||Table of Contents doesn't properly number when including templates with their own headings.||OPEN||
< ||2008.10.12||[HomePage/RobertKurcina RobertKurcina]||Seems that the rename pages doesn't catch all variations of links.  esp. sub-pages.||OPEN||
---
> === Currently Open =
> {{template:WikiBugs/OpenDefects}}
> == Defects Repaired =
> {{template:WikiBugs/ClosedDefects}}
------
WikiBugs/ClosedDefects|1226204060
6d5
< ||2007.11.16||[HomePage/RobertKurcina RobertKurcina]||The enhanced table option switches work for the last cell of a row only when it ends with a blank space||OPEN||
9,10d7
< ||2007.11.19||[HomePage/RobertKurcina RobertKurcina]||The various Admin bar links should be enabled or disable to match the left nav.||OPEN||
< ||2007.11.24||[HomePage/RobertKurcina RobertKurcina]||Table last column; the property seems to be picked up by the previous column.||OPEN||
13,15d9
< ||2008.09.28||[HomePage/RobertKurcina RobertKurcina]||Need to update T(), Ts(), Tss() and to remove all double-quotes expressions for taint.||OPEN||
< ||2008.09.29||[HomePage/RobertKurcina RobertKurcina]||Table of Contents doesn't properly number when including templates with their own headings.||OPEN||
< ||2008.10.12||[HomePage/RobertKurcina RobertKurcina]||Seems that the rename pages doesn't catch all variations of links.  esp. sub-pages.||OPEN||
------
WikiBugs/OpenDefects|1226204109
2,5d1
< ||2007.10.14||[HomePage/RobertKurcina RobertKurcina]||List Orphans appears to list valid pages||FIXED-2007.11.02||
< ||2007.10.13||[HomePage/RobertKurcina RobertKurcina]||When editing a WikiPage, adding more than the necessary carriage-returns/line-feeds will cause the page to render with HTML code visible.||FIXED-2008.09.27||
< ||2007.10.11||[HomePage/RobertKurcina RobertKurcina]||ListOfWantedPages via the UseMod:MagicContent will show pages that have been created but may exist as a Wiki sub-page or as an external link.||FIXED-2007.10.13||
< ||2007.11.05||[HomePage/RobertKurcina RobertKurcina]||Looks like MS-IE6 view of pages like WikiMarkup shows gray blocks||FIXED-2007.11.05||
7,8d2
< ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||Appears to be that bracket images within table cells fail to resolve.  See any of the home page images||FIXED-2007.11.27||
< ||2007.11.18||[HomePage/RobertKurcina RobertKurcina]||List Orphans incorrectly lists legitimate sub pages||FIXED-2008.09.28||
11,12d4
< ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Seems that the back-links or <tt><nowiki>GetFullLinkList</nowiki></tt> subroutines ignore spaces, periods, and capitilization when performing a search.||FIXED-2007.12.01||
< ||2007.12.01||[HomePage/RobertKurcina RobertKurcina]||Print preview shows that the CSS is messed up; need to create an @import for printer-friendly output.||FIXED-2007.12.03||
------
WikiBugs|1226204243
6c6
< == Defects Repaired =
---
> === Defects Repaired =
------
NobleWiki/Features|1226204677
1c1,27
< [Describe the new page here]
---
> !!Major&nbsp;Things|width=300!!Description!!
> ||Negation Search|class=first||Precede the search term with '!' exclamation point and the search API will find every <em>but</em> that term.||
> ||Manage Assets||Files uploaded go into the uploads directory as active assets, and can be moved between the uploaded and disabled directories. Supports a naming filter, folder creation, and asset deletion.  See WikiUploads for more information.||
> ||CSS||Every relevant element has been assigned a CSS class or ID||
> ||CSS Selection||All CSS files named using the pattern <tt>wiki.*</tt> such as <tt>wiki.css</tt> or <tt>wiki.gray</tt> are made available automatically for selection via the Preferences interface.||
> ||HTML Structure||Made the HTML structure a bit more robust in order to allow advanced CSS styling.  The most significant change is to add <tt><div class='wikicontainer'></div></tt> around the basic HTML ouput.||
> ||Full Tables||Revised UseMod:WikiPatches/WikiTemplate to allow option switches to control class, style, alignment, width, etc.  See WikiTables for more information||
> ||Flash Object||Flash SWFs may be added using the <tt><nowiki></nowiki></tt> directive and module. See WikiFlash for more information.||
> ||<nowiki>LightBox</nowiki> Gallery||Implemented a way to view gallery images.  See WikiGallery for more information.||
> ||File Icon Boxes||If an asset link has a non-bitmap image extension a box with an icon for that file type is presented.||
> ||JSON Blocks||Very useful for providing data to various applets like the open-source Flash charting tool.||
> ||Code Boxes||If code needs to be shown - be it perl, <nowiki>JavaScript</nowiki>, CSS, or even HTML; use [WikiCodeBox Code Boxes].   These will show line-numbering and have syntax-highlighting.||
> ||User Home||User home pages are to be created and are assumed to exist as sub-pages defined within <tt><nowiki>$HomePagePrefix</nowiki></tt> which is defaulted to be <tt><nowiki>HomePage</nowiki></tt>||
> ||Discuss Page||This is a work-in-progress.  Essentially add <tt><nowiki>{{magic: Discuss}}</nowiki></tt> in order to activate discussion form and feedback set for a page.  Deactivate form but leave feedback in place by adding parameter locked=true.||
> ||Expanded <tt><nowiki>$SimpleLinks</nowiki></tt>||Links like <tt><nowiki>Setup_Box</nowiki></tt> and <tt><nowiki>SetUp_box</nowiki></tt> are allowed.  Both will create bracketed links but not show the underscore character.||
> ||Expanded <tt><nowiki>FreeLinks and $LinkPattern</nowiki></tt>||Pages that are formed with a single word instead of a WikiWord may only be created by EditorRole and AdminRole.||
> ||View User Contributions||Use <tt><nowiki>action=rc&userid=RobertKurcina</nowiki></tt> to see all contributions by a given userid.  This is made available in each RecentChanges history line as well.||
> ||Redirect to Edit Page||By setting action=referer in the <tt><nowiki>$NotFoundPage</nowiki></tt>, the hyperlink created will redirect to the edit page for the name of the page. This is useful to automatically generate edit requests for Notes pages.||
> ||Block Colors||Introduced custom coloring with <tt><nowiki>{{color:key=value|key=value|..}}</nowiki></tt> where key is bgcolor, color, or padding [in pixels].  bgcolor and color accept standard CSS color names.||
> ||Message Boxes||Introduced custom coloring with <tt><nowiki>{{box:type|message=value}}</nowiki></tt> where type is one of error, alert, warn, info, update, todo, yes, no, delete, or lock. See MessageBox for more information. ||
> ||Source View||When a page is locked for Guests, the Edit feature will display a READONLY textarea.||
> ||<tt><nowiki>Dynamic GotoBar</nowiki></tt>||The <tt><nowiki>GotoBar</nowiki></tt>for users and admins have been consolidated.  By default only the top bar will show, but the Preferences section will allow a bottom one to appear.  The elements of the bars will dynamically enable or disable according to the page or action being viewed.||
> ||Dynamic Navigation Menu||The left-navigation incorporates user and admin options, and like the <tt><nowiki>GotoBar</nowiki></tt>will enable or disable the items.||
> ||System Info||The [LocalWiki:action=version action=version] page has been expanded with verbose but static information.||
> ||Page Creation Prompt||The <tt><nowiki>PageNotFound</nowiki></tt> result will now prompt the user to create a new page if their search request involved a legitimate page name as qualified by the <tt><nowiki>$LinkPattern</nowiki></tt> variable in the wiki code.||
> ||Description Text||Descriptions for a page can be created while editing the wikitext for it.  These will display for search results.||
> ||Formatted Search Results||Search results will display in two columns if a custom threshold of results found is exceeded.||
------
NobleWiki/Features|1226204832
22c22
< ||<tt><nowiki>Dynamic GotoBar</nowiki></tt>||The <tt><nowiki>GotoBar</nowiki></tt>for users and admins have been consolidated.  By default only the top bar will show, but the Preferences section will allow a bottom one to appear.  The elements of the bars will dynamically enable or disable according to the page or action being viewed.||
---
> ||<nowiki>Dynamic GotoBar</nowiki>||The <tt><nowiki>GotoBar</nowiki></tt>for users and admins have been consolidated.  By default only the top bar will show, but the Preferences section will allow a bottom one to appear.  The elements of the bars will dynamically enable or disable according to the page or action being viewed.||
------
NobleWiki/Features|1226205054
15,16c15,16
< ||Expanded <tt><nowiki>$SimpleLinks</nowiki></tt>||Links like <tt><nowiki>Setup_Box</nowiki></tt> and <tt><nowiki>SetUp_box</nowiki></tt> are allowed.  Both will create bracketed links but not show the underscore character.||
< ||Expanded <tt><nowiki>FreeLinks and $LinkPattern</nowiki></tt>||Pages that are formed with a single word instead of a WikiWord may only be created by EditorRole and AdminRole.||
---
> ||Expanded <nowiki>$SimpleLinks</nowiki>||Links like <tt><nowiki>Setup_Box</nowiki></tt> and <tt><nowiki>SetUp_box</nowiki></tt> are allowed.  Both will create bracketed links but not show the underscore character.||
> ||Expanded <nowiki>FreeLinks and $LinkPattern</nowiki>||Pages that are formed with a single word instead of a WikiWord may only be created by EditorRole and AdminRole.||
------
NobleWiki/Extras|1226205147
1c1,19
< [Describe the new page here]
---
> !!Minor&nbsp;Things|width=300!!Description!!
> ||Cancel button|class=first||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
> ||Print Link List||Updated this presentation to have a table.  Any non-existent pages identified will show with the 'Create this entry' icon.||
> ||Recent Changes||Instead of <tt>$FS3</tt> to split the recent changes log, use <tt>\W</tt>.  For example <tt>($ts) = split( /\W/, $fullrc[$i] );</tt>.  Seems to work better for WIN32.||
> ||Page Lock Icon||Added a small icon to the right of the page title to show that a page is locked or editable.||
> ||index.cgi||The wiki.pl script has been renamed.||
> ||IE6 textarea||Added <tt><nowiki><div style='width:100%;'>...</div></nowiki></tt> around the textarea in <tt><nowiki>sub GetTextArea {}</nowiki></tt> to enable 100% width in IE6||
> ||Table Sorting||Added jQuery Tablesorter 2.0 to engage any table created properly.  See WikiTables for more information.||
> ||Disabled regex Search||A checkbox near the search form when marked will disable the default search mechanism that allows search terms to be interpreted as regex values.||
> ||Disable regex back-links||The <tt><nowiki>DoBackLinks</nowiki></tt> subroutine no longer uses search terms as regular expressions.||
> ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] may be assigned a pixel width parameter as in <tt><nowiki>{{toc NNN}}</nowiki></tt>||
> ||Expanded Config||Added a number of configuration variables.||
> ||Windows Config||Set <tt><nowiki>$Windows = 1</nowiki></tt> to remove CGITemp files after uploading assets.||
> ||Title attribute||Added a title attribute to all links where possible||
> ||Auto Signature||Insert <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] ]</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] at 2008.10.12 21:18 ]</nowiki></tt> to append timestamp.||
> ||Bracketed Image URLs with options||<tt><nowiki>[URL upload:image|<options>]</nowiki></tt> There's a number of options available now for images including title, description, boxclear, boxwidth, boxfloat, float, and clear.  The last are for images within a caption box if description is provided.  If description is provided but not title, then the title will show "FIGURE X" where X is computed as the current number of un-titled images||
> ||Edit Box||The edit box and other textareas are always 100% width in every browser implementation.||
> ||Lock-out Indicators||Added small symbols to allow quick access to editing a page from the title, and symbols to indicate that a page is locked.  <tt>'&not;'</tt> is that symbol prefixed to a locked page.||
> ||Naming Filter||Provide multiple keywords with or with negated terms to filter the names returned from <tt>backlinks</tt>, <tt>search</tt>, or the asset management interface.||
------
NobleWiki/Patches|1226205226
1c1,22
< [Describe the new page here]
---
> !!Patches Applied!!Description!!
> ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix|class=first|width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
> ||UseMod:WikiPatches/PerlDiff||Perl-based diff; should work on WIN32 and LINUX||
> ||UseMod:WikiPatches/GetSubpages||Return all subpages of a page via the Manage Pages interface for administrators||
> ||UseMod:WikiPatches/RenameSubpages||Rename subpages if it's parent page is renamed||
> ||UseMod:WikiPatches/EmbeddedSubpageList||Allows placement of <nowiki>{{subpages}}</nowiki> on any page, and wiki engine will generate list of subpages associated with it.||
> ||UseMod:WikiPatches/BacklinksImproved||Eliminates listings that match the current page||
> ||UseMod:WikiPatches/SiteIndex||Changes the search index results to a list of links to sections named A .. Z.  Altered to allow entries to flow across a row of text delimited by commas.||
> ||UseMod:WikiPatches/AutoMailto||Convert email addresses found into mailTo:<address>||
> ||UseMod:WikiPatches/WikiTemplate||Modified to require a command string of <tt>{{template:</tt> before it can be used. Created instructions for use as well; see WikiTemplates||
> ||UseMod:WikiPatches/MagicContent||Added.  Need to create links to standard magic content pages||
> ||UseMod:WikiPatches/MagicWantedPages||Via [Wiki:WikiPatches/MagicContent MagicContent]; creates a list of pages that have not yet been created but are referenced by at least 1 existing page||
> ||UseMod:WikiPatches/ListOrphans||Available via Admin view; list all pages that have no links leading to them||
> ||UseMod:WikiPatches/FileInclusion||Insert a file into <nowiki>$DataDir/includes</nowiki> and have it appear in a page using command <tt><nowiki>INCLUDE</nowiki>: filename</tt>||
> ||UseMod:WikiPatches/UneditablePageBugFix||Prevent pages to be created that can't be edited||
> ||UseMod:WikiPatches/RobotsMetaTag||Prevent search engine robots from indexing edit history versions||
> ||UseMod:WikiPatches/OriginalAuthor||Modified from original.  Inserts prior to 'Last Edited by' the phrase 'Created on DATE' and adds an author if it one exists||
> ||UseMod:WikiPatches/AutoSignature||Modified from original; basically checks for login status and sets $id to 'Guest' if empty||
> ||UseMod:WikiPatches/SubPages||Modified syntax  <tt><nowiki>{{subpages}}</nowiki></tt>Inserts all of a page's sub-pages.  Optional page name as in <tt><nowiki>{{subpages:PageName}}</nowiki></tt> will show that page's subpages||
> ||UseMod:WikiPatches/PrivateUserGroups||Modified from original.  Each user name must be on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName} or {r:UserName}</nowiki></tt> to indicate can edit or can read.  Otherwise an Authorization Error page will appear [ AuthError ]||
> ||UseMod:WikiPatches/UserTalkSpace||Modified from original such that each page potentially has a 'Notes' page.  See NotesPages.||
> ||UseMod:WikiPatches/FooterNotes||Allows for plain-text citations.  See FootNotes page.||
------
NobleWiki/Planned|1226205308
1d0
< [Describe the new page here]
2a2,18
> !!New Commands Planned|width=300!!Description!!
> ||<tt><nowiki>{{history|events}}</nowiki></tt>|class=first||Create a timeline using the Timeline javascript widget||
> ||<tt><nowiki>{{latex|events}}</nowiki></tt>|class=first||Create LaTex markup for support of scientific notation||
> ||<tt><nowiki>{{syntax|language}}</nowiki></tt>|class=first||Switch between the various markup languages.  Support Markdown, Creole.||
> ||<tt><nowiki>{{section|WikiPage|header}}</nowiki></tt>||Non-recursively transclude the section text for any page of the identified TOC header||
> ||<tt><nowiki>{{css|media|stylesheet}}</nowiki></tt>||Added at top of an editor's home-page to alter CSS used before rendering any wiki page.||
> ||<tt><nowiki>{{feedback|template}}</nowiki></tt>||Use a template [ see above ] to capture feedback or voting information||
> ||<tt><nowiki>{{columns|color}}</nowiki></tt>||Sort of like the version use on en.wikipedia.org; specify that content following appears in one, two, or three columns.||
> ||<tt><nowiki>{{graph|type|dimension}}</nowiki></tt>||Add support for javascript-generated graphs.  Bar graphs, line graphs, etc.||
> ||<tt><nowiki>{{data|id}}</nowiki></tt>||Add dataset storage in two phases.  Phase I is JSON creation for reference by SWFs, and <tt><nowiki>JavaScript</nowiki></tt> libraries.  Phase II is a read/write API possibly via <tt><nowiki>XmlHttpSocket</nowiki></tt> for AJAX or SWF.||
> ||<tt><nowiki>{{blog|entryid}}</nowiki></tt>||This would be a new GUI that writes to a dataset page under <tt><nowiki>PageId/Blogentryid</nowiki></tt> and support RSS 1.0.  Features are editing, archive, publishing, and a WYSIWYG.||
> ||<tt><nowiki>{{form|formid}}</nowiki></tt>||Create a simple configuration-driven form generator that would write to a dataset page.  Simple form templates should be made available such as voting + graph-view, feedback/mailer, calculation, and dataset data-entry + graph-view.||
> ||<tt><nowiki>{{whiteboard|shared}}</nowiki></tt>||Create sketches using Flash, and store the output as a bitmap on the server, and the curves as JSON elements.||
> ||<tt><nowiki>{{widget|type}}</nowiki></tt>||Wdigets will be pre-defined as right-hand elements for a HomePage view; calendar, blog roll, rss feeds, tag cloud, favorites, etc.||
> ||<tt><nowiki>{{embed|type</nowiki></tt>||This is a generalized way to embed applets for java, flash, Quicktime, Windows Media Player, etc.||
> ||<tt><nowiki>{{category|names}}</nowiki></tt>||Using a category tag should do two things; create an entry in the appropriate category page, and create a list of pages in place.||
> 
------
NobleWiki/Future|1226205405
1c1,10
< [Describe the new page here]
---
> !!Features Planned|width=300!!Description!!
> ||Update <tt>PRINT</tt>||All of the incidences of the <tt>PRINT</tt> command in the code need to be replaced with a String glob.  This will make the code more flexible.||
> ||Localization||I see the <tt>trans.pl</tt> and <tt>umtrans.pl</tt>.  I'm not sure that this is the best way to support I18N.  For example, the wiki engine should be able to serve up content localized to a specific language when given a preference.  This requires sub-directories by language in the database such as <tt>//en/content1</tt>  or <tt>//ja/content2</tt>.||
> ||Lock List||The administrator view needs to be able to determine which pages have been locked, and which pages are private.||
> ||Visitor's Log||This would be an audit trail of visitors by IP address and possibly by logon ID.||
> ||Home Page Binding||Once Preferences are set and a logon ID is determined, the visitor should be given the option to create a Home Page or to redirect to it if it already exists.||
> ||GMT Offset Detection||This could be done via JavaScript and passed automatically to the CGI whenever a page is edited.  Of course, also preset this in the Preferences page as well.||
> ||Namespaces||This would create separate directories for sets of pages that will not be searched/indexed unless explicitly invoked.||
> ||<nowiki>WikiFarm</nowiki>||This will create a separate set of directories for each wiki instance, to include data and configuration files.  The idea is to have single CGI script but allow multiple wiki sites without having to modify the HTTPd configuration files.||
> ||Authentication||The existing UseMod:UseMod system for user management doesn't really support roles, groups, and management of page collections.  By enhancing this feature the NobleWiki engine becomes more realistic as an option for use by others.||
------
NobleWiki/Future|1226205416
2c2
< ||Update <tt>PRINT</tt>||All of the incidences of the <tt>PRINT</tt> command in the code need to be replaced with a String glob.  This will make the code more flexible.||
---
> ||Update PRINT||All of the incidences of the <tt>PRINT</tt> command in the code need to be replaced with a String glob.  This will make the code more flexible.||
------
NobleWiki|1226205469
11,57c10,12
< !!Major&nbsp;Things|width=300!!Description!!
< ||Negation Search|class=first||Precede the search term with '!' exclamation point and the search API will find every <em>but</em> that term.||
< ||Manage Assets||Files uploaded go into the uploads directory as active assets, and can be moved between the uploaded and disabled directories. Supports a naming filter, folder creation, and asset deletion.  See WikiUploads for more information.||
< ||CSS||Every relevant element has been assigned a CSS class or ID||
< ||CSS Selection||All CSS files named using the pattern <tt>wiki.*</tt> such as <tt>wiki.css</tt> or <tt>wiki.gray</tt> are made available automatically for selection via the Preferences interface.||
< ||HTML Structure||Made the HTML structure a bit more robust in order to allow advanced CSS styling.  The most significant change is to add <tt><div class='wikicontainer'></div></tt> around the basic HTML ouput.||
< ||Full Tables||Revised UseMod:WikiPatches/WikiTemplate to allow option switches to control class, style, alignment, width, etc.  See WikiTables for more information||
< ||Flash Object||Flash SWFs may be added using the <tt><nowiki></nowiki></tt> directive and module. See WikiFlash for more information.||
< ||<nowiki>LightBox</nowiki> Gallery||Implemented a way to view gallery images.  See WikiGallery for more information.||
< ||File Icon Boxes||If an asset link has a non-bitmap image extension a box with an icon for that file type is presented.||
< ||JSON Blocks||Very useful for providing data to various applets like the open-source Flash charting tool.||
< ||Code Boxes||If code needs to be shown - be it perl, <nowiki>JavaScript</nowiki>, CSS, or even HTML; use [WikiCodeBox Code Boxes].   These will show line-numbering and have syntax-highlighting.||
< ||User Home||User home pages are to be created and are assumed to exist as sub-pages defined within <tt><nowiki>$HomePagePrefix</nowiki></tt> which is defaulted to be <tt><nowiki>HomePage</nowiki></tt>||
< ||Discuss Page||This is a work-in-progress.  Essentially add <tt><nowiki>{{magic: Discuss}}</nowiki></tt> in order to activate discussion form and feedback set for a page.  Deactivate form but leave feedback in place by adding parameter locked=true.||
< ||Expanded <tt><nowiki>$SimpleLinks</nowiki></tt>||Links like <tt><nowiki>Setup_Box</nowiki></tt> and <tt><nowiki>SetUp_box</nowiki></tt> are allowed.  Both will create bracketed links but not show the underscore character.||
< ||Expanded <tt><nowiki>FreeLinks and $LinkPattern</nowiki></tt>||Pages that are formed with a single word instead of a WikiWord may only be created by EditorRole and AdminRole.||
< ||View User Contributions||Use <tt><nowiki>action=rc&userid=RobertKurcina</nowiki></tt> to see all contributions by a given userid.  This is made available in each RecentChanges history line as well.||
< ||Redirect to Edit Page||By setting action=referer in the <tt><nowiki>$NotFoundPage</nowiki></tt>, the hyperlink created will redirect to the edit page for the name of the page. This is useful to automatically generate edit requests for Notes pages.||
< ||Block Colors||Introduced custom coloring with <tt><nowiki>{{color:key=value|key=value|..}}</nowiki></tt> where key is bgcolor, color, or padding [in pixels].  bgcolor and color accept standard CSS color names.||
< ||Message Boxes||Introduced custom coloring with <tt><nowiki>{{box:type|message=value}}</nowiki></tt> where type is one of error, alert, warn, info, update, todo, yes, no, delete, or lock. See MessageBox for more information. ||
< ||Source View||When a page is locked for Guests, the Edit feature will display a READONLY textarea.||
< ||<tt><nowiki>Dynamic GotoBar</nowiki></tt>||The <tt><nowiki>GotoBar</nowiki></tt>for users and admins have been consolidated.  By default only the top bar will show, but the Preferences section will allow a bottom one to appear.  The elements of the bars will dynamically enable or disable according to the page or action being viewed.||
< ||Dynamic Navigation Menu||The left-navigation incorporates user and admin options, and like the <tt><nowiki>GotoBar</nowiki></tt>will enable or disable the items.||
< ||System Info||The [LocalWiki:action=version action=version] page has been expanded with verbose but static information.||
< ||Page Creation Prompt||The <tt><nowiki>PageNotFound</nowiki></tt> result will now prompt the user to create a new page if their search request involved a legitimate page name as qualified by the <tt><nowiki>$LinkPattern</nowiki></tt> variable in the wiki code.||
< ||Description Text||Descriptions for a page can be created while editing the wikitext for it.  These will display for search results.||
< ||Formatted Search Results||Search results will display in two columns if a custom threshold of results found is exceeded.||
< 
< !!Minor&nbsp;Things|width=300!!Description!!
< ||Cancel button|class=first||Added to Edit page; basically <tt><nowiki>onclick='window.location="&ScriptName()?$id;";'</nowiki></tt>||
< ||Print Link List||Updated this presentation to have a table.  Any non-existent pages identified will show with the 'Create this entry' icon.||
< ||Recent Changes||Instead of <tt>$FS3</tt> to split the recent changes log, use <tt>\W</tt>.  For example <tt>($ts) = split( /\W/, $fullrc[$i] );</tt>.  Seems to work better for WIN32.||
< ||Page Lock Icon||Added a small icon to the right of the page title to show that a page is locked or editable.||
< ||index.cgi||The wiki.pl script has been renamed.||
< ||IE6 textarea||Added <tt><nowiki><div style='width:100%;'>...</div></nowiki></tt> around the textarea in <tt><nowiki>sub GetTextArea {}</nowiki></tt> to enable 100% width in IE6||
< ||Table Sorting||Added jQuery Tablesorter 2.0 to engage any table created properly.  See WikiTables for more information.||
< ||Disabled regex Search||A checkbox near the search form when marked will disable the default search mechanism that allows search terms to be interpreted as regex values.||
< ||Disable regex back-links||The <tt><nowiki>DoBackLinks</nowiki></tt> subroutine no longer uses search terms as regular expressions.||
< ||Table Of Contents||The [LocalWiki:WikiTOCs Table of Contents] may be assigned a pixel width parameter as in <tt><nowiki>{{toc NNN}}</nowiki></tt>||
< ||Expanded Config||Added a number of configuration variables.||
< ||Windows Config||Set <tt><nowiki>$Windows = 1</nowiki></tt> to remove CGITemp files after uploading assets.||
< ||Title attribute||Added a title attribute to all links where possible||
< ||Auto Signature||Insert <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] ]</nowiki></tt> to automatically insert username with link to home page; defaults to 'Guest' and no link if not logged in.  Use <tt><nowiki>[ [HomePage/RobertKurcina RobertKurcina] at 2008.10.12 21:18 ]</nowiki></tt> to append timestamp.||
< ||Bracketed Image URLs with options||<tt><nowiki>[URL upload:image|<options>]</nowiki></tt> There's a number of options available now for images including title, description, boxclear, boxwidth, boxfloat, float, and clear.  The last are for images within a caption box if description is provided.  If description is provided but not title, then the title will show "FIGURE X" where X is computed as the current number of un-titled images||
< ||Edit Box||The edit box and other textareas are always 100% width in every browser implementation.||
< ||Lock-out Indicators||Added small symbols to allow quick access to editing a page from the title, and symbols to indicate that a page is locked.  <tt>'&not;'</tt> is that symbol prefixed to a locked page.||
< ||Naming Filter||Provide multiple keywords with or with negated terms to filter the names returned from <tt>backlinks</tt>, <tt>search</tt>, or the asset management interface.||
---
> {{template:NobleWiki/Features}}
> 
> {{template:NobleWiki/Extras}}
61,82c16
< !!Patches Applied!!Description!!
< ||UseMod:WikiPatches/AnchorsInFreeLinkBugFix|class=first|width=300||Corrects how [LocalWiki:WikiURLs#freelinks FreeLinks] appear||
< ||UseMod:WikiPatches/PerlDiff||Perl-based diff; should work on WIN32 and LINUX||
< ||UseMod:WikiPatches/GetSubpages||Return all subpages of a page via the Manage Pages interface for administrators||
< ||UseMod:WikiPatches/RenameSubpages||Rename subpages if it's parent page is renamed||
< ||UseMod:WikiPatches/EmbeddedSubpageList||Allows placement of <nowiki>{{subpages}}</nowiki> on any page, and wiki engine will generate list of subpages associated with it.||
< ||UseMod:WikiPatches/BacklinksImproved||Eliminates listings that match the current page||
< ||UseMod:WikiPatches/SiteIndex||Changes the search index results to a list of links to sections named A .. Z.  Altered to allow entries to flow across a row of text delimited by commas.||
< ||UseMod:WikiPatches/AutoMailto||Convert email addresses found into mailTo:<address>||
< ||UseMod:WikiPatches/WikiTemplate||Modified to require a command string of <tt>{{template:</tt> before it can be used. Created instructions for use as well; see WikiTemplates||
< ||UseMod:WikiPatches/MagicContent||Added.  Need to create links to standard magic content pages||
< ||UseMod:WikiPatches/MagicWantedPages||Via [Wiki:WikiPatches/MagicContent MagicContent]; creates a list of pages that have not yet been created but are referenced by at least 1 existing page||
< ||UseMod:WikiPatches/ListOrphans||Available via Admin view; list all pages that have no links leading to them||
< ||UseMod:WikiPatches/FileInclusion||Insert a file into <nowiki>$DataDir/includes</nowiki> and have it appear in a page using command <tt><nowiki>INCLUDE</nowiki>: filename</tt>||
< ||UseMod:WikiPatches/UneditablePageBugFix||Prevent pages to be created that can't be edited||
< ||UseMod:WikiPatches/RobotsMetaTag||Prevent search engine robots from indexing edit history versions||
< ||UseMod:WikiPatches/OriginalAuthor||Modified from original.  Inserts prior to 'Last Edited by' the phrase 'Created on DATE' and adds an author if it one exists||
< ||UseMod:WikiPatches/AutoSignature||Modified from original; basically checks for login status and sets $id to 'Guest' if empty||
< ||UseMod:WikiPatches/SubPages||Modified syntax  <tt><nowiki>{{subpages}}</nowiki></tt>Inserts all of a page's sub-pages.  Optional page name as in <tt><nowiki>{{subpages:PageName}}</nowiki></tt> will show that page's subpages||
< ||UseMod:WikiPatches/PrivateUserGroups||Modified from original.  Each user name must be on it's own line and surrounded by curly braces like <tt><nowiki>{e:UserName} or {r:UserName}</nowiki></tt> to indicate can edit or can read.  Otherwise an Authorization Error page will appear [ AuthError ]||
< ||UseMod:WikiPatches/UserTalkSpace||Modified from original such that each page potentially has a 'Notes' page.  See NotesPages.||
< ||UseMod:WikiPatches/FooterNotes||Allows for plain-text citations.  See FootNotes page.||
---
> {{template:NobleWiki/Patches}}
102,117c35
< !!New Commands Planned|width=300!!Description!!
< ||<tt><nowiki>{{history|events}}</nowiki></tt>|class=first||Create a timeline using the Timeline javascript widget||
< ||<tt><nowiki>{{latex|events}}</nowiki></tt>|class=first||Create LaTex markup for support of scientific notation||
< ||<tt><nowiki>{{syntax|language}}</nowiki></tt>|class=first||Switch between the various markup languages.  Support Markdown, Creole.||
< ||<tt><nowiki>{{section|WikiPage|header}}</nowiki></tt>||Non-recursively transclude the section text for any page of the identified TOC header||
< ||<tt><nowiki>{{css|media|stylesheet}}</nowiki></tt>||Added at top of an editor's home-page to alter CSS used before rendering any wiki page.||
< ||<tt><nowiki>{{feedback|template}}</nowiki></tt>||Use a template [ see above ] to capture feedback or voting information||
< ||<tt><nowiki>{{columns|color}}</nowiki></tt>||Sort of like the version use on en.wikipedia.org; specify that content following appears in one, two, or three columns.||
< ||<tt><nowiki>{{graph|type|dimension}}</nowiki></tt>||Add support for javascript-generated graphs.  Bar graphs, line graphs, etc.||
< ||<tt><nowiki>{{data|id}}</nowiki></tt>||Add dataset storage in two phases.  Phase I is JSON creation for reference by SWFs, and <tt><nowiki>JavaScript</nowiki></tt> libraries.  Phase II is a read/write API possibly via <tt><nowiki>XmlHttpSocket</nowiki></tt> for AJAX or SWF.||
< ||<tt><nowiki>{{blog|entryid}}</nowiki></tt>||This would be a new GUI that writes to a dataset page under <tt><nowiki>PageId/Blogentryid</nowiki></tt> and support RSS 1.0.  Features are editing, archive, publishing, and a WYSIWYG.||
< ||<tt><nowiki>{{form|formid}}</nowiki></tt>||Create a simple configuration-driven form generator that would write to a dataset page.  Simple form templates should be made available such as voting + graph-view, feedback/mailer, calculation, and dataset data-entry + graph-view.||
< ||<tt><nowiki>{{whiteboard|shared}}</nowiki></tt>||Create sketches using Flash, and store the output as a bitmap on the server, and the curves as JSON elements.||
< ||<tt><nowiki>{{widget|type}}</nowiki></tt>||Wdigets will be pre-defined as right-hand elements for a HomePage view; calendar, blog roll, rss feeds, tag cloud, favorites, etc.||
< ||<tt><nowiki>{{embed|type</nowiki></tt>||This is a generalized way to embed applets for java, flash, Quicktime, Windows Media Player, etc.||
< ||<tt><nowiki>{{category|names}}</nowiki></tt>||Using a category tag should do two things; create an entry in the appropriate category page, and create a list of pages in place.||
---
> {{template:NobleWiki/Planned}}
122,131c39
< !!Features Planned|width=300!!Description!!
< ||Update <tt>PRINT</tt>||All of the incidences of the <tt>PRINT</tt> command in the code need to be replaced with a String glob.  This will make the code more flexible.||
< ||Localization||I see the <tt>trans.pl</tt> and <tt>umtrans.pl</tt>.  I'm not sure that this is the best way to support I18N.  For example, the wiki engine should be able to serve up content localized to a specific language when given a preference.  This requires sub-directories by language in the database such as <tt>//en/content1</tt>  or <tt>//ja/content2</tt>.||
< ||Lock List||The administrator view needs to be able to determine which pages have been locked, and which pages are private.||
< ||Visitor's Log||This would be an audit trail of visitors by IP address and possibly by logon ID.||
< ||Home Page Binding||Once Preferences are set and a logon ID is determined, the visitor should be given the option to create a Home Page or to redirect to it if it already exists.||
< ||GMT Offset Detection||This could be done via JavaScript and passed automatically to the CGI whenever a page is edited.  Of course, also preset this in the Preferences page as well.||
< ||Namespaces||This would create separate directories for sets of pages that will not be searched/indexed unless explicitly invoked.||
< ||<nowiki>WikiFarm</nowiki>||This will create a separate set of directories for each wiki instance, to include data and configuration files.  The idea is to have single CGI script but allow multiple wiki sites without having to modify the HTTPd configuration files.||
< ||Authentication||The existing UseMod:UseMod system for user management doesn't really support roles, groups, and management of page collections.  By enhancing this feature the NobleWiki engine becomes more realistic as an option for use by others.||
---
> {{template:NobleWiki/Future}}
------
NobleWiki/Features|1226205898
0a1,2
> This version of the <nowiki>UseMod</nowiki>wiki engine is highly customized, and adds the following features not available in the standard wiki.pl. 
> 
------
NobleWiki/Patches|1226205929
0a1,2
> These are the patches that have been applied:
> 
------
NobleWiki/Planned|1226205952
1c1,2
< 
---
> Not sure when these will come in, but definitely on the TODO list;
> 
------
NobleWiki/Future|1226205989
0a1,2
> These items I think I'll need to complete before I submit the code to [http://www.sourceforge.net SourceForge]
> 
2c4
< ||Update PRINT||All of the incidences of the <tt>PRINT</tt> command in the code need to be replaced with a String glob.  This will make the code more flexible.||
---
> ||Update <tt>PRINT</tt>||All of the incidences of the <tt>PRINT</tt> command in the code need to be replaced with a String glob.  This will make the code more flexible.||
------
NobleWiki/Extras|1226206048
0a1,2
> These are minor features of NobleWiki.
> 
------
NobleWiki|1226206155
9d8
< This version of the <nowiki>UseMod</nowiki>wiki engine is highly customized, and adds the following features not available in the standard UseMod:wiki.pl. 
15d12
< These are the patches that have been applied:
18a16
> Other patches worth implementing for Anti-spam and Denial of Service attacks are as follows:
34d31
< Not sure when these will come in, but definitely on the TODO list;
38d34
< These items I think I'll need to complete before I submit the code to [http://www.sourceforge.net SourceForge]
------
NobleWiki|1226206341
38a39
>  {{subpages}}
------
TextColors|1226207082
1c1,9
< [Describe the new page here]
---
> == Colorful Text =
> 
> The [WikiCommands WikiCommand] <tt><nowiki>{{color:}}</nowiki></tt> allows an author to alter how a line of text may appear by setting text color, padding, and background color.  The syntax for this is:
> 
> <pre>
> {{color:text=value|color=value|bgcolor=value|padding=value}}
> </pre>
> 
> The values of padding are in pixels, and the values of color can be any of the known RGB hex colors or color names available.
------
HtmlColors|1226208125
1c1,150
< [Describe the new page here]
---
> == Sample Colors =
> 
> !!Color Name|width=300!!Color!!Code!!
> ||<nowiki>AliceBlue</nowiki>||{{color:text=AliceBlue|bgcolor=AliceBlue}}||#F0F8FF||
> ||<nowiki>AntiqueWhite</nowiki>||{{color:text=AntiqueWhite|bgcolor=AntiqueWhite}}||#FAEBD7||
> ||<nowiki>Aqua</nowiki>||{{color:text=Aqua|bgcolor=Aqua}}||#00FFFF||
> ||<nowiki>Aquamarine</nowiki>||{{color:text=Aquamarine|bgcolor=Aquamarine}}||#7FFFD4||
> ||<nowiki>Azure</nowiki>||{{color:text=Azure|bgcolor=Azure}}||#F0FFFF||
> ||<nowiki>Beige</nowiki>||{{color:text=Beige|bgcolor=Beige}}||#F5F5DC||
> ||<nowiki>Bisque</nowiki>||{{color:text=Bisque|bgcolor=Bisque}}||#FFE4C4||
> ||<nowiki>Black</nowiki>||{{color:text=Black|bgcolor=Black}}||#000000||
> ||<nowiki>BlanchedAlmond</nowiki>||{{color:text=BlanchedAlmond|bgcolor=BlanchedAlmond}}||#FFEBCD||
> ||<nowiki>Blue</nowiki>||{{color:text=Blue|bgcolor=Blue}}||#0000FF||
> ||<nowiki>BlueViolet</nowiki>||{{color:text=BlueViolet|bgcolor=BlueViolet}}||#8A2BE2||
> ||<nowiki>Brown</nowiki>||{{color:text=Brown|bgcolor=Brown}}||#A52A2A||
> ||<nowiki>BurlyWood</nowiki>||{{color:text=BurlyWood|bgcolor=BurlyWood}}||#DEB887||
> ||<nowiki>CadetBlue</nowiki>||{{color:text=CadetBlue|bgcolor=CadetBlue}}||#5F9EA0||
> ||<nowiki>Chartreuse</nowiki>||{{color:text=Chartreuse|bgcolor=Chartreuse}}||#7FFF00||
> ||<nowiki>Chocolate</nowiki>||{{color:text=Chocolate|bgcolor=Chocolate}}||#D2691E||
> ||<nowiki>Coral</nowiki>||{{color:text=Coral|bgcolor=Coral}}||#FF7F50||
> ||<nowiki>CornflowerBlue</nowiki>||{{color:text=CornflowerBlue|bgcolor=CornflowerBlue}}||#6495ED||
> ||<nowiki>Cornsilk</nowiki>||{{color:text=Cornsilk|bgcolor=Cornsilk}}||#FFF8DC||
> ||<nowiki>Crimson</nowiki>||{{color:text=Crimson|bgcolor=Crimson}}||#DC143C||
> ||<nowiki>Cyan</nowiki>||{{color:text=Cyan|bgcolor=Cyan}}||#00FFFF||
> ||<nowiki>DarkBlue</nowiki>||{{color:text=DarkBlue|bgcolor=DarkBlue}}||#00008B||
> ||<nowiki>DarkCyan</nowiki>||{{color:text=DarkCyan|bgcolor=DarkCyan}}||#008B8B||
> ||<nowiki>DarkGoldenRod</nowiki>||{{color:text=DarkGoldenRod|bgcolor=DarkGoldenRod}}||#B8860B||
> ||<nowiki>DarkGray</nowiki>||{{color:text=DarkGray|bgcolor=DarkGray}}||#A9A9A9||
> ||<nowiki>DarkGrey</nowiki>||{{color:text=DarkGrey|bgcolor=DarkGrey}}||#A9A9A9||
> ||<nowiki>DarkGreen</nowiki>||{{color:text=DarkGreen|bgcolor=DarkGreen}}||#006400||
> ||<nowiki>DarkKhaki</nowiki>||{{color:text=DarkKhaki|bgcolor=DarkKhaki}}||#BDB76B||
> ||<nowiki>DarkMagenta</nowiki>||{{color:text=DarkMagenta|bgcolor=DarkMagenta}}||#8B008B||
> ||<nowiki>DarkOliveGreen</nowiki>||{{color:text=DarkOliveGreen|bgcolor=DarkOliveGreen}}||#556B2F||
> ||<nowiki>Darkorange</nowiki>||{{color:text=Darkorange|bgcolor=Darkorange}}||#FF8C00||
> ||<nowiki>DarkOrchid</nowiki>||{{color:text=DarkOrchid|bgcolor=DarkOrchid}}||#9932CC||
> ||<nowiki>DarkRed</nowiki>||{{color:text=DarkRed|bgcolor=DarkRed}}||#8B0000||
> ||<nowiki>DarkSalmon</nowiki>||{{color:text=DarkSalmon|bgcolor=DarkSalmon}}||#E9967A||
> ||<nowiki>DarkSeaGreen</nowiki>||{{color:text=DarkSeaGreen|bgcolor=DarkSeaGreen}}||#8FBC8F||
> ||<nowiki>DarkSlateBlue</nowiki>||{{color:text=DarkSlateBlue|bgcolor=DarkSlateBlue}}||#483D8B||
> ||<nowiki>DarkSlateGray</nowiki>||{{color:text=DarkSlateGray|bgcolor=DarkSlateGray}}||#2F4F4F||
> ||<nowiki>DarkSlateGrey</nowiki>||{{color:text=DarkSlateGrey|bgcolor=DarkSlateGrey}}||#2F4F4F||
> ||<nowiki>DarkTurquoise</nowiki>||{{color:text=DarkTurquoise|bgcolor=DarkTurquoise}}||#00CED1||
> ||<nowiki>DarkViolet</nowiki>||{{color:text=DarkViolet|bgcolor=DarkViolet}}||#9400D3||
> ||<nowiki>DeepPink</nowiki>||{{color:text=DeepPink|bgcolor=DeepPink}}||#FF1493||
> ||<nowiki>DeepSkyBlue</nowiki>||{{color:text=DeepSkyBlue|bgcolor=DeepSkyBlue}}||#00BFFF||
> ||<nowiki>DimGray</nowiki>||{{color:text=DimGray|bgcolor=DimGray}}||#696969||
> ||<nowiki>DimGrey</nowiki>||{{color:text=DimGrey|bgcolor=DimGrey}}||#696969||
> ||<nowiki>DodgerBlue</nowiki>||{{color:text=DodgerBlue|bgcolor=DodgerBlue}}||#1E90FF||
> ||<nowiki>FireBrick</nowiki>||{{color:text=FireBrick|bgcolor=FireBrick}}||#B22222||
> ||<nowiki>FloralWhite</nowiki>||{{color:text=FloralWhite|bgcolor=FloralWhite}}||#FFFAF0||
> ||<nowiki>ForestGreen</nowiki>||{{color:text=ForestGreen|bgcolor=ForestGreen}}||#228B22||
> ||<nowiki>Fuchsia</nowiki>||{{color:text=Fuchsia|bgcolor=Fuchsia}}||#FF00FF||
> ||<nowiki>Gainsboro</nowiki>||{{color:text=Gainsboro|bgcolor=Gainsboro}}||#DCDCDC||
> ||<nowiki>GhostWhite</nowiki>||{{color:text=GhostWhite|bgcolor=GhostWhite}}||#F8F8FF||
> ||<nowiki>Gold</nowiki>||{{color:text=Gold|bgcolor=Gold}}||#FFD700||
> ||<nowiki>GoldenRod</nowiki>||{{color:text=GoldenRod|bgcolor=GoldenRod}}||#DAA520||
> ||<nowiki>Gray</nowiki>||{{color:text=Gray|bgcolor=Gray}}||#808080||
> ||<nowiki>Grey</nowiki>||{{color:text=Grey|bgcolor=Grey}}||#808080||
> ||<nowiki>Green</nowiki>||{{color:text=Green|bgcolor=Green}}||#008000||
> ||<nowiki>GreenYellow</nowiki>||{{color:text=GreenYellow|bgcolor=GreenYellow}}||#ADFF2F||
> ||<nowiki>HoneyDew</nowiki>||{{color:text=HoneyDew|bgcolor=HoneyDew}}||#F0FFF0||
> ||<nowiki>HotPink</nowiki>||{{color:text=HotPink|bgcolor=HotPink}}||#FF69B4||
> ||<nowiki>IndianRed</nowiki>||{{color:text=IndianRed|bgcolor=IndianRed}}||#CD5C5C||
> ||<nowiki>Indigo</nowiki>||{{color:text=Indigo|bgcolor=Indigo}}||#4B0082||
> ||<nowiki>Ivory</nowiki>||{{color:text=Ivory|bgcolor=Ivory}}||#FFFFF0||
> ||<nowiki>Khaki</nowiki>||{{color:text=Khaki|bgcolor=Khaki}}||#F0E68C||
> ||<nowiki>Lavender</nowiki>||{{color:text=Lavender|bgcolor=Lavender}}||#E6E6FA||
> ||<nowiki>LavenderBlush</nowiki>||{{color:text=LavenderBlush|bgcolor=LavenderBlush}}||#FFF0F5||
> ||<nowiki>LawnGreen</nowiki>||{{color:text=LawnGreen|bgcolor=LawnGreen}}||#7CFC00||
> ||<nowiki>LemonChiffon</nowiki>||{{color:text=LemonChiffon|bgcolor=LemonChiffon}}||#FFFACD||
> ||<nowiki>LightBlue</nowiki>||{{color:text=LightBlue|bgcolor=LightBlue}}||#ADD8E6||
> ||<nowiki>LightCoral</nowiki>||{{color:text=LightCoral|bgcolor=LightCoral}}||#F08080||
> ||<nowiki>LightCyan</nowiki>||{{color:text=LightCyan|bgcolor=LightCyan}}||#E0FFFF||
> ||<nowiki>LightGoldenRodYellow</nowiki>||{{color:text=LightGoldenRodYellow|bgcolor=LightGoldenRodYellow}}||#FAFAD2||
> ||<nowiki>LightGray</nowiki>||{{color:text=LightGray|bgcolor=LightGray}}||#D3D3D3||
> ||<nowiki>LightGrey</nowiki>||{{color:text=LightGrey|bgcolor=LightGrey}}||#D3D3D3||
> ||<nowiki>LightGreen</nowiki>||{{color:text=LightGreen|bgcolor=LightGreen}}||#90EE90||
> ||<nowiki>LightPink</nowiki>||{{color:text=LightPink|bgcolor=LightPink}}||#FFB6C1||
> ||<nowiki>LightSalmon</nowiki>||{{color:text=LightSalmon|bgcolor=LightSalmon}}||#FFA07A||
> ||<nowiki>LightSeaGreen</nowiki>||{{color:text=LightSeaGreen|bgcolor=LightSeaGreen}}||#20B2AA||
> ||<nowiki>LightSkyBlue</nowiki>||{{color:text=LightSkyBlue|bgcolor=LightSkyBlue}}||#87CEFA||
> ||<nowiki>LightSlateGray</nowiki>||{{color:text=LightSlateGray|bgcolor=LightSlateGray}}||#778899||
> ||<nowiki>LightSlateGrey</nowiki>||{{color:text=LightSlateGrey|bgcolor=LightSlateGrey}}||#778899||
> ||<nowiki>LightSteelBlue</nowiki>||{{color:text=LightSteelBlue|bgcolor=LightSteelBlue}}||#B0C4DE||
> ||<nowiki>LightYellow</nowiki>||{{color:text=LightYellow|bgcolor=LightYellow}}||#FFFFE0||
> ||<nowiki>Lime</nowiki>||{{color:text=Lime|bgcolor=Lime}}||#00FF00||
> ||<nowiki>LimeGreen</nowiki>||{{color:text=LimeGreen|bgcolor=LimeGreen}}||#32CD32||
> ||<nowiki>Linen</nowiki>||{{color:text=Linen|bgcolor=Linen}}||#FAF0E6||
> ||<nowiki>Magenta</nowiki>||{{color:text=Magenta|bgcolor=Magenta}}||#FF00FF||
> ||<nowiki>Maroon</nowiki>||{{color:text=Maroon|bgcolor=Maroon}}||#800000||
> ||<nowiki>MediumAquaMarine</nowiki>||{{color:text=MediumAquaMarine|bgcolor=MediumAquaMarine}}||#66CDAA||
> ||<nowiki>MediumBlue</nowiki>||{{color:text=MediumBlue|bgcolor=MediumBlue}}||#0000CD||
> ||<nowiki>MediumOrchid</nowiki>||{{color:text=MediumOrchid|bgcolor=MediumOrchid}}||#BA55D3||
> ||<nowiki>MediumPurple</nowiki>||{{color:text=MediumPurple|bgcolor=MediumPurple}}||#9370D8||
> ||<nowiki>MediumSeaGreen</nowiki>||{{color:text=MediumSeaGreen|bgcolor=MediumSeaGreen}}||#3CB371||
> ||<nowiki>MediumSlateBlue</nowiki>||{{color:text=MediumSlateBlue|bgcolor=MediumSlateBlue}}||#7B68EE||
> ||<nowiki>MediumSpringGreen</nowiki>||{{color:text=MediumSpringGreen|bgcolor=MediumSpringGreen}}||#00FA9A||
> ||<nowiki>MediumTurquoise</nowiki>||{{color:text=MediumTurquoise|bgcolor=MediumTurquoise}}||#48D1CC||
> ||<nowiki>MediumVioletRed</nowiki>||{{color:text=MediumVioletRed|bgcolor=MediumVioletRed}}||#C71585||
> ||<nowiki>MidnightBlue</nowiki>||{{color:text=MidnightBlue|bgcolor=MidnightBlue}}||#191970||
> ||<nowiki>MintCream</nowiki>||{{color:text=MintCream|bgcolor=MintCream}}||#F5FFFA||
> ||<nowiki>MistyRose</nowiki>||{{color:text=MistyRose|bgcolor=MistyRose}}||#FFE4E1||
> ||<nowiki>Moccasin</nowiki>||{{color:text=Moccasin|bgcolor=Moccasin}}||#FFE4B5||
> ||<nowiki>NavajoWhite</nowiki>||{{color:text=NavajoWhite|bgcolor=NavajoWhite}}||#FFDEAD||
> ||<nowiki>Navy</nowiki>||{{color:text=Navy|bgcolor=Navy}}||#000080||
> ||<nowiki>OldLace</nowiki>||{{color:text=OldLace|bgcolor=OldLace}}||#FDF5E6||
> ||<nowiki>Olive</nowiki>||{{color:text=Olive|bgcolor=Olive}}||#808000||
> ||<nowiki>OliveDrab</nowiki>||{{color:text=OliveDrab|bgcolor=OliveDrab}}||#6B8E23||
> ||<nowiki>Orange</nowiki>||{{color:text=Orange|bgcolor=Orange}}||#FFA500||
> ||<nowiki>OrangeRed</nowiki>||{{color:text=OrangeRed|bgcolor=OrangeRed}}||#FF4500||
> ||<nowiki>Orchid</nowiki>||{{color:text=Orchid|bgcolor=Orchid}}||#DA70D6||
> ||<nowiki>PaleGoldenRod</nowiki>||{{color:text=PaleGoldenRod|bgcolor=PaleGoldenRod}}||#EEE8AA||
> ||<nowiki>PaleGreen</nowiki>||{{color:text=PaleGreen|bgcolor=PaleGreen}}||#98FB98||
> ||<nowiki>PaleTurquoise</nowiki>||{{color:text=PaleTurquoise|bgcolor=PaleTurquoise}}||#AFEEEE||
> ||<nowiki>PaleVioletRed</nowiki>||{{color:text=PaleVioletRed|bgcolor=PaleVioletRed}}||#D87093||
> ||<nowiki>PapayaWhip</nowiki>||{{color:text=PapayaWhip|bgcolor=PapayaWhip}}||#FFEFD5||
> ||<nowiki>PeachPuff</nowiki>||{{color:text=PeachPuff|bgcolor=PeachPuff}}||#FFDAB9||
> ||<nowiki>Peru</nowiki>||{{color:text=Peru|bgcolor=Peru}}||#CD853F||
> ||<nowiki>Pink</nowiki>||{{color:text=Pink|bgcolor=Pink}}||#FFC0CB||
> ||<nowiki>Plum</nowiki>||{{color:text=Plum|bgcolor=Plum}}||#DDA0DD||
> ||<nowiki>PowderBlue</nowiki>||{{color:text=PowderBlue|bgcolor=PowderBlue}}||#B0E0E6||
> ||<nowiki>Purple</nowiki>||{{color:text=Purple|bgcolor=Purple}}||#800080||
> ||<nowiki>Red</nowiki>||{{color:text=Red|bgcolor=Red}}||#FF0000||
> ||<nowiki>RosyBrown</nowiki>||{{color:text=RosyBrown|bgcolor=RosyBrown}}||#BC8F8F||
> ||<nowiki>RoyalBlue</nowiki>||{{color:text=RoyalBlue|bgcolor=RoyalBlue}}||#4169E1||
> ||<nowiki>SaddleBrown</nowiki>||{{color:text=SaddleBrown|bgcolor=SaddleBrown}}||#8B4513||
> ||<nowiki>Salmon</nowiki>||{{color:text=Salmon|bgcolor=Salmon}}||#FA8072||
> ||<nowiki>SandyBrown</nowiki>||{{color:text=SandyBrown|bgcolor=SandyBrown}}||#F4A460||
> ||<nowiki>SeaGreen</nowiki>||{{color:text=SeaGreen|bgcolor=SeaGreen}}||#2E8B57||
> ||<nowiki>SeaShell</nowiki>||{{color:text=SeaShell|bgcolor=SeaShell}}||#FFF5EE||
> ||<nowiki>Sienna</nowiki>||{{color:text=Sienna|bgcolor=Sienna}}||#A0522D||
> ||<nowiki>Silver</nowiki>||{{color:text=Silver|bgcolor=Silver}}||#C0C0C0||
> ||<nowiki>SkyBlue</nowiki>||{{color:text=SkyBlue|bgcolor=SkyBlue}}||#87CEEB||
> ||<nowiki>SlateBlue</nowiki>||{{color:text=SlateBlue|bgcolor=SlateBlue}}||#6A5ACD||
> ||<nowiki>SlateGray</nowiki>||{{color:text=SlateGray|bgcolor=SlateGray}}||#708090||
> ||<nowiki>SlateGrey</nowiki>||{{color:text=SlateGrey|bgcolor=SlateGrey}}||#708090||
> ||<nowiki>Snow</nowiki>||{{color:text=Snow|bgcolor=Snow}}||#FFFAFA||
> ||<nowiki>SpringGreen</nowiki>||{{color:text=SpringGreen|bgcolor=SpringGreen}}||#00FF7F||
> ||<nowiki>SteelBlue</nowiki>||{{color:text=SteelBlue|bgcolor=SteelBlue}}||#4682B4||
> ||<nowiki>Tan</nowiki>||{{color:text=Tan|bgcolor=Tan}}||#D2B48C||
> ||<nowiki>Teal</nowiki>||{{color:text=Teal|bgcolor=Teal}}||#008080||
> ||<nowiki>Thistle</nowiki>||{{color:text=Thistle|bgcolor=Thistle}}||#D8BFD8||
> ||<nowiki>Tomato</nowiki>||{{color:text=Tomato|bgcolor=Tomato}}||#FF6347||
> ||<nowiki>Turquoise</nowiki>||{{color:text=Turquoise|bgcolor=Turquoise}}||#40E0D0||
> ||<nowiki>Violet</nowiki>||{{color:text=Violet|bgcolor=Violet}}||#EE82EE||
> ||<nowiki>Wheat</nowiki>||{{color:text=Wheat|bgcolor=Wheat}}||#F5DEB3||
> ||<nowiki>White</nowiki>||{{color:text=White|bgcolor=White}}||#FFFFFF||
> ||<nowiki>WhiteSmoke</nowiki>||{{color:text=WhiteSmoke|bgcolor=WhiteSmoke}}||#F5F5F5||
> ||<nowiki>Yellow</nowiki>||{{color:text=Yellow|bgcolor=Yellow}}||#FFFF00||
> ||YellowGreen||#9ACD32
------
HtmlColors|1226213860
3c3
< !!Color Name|width=300!!Color!!Code!!
---
> !!Color Name|width=300|tablestyle=width:50%;!!Color!!Code!!
150c150
< ||YellowGreen||#9ACD32
---
> ||<nowiki>YellowGreen</nowiki>||{{color:text=YellowGreen|bgcolor=YellowGreen}}||#FFFF00||#9ACD32||
------
WikiBugs/OpenDefects|1226222138
7a8
> ||2008.11.11||[HomePage/RobertKurcina RobertKurcina]||Need to figure out a way to store cached pages without header, footer, leftnavigation.||OPEN||
------
HtmlColors|1226222238
150c150
< ||<nowiki>YellowGreen</nowiki>||{{color:text=YellowGreen|bgcolor=YellowGreen}}||#FFFF00||#9ACD32||
---
> ||<nowiki>YellowGreen</nowiki>||{{color:text=YellowGreen|bgcolor=YellowGreen}}||#9ACD32||
------
Users|1226286643
1c1,5
< [Describe the new page here]
---
> == Accounts Page =
> 
> Any user accounts active in NobleWiki are listed below.
> 
> {{subpages}}
------
Users|1226286654
5c5
< {{subpages}}
---
>  {{subpages}}
------
HomePage|1226287381
20d18
<  {{subpages}}
------
/Kitrok|1226287430
1c1
< [Describe the new page here]
---
> {{redirect:Users/RobertKurcina}}
------
Users|1226287478
5c5,7
<  {{subpages}}
---
>  /Kitrok
>  /RobertKurcina
>  /RalphMorgan
------
/Kitrok|1226287486
1c1
< {{redirect:Users/RobertKurcina}}
---
> {{redirect:HomePage/RobertKurcina}}
------
Users|1226287758
1c1
< == Accounts Page =
---
> == Central Users Nexus =
------
Users|1226287786
1,7c1
< == Central Users Nexus =
< 
< Any user accounts active in NobleWiki are listed below.
< 
<  /Kitrok
<  /RobertKurcina
<  /RalphMorgan
---
> {{delete}}
------
UserNexus|1226287953
1c1,3
< [Describe the new page here]
---
> == User Accounts Nexus =
> 
> All user accounts are filed here as subpages.
------
UserNexus/Kitrok|1226287992
1c1
< [Describe the new page here]
---
> {{redirect:HomePage/RobertKurcina}}
------
UserPage/RobertKurcina|1226288087
1c1,10
< [Describe the new page here]
---
> = Robert Kurcina =
> 
> {{template:WikiTemplates/HomePage
> UPLOADIMAGE = upload:HomePage/RobertKurcina.jpg
> NAME = Robert Kurcina
> SKILLS = Software Development, Illustration, Design, Writing
> INTERESTS = Game Theory, History
> QUOTE = Work harder and work smarter
> WEBSITEURL= http://talkorigins.org/
> }}
------
UserPage/RalphMorgan|1226288107
1c1,10
< [Describe the new page here]
---
> = Ralph Morgan =
> 
> {{template:WikiTemplates/HomePage
> NAME = Ralph Morgan
> UPLOADIMAGE = upload:HomePage/RalphMorgan.jpg
> SKILLS = Game Design, Project Coordination
> INTERESTS = Game Theory, History, Illustration
> QUOTE = Robert, this game sucks.  ... hey, I never said that! - ralph
> WEBSITEURL= http://rosecitygames.com/
> }}
------
UserNexus/Kitrok|1226288127
1c1
< {{redirect:HomePage/RobertKurcina}}
---
> {{redirect:UserNexus/RobertKurcina}}
------
UserNexus/RobertKurcina|1226288197
1c1,10
< [Describe the new page here]
---
> = Robert Kurcina =
> 
> {{template:WikiTemplates/HomePage
> UPLOADIMAGE = upload:HomePage/RobertKurcina.jpg
> NAME = Robert Kurcina
> SKILLS = Software Development, Illustration, Design, Writing
> INTERESTS = Game Theory, History
> QUOTE = Work harder and work smarter
> WEBSITEURL= http://talkorigins.org/
> }}
------
UserNexus/RalphMorgan|1226288212
1c1,10
< [Describe the new page here]
---
> = Ralph Morgan =
> 
> {{template:WikiTemplates/HomePage
> NAME = Ralph Morgan
> UPLOADIMAGE = upload:HomePage/RalphMorgan.jpg
> SKILLS = Game Design, Project Coordination
> INTERESTS = Game Theory, History, Illustration
> QUOTE = Robert, this game sucks.  ... hey, I never said that! - ralph
> WEBSITEURL= http://rosecitygames.com/
> }}
------
UserNexus|1226288241
3a5
>  {{subpages}}
